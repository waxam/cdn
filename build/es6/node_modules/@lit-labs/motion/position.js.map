{"version":3,"file":"position.js","sources":["src/position.ts"],"sourcesContent":["import {LitElement} from 'lit';\nimport {nothing, AttributePart} from 'lit/html.js';\nimport {directive, PartInfo, PartType} from 'lit/directive.js';\nimport {AsyncDirective} from 'lit/async-directive.js';\n\ninterface Positionables {\n  readonly bottom: number;\n  readonly height: number;\n  readonly left: number;\n  readonly right: number;\n  readonly top: number;\n  readonly width: number;\n}\n\ntype Ref = {value: HTMLElement};\nexport type TargetCallbackOrRef = (() => HTMLElement) | Ref;\n\nexport type Positions = Array<keyof Positionables>;\n\nconst positionedPoints = ['top', 'right', 'bottom', 'left'];\n\nexport class Position extends AsyncDirective {\n  private _host?: LitElement;\n  private _element?: Element;\n  private _targetCallbackOrRef!: TargetCallbackOrRef;\n  private _positions?: Positions;\n\n  constructor(part: PartInfo) {\n    super(part);\n    if (part.type !== PartType.ELEMENT) {\n      throw new Error(\n        'The `position` directive must be used in attribute position.'\n      );\n    }\n  }\n\n  render(_targetCallbackOrRef: TargetCallbackOrRef, _positions: Positions) {\n    return nothing;\n  }\n\n  override update(\n    part: AttributePart,\n    [target, positions]: Parameters<this['render']>\n  ) {\n    if (this._host === undefined) {\n      this._host = part.options?.host as LitElement;\n      this._host.addController(this);\n    }\n    this._element = part.element;\n    this._targetCallbackOrRef = target;\n    this._positions = positions ?? ['left', 'top', 'width', 'height'];\n    return this.render(target, positions);\n  }\n\n  hostUpdated() {\n    this._position();\n  }\n\n  private _position() {\n    const target =\n      typeof this._targetCallbackOrRef === 'function'\n        ? this._targetCallbackOrRef()\n        : this._targetCallbackOrRef?.value;\n    const parent = target.offsetParent;\n    if (target === undefined || !parent) {\n      return;\n    }\n    const tr = target.getBoundingClientRect();\n    const pr = parent.getBoundingClientRect();\n    this._positions?.forEach((p) => {\n      const x = positionedPoints.includes(p) ? tr[p] - pr[p] : tr[p];\n      (this._element as HTMLElement).style[p] = `${x}px`;\n    });\n  }\n}\n\n/**\n * Positions and sizes the element on which the `position()` directive is used\n * relative to the given target element.\n */\nexport const position = directive(Position);\n"],"names":["positionedPoints","Position","AsyncDirective","constructor","part","super","type","PartType","ELEMENT","Error","render","_targetCallbackOrRef","_positions","nothing","update","target","positions","undefined","this","_host","_a","options","host","addController","_element","element","hostUpdated","_position","value","parent","offsetParent","tr","getBoundingClientRect","pr","_b","forEach","p","x","includes","style","position","directive"],"mappings":"yJAmBA,MAAMA,EAAmB,CAAC,MAAO,QAAS,SAAU,QAE9C,MAAOC,UAAiBC,EAM5BC,YAAYC,GAEV,GADAC,MAAMD,GACFA,EAAKE,OAASC,EAASC,QACzB,MAAUC,MACR,+DAGL,CAEDC,OAAOC,EAA2CC,GAChD,OAAOC,CACR,CAEQC,OACPV,GACCW,EAAQC,UAST,YAPmBC,IAAfC,KAAKC,IACPD,KAAKC,EAAsB,QAAdC,EAAAhB,EAAKiB,eAAS,IAAAD,OAAA,EAAAA,EAAAE,KAC3BJ,KAAKC,EAAMI,cAAcL,OAE3BA,KAAKM,EAAWpB,EAAKqB,QACrBP,KAAKP,EAAuBI,EAC5BG,KAAKN,EAAaI,QAAAA,EAAa,CAAC,OAAQ,MAAO,QAAS,UACjDE,KAAKR,OAAOK,EAAQC,EAC5B,CAEDU,cACER,KAAKS,GACN,CAEOA,YACN,MAAMZ,EACiC,mBAA9BG,KAAKP,EACRO,KAAKP,IACoB,QAAzBS,EAAAF,KAAKP,SAAoB,IAAAS,OAAA,EAAAA,EAAEQ,MAC3BC,EAASd,EAAOe,aACtB,QAAeb,IAAXF,IAAyBc,EAC3B,OAEF,MAAME,EAAKhB,EAAOiB,wBACZC,EAAKJ,EAAOG,wBACH,QAAfE,EAAAhB,KAAKN,SAAU,IAAAsB,GAAAA,EAAEC,SAASC,IACxB,MAAMC,EAAIrC,EAAiBsC,SAASF,GAAKL,EAAGK,GAAKH,EAAGG,GAAKL,EAAGK,GAC3DlB,KAAKM,EAAyBe,MAAMH,GAAQC,EAAH,IAAQ,GAErD,QAOUG,EAAWC,EAAUxC"}