/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
import templateMap from"./template-map.js";import{StyleNode}from"./css-parse.js";const CURRENT_VERSION="_applyShimCurrentVersion",NEXT_VERSION="_applyShimNextVersion",promise=Promise.resolve();export function invalidate(elementName){let template=templateMap[elementName];template&&invalidateTemplate(template)}export function invalidateTemplate(template){template[CURRENT_VERSION]=template[CURRENT_VERSION]||0,template._applyShimValidatingVersion=template._applyShimValidatingVersion||0,template[NEXT_VERSION]=(template[NEXT_VERSION]||0)+1}export function isValid(elementName){let template=templateMap[elementName];return!template||templateIsValid(template)}export function templateIsValid(template){return template[CURRENT_VERSION]===template[NEXT_VERSION]}export function isValidating(elementName){let template=templateMap[elementName];return!!template&&templateIsValidating(template)}export function templateIsValidating(template){return!templateIsValid(template)&&template._applyShimValidatingVersion===template[NEXT_VERSION]}export function startValidating(elementName){startValidatingTemplate(templateMap[elementName])}export function startValidatingTemplate(template){template._applyShimValidatingVersion=template[NEXT_VERSION],template._validating||(template._validating=!0,promise.then((function(){template[CURRENT_VERSION]=template[NEXT_VERSION],template._validating=!1})))}export function elementsAreInvalid(){for(let elementName in templateMap){if(!templateIsValid(templateMap[elementName]))return!0}return!1}