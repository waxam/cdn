/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
var e=this&&this.__asyncValues||function(e){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var t,r=e[Symbol.asyncIterator];return r?r.call(e):(e="function"==typeof __values?__values(e):e[Symbol.iterator](),t={},verb("next"),verb("throw"),verb("return"),t[Symbol.asyncIterator]=function(){return this},t);function verb(r){t[r]=e[r]&&function(t){return new Promise((function(n,o){(function settle(e,t,r,n){Promise.resolve(n).then((function(t){e({value:t,done:r})}),t)})(n,o,(t=e[r](t)).done,t.value)}))}}};import{directive as t,NodePart as r}from"../lit-html.js";export const asyncReplace=t((t,n)=>async o=>{var a,i;if(!(o instanceof r))throw new Error("asyncReplace can only be used in text bindings");if(t===o.value)return;const l=new r(o.options);o.value=t;let c=0;try{for(var s,u=e(t);!(s=await u.next()).done;){let e=s.value;if(o.value!==t)break;0===c&&(o.clear(),l.appendIntoPart(o)),void 0!==n&&(e=n(e,c)),l.setValue(e),l.commit(),c++}}catch(e){a={error:e}}finally{try{s&&!s.done&&(i=u.return)&&await i.call(u)}finally{if(a)throw a.error}}});