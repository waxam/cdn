/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
import{removeNodes as e}from"./dom.js";import{insertNodeIntoTemplate as t,removeNodesFromTemplate as o}from"./modify-template.js";import{parts as n,render as r}from"./render.js";import{templateCaches as s}from"./template-factory.js";import{TemplateInstance as a}from"./template-instance.js";import{marker as i,Template as l}from"./template.js";export{html,svg,TemplateResult}from"../lit-html.js";const getTemplateCacheKey=(e,t)=>`${e}--${t}`;let d=!0;void 0===window.ShadyCSS?d=!1:void 0===window.ShadyCSS.prepareTemplateDom&&(console.warn("Incompatible ShadyCSS version detected. Please update to at least @webcomponents/webcomponentsjs@2.0.2 and @webcomponents/shadycss@1.3.1."),d=!1);const shadyTemplateFactory=e=>t=>{const o=getTemplateCacheKey(t.type,e);let n=s.get(o);void 0===n&&(n={stringsArray:new WeakMap,keyString:new Map},s.set(o,n));let r=n.stringsArray.get(t.strings);if(void 0!==r)return r;const a=t.strings.join(i);if(r=n.keyString.get(a),void 0===r){const o=t.getTemplateElement();d&&window.ShadyCSS.prepareTemplateDom(o,e),r=new l(t,o),n.keyString.set(a,r)}return n.stringsArray.set(t.strings,r),r},m=["html","svg"],c=new Set,prepareTemplateStyles=(e,n,r)=>{c.add(e);const a=r?r.element:document.createElement("template"),i=n.querySelectorAll("style"),{length:l}=i;if(0===l)return void window.ShadyCSS.prepareTemplateStyles(a,e);const d=document.createElement("style");for(let e=0;e<l;e++){const t=i[e];t.parentNode.removeChild(t),d.textContent+=t.textContent}(e=>{m.forEach(t=>{const n=s.get(getTemplateCacheKey(t,e));void 0!==n&&n.keyString.forEach(e=>{const{element:{content:t}}=e,n=new Set;Array.from(t.querySelectorAll("style")).forEach(e=>{n.add(e)}),o(e,n)})})})(e);const p=a.content;r?t(r,d,p.firstChild):p.insertBefore(d,p.firstChild),window.ShadyCSS.prepareTemplateStyles(a,e);const S=p.querySelector("style");if(window.ShadyCSS.nativeShadow&&null!==S)n.insertBefore(S.cloneNode(!0),n.firstChild);else if(r){p.insertBefore(d,p.firstChild);const e=new Set;e.add(d),o(r,e)}};export const render=(t,o,s)=>{if(!s||"object"!=typeof s||!s.scopeName)throw new Error("The `scopeName` option is required.");const i=s.scopeName,l=n.has(o),m=d&&11===o.nodeType&&!!o.host,p=m&&!c.has(i),S=p?document.createDocumentFragment():o;if(r(t,S,Object.assign({templateFactory:shadyTemplateFactory(i)},s)),p){const t=n.get(S);n.delete(S);const r=t.value instanceof a?t.value.template:void 0;prepareTemplateStyles(i,S,r),e(o,o.firstChild),o.appendChild(S),n.set(o,t)}!l&&m&&window.ShadyCSS.styleElement(o.host)};