/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
import"./boot.js";export function isPath(path){return path.indexOf(".")>=0}export function root(path){let dotIndex=path.indexOf(".");return-1===dotIndex?path:path.slice(0,dotIndex)}export function isAncestor(base,path){return 0===base.indexOf(path+".")}export function isDescendant(base,path){return 0===path.indexOf(base+".")}export function translate(base,newBase,path){return newBase+path.slice(base.length)}export function matches(base,path){return base===path||isAncestor(base,path)||isDescendant(base,path)}export function normalize(path){if(Array.isArray(path)){let parts=[];for(let i=0;i<path.length;i++){let args=path[i].toString().split(".");for(let j=0;j<args.length;j++)parts.push(args[j])}return parts.join(".")}return path}export function split(path){return Array.isArray(path)?normalize(path).split("."):path.toString().split(".")}export function get(root,path,info){let prop=root,parts=split(path);for(let i=0;i<parts.length;i++){if(!prop)return;prop=prop[parts[i]]}return info&&(info.path=parts.join(".")),prop}export function set(root,path,value){let prop=root,parts=split(path),last=parts[parts.length-1];if(parts.length>1){for(let i=0;i<parts.length-1;i++){if(prop=prop[parts[i]],!prop)return}prop[last]=value}else prop[path]=value;return parts.join(".")}export const isDeep=isPath;