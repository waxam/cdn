import"../utils/boot.js";import{wrap}from"../utils/wrap.js";import{dedupingMixin}from"../utils/mixin.js";import{root,isAncestor,isDescendant,get,translate,isPath,set,normalize}from"../utils/path.js";import{camelToDashCase,dashToCamelCase}from"../utils/case-map.js";import{PropertyAccessors}from"./property-accessors.js";import{TemplateStamp}from"./template-stamp.js";import{sanitizeDOMValue}from"../utils/settings.js";let dedupeId=0;const TYPES={COMPUTE:"__computeEffects",REFLECT:"__reflectEffects",NOTIFY:"__notifyEffects",PROPAGATE:"__propagateEffects",OBSERVE:"__observeEffects",READ_ONLY:"__readOnly"},capitalAttributeRegex=/[A-Z]/;function ensureOwnEffectMap(model,type){let effects=model[type];if(effects){if(!model.hasOwnProperty(type)){effects=model[type]=Object.create(model[type]);for(let p in effects){let protoFx=effects[p],instFx=effects[p]=Array(protoFx.length);for(let i=0;i<protoFx.length;i++)instFx[i]=protoFx[i]}}}else effects=model[type]={};return effects}function runEffects(inst,effects,props,oldProps,hasPaths,extraArgs){if(effects){let ran=!1,id=dedupeId++;for(let prop in props)runEffectsForProperty(inst,effects,id,prop,props,oldProps,hasPaths,extraArgs)&&(ran=!0);return ran}return!1}function runEffectsForProperty(inst,effects,dedupeId,prop,props,oldProps,hasPaths,extraArgs){let ran=!1,fxs=effects[hasPaths?root(prop):prop];if(fxs)for(let fx,i=0,l=fxs.length;i<l&&(fx=fxs[i]);i++)fx.info&&fx.info.lastRun===dedupeId||hasPaths&&!pathMatchesTrigger(prop,fx.trigger)||(fx.info&&(fx.info.lastRun=dedupeId),fx.fn(inst,prop,props,oldProps,fx.info,hasPaths,extraArgs),ran=!0);return ran}function pathMatchesTrigger(path,trigger){if(trigger){let triggerPath=trigger.name;return triggerPath==path||!(!trigger.structured||!isAncestor(triggerPath,path))||!(!trigger.wildcard||!isDescendant(triggerPath,path))}return!0}function runObserverEffect(inst,property,props,oldProps,info){let fn="string"==typeof info.method?inst[info.method]:info.method,changedProp=info.property;fn?fn.call(inst,inst.__data[changedProp],oldProps[changedProp]):info.dynamicFn||console.warn("observer method `"+info.method+"` not defined")}function notifyPath(inst,path,props){let rootProperty=root(path);if(rootProperty!==path){return dispatchNotifyEvent(inst,camelToDashCase(rootProperty)+"-changed",props[path],path),!0}return!1}function dispatchNotifyEvent(inst,eventName,value,path){let detail={value:value,queueProperty:!0};path&&(detail.path=path),wrap(inst).dispatchEvent(new CustomEvent(eventName,{detail:detail}))}function runNotifyEffect(inst,property,props,oldProps,info,hasPaths){let path=(hasPaths?root(property):property)!=property?property:null,value=path?get(inst,path):inst.__data[property];path&&void 0===value&&(value=props[property]),dispatchNotifyEvent(inst,info.eventName,value,path)}function runReflectEffect(inst,property,props,oldProps,info){let value=inst.__data[property];sanitizeDOMValue&&(value=sanitizeDOMValue(value,info.attrName,"attribute",inst)),inst._propertyToAttribute(property,info.attrName,value)}function runComputedEffect(inst,property,props,oldProps,info){let result=runMethodEffect(inst,property,props,oldProps,info),computedProp=info.methodInfo;inst.__dataHasAccessor&&inst.__dataHasAccessor[computedProp]?inst._setPendingProperty(computedProp,result,!0):inst[computedProp]=result}function addBinding(constructor,templateInfo,nodeInfo,kind,target,parts,literal){nodeInfo.bindings=nodeInfo.bindings||[];let binding={kind:kind,target:target,parts:parts,literal:literal,isCompound:1!==parts.length};if(nodeInfo.bindings.push(binding),function shouldAddListener(binding){return Boolean(binding.target)&&"attribute"!=binding.kind&&"text"!=binding.kind&&!binding.isCompound&&"{"===binding.parts[0].mode}(binding)){let{event:event,negate:negate}=binding.parts[0];binding.listenerEvent=event||camelToDashCase(target)+"-changed",binding.listenerNegate=negate}let index=templateInfo.nodeInfoList.length;for(let i=0;i<binding.parts.length;i++){let part=binding.parts[i];part.compoundIndex=i,addEffectForBindingPart(constructor,templateInfo,binding,part,index)}}function addEffectForBindingPart(constructor,templateInfo,binding,part,index){if(!part.literal)if("attribute"===binding.kind&&"-"===binding.target[0])console.warn("Cannot set attribute "+binding.target+' because "-" is not a valid attribute starting character');else{let dependencies=part.dependencies,info={index:index,binding:binding,part:part,evaluator:constructor};for(let j=0;j<dependencies.length;j++){let trigger=dependencies[j];"string"==typeof trigger&&((trigger=parseArg(trigger)).wildcard=!0),constructor._addTemplatePropertyEffect(templateInfo,trigger.rootProperty,{fn:runBindingEffect,info:info,trigger:trigger})}}}function runBindingEffect(inst,path,props,oldProps,info,hasPaths,nodeList){let node=nodeList[info.index],binding=info.binding,part=info.part;if(hasPaths&&part.source&&path.length>part.source.length&&"property"==binding.kind&&!binding.isCompound&&node.__isPropertyEffectsClient&&node.__dataHasAccessor&&node.__dataHasAccessor[binding.target]){let value=props[path];path=translate(part.source,binding.target,path),node._setPendingPropertyOrPath(path,value,!1,!0)&&inst._enqueueClient(node)}else{!function applyBindingValue(inst,node,binding,part,value){value=function computeBindingValue(node,value,binding,part){if(binding.isCompound){let storage=node.__dataCompoundStorage[binding.target];storage[part.compoundIndex]=value,value=storage.join("")}return"attribute"!==binding.kind&&("textContent"!==binding.target&&("value"!==binding.target||"input"!==node.localName&&"textarea"!==node.localName)||(value=null==value?"":value)),value}(node,value,binding,part),sanitizeDOMValue&&(value=sanitizeDOMValue(value,binding.target,binding.kind,node));if("attribute"==binding.kind)inst._valueToNodeAttribute(node,value,binding.target);else{let prop=binding.target;node.__isPropertyEffectsClient&&node.__dataHasAccessor&&node.__dataHasAccessor[prop]?node[TYPES.READ_ONLY]&&node[TYPES.READ_ONLY][prop]||node._setPendingProperty(prop,value)&&inst._enqueueClient(node):inst._setUnmanagedPropertyToNode(node,prop,value)}}(inst,node,binding,part,info.evaluator._evaluateBinding(inst,part,path,props,oldProps,hasPaths))}}function setupCompoundStorage(node,binding){if(binding.isCompound){let storage=node.__dataCompoundStorage||(node.__dataCompoundStorage={}),parts=binding.parts,literals=new Array(parts.length);for(let j=0;j<parts.length;j++)literals[j]=parts[j].literal;let target=binding.target;storage[target]=literals,binding.literal&&"property"==binding.kind&&("className"===target&&(node=wrap(node)),node[target]=binding.literal)}}function addNotifyListener(node,inst,binding){if(binding.listenerEvent){let part=binding.parts[0];node.addEventListener(binding.listenerEvent,function(e){!function handleNotification(event,inst,fromProp,toPath,negate){let value,detail=event.detail,fromPath=detail&&detail.path;fromPath?(toPath=translate(fromProp,toPath,fromPath),value=detail&&detail.value):value=event.currentTarget[fromProp],value=negate?!value:value,inst[TYPES.READ_ONLY]&&inst[TYPES.READ_ONLY][toPath]||!inst._setPendingPropertyOrPath(toPath,value,!0,Boolean(fromPath))||detail&&detail.queueProperty||inst._invalidateProperties()}(e,inst,binding.target,part.source,part.negate)})}}function createMethodEffect(model,sig,type,effectFn,methodInfo,dynamicFn){dynamicFn=sig.static||dynamicFn&&("object"!=typeof dynamicFn||dynamicFn[sig.methodName]);let info={methodName:sig.methodName,args:sig.args,methodInfo:methodInfo,dynamicFn:dynamicFn};for(let arg,i=0;i<sig.args.length&&(arg=sig.args[i]);i++)arg.literal||model._addPropertyEffect(arg.rootProperty,type,{fn:effectFn,info:info,trigger:arg});dynamicFn&&model._addPropertyEffect(sig.methodName,type,{fn:effectFn,info:info})}function runMethodEffect(inst,property,props,oldProps,info){let context=inst._methodHost||inst,fn=context[info.methodName];if(fn){let args=inst._marshalArgs(info.args,property,props);return fn.apply(context,args)}info.dynamicFn||console.warn("method `"+info.methodName+"` not defined")}const emptyArray=[],bindingRegex=new RegExp("(\\[\\[|{{)\\s*(?:(!)\\s*)?((?:[a-zA-Z_$][\\w.:$\\-*]*)\\s*(?:\\(\\s*(?:(?:(?:((?:[a-zA-Z_$][\\w.:$\\-*]*)|(?:[-+]?[0-9]*\\.?[0-9]+(?:[eE][-+]?[0-9]+)?)|(?:(?:'(?:[^'\\\\]|\\\\.)*')|(?:\"(?:[^\"\\\\]|\\\\.)*\")))\\s*)(?:,\\s*(?:((?:[a-zA-Z_$][\\w.:$\\-*]*)|(?:[-+]?[0-9]*\\.?[0-9]+(?:[eE][-+]?[0-9]+)?)|(?:(?:'(?:[^'\\\\]|\\\\.)*')|(?:\"(?:[^\"\\\\]|\\\\.)*\")))\\s*))*)?)\\)\\s*)?)(?:]]|}})","g");function literalFromParts(parts){let s="";for(let i=0;i<parts.length;i++){s+=parts[i].literal||""}return s}function parseMethod(expression){let m=expression.match(/([^\s]+?)\(([\s\S]*)\)/);if(m){let sig={methodName:m[1],static:!0,args:emptyArray};if(m[2].trim()){return function parseArgs(argList,sig){return sig.args=argList.map(function(rawArg){let arg=parseArg(rawArg);return arg.literal||(sig.static=!1),arg},this),sig}(m[2].replace(/\\,/g,"&comma;").split(","),sig)}return sig}return null}function parseArg(rawArg){let arg=rawArg.trim().replace(/&comma;/g,",").replace(/\\(.)/g,"$1"),a={name:arg,value:"",literal:!1},fc=arg[0];switch("-"===fc&&(fc=arg[1]),fc>="0"&&fc<="9"&&(fc="#"),fc){case"'":case'"':a.value=arg.slice(1,-1),a.literal=!0;break;case"#":a.value=Number(arg),a.literal=!0}return a.literal||(a.rootProperty=root(arg),a.structured=isPath(arg),a.structured&&(a.wildcard=".*"==arg.slice(-2),a.wildcard&&(a.name=arg.slice(0,-2)))),a}function getArgValue(data,props,path){let value=get(data,path);return void 0===value&&(value=props[path]),value}function notifySplices(inst,array,path,splices){inst.notifyPath(path+".splices",{indexSplices:splices}),inst.notifyPath(path+".length",array.length)}function notifySplice(inst,array,path,index,addedCount,removed){notifySplices(inst,array,path,[{index:index,addedCount:addedCount,removed:removed,object:array,type:"splice"}])}export const PropertyEffects=dedupingMixin(superClass=>{const propertyEffectsBase=TemplateStamp(PropertyAccessors(superClass));return class PropertyEffects extends propertyEffectsBase{constructor(){super(),this.__isPropertyEffectsClient=!0,this.__dataCounter=0,this.__dataClientsReady,this.__dataPendingClients,this.__dataToNotify,this.__dataLinkedPaths,this.__dataHasPaths,this.__dataCompoundStorage,this.__dataHost,this.__dataTemp,this.__dataClientsInitialized,this.__data,this.__dataPending,this.__dataOld,this.__computeEffects,this.__reflectEffects,this.__notifyEffects,this.__propagateEffects,this.__observeEffects,this.__readOnly,this.__templateInfo}get PROPERTY_EFFECT_TYPES(){return TYPES}_initializeProperties(){super._initializeProperties(),hostStack.registerHost(this),this.__dataClientsReady=!1,this.__dataPendingClients=null,this.__dataToNotify=null,this.__dataLinkedPaths=null,this.__dataHasPaths=!1,this.__dataCompoundStorage=this.__dataCompoundStorage||null,this.__dataHost=this.__dataHost||null,this.__dataTemp={},this.__dataClientsInitialized=!1}_initializeProtoProperties(props){this.__data=Object.create(props),this.__dataPending=Object.create(props),this.__dataOld={}}_initializeInstanceProperties(props){let readOnly=this[TYPES.READ_ONLY];for(let prop in props)readOnly&&readOnly[prop]||(this.__dataPending=this.__dataPending||{},this.__dataOld=this.__dataOld||{},this.__data[prop]=this.__dataPending[prop]=props[prop])}_addPropertyEffect(property,type,effect){this._createPropertyAccessor(property,type==TYPES.READ_ONLY);let effects=ensureOwnEffectMap(this,type)[property];effects||(effects=this[type][property]=[]),effects.push(effect)}_removePropertyEffect(property,type,effect){let effects=ensureOwnEffectMap(this,type)[property],idx=effects.indexOf(effect);idx>=0&&effects.splice(idx,1)}_hasPropertyEffect(property,type){let effects=this[type];return Boolean(effects&&effects[property])}_hasReadOnlyEffect(property){return this._hasPropertyEffect(property,TYPES.READ_ONLY)}_hasNotifyEffect(property){return this._hasPropertyEffect(property,TYPES.NOTIFY)}_hasReflectEffect(property){return this._hasPropertyEffect(property,TYPES.REFLECT)}_hasComputedEffect(property){return this._hasPropertyEffect(property,TYPES.COMPUTE)}_setPendingPropertyOrPath(path,value,shouldNotify,isPathNotification){if(isPathNotification||root(Array.isArray(path)?path[0]:path)!==path){if(!isPathNotification){let old=get(this,path);if(!(path=set(this,path,value))||!super._shouldPropertyChange(path,value,old))return!1}if(this.__dataHasPaths=!0,this._setPendingProperty(path,value,shouldNotify))return function computeLinkedPaths(inst,path,value){let links=inst.__dataLinkedPaths;if(links){let link;for(let a in links){let b=links[a];isDescendant(a,path)?(link=translate(a,b,path),inst._setPendingPropertyOrPath(link,value,!0,!0)):isDescendant(b,path)&&(link=translate(b,a,path),inst._setPendingPropertyOrPath(link,value,!0,!0))}}}(this,path,value),!0}else{if(this.__dataHasAccessor&&this.__dataHasAccessor[path])return this._setPendingProperty(path,value,shouldNotify);this[path]=value}return!1}_setUnmanagedPropertyToNode(node,prop,value){value===node[prop]&&"object"!=typeof value||("className"===prop&&(node=wrap(node)),node[prop]=value)}_setPendingProperty(property,value,shouldNotify){let propIsPath=this.__dataHasPaths&&isPath(property),prevProps=propIsPath?this.__dataTemp:this.__data;return!!this._shouldPropertyChange(property,value,prevProps[property])&&(this.__dataPending||(this.__dataPending={},this.__dataOld={}),property in this.__dataOld||(this.__dataOld[property]=this.__data[property]),propIsPath?this.__dataTemp[property]=value:this.__data[property]=value,this.__dataPending[property]=value,(propIsPath||this[TYPES.NOTIFY]&&this[TYPES.NOTIFY][property])&&(this.__dataToNotify=this.__dataToNotify||{},this.__dataToNotify[property]=shouldNotify),!0)}_setProperty(property,value){this._setPendingProperty(property,value,!0)&&this._invalidateProperties()}_invalidateProperties(){this.__dataReady&&this._flushProperties()}_enqueueClient(client){this.__dataPendingClients=this.__dataPendingClients||[],client!==this&&this.__dataPendingClients.push(client)}_flushProperties(){this.__dataCounter++,super._flushProperties(),this.__dataCounter--}_flushClients(){this.__dataClientsReady?this.__enableOrFlushClients():(this.__dataClientsReady=!0,this._readyClients(),this.__dataReady=!0)}__enableOrFlushClients(){let clients=this.__dataPendingClients;if(clients){this.__dataPendingClients=null;for(let i=0;i<clients.length;i++){let client=clients[i];client.__dataEnabled?client.__dataPending&&client._flushProperties():client._enableProperties()}}}_readyClients(){this.__enableOrFlushClients()}setProperties(props,setReadOnly){for(let path in props)!setReadOnly&&this[TYPES.READ_ONLY]&&this[TYPES.READ_ONLY][path]||this._setPendingPropertyOrPath(path,props[path],!0);this._invalidateProperties()}ready(){this._flushProperties(),this.__dataClientsReady||this._flushClients(),this.__dataPending&&this._flushProperties()}_propertiesChanged(currentProps,changedProps,oldProps){let hasPaths=this.__dataHasPaths;this.__dataHasPaths=!1,function runComputedEffects(inst,changedProps,oldProps,hasPaths){let computeEffects=inst[TYPES.COMPUTE];if(computeEffects){let inputProps=changedProps;for(;runEffects(inst,computeEffects,inputProps,oldProps,hasPaths);)Object.assign(oldProps,inst.__dataOld),Object.assign(changedProps,inst.__dataPending),inputProps=inst.__dataPending,inst.__dataPending=null}}(this,changedProps,oldProps,hasPaths);let notifyProps=this.__dataToNotify;this.__dataToNotify=null,this._propagatePropertyChanges(changedProps,oldProps,hasPaths),this._flushClients(),runEffects(this,this[TYPES.REFLECT],changedProps,oldProps,hasPaths),runEffects(this,this[TYPES.OBSERVE],changedProps,oldProps,hasPaths),notifyProps&&function runNotifyEffects(inst,notifyProps,props,oldProps,hasPaths){let notified,host,fxs=inst[TYPES.NOTIFY],id=dedupeId++;for(let prop in notifyProps)notifyProps[prop]&&(fxs&&runEffectsForProperty(inst,fxs,id,prop,props,oldProps,hasPaths)?notified=!0:hasPaths&&notifyPath(inst,prop,props)&&(notified=!0));notified&&(host=inst.__dataHost)&&host._invalidateProperties&&host._invalidateProperties()}(this,notifyProps,changedProps,oldProps,hasPaths),1==this.__dataCounter&&(this.__dataTemp={})}_propagatePropertyChanges(changedProps,oldProps,hasPaths){this[TYPES.PROPAGATE]&&runEffects(this,this[TYPES.PROPAGATE],changedProps,oldProps,hasPaths);let templateInfo=this.__templateInfo;for(;templateInfo;)runEffects(this,templateInfo.propertyEffects,changedProps,oldProps,hasPaths,templateInfo.nodeList),templateInfo=templateInfo.nextTemplateInfo}linkPaths(to,from){to=normalize(to),from=normalize(from),this.__dataLinkedPaths=this.__dataLinkedPaths||{},this.__dataLinkedPaths[to]=from}unlinkPaths(path){path=normalize(path),this.__dataLinkedPaths&&delete this.__dataLinkedPaths[path]}notifySplices(path,splices){let info={path:""};notifySplices(this,get(this,path,info),info.path,splices)}get(path,root){return get(root||this,path)}set(path,value,root){root?set(root,path,value):this[TYPES.READ_ONLY]&&this[TYPES.READ_ONLY][path]||this._setPendingPropertyOrPath(path,value,!0)&&this._invalidateProperties()}push(path,...items){let info={path:""},array=get(this,path,info),len=array.length,ret=array.push(...items);return items.length&&notifySplice(this,array,info.path,len,items.length,[]),ret}pop(path){let info={path:""},array=get(this,path,info),hadLength=Boolean(array.length),ret=array.pop();return hadLength&&notifySplice(this,array,info.path,array.length,0,[ret]),ret}splice(path,start,deleteCount,...items){let ret,info={path:""},array=get(this,path,info);return start<0?start=array.length-Math.floor(-start):start&&(start=Math.floor(start)),ret=2===arguments.length?array.splice(start):array.splice(start,deleteCount,...items),(items.length||ret.length)&&notifySplice(this,array,info.path,start,items.length,ret),ret}shift(path){let info={path:""},array=get(this,path,info),hadLength=Boolean(array.length),ret=array.shift();return hadLength&&notifySplice(this,array,info.path,0,0,[ret]),ret}unshift(path,...items){let info={path:""},array=get(this,path,info),ret=array.unshift(...items);return items.length&&notifySplice(this,array,info.path,0,items.length,[]),ret}notifyPath(path,value){let propPath;if(1==arguments.length){let info={path:""};value=get(this,path,info),propPath=info.path}else propPath=Array.isArray(path)?normalize(path):path;this._setPendingPropertyOrPath(propPath,value,!0,!0)&&this._invalidateProperties()}_createReadOnlyProperty(property,protectedSetter){this._addPropertyEffect(property,TYPES.READ_ONLY),protectedSetter&&(this["_set"+function upper(name){return name[0].toUpperCase()+name.substring(1)}(property)]=function(value){this._setProperty(property,value)})}_createPropertyObserver(property,method,dynamicFn){let info={property:property,method:method,dynamicFn:Boolean(dynamicFn)};this._addPropertyEffect(property,TYPES.OBSERVE,{fn:runObserverEffect,info:info,trigger:{name:property}}),dynamicFn&&this._addPropertyEffect(method,TYPES.OBSERVE,{fn:runObserverEffect,info:info,trigger:{name:method}})}_createMethodObserver(expression,dynamicFn){let sig=parseMethod(expression);if(!sig)throw new Error("Malformed observer expression '"+expression+"'");createMethodEffect(this,sig,TYPES.OBSERVE,runMethodEffect,null,dynamicFn)}_createNotifyingProperty(property){this._addPropertyEffect(property,TYPES.NOTIFY,{fn:runNotifyEffect,info:{eventName:camelToDashCase(property)+"-changed",property:property}})}_createReflectedProperty(property){let attr=this.constructor.attributeNameForProperty(property);"-"===attr[0]?console.warn("Property "+property+" cannot be reflected to attribute "+attr+' because "-" is not a valid starting attribute name. Use a lowercase first letter for the property instead.'):this._addPropertyEffect(property,TYPES.REFLECT,{fn:runReflectEffect,info:{attrName:attr}})}_createComputedProperty(property,expression,dynamicFn){let sig=parseMethod(expression);if(!sig)throw new Error("Malformed computed expression '"+expression+"'");createMethodEffect(this,sig,TYPES.COMPUTE,runComputedEffect,property,dynamicFn)}_marshalArgs(args,path,props){const data=this.__data,values=[];for(let i=0,l=args.length;i<l;i++){let{name:name,structured:structured,wildcard:wildcard,value:value,literal:literal}=args[i];if(!literal)if(wildcard){const matches=isDescendant(name,path),pathValue=getArgValue(data,props,matches?path:name);value={path:matches?path:name,value:pathValue,base:matches?get(data,name):pathValue}}else value=structured?getArgValue(data,props,name):data[name];values[i]=value}return values}static addPropertyEffect(property,type,effect){this.prototype._addPropertyEffect(property,type,effect)}static createPropertyObserver(property,method,dynamicFn){this.prototype._createPropertyObserver(property,method,dynamicFn)}static createMethodObserver(expression,dynamicFn){this.prototype._createMethodObserver(expression,dynamicFn)}static createNotifyingProperty(property){this.prototype._createNotifyingProperty(property)}static createReadOnlyProperty(property,protectedSetter){this.prototype._createReadOnlyProperty(property,protectedSetter)}static createReflectedProperty(property){this.prototype._createReflectedProperty(property)}static createComputedProperty(property,expression,dynamicFn){this.prototype._createComputedProperty(property,expression,dynamicFn)}static bindTemplate(template){return this.prototype._bindTemplate(template)}_bindTemplate(template,instanceBinding){let templateInfo=this.constructor._parseTemplate(template),wasPreBound=this.__templateInfo==templateInfo;if(!wasPreBound)for(let prop in templateInfo.propertyEffects)this._createPropertyAccessor(prop);if(instanceBinding&&((templateInfo=Object.create(templateInfo)).wasPreBound=wasPreBound,!wasPreBound&&this.__templateInfo)){let last=this.__templateInfoLast||this.__templateInfo;return this.__templateInfoLast=last.nextTemplateInfo=templateInfo,templateInfo.previousTemplateInfo=last,templateInfo}return this.__templateInfo=templateInfo}static _addTemplatePropertyEffect(templateInfo,prop,effect){(templateInfo.hostProps=templateInfo.hostProps||{})[prop]=!0;let effects=templateInfo.propertyEffects=templateInfo.propertyEffects||{};(effects[prop]=effects[prop]||[]).push(effect)}_stampTemplate(template){hostStack.beginHosting(this);let dom=super._stampTemplate(template);hostStack.endHosting(this);let templateInfo=this._bindTemplate(template,!0);if(templateInfo.nodeList=dom.nodeList,!templateInfo.wasPreBound){let nodes=templateInfo.childNodes=[];for(let n=dom.firstChild;n;n=n.nextSibling)nodes.push(n)}return dom.templateInfo=templateInfo,function setupBindings(inst,templateInfo){let{nodeList:nodeList,nodeInfoList:nodeInfoList}=templateInfo;if(nodeInfoList.length)for(let i=0;i<nodeInfoList.length;i++){let info=nodeInfoList[i],node=nodeList[i],bindings=info.bindings;if(bindings)for(let i=0;i<bindings.length;i++){let binding=bindings[i];setupCompoundStorage(node,binding),addNotifyListener(node,inst,binding)}node.__dataHost=inst}}(this,templateInfo),this.__dataReady&&runEffects(this,templateInfo.propertyEffects,this.__data,null,!1,templateInfo.nodeList),dom}_removeBoundDom(dom){let templateInfo=dom.templateInfo;templateInfo.previousTemplateInfo&&(templateInfo.previousTemplateInfo.nextTemplateInfo=templateInfo.nextTemplateInfo),templateInfo.nextTemplateInfo&&(templateInfo.nextTemplateInfo.previousTemplateInfo=templateInfo.previousTemplateInfo),this.__templateInfoLast==templateInfo&&(this.__templateInfoLast=templateInfo.previousTemplateInfo),templateInfo.previousTemplateInfo=templateInfo.nextTemplateInfo=null;let nodes=templateInfo.childNodes;for(let i=0;i<nodes.length;i++){let node=nodes[i];node.parentNode.removeChild(node)}}static _parseTemplateNode(node,templateInfo,nodeInfo){let noted=propertyEffectsBase._parseTemplateNode.call(this,node,templateInfo,nodeInfo);if(node.nodeType===Node.TEXT_NODE){let parts=this._parseBindings(node.textContent,templateInfo);parts&&(node.textContent=literalFromParts(parts)||" ",addBinding(this,templateInfo,nodeInfo,"text","textContent",parts),noted=!0)}return noted}static _parseTemplateNodeAttribute(node,templateInfo,nodeInfo,name,value){let parts=this._parseBindings(value,templateInfo);if(parts){let origName=name,kind="property";capitalAttributeRegex.test(name)?kind="attribute":"$"==name[name.length-1]&&(name=name.slice(0,-1),kind="attribute");let literal=literalFromParts(parts);return literal&&"attribute"==kind&&("class"==name&&node.hasAttribute("class")&&(literal+=" "+node.getAttribute(name)),node.setAttribute(name,literal)),"input"===node.localName&&"value"===origName&&node.setAttribute(origName,""),node.removeAttribute(origName),"property"===kind&&(name=dashToCamelCase(name)),addBinding(this,templateInfo,nodeInfo,kind,name,parts,literal),!0}return propertyEffectsBase._parseTemplateNodeAttribute.call(this,node,templateInfo,nodeInfo,name,value)}static _parseTemplateNestedTemplate(node,templateInfo,nodeInfo){let noted=propertyEffectsBase._parseTemplateNestedTemplate.call(this,node,templateInfo,nodeInfo),hostProps=nodeInfo.templateInfo.hostProps;for(let source in hostProps)addBinding(this,templateInfo,nodeInfo,"property","_host_"+source,[{mode:"{",source:source,dependencies:[source]}]);return noted}static _parseBindings(text,templateInfo){let m,parts=[],lastIndex=0;for(;null!==(m=bindingRegex.exec(text));){m.index>lastIndex&&parts.push({literal:text.slice(lastIndex,m.index)});let mode=m[1][0],negate=Boolean(m[2]),source=m[3].trim(),customEvent=!1,notifyEvent="",colon=-1;"{"==mode&&(colon=source.indexOf("::"))>0&&(notifyEvent=source.substring(colon+2),source=source.substring(0,colon),customEvent=!0);let signature=parseMethod(source),dependencies=[];if(signature){let{args:args,methodName:methodName}=signature;for(let i=0;i<args.length;i++){let arg=args[i];arg.literal||dependencies.push(arg)}let dynamicFns=templateInfo.dynamicFns;(dynamicFns&&dynamicFns[methodName]||signature.static)&&(dependencies.push(methodName),signature.dynamicFn=!0)}else dependencies.push(source);parts.push({source:source,mode:mode,negate:negate,customEvent:customEvent,signature:signature,dependencies:dependencies,event:notifyEvent}),lastIndex=bindingRegex.lastIndex}if(lastIndex&&lastIndex<text.length){let literal=text.substring(lastIndex);literal&&parts.push({literal:literal})}return parts.length?parts:null}static _evaluateBinding(inst,part,path,props,oldProps,hasPaths){let value;return value=part.signature?runMethodEffect(inst,path,props,0,part.signature):path!=part.source?get(inst,part.source):hasPaths&&isPath(path)?get(inst,path):inst.__data[path],part.negate&&(value=!value),value}}});const hostStack=new class HostStack{constructor(){this.stack=[]}registerHost(inst){this.stack.length&&this.stack[this.stack.length-1]._enqueueClient(inst)}beginHosting(inst){this.stack.push(inst)}endHosting(inst){let stackLen=this.stack.length;stackLen&&this.stack[stackLen-1]==inst&&this.stack.pop()}};