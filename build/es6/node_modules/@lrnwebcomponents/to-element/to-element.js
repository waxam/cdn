class ToElement extends HTMLElement{get html(){return"\n<style></style>\n<slot></slot>"}static get properties(){return{element:{name:"element",type:"Object",value:{}},name:{name:"name",type:"String",value:"new-element"},sourceUrl:{name:"sourceUrl",type:"String",value:""},fileTypes:{type:"Object",value:()=>({CSV:"text/csv",JSON:"text/json",PDF:"application/pdf",TXT:"text/plain"})}}}static get tag(){return"to-element"}constructor(delayRender=!1){super(),this.tag=ToElement.tag;let obj=ToElement.properties;for(let p in obj)obj.hasOwnProperty(p)&&(this.hasAttribute(p)?this[p]=this.getAttribute(p):(this.setAttribute(p,obj[p].value),this[p]=obj[p].value));this._queue=[],this.template=document.createElement("template"),this.attachShadow({mode:"open"}),delayRender||this.render()}connectedCallback(){window.ShadyCSS&&window.ShadyCSS.styleElement(this),this._queue.length&&this._processQueue()}_copyAttribute(name,to){const recipients=this.shadowRoot.querySelectorAll(to),value=this.getAttribute(name),fname=null==value?"removeAttribute":"setAttribute";for(const node of recipients)node[fname](name,value)}_queueAction(action){this._queue.push(action)}_processQueue(){this._queue.forEach(action=>{this[`_${action.type}`](action.data)}),this._queue=[]}_setProperty({name:name,value:value}){this[name]=value}render(){this.shadowRoot.innerHTML=null,this.template.innerHTML=this.html,window.ShadyCSS&&window.ShadyCSS.prepareTemplate(this.template,this.tag),this.shadowRoot.appendChild(this.template.content.cloneNode(!0))}createNewElement(){this._tmp=this.element;let css=this.extractCSS(this._tmp).stylesheet;return{html:this._tmp.outerHTML,css:css}}generateUUID(){return"item-sss-ss-ss".replace(/s/g,this._uuidPart)}_uuidPart(){return Math.floor(65536*(1+Math.random())).toString(16).substring(1)}getDefaultStyling(element,part=null){let tagName=element.tagName;var iframe=document.createElement("iframe");this.shadowRoot.appendChild(iframe);var iframeDocument=iframe.contentDocument,targetElement=iframeDocument.createElement(tagName);iframeDocument.body.appendChild(targetElement);for(var styling=iframe.contentWindow.getComputedStyle(targetElement),clonedStyling={},i=0,len=styling.length;i<len;i++){var property=styling[i];clonedStyling[i]=property,clonedStyling[property]=styling[property]}return this.shadowRoot.removeChild(iframe),clonedStyling}getStylesWithoutDefaults(element,part=null){for(var allStyling=window.getComputedStyle(element,part),defaultStyling=this.getDefaultStyling(element.tagName),userStyling={},i=0,len=allStyling.length;i<len;i++){var property=allStyling[i],value=allStyling[property];value!=defaultStyling[property]&&"transform-origin"!==property&&"perspective-origin"!==property&&(userStyling[property]=value)}return userStyling}flatten(arr){return arr.reduce((flat,toFlatten)=>flat.concat(Array.isArray(toFlatten)?this.flatten(toFlatten):toFlatten),[])}recursiveExtract(element){const id=this.generateUUID(),styles=this.getStylesWithoutDefaults(element);element.setAttribute("id",id);let css="";for(var i in styles)css+=`      ${i}: ${styles[i]};\n`;var children=Array.prototype.slice.call(element.children);return[{id:id,style:css}].concat(children.map(this.recursiveExtract.bind(this)))}extractCSS(element){if(!element)return{elements:[],stylesheet:""};var raw=this.recursiveExtract(element),flat=this.flatten(raw);return{elements:flat,stylesheet:flat.reduce(function(acc,cur){return acc+("    #"+cur.id+" {\n"+cur.style+"    }\n")},"")}}dashToCamel(str){return str.replace(/-([a-z])/g,function(g){return g[1].toUpperCase()})}contentToFile(html){return`\n/**\n * Copyright 2019 {Your compay}\n * @license Apache-2.0, see License.md for full text.\n */\nimport { html, PolymerElement } from "@polymer/polymer/polymer-element.js";\n/**\n * \`${this.name}\`\n * \`An auto generated element via to-element\`\n *\n * @microcopy - language worth noting:\n *  - This element was made by someone else and then forked from their site\n *  - The point is not perfection but to rapidly generate boilerplate\n *\n * @originalSite - This code is based on work originally found on\n *   - ${this.sourceUrl}\n * @customElement\n * @polymer\n */\nclass ${this.dashToCamel(this.name)} extends PolymerElement {\n  \n  // render function\n  static get template() {\n    return html\`\n    ${html}\n    \`;\n  }\n\n  // properties available to the custom element for data binding\n  static get properties() {\n    return {\n      "title": {\n        "name": "title",\n        "type": "String",\n        "value": "",\n      }\n    };\n  }\n\n  /**\n   * Store the tag name to make it easier to obtain directly.\n   */\n  static get tag() {\n    return "${this.name}";\n  }\n  /**\n   * life cycle, element is afixed to the DOM\n   */\n  //connectedCallback() { super.connectedCallback(); }\n  /**\n   * life cycle, element is removed from the DOM\n   */\n  //disconnectedCallback() {super.disconnectedCallback();}\n}\nwindow.customElements.define(${this.dashToCamel(this.name)}.tag, ${this.dashToCamel(this.name)});\nexport { ${this.dashToCamel(this.name)} };\n    `}downloadNewComponent(element,name){element&&(this.element=element),name&&(this.name=name);let tmp=this.createNewElement(),html=`<style>\n${tmp.css}</style>\n    ${tmp.html}`,data=this.contentToFile(html);this.downloadFromData(data,"js",this.name)}downloadFromData(data,type,name="download",newTab=!0){const mimeType=this.fileTypes[type.toUpperCase()],blob=new Blob([decodeURIComponent(encodeURI(data))],{type:mimeType}),filename=name+"."+type.toLowerCase();if(window.navigator&&window.navigator.msSaveOrOpenBlob)window.navigator.msSaveOrOpenBlob(blob,filename);else{const link=document.createElement("a");link.href=(window.URL||window.webkitURL).createObjectURL(blob),link.download=filename,link.target=newTab?"_blank":"_self",this.shadowRoot.appendChild(link),link.click(),this.shadowRoot.removeChild(link)}}downloadFromURI(uri,newTab=!0){return window.open(uri,newTab?"_blank":"_self"),!0}}window.customElements.define(ToElement.tag,ToElement);export{ToElement};