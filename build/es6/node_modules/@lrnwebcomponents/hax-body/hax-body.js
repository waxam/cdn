import{html,PolymerElement}from"../../@polymer/polymer/polymer-element.js";import{dom}from"../../@polymer/polymer/lib/legacy/polymer.dom.js";import{FlattenedNodesObserver}from"../../@polymer/polymer/lib/utils/flattened-nodes-observer.js";import{flush}from"../../@polymer/polymer/lib/utils/flush.js";import{afterNextRender}from"../../@polymer/polymer/lib/utils/render-status.js";import*as async from"../../@polymer/polymer/lib/utils/async.js";import{encapScript,wipeSlot}from"./lib/haxutils.js";import"../simple-colors/simple-colors.js";import"./lib/hax-text-context.js";import"./lib/hax-ce-context.js";import"./lib/hax-plate-context.js";import"./lib/hax-input-mixer.js";import"./lib/hax-shared-styles.js";/**
 * `hax-body`
 * `Manager of the body area that can be modified`
 * @microcopy - the mental model for this element
 *  - body is effectively a body of content that can be manipulated in the browser. This is for other HAX elements ultimately to interface with and reside in. It is the controller of input and output for all of HAX as it exists in a document. body is not the <body> tag but we need a similar mental model container for all our other elements.
 *  - text-context - the context menu that shows up when an item is active so it can have text based operations performed to it.
 *  - plate/grid plate - a plate or grid plate is a container that we can operate on in HAX. it can also have layout / "global" type of body operations performed on it such as delete, duplicate and higher level format styling.
 */class HaxBody extends PolymerElement{constructor(){super();import("../../@polymer/iron-a11y-keys/iron-a11y-keys.js");import("../../@polymer/paper-item/paper-item.js");import("../grid-plate/grid-plate.js")}static get tag(){return"hax-body"}static get template(){return html`
      <style include="simple-colors hax-shared-styles">
        @import url("https://fonts.googleapis.com/css?family=Noto+Serif");
        :host {
          display: block;
          min-height: 32px;
          min-width: 32px;
          outline: none;
        }
        .hax-context-menu {
          padding: 0;
          margin-left: -5000px;
          position: absolute;
          visibility: hidden;
          opacity: 0;
          z-index: 1000;
          float: left;
          display: block;
          pointer-events: none;
          transition: 0.8s opacity ease-in-out, 0.8s visibility ease-in-out;
        }
        #haxinputmixer {
          z-index: 10000000;
        }
        .hax-context-visible.hax-active-hover {
          visibility: visible;
          opacity: 1;
          pointer-events: all;
          margin-left: unset;
        }
        :host #bodycontainer ::slotted(*) {
          font-family: "Noto Serif", serif;
          color: #444;
          margin: 2px;
        }
        :host #bodycontainer ::slotted(h1) {
          font-size: 2.5em;
          line-height: 2.5em;
        }
        :host #bodycontainer ::slotted(h2) {
          font-size: 2em;
        }
        :host #bodycontainer ::slotted(h3) {
          font-size: 1.75em;
        }
        :host #bodycontainer ::slotted(h4) {
          font-size: 1.5em;
        }
        :host #bodycontainer ::slotted(h5),
        :host #bodycontainer ::slotted(h6) {
          font-size: 1.25em;
        }
        :host #bodycontainer ::slotted(p) {
          line-height: 40px;
          min-height: 26px;
          font-size: 24px;
        }
        :host #bodycontainer ::slotted(a),
        :host #bodycontainer ::slotted(a:visited),
        :host #bodycontainer ::slotted(a:active) {
          color: #000;
        }
        :host #bodycontainer ::slotted(a:hover) {
          color: #2196f3;
        }
        :host #bodycontainer ::slotted(ol),
        :host #bodycontainer ::slotted(ul),
        :host #bodycontainer ::slotted(li) {
          padding-bottom: 1.5em;
          line-height: 40px;
          font-size: 24px;
          max-width: 28em;
        }
        :host #bodycontainer ::slotted(ol > li:last-child),
        :host #bodycontainer ::slotted(ul > li:last-child) {
          padding-bottom: 1em;
        }
        :host #bodycontainer ::slotted(ul),
        :host #bodycontainer ::slotted(ol) {
          padding-left: 20px;
          margin-left: 20px;
        }

        :host([edit-mode]) #bodycontainer ::slotted(*[data-editable]) {
          outline: none;
          outline-offset: 2px;
          transition: 0.2s width ease-in-out, 0.2s height ease-in-out,
            0.2s margin ease-in-out;
          caret-color: var(--hax-color-text);
        }
        :host([edit-mode]) #bodycontainer ::slotted(*[data-editable]:hover) {
          outline: 1px solid rgba(145, 151, 162, 0.25);
          caret-color: #000000;
        }
        :host([edit-mode])
          #bodycontainer
          ::slotted(*.hax-active[data-editable]:hover) {
          cursor: text !important;
          outline: 1px solid rgba(145, 151, 162, 0.25);
        }
        :host([edit-mode])
          #bodycontainer
          ::slotted(*[data-editable] .hax-active:hover) {
          cursor: text !important;
          outline: 1px solid rgba(145, 151, 162, 0.25);
        }
        :host([edit-mode])
          #bodycontainer
          ::slotted(code.hax-active[data-editable]) {
          display: block;
        }
        :host([edit-mode]) #bodycontainer ::slotted(hr[data-editable]) {
          height: 2px;
          background-color: #eeeeee;
          padding-top: 4px;
          padding-bottom: 4px;
        }
        /** Fix to support safari as it defaults to none */
        :host([edit-mode]) #bodycontainer ::slotted(*[data-editable]) {
          -webkit-user-select: text;
          cursor: pointer;
        }

        :host([edit-mode])
          #bodycontainer
          ::slotted(*[data-editable]::-moz-selection),
        :host([edit-mode])
          #bodycontainer
          ::slotted(*[data-editable] *::-moz-selection) {
          background-color: var(--hax-body-highlight, --paper-yellow-300);
          color: black;
        }
        :host([edit-mode])
          #bodycontainer
          ::slotted(*[data-editable]::selection),
        :host([edit-mode])
          #bodycontainer
          ::slotted(*[data-editable] *::selection) {
          background-color: var(--hax-body-highlight, --paper-yellow-300);
          color: black;
        }
        #bodycontainer {
          -webkit-user-select: text;
          user-select: text;
        }
        :host([edit-mode][hax-ray-mode])
          #bodycontainer
          ::slotted(*[data-editable]):before {
          content: attr(data-hax-ray) " " attr(resource) " " attr(typeof) " "
            attr(property) " " attr(content);
          font-size: 10px;
          font-style: italic;
          left: unset;
          right: unset;
          top: unset;
          background-color: #d3d3d3;
          color: #000000;
          bottom: unset;
          width: auto;
          padding: 8px;
          margin: 0;
          z-index: 1;
          margin: -16px 0 0 0;
          float: right;
          line-height: 2;
        }
      </style>
      <div id="bodycontainer" class="ignore-activation">
        <slot id="body"></slot>
      </div>
      <hax-text-context
        id="textcontextmenu"
        class="hax-context-menu ignore-activation"
      ></hax-text-context>
      <hax-ce-context
        id="cecontextmenu"
        class="hax-context-menu ignore-activation"
      ></hax-ce-context>
      <hax-plate-context
        id="platecontextmenu"
        class="hax-context-menu ignore-activation"
      ></hax-plate-context>
      <hax-input-mixer
        id="haxinputmixer"
        class="hax-context-menu ignore-activation"
      ></hax-input-mixer>
    `}static get properties(){return{/**
       * State of if we are editing or not.
       */editMode:{type:Boolean,value:!1,reflectToAttribute:!0,observer:"_editModeChanged"},/**
       * Access to the global properties object.
       */globalPreferences:{type:Object,value:{},observer:"_globalPreferencesUpdated"},/**
       * Bust out the HAX Ray mode
       */haxRayMode:{type:Boolean,value:!1,reflectToAttribute:!0},/**
       * A reference to the active node in the slot.
       */activeNode:{type:Object,value:null,notify:!0,observer:"_activeNodeChanged"},/**
       * A reference to the active node in the slot.
       */activeContainerNode:{type:Object,value:null,notify:!0,observer:"_activeContainerNodeChanged"}}}/**
   * Ready state to tee everything up.
   */ready(){super.ready();this.dispatchEvent(new CustomEvent("hax-register-body",{bubbles:!0,cancelable:!0,composed:!0,detail:this}));this.polyfillSafe=window.HaxStore.instance.computePolyfillSafe();// mutation observer that ensures state of hax applied correctly
afterNextRender(this,function(){this._observer=new FlattenedNodesObserver(this,info=>{// MAKE SURE WE KNOW WHAT JUST GOT ADDED HERE
flush();// if we've got new nodes, we have to react to that
if(0<info.addedNodes.length){info.addedNodes.map(node=>{if(this._haxElementTest(node)){if(this._HTMLPrimativeTest(node)){node.contentEditable=this.editMode}// this does the real targetting
node.setAttribute("data-editable",this.editMode);let haxRay=node.tagName.replace("-"," ").toLowerCase(),i=window.HaxStore.instance.gizmoList.findIndex(j=>j.tag===node.tagName.toLowerCase());if(-1!==i){haxRay=window.HaxStore.instance.gizmoList[i].title}node.setAttribute("data-hax-ray",haxRay);this.dispatchEvent(new CustomEvent("hax-body-tag-added",{bubbles:!0,cancelable:!0,composed:!0,detail:{node:node}}))}})}// if we dropped nodes via the UI (delete event basically)
if(0<info.removedNodes.length){// handle removing items... not sure we need to do anything here
info.removedNodes.map(node=>{if(this._haxElementTest(node)&&!node.classList.contains("hax-active")){this.dispatchEvent(new CustomEvent("hax-body-tag-removed",{bubbles:!0,cancelable:!0,composed:!0,detail:{node:node}}))}})}})})}/**
   * Attached to the DOM; now we can fire event to the store that
   * we exist and are the thing being edited.
   */connectedCallback(){super.connectedCallback();afterNextRender(this,function(){// in case we miss this on the initial setup. possible in auto opening environments.
this.editMode=window.HaxStore.instance.editMode;// try to normalize paragraph insert on enter
try{document.execCommand("enableObjectResizing",!1,!1);document.execCommand("defaultParagraphSeparator",!1,"p")}catch(e){console.log(e)}window.addEventListener("keydown",this._onKeyDown.bind(this));window.addEventListener("keypress",this._onKeyPress.bind(this));this.shadowRoot.querySelector("slot").addEventListener("mousemove",this.hoverEvent.bind(this));this.shadowRoot.querySelector("slot").addEventListener("mouseup",e=>{const tmp=window.HaxStore.getSelection();window.HaxStore._tmpSelection=tmp;try{const range=window.HaxStore.getRange();if(range.cloneRange){window.HaxStore._tmpRange=range.cloneRange()}}catch(e){console.log(e)}});this.shadowRoot.querySelector("slot").addEventListener("paste",e=>{// only perform this on a text element that is active
if(window.HaxStore.instance.isTextElement(window.HaxStore.instance.activeNode)&&!window.HaxStore.instance.haxManager.opened){e.preventDefault();e.stopPropagation();e.stopImmediatePropagation();let text="";// intercept paste event
if(e.clipboardData||e.originalEvent.clipboardData){text=(e.originalEvent||e).clipboardData.getData("text/plain")}else if(window.clipboardData){text=window.clipboardData.getData("Text")}try{let range=window.HaxStore.getRange(),sel=window.HaxStore.getSelection(),newNode=document.createTextNode(text),newRange=document.createRange();if(range&&sel){range.deleteContents();range.insertNode(newNode);newRange.setStart(newNode,text.length);newRange.collapse(!0);sel.removeAllRanges();sel.addRange(newRange)}}catch(e){console.log(e)}}});this.__tabTrap=!1;document.body.addEventListener("hax-store-property-updated",this._haxStorePropertyUpdated.bind(this));window.addEventListener("scroll",this._keepContextVisible.bind(this));this.addEventListener("focusin",this._focusIn.bind(this));this.addEventListener("mousedown",this._focusIn.bind(this));this.addEventListener("hax-context-item-selected",this._haxContextOperation.bind(this));this.addEventListener("hax-input-mixer-update",this._haxInputMixerOperation.bind(this));this.addEventListener("place-holder-replace",this.replacePlaceholder.bind(this))})}/**
   * Detached life cycle
   */disconnectedCallback(){window.removeEventListener("keydown",this._onKeyDown.bind(this));window.removeEventListener("keypress",this._onKeyPress.bind(this));this.shadowRoot.querySelector("slot").removeEventListener("mousemove",this.hoverEvent.bind(this));this.shadowRoot.querySelector("slot").removeEventListener("mouseup",e=>{const tmp=window.HaxStore.getSelection();window.HaxStore._tmpSelection=tmp;try{const range=window.HaxStore.getRange();if(range.cloneRange){window.HaxStore._tmpRange=range.cloneRange()}}catch(e){console.log(e)}});this.shadowRoot.querySelector("slot").removeEventListener("paste",e=>{// only perform this on a text element that is active
if(window.HaxStore.instance.isTextElement(window.HaxStore.instance.activeNode)&&!window.HaxStore.instance.haxManager.opened){e.preventDefault();e.stopPropagation();e.stopImmediatePropagation();let text="";// intercept paste event
if(e.clipboardData||e.originalEvent.clipboardData){text=(e.originalEvent||e).clipboardData.getData("text/plain")}else if(window.clipboardData){text=window.clipboardData.getData("Text")}try{let range=window.HaxStore.getRange(),sel=window.HaxStore.getSelection(),newNode=document.createTextNode(text),newRange=document.createRange();if(range&&sel){range.deleteContents();range.insertNode(newNode);newRange.setStart(newNode,text.length);newRange.collapse(!0);sel.removeAllRanges();sel.addRange(newRange)}}catch(e){console.log(e)}}});document.body.removeEventListener("hax-store-property-updated",this._haxStorePropertyUpdated.bind(this));window.removeEventListener("scroll",this._keepContextVisible.bind(this));this.removeEventListener("focusin",this._focusIn.bind(this));this.removeEventListener("mousedown",this._focusIn.bind(this));this.removeEventListener("hax-context-item-selected",this._haxContextOperation.bind(this));this.removeEventListener("hax-input-mixer-update",this._haxInputMixerOperation.bind(this));this.removeEventListener("place-holder-replace",this.replacePlaceholder.bind(this));super.disconnectedCallback()}/**
   * Keep the context menu visible if needed
   */_keepContextVisible(e){// see if the text context menu is visible
let el=!1;if(this.$.textcontextmenu.classList.contains("hax-context-visible")){el=this.$.textcontextmenu}else if(this.$.cecontextmenu.classList.contains("hax-context-visible")){el=this.$.cecontextmenu}// if we see it, ensure we don't have the pin
if(el){if(this.elementInViewport(el)){el.classList.remove("hax-context-pin-bottom","hax-context-pin-top")}else{if(this.__OffBottom){el.classList.add("hax-context-pin-top")}else{el.classList.add("hax-context-pin-bottom")}}}}_onKeyDown(e){if(this.editMode&&this.getAttribute("contenteditable")){setTimeout(()=>{const rng=window.HaxStore.getRange();switch(e.key){case"Tab":if(window.HaxStore.instance.isTextElement(this.activeContainerNode)){if(e.detail.keyboardEvent){e.detail.keyboardEvent.preventDefault();e.detail.keyboardEvent.stopPropagation();e.detail.keyboardEvent.stopImmediatePropagation()}e.preventDefault();e.stopPropagation();e.stopImmediatePropagation();if(e.shiftKey){this._tabBackKeyPressed()}else{this._tabKeyPressed()}}break;case"Enter":this.setAttribute("contenteditable",!0);setTimeout(()=>{if(rng.commonAncestorContainer&&"function"===typeof rng.commonAncestorContainer.focus){rng.commonAncestorContainer.focus();this.__focusLogic(rng.commonAncestorContainer)}},900);break;case"ArrowUp":case"ArrowDown":case"ArrowLeft":case"ArrowRight":if(rng.commonAncestorContainer&&this.activeNode!==rng.commonAncestorContainer&&"function"===typeof rng.commonAncestorContainer.focus){if("HAX-BODY"!==rng.commonAncestorContainer.tagName){if(window.HaxStore.instance.isTextElement(rng.commonAncestorContainer)){this.setAttribute("contenteditable",!0)}else{this.removeAttribute("contenteditable")}setTimeout(()=>{rng.commonAncestorContainer.focus();this.__focusLogic(rng.commonAncestorContainer)},900)}}// need to check on the parent too if this was a text node
else if(rng.commonAncestorContainer&&rng.commonAncestorContainer.parentNode&&this.activeNode!==rng.commonAncestorContainer.parentNode&&"function"===typeof rng.commonAncestorContainer.parentNode.focus){if("HAX-BODY"!==rng.commonAncestorContainer.parentNode.tagName){if(window.HaxStore.instance.isTextElement(rng.commonAncestorContainer.parentNode)){this.setAttribute("contenteditable",!0)}else{this.removeAttribute("contenteditable")}setTimeout(()=>{rng.commonAncestorContainer.parentNode.focus();this.__focusLogic(rng.commonAncestorContainer.parentNode)},900)}}break;}},100);if(this.$.platecontextmenu.classList.contains("hax-active-hover")){this.__dropActiveHover()}}}_onKeyPress(e){if(this.editMode&&this.$.platecontextmenu.classList.contains("hax-active-hover")){this.__dropActiveHover()}}/**
   * on mouse over then fire the hax ray value if we have one
   */hoverEvent(e){if(this.editMode){if(e.target&&null!=e.target.getAttribute("data-hax-ray")){this.__activeHover=e.target;this.dispatchEvent(new CustomEvent("hax-active-hover-name",{bubbles:!0,cancelable:!0,composed:!0,detail:e.target.getAttribute("data-hax-ray")}))}else if(e.target&&e.target.parentNode&&null!=e.target.parentNode.getAttribute("data-hax-ray")){this.__activeHover=e.target.parentNode;this.dispatchEvent(new CustomEvent("hax-active-hover-name",{bubbles:!0,cancelable:!0,composed:!0,detail:e.target.parentNode.getAttribute("data-hax-ray")}))}if(!this.$.platecontextmenu.classList.contains("hax-active-hover")){let normalizedEvent=dom(e),local=normalizedEvent.localTarget;// see if the target is relevent when showing the edit menu operations
if(e.target===this.$.cecontextmenu||e.target===this.$.textcontextmenu||e.target===this.$.platecontextmenu||local===this.activeNode||local===this.activeContainerNode||e.target===this.activeNode||e.target===this.activeContainerNode||local.parentNode===this.activeContainerNode||local.parentNode.parentNode===this.activeContainerNode||local.parentNode.parentNode.parentNode===this.activeContainerNode){this.__addActiveHover();this.__typeLock=!1}else{this.__dropActiveHover()}}}}__addActiveHover(){this.$.cecontextmenu.classList.add("hax-active-hover");this.$.textcontextmenu.classList.add("hax-active-hover");this.$.platecontextmenu.classList.add("hax-active-hover")}__dropActiveHover(){this.$.cecontextmenu.classList.remove("hax-active-hover");this.$.textcontextmenu.classList.remove("hax-active-hover");this.$.platecontextmenu.classList.remove("hax-active-hover")}/**
   * Check if part of the passed element is int he viewport
   */elementInViewport(el){let top=el.offsetTop-32-window.HaxStore.instance.haxPanel.$.drawer.offsetHeight,left=el.offsetLeft,width=el.offsetWidth,height=el.offsetHeight;while(el.offsetParent){el=el.offsetParent;top+=el.offsetTop;left+=el.offsetLeft}this.__OffBottom=top<window.pageYOffset+window.innerHeight;return top<window.pageYOffset+window.innerHeight&&left<window.pageXOffset+window.innerWidth&&top+height>window.pageYOffset&&left+width>window.pageXOffset}/**
   * Replace place holder after an event has called for it in the element itself
   */replacePlaceholder(e){// generate a paragraph of text here on click
if("text"===e.detail){// make sure text just escalates to a paragraph tag
let p=document.createElement("p");p.innerHTML="<br/>";this.haxReplaceNode(this.activeNode,p,dom(this.activeNode).parentNode);// allow swap out to happen
setTimeout(()=>{// set active to this p tag
this.activeNode=p;window.HaxStore.write("activeNode",p,this);this.activeContainerNode.setAttribute("contenteditable",!0);// focus on it
p.focus();this.__focusLogic(p)},210)}else{this.replaceElementWorkflow()}}/**
   * Whole workflow of replacing something in place contextually.
   * This can fire for things like events needing this workflow to
   * invoke whether it's a "convert" event or a "replace placeholder" event
   */replaceElementWorkflow(){let element=window.HaxStore.nodeToHaxElement(this.activeNode,null),type="*",skipPropMatch=!1;// special support for place holder which defines exactly
// what the user wants this replaced with
if("place-holder"===element.tag&&typeof element.properties.type!==typeof void 0){type=element.properties.type;skipPropMatch=!0}var props={};// see if we have a gizmo as it's not a requirement to registration
// as well as having handlers since mapping is not required either
if(typeof window.HaxStore.instance.elementList[element.tag]!==typeof void 0&&!1!==window.HaxStore.instance.elementList[element.tag].gizmo&&typeof window.HaxStore.instance.elementList[element.tag].gizmo.handles!==typeof void 0&&0<window.HaxStore.instance.elementList[element.tag].gizmo.handles.length){// get the haxProperties for this item
let gizmo=window.HaxStore.instance.elementList[element.tag].gizmo;// walk through each handler
for(var i=0;i<gizmo.handles.length;i++){// walk the properties defined as they would be to the
// left side of the ledger and tell us which property to
// mesh with. This effectively rehydrates / inverts that
// relationship where we have an element and want to say
// "oh ya, but what could have handled this" so that we
// can use that translation to offer up convertion to a
// new element. This is insane.
for(var prop in gizmo.handles[i]){// type is a reserved handler but any other property
// which we actually have in our element let's go for it
if("type"!==prop&&typeof element.properties[gizmo.handles[i][prop]]!==typeof void 0){// The cake is a lie... oh wait... no it's not.
// This will completely bend your mind when it comes to
// what HTML is, how it should operate and what universe
// we can now contort as a result. This effectively allows
// reverse engineering any element on the page into any
// other compatible element based on the properties in
// each element claiming to be compatible.
props[prop]=element.properties[gizmo.handles[i][prop]]}}}}let haxElements=window.HaxStore.guessGizmo(type,props,skipPropMatch);// see if we got anything
if(0<haxElements.length){// hand off to hax-app-picker to deal with the rest of this
let tag=this.activeNode.tagName.toLowerCase(),humanName=tag.replace("-"," ");if(typeof window.HaxStore.instance.elementList[tag]!==typeof void 0&&!1!==window.HaxStore.instance.elementList[tag].gizmo){humanName=window.HaxStore.instance.elementList[tag].gizmo.title}window.HaxStore.instance.haxAppPicker.presentOptions(haxElements,"__convert",`Transform ${humanName} to..`,"gizmo")}else{window.HaxStore.toast("Sorry, this can not be transformed!",5e3)}}/**
   * Global prefs updated, let's visualize stuff from hax-ray
   */_globalPreferencesUpdated(newValue,oldValue){if(typeof newValue!==typeof void 0&&null!=newValue){this.haxRayMode=newValue.haxRayMode}}/**
   * Store updated, sync.
   */_haxStorePropertyUpdated(e){if(e.detail&&typeof e.detail.value!==typeof void 0&&e.detail.property){if("object"===typeof e.detail.value){this.set(e.detail.property,null)}this.set(e.detail.property,e.detail.value)}}/**
   * Clear area.
   */haxClearBody(confirm=!0){let status=!0;// only confirm if asked so we can support wipes without it
if(confirm){status=prompt("Are you sure you want to delete all content?")}// ensure they said yes
if(status){wipeSlot(this)}}/**
   * Insert new tag + content into the local DOM as a node.
   */haxInsert(tag,content,properties={},waitForLock=!0){var tags=window.HaxStore.instance.validTagList;this.__activeHover=null;// verify this tag is a valid one
if(tags.includes(tag)){// create a new element fragment w/ content in it
// if this is a custom-element it won't expand though
var frag=document.createElement(tag);frag.innerHTML=content;// clone the fragment which will force an escalation to full node
var newNode=frag.cloneNode(!0);// support for properties if they exist
for(var property in properties){let attributeName=window.HaxStore.camelToDash(property);if(properties.hasOwnProperty(property)){// special supporting for boolean because html is weird :p
if(!0===properties[property]){newNode.setAttribute(attributeName,attributeName)}else if(!1===properties[property]){newNode.removeAttribute(attributeName)}else if(null!=properties[property]&&properties[property].constructor===Array){if(newNode.properties&&newNode.properties[property].readOnly){}else{newNode.set(attributeName,properties[property])}}else if(null!=properties[property]&&properties[property].constructor===Object){if(newNode.properties&&newNode.properties[property].readOnly){}else{newNode.set(attributeName,properties[property])}}else{newNode.setAttribute(attributeName,properties[property])}}}// special support for a drag and drop into a place-holder tag
// as this is a more aggressive operation then the others
if(null!==window.HaxStore.instance.activePlaceHolder&&typeof window.HaxStore.instance.activePlaceHolder.style!==typeof void 0){// replicate styles so that it doesn't jar the UI
newNode.style.width=window.HaxStore.instance.activePlaceHolder.style.width;newNode.style.float=window.HaxStore.instance.activePlaceHolder.style.float;newNode.style.margin=window.HaxStore.instance.activePlaceHolder.style.margin;newNode.style.display=window.HaxStore.instance.activePlaceHolder.style.display;this.haxReplaceNode(window.HaxStore.instance.activePlaceHolder,newNode,dom(window.HaxStore.instance.activePlaceHolder).parentNode);window.HaxStore.instance.activePlaceHolder=null}// insert at active insert point if we have one
else if(null!==this.activeContainerNode){// allow for inserting things into things but not grid plate
if("GRID-PLATE"!==newNode.tagName&&"GRID-PLATE"===this.activeContainerNode.tagName&&this.activeContainerNode!==this.activeNode){newNode.setAttribute("slot",this.activeNode.getAttribute("slot"));dom(this.activeContainerNode).insertBefore(newNode,this.activeNode)}else{dom(this).insertBefore(newNode,this.activeContainerNode.nextElementSibling)}}else{// send this into the root, which should filter it back down into the slot
dom(this).appendChild(newNode)}this.$.textcontextmenu.highlightOps=!1;this.__updateLockFocus=newNode;// wait so that the DOM can have the node to then attach to
if(waitForLock){setTimeout(()=>{this.breakUpdateLock()},50)}return!0}return!1}breakUpdateLock(){window.HaxStore.write("activeContainerNode",this.__updateLockFocus,this);window.HaxStore.write("activeNode",this.__updateLockFocus,this);// attempt to focus on the new node, may not always work
this.__updateLockFocus.focus();// scroll to it
if("function"===typeof this.__updateLockFocus.scrollIntoViewIfNeeded){this.__updateLockFocus.scrollIntoViewIfNeeded(!0)}else{this.__updateLockFocus.scrollIntoView({behavior:"smooth",inline:"center"})}}/**
   * Return the current hax content area as text that could be
   * inserted into something.
   */haxToContent(){this.hideContextMenus();var __active=this.activeNode;// null this to drop hax based classes
this.set("activeNode",null);this.set("activeContainerNode",null);window.HaxStore.write("activeNode",null,this);window.HaxStore.write("activeContainerNode",null,this);let children=dom(this.$.body).getDistributedNodes();if(this.globalPreferences.haxDeveloperMode){console.log(children)}for(var content="",i=0,len=children.length;i<len;i++){// see if this is a valid element or not, providing
// some mild front-end sanitization
if(this._haxElementTest(children[i])){children[i].removeAttribute("data-editable");children[i].removeAttribute("data-hax-ray");children[i].contentEditable=!1;content+=window.HaxStore.haxNodeToContent(children[i]);if("grid-plate"===children[i].tagName.toLowerCase()){this._applyContentEditable(this.editMode,children[i])}}// keep comments with a special case since they need wrapped
else if(8===children[i].nodeType){content+="<!-- "+children[i].textContent+" -->"}// keep everything NOT an element at this point, this helps
// preserve whitespace because we're crazy about accuracy
else if(1!==children[i].nodeType&&typeof children[i].textContent!==typeof void 0&&"undefined"!==children[i].textContent){content+=children[i].textContent}}// remove the contenteditable attribute
content=content.replace(/\scontenteditable=\"false\"/g,"");// remove the data-editable attribute
content=content.replace(/\sdata-editable=\"true\"/g,"");content=content.replace(/\sdata-editable=\"false\"/g,"");content=content.replace(/\sdata-editable=\""/g,"");// remove other attributes that can linger in slots
content=content.replace(/\sdata-editable/g,"");content=content.replace(/\scontenteditable/g,"");content=content.replace(/\sdraggable/g,"");content=content.replace(/\sdata-draggable/g,"");// clean up stray hax-ray leftovers
content=content.replace(/\sdata-hax-ray=\".*?\"/g,"");// remove HAX specific classes / scoping classes
if(this.parentNode.tagName){let parentTag=this.parentNode.tagName.toLowerCase(),string="style-scope "+parentTag+" x-scope",re=new RegExp(string,"g");content=content.replace(re,"");// remove without the deeeper scope as well for primitives
string="style-scope "+parentTag;re=new RegExp(string,"g");content=content.replace(re,"");// remove the last common one unpacked
string="x-scope "+parentTag+"-0";re=new RegExp(string,"g");content=content.replace(re,"");// now all tags we have defined as valid
let tags=window.HaxStore.instance.validTagList;tags.push("hax-preview");for(var i in tags){string="style-scope "+tags[i];re=new RegExp(string,"g");content=content.replace(re,"");string="x-scope "+tags[i]+"-0 ";re=new RegExp(string,"g");content=content.replace(re,"");string="x-scope "+tags[i]+"-0";re=new RegExp(string,"g");content=content.replace(re,"")}}// remove empty class structures
content=content.replace(/\sclass=\"\"/g,"");content=content.replace(/\sclass=\"\s\"/g,"");// re-apply contenteditable if needed
this._applyContentEditable(this.editMode);// set active again
window.HaxStore.write("activeNode",__active,this);window.HaxStore.write("activeContainerNode",__active,this);// oh one last thing. escape all script/style tags
content=encapScript(content);if(this.globalPreferences.haxDeveloperMode){console.log(content)}return content}/**
   * Duplicate node into the local DOM below the current item if we can.
   */haxDuplicateNode(node,parent=this){// move the context menu before duplicating!!!!
this.hideContextMenus();// convert the node to a hax element
let haxElement=window.HaxStore.nodeToHaxElement(node,null);// convert it back to a clone, seems odd I'm sure but this ensures that all props are copied
// correctly and that we get a brand new object
var nodeClone=window.HaxStore.haxElementToNode(haxElement.tag,haxElement.content,haxElement.properties);if("webview"===nodeClone.tagName.toLowerCase()&&window.HaxStore.instance._isSandboxed&&typeof nodeClone.guestinstance!==typeof void 0){delete nodeClone.guestinstance}// shouldn't be possible but might as well check
if(null!==node){dom(parent).insertBefore(nodeClone,dom(node).nextSibling)}else{dom(parent).appendChild(nodeClone)}setTimeout(()=>{// test for a grid plate clone
if(parent===this){window.HaxStore.write("activeContainerNode",nodeClone,this)}window.HaxStore.write("activeNode",nodeClone,this)},50);return!0}/**
   * Hide all context menus.
   */hideContextMenus(){// primary context menus
this._hideContextMenu(this.$.textcontextmenu);this._hideContextMenu(this.$.cecontextmenu);// secondary menus and clean up areas
this._hideContextMenu(this.$.platecontextmenu);this._hideContextMenu(this.$.haxinputmixer);// force context menu state to closed
this.$.textcontextmenu.highlightOps=!1}/**
   * Reposition context menus to match an element.
   */positionContextMenus(node,container){if(node){let tag=node.tagName.toLowerCase();if(window.HaxStore.instance._isSandboxed&&"webview"===tag){tag="iframe"}let props=window.HaxStore.instance.elementList[tag];// try and work against anything NOT a P tag
if(typeof props!==typeof void 0&&!window.HaxStore.instance.isTextElement(node)){this.__activeContextType=this.$.cecontextmenu;props.element=node;this.__activeContextType.setHaxProperties(props)}else{this.__activeContextType=this.$.textcontextmenu}this._positionContextMenu(this.__activeContextType,container,-39,-39);this._positionContextMenu(this.$.platecontextmenu,container,-31,0);// special case for node not matching container
if(container&&!this._HTMLPrimativeTest(node)&&node!==container){container.contentEditable=!1}else if(container&&this._HTMLPrimativeTest(container)){container.contentEditable=!0}}}/**
   * Move grid plate around
   */haxMoveGridPlate(direction,node,container){// menu is actually in the element for render purposes
// support moving things multiple directions
switch(direction){case"first":// ensure we can go up, first being a mode of up
if(null!==container.previousElementSibling){dom(this).insertBefore(container,dom(this).firstChild)}break;case"up":// ensure we can go up
if(null!==container.previousElementSibling){dom(this).insertBefore(container,container.previousElementSibling)}break;case"down":if(null!==container.nextElementSibling){dom(this).insertBefore(container.nextElementSibling,container)}break;case"last":if(null!==container.nextElementSibling){dom(this).appendChild(container)}break;// @todo support other directions for when inside of an element
}setTimeout(()=>{this.positionContextMenus(node,container);if("function"===typeof container.scrollIntoViewIfNeeded){container.scrollIntoViewIfNeeded(!0)}else{container.scrollIntoView({behavior:"smooth",inline:"center"})}},50);return!0}/**
   * Convert an element from one tag to another.
   */haxReplaceNode(node,replacement,parent=this){// ensure we're not in the document tree for the replaced node
this.hideContextMenus();// Switch, try loop in case we screwed up elsewhere
try{// test for slots to match
if(null!=node.getAttribute("slot")){replacement.setAttribute("slot",node.getAttribute("slot"))}dom(parent).replaceChild(replacement,node)}catch(e){console.log(e)}return replacement}/**
   * Convert an element from one tag to another.
   */haxChangeTagName(node,tagName,newNode){// ensure we're not in the document tree for the replaced node
this.hideContextMenus();// Create a replacement tag of the desired type
// Grab all of the original's attributes, and pass them to the replacement
for(var replacement=document.createElement(tagName),i=0,l=node.attributes.length;i<l;++i){var nodeName=node.attributes.item(i).nodeName,value=node.attributes.item(i).value;replacement.setAttribute(nodeName,value)}// Persist contents
// account for empty list and ordered list items
replacement.innerHTML=node.innerHTML.trim();if("ul"==tagName||"ol"==tagName){if(""==replacement.innerHTML){replacement.innerHTML="<li></li>"}else if(!("ul"==node.tagName.toLowerCase()||"ol"==node.tagName.toLowerCase())){replacement.innerHTML="<li>"+node.innerHTML.trim().replace(/<br\/>/g,"</li>\n<li>").replace(/<br>/g,"</li>\n<li>")+"</li>"}}else if("ul"==node.tagName.toLowerCase()||"ol"==node.tagName.toLowerCase()){// if we're coming from ul or ol strip out the li tags
replacement.innerHTML=replacement.innerHTML.replace(/<ul>/g,"").replace(/<\/ul>/g,"").replace(/<li><\/li>/g,"").replace(/<li>/g,"").replace(/<\/li>/g,"<br/>")}// Switch!
dom(this).replaceChild(replacement,node);// focus on the thing switched to
setTimeout(()=>{let children=dom(replacement).getEffectiveChildNodes();// see if there's a child element and focus that instead if there is
if(children[0]&&children.tagName){children[0].focus()}else{replacement.focus()}},50);return replacement}/**
   * Delete the node passed in
   */haxDeleteNode(node,parent=this){// move the context menu before deleting!!!!
this.hideContextMenus();// shift active to a viable replacement
if(null!=this.activeContainerNode&&null!==this.activeContainerNode.previousElementSibling){this.activeContainerNode.previousElementSibling.focus();// cursor at the END of the element assuming not empty
if(null!=this.activeContainerNode&&window.HaxStore.instance.isTextElement(this.activeContainerNode)&&""!==dom(this.activeContainerNode).textContent){try{var range=document.createRange(),sel=window.HaxStore.getSelection();range.setStart(this.activeContainerNode,1);range.collapse(!0);sel.removeAllRanges();sel.addRange(range);this.activeContainerNode.focus()}catch(e){console.log(e)}}}else if(null!=this.activeContainerNode&&null!==this.activeContainerNode.nextElementSibling){this.activeContainerNode.nextElementSibling.focus()}else{this.set("activeNode",null);this.set("activeContainerNode",null);window.HaxStore.write("activeNode",null,this);window.HaxStore.write("activeContainerNode",null,this)}// @todo figure out why this is complaining
try{return dom(parent).removeChild(node)}catch(e){console.log(e)}}/**
   * Bulk import HTML with option to clear what is currently
   * in the slot of this tag. This also validates tags
   * that are being inserted for security based on the
   * internal whitelist.
   */importContent(html,clear=!0){// kill the slot of the active body, all of it
if(clear){wipeSlot(this,"*")}// pause quickly to ensure wipe goes through successfully
setTimeout(()=>{html=encapScript(html);const validTags=window.HaxStore.instance.validTagList;let fragment=document.createElement("div");fragment.insertAdjacentHTML("beforeend",html);while(null!==fragment.firstChild){if(typeof fragment.firstChild.tagName!==typeof void 0&&validTags.includes(fragment.firstChild.tagName.toLowerCase())){// ensure import doesn't import non-sandbox safe things!
if(window.HaxStore.instance._isSandboxed&&"iframe"===fragment.firstChild.tagName.toLowerCase()){// Create a replacement tag of the desired type
// Grab all of the original's attributes, and pass them to the replacement
for(var replacement=document.createElement("webview"),j=0,l=fragment.firstChild.attributes.length;j<l;++j){var nodeName=fragment.firstChild.attributes.item(j).nodeName,value=fragment.firstChild.attributes.item(j).value;if("height"===nodeName||"width"===nodeName){replacement.style[nodeName]==value}replacement.setAttribute(nodeName,value)}dom(this).appendChild(replacement)}else{dom(this).appendChild(fragment.firstChild)}}else{// this tag didn't pass the test, get rid of it
fragment.removeChild(fragment.firstChild)}}},50)}/**
   * Respond to hax operations.
   */_haxContextOperation(e){let detail=e.detail;var haxElement;// support a simple insert event to bubble up or everything else
switch(detail.eventName){// text based operations for primatives
case"p":case"ol":case"ul":case"h2":case"h3":case"h4":case"h5":case"h6":case"blockquote":case"code":// trigger the default selected value in context menu to match
this.$.textcontextmenu.selectedValue=detail.eventName;window.HaxStore.write("activeContainerNode",this.haxChangeTagName(this.activeContainerNode,detail.eventName),this);this.positionContextMenus(this.activeNode,this.activeContainerNode);break;case"text-align-left":this.activeNode.style.textAlign=null;this.positionContextMenus(this.activeNode,this.activeContainerNode);break;// grid plate based operations
// allow for transforming this haxElement into another one
case"grid-plate-convert":this.replaceElementWorkflow();break;// duplicate the active item or container
case"grid-plate-duplicate":if(this.activeNode===this.activeContainerNode){this.haxDuplicateNode(this.activeNode)}else{this.haxDuplicateNode(this.activeNode,this.activeContainerNode)}break;case"grid-plate-delete":if(null!=this.activeNode){let options=[{icon:"thumb-up",color:"green",title:"Yes"},{icon:"thumb-down",color:"red",title:"No"}],tag=this.activeNode.tagName.toLowerCase(),humanName=tag.replace("-"," ");if(typeof window.HaxStore.instance.elementList[tag]!==typeof void 0&&!1!==window.HaxStore.instance.elementList[tag].gizmo){humanName=window.HaxStore.instance.elementList[tag].gizmo.title}window.HaxStore.instance.haxAppPicker.presentOptions(options,"",`Remove this \`${humanName}\`?`,"delete")}break;case"grid-plate-first":this.haxMoveGridPlate("first",this.activeNode,this.activeContainerNode);break;case"grid-plate-up":this.haxMoveGridPlate("up",this.activeNode,this.activeContainerNode);break;case"hax-manager-open":window.HaxStore.write("activeHaxElement",{},this);window.HaxStore.instance.haxManager.resetManager(parseInt(detail.value));window.HaxStore.instance.haxManager.toggleDialog();break;case"grid-plate-down":this.haxMoveGridPlate("down",this.activeNode,this.activeContainerNode);break;case"grid-plate-last":this.haxMoveGridPlate("last",this.activeNode,this.activeContainerNode);break;case"close-menu":this.set("activeNode",null);this.set("activeContainerNode",null);window.HaxStore.write("activeNode",null,this);window.HaxStore.write("activeContainerNode",null,this);break;case"hax-edit-property":let haxInputMixer=this.$.haxinputmixer;haxInputMixer.label=detail.target.label;haxInputMixer.options=detail.target.options;haxInputMixer.icon=detail.target.icon;haxInputMixer.description=detail.target.description;haxInputMixer.required=detail.target.required;haxInputMixer.validation=detail.target.validation;haxInputMixer.validationType=detail.target.validationType;haxInputMixer.inputMethod=detail.target.inputMethod;haxInputMixer.value="";// see if response should bind to the slot or property
if(typeof detail.target.propertyToBind!==typeof void 0&&null!=detail.target.propertyToBind&&!1!=detail.target.propertyToBind){haxInputMixer.propertyToBind=detail.target.propertyToBind;if(typeof this.activeNode[detail.target.propertyToBind]!==typeof void 0){haxInputMixer.value=this.activeNode[detail.target.propertyToBind]}// try to get an attribute bind
else{haxInputMixer.value=this.activeNode.getAttribute(detail.target.propertyToBind)}// @todo need to be able to support slot binding
}// make input mixer show up
this._positionContextMenu(haxInputMixer,this.activeContainerNode,-1,-38);let style=this.$.cecontextmenu.currentStyle||window.getComputedStyle(this.$.cecontextmenu);// force input mixes to match width of the ce context menu currently
haxInputMixer.style.width=style.width.replace("px","")-40+"px";break;// directional / proportion operations
case"hax-align-left":this.activeNode.style.float=null;this.activeNode.style.margin=null;this.activeNode.style.display=null;setTimeout(()=>{this.positionContextMenus(this.activeNode,this.activeContainerNode)},200);break;case"hax-align-center":this.activeNode.style.float=null;this.activeNode.style.margin="0 auto";this.activeNode.style.display="block";setTimeout(()=>{this.positionContextMenus(this.activeNode,this.activeContainerNode)},200);break;case"hax-size-change":if(this.activeNode){this.activeNode.style.width=detail.value+"%";setTimeout(()=>{this.positionContextMenus(this.activeNode,this.activeContainerNode)},200)}break;// settings button selected from hax-ce-context bar
// which means we should skip to the settings page after
// we set the thing selected as the active element to work
// on in the manager
case"hax-manager-configure":// make sure input mixer is closed
this._hideContextMenu(this.$.haxinputmixer);// reset the manager
window.HaxStore.instance.haxManager.resetManager();// write activeElement updated so it'll go into the preview
haxElement=window.HaxStore.nodeToHaxElement(window.HaxStore.instance.activeNode);window.HaxStore.write("activeHaxElement",haxElement,this);// clean up the manager before opening
window.HaxStore.instance.haxManager.editExistingNode=!0;window.HaxStore.instance.haxManager.selectStep("configure");window.HaxStore.instance.haxManager.toggleDialog();// accessibility enhancement to keyboard focus configure button
setTimeout(()=>{window.HaxStore.instance.haxManager.$.preview.$.configurebutton.focus()},100);break;// container / layout settings button has been activated
case"hax-manager-configure-container":window.HaxStore.write("activeNode",window.HaxStore.instance.activeContainerNode,this);// make sure input mixer is closed
this._hideContextMenu(this.$.haxinputmixer);// reset the manager
window.HaxStore.instance.haxManager.resetManager();// write activeElement updated so it'll go into the preview
haxElement=window.HaxStore.nodeToHaxElement(window.HaxStore.instance.activeNode);window.HaxStore.write("activeHaxElement",haxElement,this);// clean up the manager before opening
window.HaxStore.instance.haxManager.editExistingNode=!0;window.HaxStore.instance.haxManager.selectStep("configure");window.HaxStore.instance.haxManager.toggleDialog();// accessibility enhancement to keyboard focus configure button
setTimeout(()=>{window.HaxStore.instance.haxManager.$.preview.$.configurebutton.focus()},100);break;}}/**
   * Respond to an input mixer call.
   */_haxInputMixerOperation(e){// this is a big deal how simple this part is in the end
let mixer=e.detail.inputMixer;// if we have a property to bind, set that value from the
// widget that was dictated by the element itself
if(null!=mixer.propertyToBind){this.activeNode[mixer.propertyToBind]=mixer.value}// if we're told instead to do a slot bind, make a span tag
// with height same as parent and then mix in the innerHTML
else if(null!=mixer.slotToBind){item=document.createElement("span");item.style.height="inherit";item.innerHTML=mixer.value;//item.attribute.slot = mixer.slotToBind;
item.slot=mixer.slotToBind;this.activeNode.appendChild(item)}// hide mixer
this._hideContextMenu(this.$.haxinputmixer)}/**
   * Item has gained focus, change active element to match
   */_focusIn(e){var normalizedEvent=dom(e);if(this.__focusLogic(normalizedEvent.localTarget)){e.stopPropagation()}}/**
   * Focus a target and update the data model to reflect this.
   * This helps ensure that keyboard and non click based focusing
   * registers the same as click events
   */__focusLogic(target){let stopProp=!1;// only worry about these when we are in edit mode
if(this.editMode&&!this.__tabTrap){var tags=window.HaxStore.instance.validTagList;let containerNode=target,activeNode=null;// ensure this is valid
if(this._haxElementTest(containerNode)&&null!=containerNode.parentNode){// keep looking til we are juuuust below the container
// @todo this is where we force a selection on highest level
// of the document
while("HAX-BODY"!=containerNode.parentNode.tagName){// make sure active is set after closest legit element
if(null===activeNode&&tags.includes(containerNode.tagName.toLowerCase())&&"LI"!==containerNode.tagName&&"B"!==containerNode.tagName&&"I"!==containerNode.tagName&&"STRONG"!==containerNode.tagName&&"EM"!==containerNode.tagName){activeNode=containerNode}containerNode=containerNode.parentNode}// case with simple element
if(null===activeNode){activeNode=containerNode}// we only allow disconnected node from container when
// the container is a grid plate
else if(!window.HaxStore.instance.isGridPlateElement(containerNode)){activeNode=containerNode}// won't deal with lists inside of p tags
else if(["UL","OL","LI","P","GRID-PLATE"].includes(containerNode.tagName)&&["UL","OL","LI"].includes(activeNode.tagName)){activeNode=containerNode}// ensure this is a tag we care about / have support for and
// that it is a new value
if(this.activeContainerNode!==containerNode&&tags.includes(containerNode.tagName.toLowerCase())&&!containerNode.classList.contains("ignore-activation")){this.hideContextMenus();this.activeContainerNode=containerNode;window.HaxStore.write("activeContainerNode",containerNode,this);stopProp=!0}else if(containerNode.classList.contains("ignore-activation")){stopProp=!0}// test for active node changing
if(this.activeNode!==activeNode&&tags.includes(containerNode.tagName.toLowerCase())&&!activeNode.classList.contains("ignore-activation")){this.activeNode=activeNode;window.HaxStore.write("activeNode",activeNode,this);this.positionContextMenus(activeNode,containerNode);stopProp=!0}}}else{this.__tabTrap=!1}return stopProp}/**
   * Notice the change between states for editing.
   */_editModeChanged(newValue,oldValue){// fire above that we have changed states so things can react if needed
if(typeof oldValue!==typeof void 0){this._applyContentEditable(newValue);this.setAttribute("tabindex","-1");if(!1!==newValue&&typeof this.activeNode!==typeof void 0&&null!==this.activeNode){this.positionContextMenus(this.activeNode,this.activeContainerNode)}}// hide menus when state changes
if(!1===newValue){this.removeAttribute("contenteditable");this.hideContextMenus()}}/**
   * Test if this is a HAX element or not
   */_haxResolvePreviousElement(node){node=dom(node).previousElementSibling;while(null!=node&&typeof node.tagName!==typeof void 0&&"HAX-"===node.tagName.substring(0,4)){node=dom(node).previousElementSibling}return node}/**
   * Test if this is a HAX element or not
   */_haxElementTest(node){if(typeof node.tagName!==typeof void 0&&"HAX-"!==node.tagName.substring(0,4)){return!0}return!1}/**
   * Test if this is an HTML primative
   */_HTMLPrimativeTest(node){if(null!=node&&typeof node.tagName!==typeof void 0&&-1==node.tagName.indexOf("-")){return!0}return!1}/**
   * Walk everything we find and either enable or disable editable state.
   */_applyContentEditable(status,target=this.$.body){let children=dom(target).getDistributedNodes();// fallback for content nodes if not polymer managed nodes above
if(0===children.length){children=dom(target).getEffectiveChildNodes()}for(var i=0,len=children.length;i<len;i++){// we have to tell the browser that primatives are editable
if(this._HTMLPrimativeTest(children[i])){children[i].contentEditable=status}// this does the real targetting
if(this._haxElementTest(children[i])){if(status){children[i].setAttribute("data-editable",status);let haxRay=children[i].tagName.replace("-"," ").toLowerCase(),l=window.HaxStore.instance.gizmoList.findIndex(j=>j.tag===children[i].tagName.toLowerCase());if(-1!==l){haxRay=window.HaxStore.instance.gizmoList[l].title}children[i].setAttribute("data-hax-ray",haxRay)}else{children[i].removeAttribute("data-editable");children[i].removeAttribute("data-hax-ray")}}}}/**
   * Container has changed
   */_activeContainerNodeChanged(newValue,oldValue){if(this.editMode&&typeof newValue!==typeof void 0&&null!=newValue&&null!=newValue.tagName){if(window.HaxStore.instance.isTextElement(newValue)||window.HaxStore.instance.isGridPlateElement(newValue)){this.setAttribute("contenteditable",!0)}else{this.removeAttribute("contenteditable")}let tag=newValue.tagName.toLowerCase();// special case for the grid plate since it brings in dom nodes
// nested in it and needs to be put into an editMode
if("grid-plate"===tag){newValue.editMode=this.editMode;this._applyContentEditable(this.editMode,newValue)}}}/**
   * React to a new node being set to active.
   */_activeNodeChanged(newValue,oldValue){// clean up the older one
if(typeof oldValue!==typeof void 0&&null!=oldValue){oldValue.classList.remove("hax-active")}if(this.editMode&&typeof newValue!==typeof void 0&&null!==newValue){let tag=newValue.tagName.toLowerCase();// remove the menu, establish the new active, then reapply
// this is nessecary because the context menu gets appended into
// the document
// only hide if we change containers
newValue.classList.add("hax-active");if(window.HaxStore.instance.isTextElement(newValue)||window.HaxStore.instance.isGridPlateElement(newValue)){this.setAttribute("contenteditable",!0)}else{this.removeAttribute("contenteditable")}this.$.textcontextmenu.selectedValue=tag;// position the operations / in context element
setTimeout(()=>{this.positionContextMenus(newValue,window.HaxStore.instance.activeContainerNode)},100);if("left"==newValue.style.textAlign){this.$.textcontextmenu.justifyIcon="editor:format-align-left";this.$.textcontextmenu.justifyValue="text-align-left"}else if("left"==newValue.style.float){this.$.cecontextmenu.justifyIcon="editor:format-align-left";this.$.cecontextmenu.justifyValue="hax-align-left"}else if("0 auto"==newValue.style.margin){this.$.cecontextmenu.justifyIcon="editor:format-align-center";this.$.cecontextmenu.justifyValue="hax-align-center"}}// just hide menus if we don't have an active item
else if(null===newValue){this.hideContextMenus();this.$.textcontextmenu.justifyIcon="editor:format-align-left";this.$.textcontextmenu.justifyValue="text-align-left"}}/**
   * walk parents and find the correct position from top of document
   * https://stackoverflow.com/questions/11805955/how-to-get-the-distance-from-the-top-for-an-element
   */_getPosition(element){let xPosition=element.offsetLeft-element.scrollLeft+element.clientLeft,yPosition=element.offsetTop-element.scrollTop+element.clientTop;return{x:xPosition,y:yPosition}}/**
   * Handle display and position of the context menu
   */_positionContextMenu(menu,target,xoffset,yoffset){// make it account for the offset if it's floated over to one side
// or inside of something that's over that way
if(null!=target){let pos=this._getPosition(target);if(null!=xoffset){menu.style.left=pos.x+xoffset+"px"}else{menu.style.left=pos.x+"px"}if(null!=yoffset){menu.style.top=pos.y+yoffset+"px"}else{menu.style.top=pos.y+"px"}}menu.classList.add("hax-context-visible");// text we want to operate this way
if(this.__activeHover){menu.classList.add("hax-active-hover");menu.style.marginLeft="";this.__typeLock=!1}setTimeout(()=>{async.microTask.run(this._keepContextVisible())},100)}/**
   * Simple hide / reset of whatever menu it's handed.
   */_hideContextMenu(menu){menu.classList.remove("hax-context-visible","hax-context-pin-top","hax-context-pin-bottom");menu.style.left="-100px"}/**
   * Find the next thing to tab forward to.
   */_tabKeyPressed(){let focus=!1,node=this.activeContainerNode;const activeNodeTagName=this.activeContainerNode.tagName;// try selection / tab block since range can cause issues
try{let range=window.HaxStore.getRange().cloneRange();var tagTest=range.commonAncestorContainer.tagName;if(typeof tagTest===typeof void 0){tagTest=range.commonAncestorContainer.parentNode.tagName}if(["UL","OL","LI"].includes(activeNodeTagName)||["UL","OL","LI"].includes(tagTest)){if(this.polyfillSafe){document.execCommand("indent");this.__tabTrap=!0}}else{while(!focus){// do nothing
if(null==dom(node).nextSibling){focus=!0}else if("function"===dom(node).nextSibling.focus){dom(node).nextSibling.focus();focus=!0}else{node=dom(node).nextSibling}}}}catch(e){console.log(e)}}/**
   * Move back through things when tab back pressed
   */_tabBackKeyPressed(){let node=this.activeContainerNode;const activeNodeTagName=this.activeContainerNode.tagName;// try selection / tab block since range can cause issues
try{let range=window.HaxStore.getRange().cloneRange();var tagTest=range.commonAncestorContainer.tagName;if(typeof tagTest===typeof void 0){tagTest=range.commonAncestorContainer.parentNode.tagName}if(["UL","OL","LI"].includes(activeNodeTagName)||["UL","OL","LI"].includes(tagTest)){if(this.polyfillSafe){document.execCommand("outdent");this.__tabTrap=!0}}else{if(null!=node){// step back ignoring hax- prefixed elements
while(null!=node&&!this._haxElementTest(node)){node=dom(node).previousSibling}}if(null!=node){setTimeout(()=>{node.focus()},50)}}}catch(e){console.log(e)}}}window.customElements.define(HaxBody.tag,HaxBody);export{HaxBody};