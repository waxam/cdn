import{html,PolymerElement}from"../../../@polymer/polymer/polymer-element.js";import*as async from"../../../@polymer/polymer/lib/utils/async.js";import{FlattenedNodesObserver}from"../../../@polymer/polymer/lib/utils/flattened-nodes-observer.js";import{pathFromUrl}from"../../../@polymer/polymer/lib/utils/resolve-url.js";import{HAXElement}from"../../hax-body-behaviors/hax-body-behaviors.js";/**
 * `hax-autoloader`
 * `Automatically load elements based on the most logical location with future fallback support for CDNs.`
 * @microcopy - the mental model for this element
 * - hax-autoloader - autoloading of custom element imports which can then emmit events as needed
 */class HaxAutoloader extends HAXElement(PolymerElement){static get template(){return html`
      <style>
        :host {
          display: none;
        }
      </style>
      <slot></slot>
    `}static get tag(){return"hax-autoloader"}static get properties(){return{/**
       * List of elements processed so we don't double process
       */processedList:{type:Object,value:{}}}}/**
   * Attached to the DOM, now fire that we exist.
   */connectedCallback(){super.connectedCallback();// fire an event that this is the manager
this.dispatchEvent(new CustomEvent("hax-register-autoloader",{bubbles:!0,cancelable:!0,composed:!0,detail:this}));// notice elements when they update
this._observer=new FlattenedNodesObserver(this,info=>{// if we've got new nodes, we have to react to that
if(0<info.addedNodes.length){async.microTask.run(()=>{this.processNewElements(info.addedNodes)})}})}/**
   * Process new elements
   */processNewElements(e){// when new nodes show up in the slots then fire the needed pieces
let effectiveChildren=FlattenedNodesObserver.getFlattenedNodes(this).filter(n=>n.nodeType===Node.ELEMENT_NODE);for(var i=0;i<effectiveChildren.length;i++){// strip invalid tags / textnodes
if(typeof effectiveChildren[i].tagName!==typeof void 0&&typeof this.processedList[effectiveChildren[i].tagName]===typeof void 0){// attempt a dynamic import with graceful failure / fallback
try{let name=effectiveChildren[i].tagName.toLowerCase();// see if we already have this definition
if("function"===typeof effectiveChildren[i].getHaxProperties){const evt=new CustomEvent("hax-register-properties",{bubbles:!0,composed:!0,cancelable:!0,detail:{tag:name,properties:effectiveChildren[i].getHaxProperties(),polymer:!0}});context.dispatchEvent(evt)}else if("function"===typeof effectiveChildren[i].HAXWiring){const evt=new CustomEvent("hax-register-properties",{bubbles:!0,cancelable:!0,composed:!0,detail:{tag:name,properties:effectiveChildren[i].HAXWiring.getHaxProperties(),polymer:!1}});context.dispatchEvent(evt)}else{// @todo support CDN failover or a flag of some kind to ensure
// this delivers locally or from remote
// @todo need to support name spacing of packages so that we
// don't assume they are all relative to lrnwebcomponents
const basePath=pathFromUrl(decodeURIComponent(import.meta.url));import(`${basePath}../../${name}/${name}.js`).then(response=>{// get the custom element definition we used to add that file
let CEClass=window.customElements.get(name);if("function"===typeof CEClass.getHaxProperties){this.setHaxProperties(CEClass.getHaxProperties(),name)}else if("function"===typeof CEClass.HAXWiring){this.setHaxProperties(CEClass.HAXWiring.getHaxProperties(),name)}else if(CEClass.haxProperties){this.setHaxProperties(CEClass.haxProperties,name)}else{console.log(`${name} didn't have hax wiring in the end`)}}).catch(error=>{/* Error handling */console.log(error)})}this.processedList[name]=name}catch(err){// error in the event this is a double registration
}}}}}window.customElements.define(HaxAutoloader.tag,HaxAutoloader);export{HaxAutoloader};