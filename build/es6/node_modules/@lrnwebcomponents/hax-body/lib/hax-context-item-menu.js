import{html,PolymerElement}from"../../../@polymer/polymer/polymer-element.js";import{dom}from"../../../@polymer/polymer/lib/legacy/polymer.dom.js";import"./hax-shared-styles.js";/**
 * `hax-context-item-menu`
 * `An icon / button that has support for multiple options via drop down.`
 * @microcopy - the mental model for this element
 * - panel - the flyout from left or right side that has elements that can be placed
 * - button - an item that expresses what interaction you will have with the content.
 */class HaxContextItemMenu extends PolymerElement{constructor(){super();import("./hax-toolbar-menu.js");import("../../../@polymer/paper-tooltip/paper-tooltip.js");import("../../../@polymer/paper-item/paper-item.js");import("../../../@polymer/neon-animation/neon-animation.js")}static get template(){return html`
      <style include="hax-shared-styles">
        :host {
          display: inline-flex;
          height: 36px;
          box-sizing: border-box;
        }
        :host hax-toolbar-menu ::slotted(*):hover {
          background-color: var(--hax-color-bg-accent);
        }
        :host hax-toolbar-menu ::slotted(*) {
          height: 36px;
        }
      </style>
      <hax-toolbar-menu
        id="menu"
        icon="[[icon]]"
        tooltip="[[label]]"
        tooltip-direction="[[direction]]"
        selected="{{selectedValue}}"
        reset-on-select="[[resetOnSelect]]"
      >
        <slot></slot>
      </hax-toolbar-menu>
    `}static get tag(){return"hax-context-item-menu"}static get properties(){return{/**
       * Internal flag to allow blocking the event firing if machine selects tag.
       */_blockEvent:{type:Boolean,value:!1},/**
       * Should we reset the selection after it is made
       */resetOnSelect:{type:Boolean,value:!1},/**
       * Value.
       */selectedValue:{type:Number,reflectToAttribute:!0,notify:!0,value:0,observer:"_selectedUpdated"},/**
       * Direction for the tooltip
       */direction:{type:String,value:"top"},/**
       * Icon for the button.
       */icon:{type:String,value:"editor:text-fields",reflectToAttribute:!0},/**
       * Label for the button.
       */label:{type:String,value:"editor:text-fields",reflectToAttribute:!0},/**
       * Name of the event to bubble up as being tapped.
       * This can be used to tell other elements what was
       * clicked so it can take action appropriately.
       */eventName:{type:String,value:"button",reflectToAttribute:!0}}}/**
   * Notice the selected value has changed.
   */_selectedUpdated(newValue,oldValue){if(typeof null!==typeof newValue&&typeof oldValue!==typeof void 0&&typeof null!==typeof oldValue){let children=dom(this).children;// check for tag match since we have to filter out text nodes
for(var item={},j=0,i=0,len=children.length;i<len;i++){if("PAPER-ITEM"===children[i].tagName){if(j===newValue){item=children[i];len=i;continue}j++}}// ensure we have a value; if so, this becomes the event to look for
// also use our flag to ensure machine setting the tag default doesn't
// equate to firing off a selected event.
if(!this._blockEvent&&typeof item.attributes!==typeof void 0&&typeof item.attributes.value!==typeof void 0&&typeof item.attributes.value.value!==typeof void 0){// weird but this makes the menu close when we send up an event
// that indicates something higher should do something. This
// avoids an annoying UX error where the menu stays open for
// no reason.
this.shadowRoot.querySelector("#menu").hideMenu();this.dispatchEvent(new CustomEvent("hax-context-item-selected",{bubbles:!0,cancelable:!0,composed:!0,detail:{target:item,eventName:item.attributes.value.value}}))}// we only block 1 time if it's available
if(this._blockEvent){this._blockEvent=!1}}}}window.customElements.define(HaxContextItemMenu.tag,HaxContextItemMenu);export{HaxContextItemMenu};