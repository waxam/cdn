/**
 * Copyright 2019 The Pennsylvania State University
 * @license Apache-2.0, see License.md for full text.
 */
import{LitElement,html,css}from"../../lit-element/lit-element.js";import"../es-global-bridge/es-global-bridge.js";window.__H5PBridgeTimeOut=function(){setTimeout((function(){window.H5P.init()}),500)};class H5PElement extends LitElement{static get styles(){return[css`
        :host {
          display: block;
        }
      `]}render(){return html`
      <div
        class="h5p-container"
        data-content-id="wrapper-${this.contentId}"
      ></div>
    `}static get haxProperties(){return{canScale:!0,canPosition:!0,canEditSource:!1,gizmo:{title:"H5P element",description:"h5p wrapper for loading and presenting .h5p files",icon:"icons:android",color:"green",groups:["Interactive"],meta:{author:"btopro",owner:"The Pennsylvania State University"}},settings:{quick:[],configure:[{attribute:"source",description:"Location the H5P file was unpacked to",inputMethod:"textfield",required:!0,icon:"icons:link"}],advanced:[]},saveOptions:{wipeSlot:!0,unsetAttributes:["content-id"]}}}static get properties(){return{...super.properties,source:{name:"source",type:String}}}static get tag(){return"h5p-element"}constructor(){super(),this.contentId=this.generateUUID(),this.H5PDepsLoader()}createRenderRoot(){return this}pathFromUrl(url){return url.substring(0,url.lastIndexOf("/")+1)}async H5PDepsLoader(){window.ESGlobalBridge.requestAvailability();const basePath=this.pathFromUrl(decodeURIComponent(import.meta.url))+"lib/h5p/";this.h5pJSDeps=[basePath+"js/jquery.js",basePath+"js/h5p.js",basePath+"js/h5p-event-dispatcher.js",basePath+"js/h5p-content-type.js",basePath+"js/h5p-action-bar.js",basePath+"js/h5p-confirmation-dialog.js",basePath+"js/h5p-x-api-event.js",basePath+"js/h5p-x-api.js"],this.__h5pDepsLength=this.h5pJSDeps.length-1,await window.ESGlobalBridge.instance.load("h5p-jquery",basePath+"js/jquery.js"),window.addEventListener("es-bridge-h5p-jquery-loaded",this.h5pJqueryReady.bind(this)),window.addEventListener("es-bridge-h5p-"+this.__h5pDepsLength+"-loaded",this.h5pReadyCallback.bind(this))}generateUUID(){return"item-sss-ss-ss".replace(/s/g,this._uuidPart)}_uuidPart(){return Math.floor(65536*(1+Math.random())).toString(16).substring(1)}firstUpdated(){window.ESGlobalBridge.imports["h5p-"+this.__h5pDepsLength]&&this.contentId&&this.setupH5P(this.contentId)}async h5pJqueryReady(e){for(var i in this.h5pJSDeps)await window.ESGlobalBridge.instance.load("h5p-"+i,this.h5pJSDeps[i])}h5pReadyCallback(e){this.contentId&&this.setupH5P(this.contentId)}async setupH5P(id=1,displayOptions={}){displayOptions=Object.assign(displayOptions,{frame:displayOptions.frame=!1,copyright:displayOptions.copyright=!1,embed:displayOptions.embed=!1,download:displayOptions.download=!1,icon:displayOptions.icon=!1,export:displayOptions.export=!1});const basePath=this.pathFromUrl(decodeURIComponent(import.meta.url))+"lib/h5p/";H5PIntegration.core={styles:[basePath+"styles/h5p.css",basePath+"styles/h5p-confirmation-dialog.css",basePath+"styles/h5p-core-button.css"],scripts:this.h5pJSDeps};let frag=document.createRange().createContextualFragment(`\n    <div class="h5p-iframe-wrapper" style="background-color:#DDD;">\n      <iframe id="h5p-iframe-${id}" class="h5p-iframe" data-content-id="${id}" style="width: 100%; height: 100%; border: none; display: block;" src="about:blank" frameBorder="0"></iframe>\n    </div>\n    `);if(this.querySelector('[data-content-id="wrapper-'+this.contentId+'"').appendChild(frag),this.source){let stand=new H5PStandalone(id,this.source,displayOptions);await stand.init(),window.__H5PBridgeTimeOut&&(clearTimeout(window.__H5PBridgeTimeOut),window.__H5PBridgeTimeOut())}return!0}disconnectedCallback(){window.removeEventListener("es-bridge-h5p-"+this.__h5pDepsLength+"-loaded",this.h5pReadyCallback.bind(this)),window.removeEventListener("es-bridge-h5p-jquery-loaded",this.h5pJqueryReady.bind(this)),super.disconnectedCallback()}updated(changedProperties){changedProperties.forEach((oldValue,propName)=>{})}}customElements.define("h5p-element",H5PElement),window.H5P=window.H5P||{},window.H5PIntegration=window.H5PIntegration||{},H5PIntegration.l10n={H5P:{advancedHelp:"Include this script on your website if you want dynamic sizing of the embedded content:",author:"Author",by:"by",close:"Close",contentChanged:"This content has changed since you last used it.",copyrightInformation:"Rights of use",copyrights:"Rights of use",copyrightsDescription:"View copyright information for this content.",disableFullscreen:"Disable fullscreen",download:"Download",downloadDescription:"Download this content as a H5P file.",embed:"Embed",embedDescription:"View the embed code for this content.",fullscreen:"Fullscreen",h5pDescription:"Visit H5P.org to check out more cool content.",hideAdvanced:"Hide advanced",license:"License",noCopyrights:"No copyright information available for this content.",showAdvanced:"Show advanced",showLess:"Show less",showMore:"Show more",size:"Size",source:"Source",startingOver:"You'll be starting over.",subLevel:"Sublevel",thumbnail:"Thumbnail",title:"Title",year:"Year"}};class H5PStandalone{constructor(id=1,pathToContent,displayOptions){return this.id=id,this.path=pathToContent,this.displayOptions=displayOptions,!0}getJSONPromise(url){return fetch(url).then((function(response){return response.json()}))}async init(){this.h5p=await this.getJSONPromise(`${this.path}/h5p.json`),this.content=JSON.stringify(await this.getJSONPromise(`${this.path}/content/content.json`)),window.H5PIntegration.pathIncludesVersion=this.pathIncludesVersion=await this.checkIfPathIncludesVersion(),this.mainLibrary=await this.findMainLibrary();const dependencies=await this.findAllDependencies(),{styles,scripts}=await this.sortDependencies(dependencies);return H5PIntegration.url=this.path,H5PIntegration.contents=H5PIntegration.contents?H5PIntegration.contents:{},H5PIntegration.contents["cid-"+this.id]={library:`${this.mainLibrary.machineName} ${this.mainLibrary.majorVersion}.${this.mainLibrary.minorVersion}`,jsonContent:this.content,styles,scripts,displayOptions:this.displayOptions},!0}async checkIfPathIncludesVersion(){let pathIncludesVersion,dependency=this.h5p.preloadedDependencies[0],machinePath=dependency.machineName+"-"+dependency.majorVersion+"."+dependency.minorVersion;try{await this.getJSONPromise(`${this.path}/${machinePath}/library.json`),pathIncludesVersion=!0}catch(e){pathIncludesVersion=!1}return pathIncludesVersion}libraryPath(library){return library.machineName+(this.pathIncludesVersion?"-"+library.majorVersion+"."+library.minorVersion:"")}findMainLibrary(){const mainLibraryInfo=this.h5p.preloadedDependencies.find(dep=>dep.machineName===this.h5p.mainLibrary);return this.mainLibraryPath=this.h5p.mainLibrary+(this.pathIncludesVersion?"-"+mainLibraryInfo.majorVersion+"."+mainLibraryInfo.minorVersion:""),this.getJSONPromise(`${this.path}/${this.mainLibraryPath}/library.json`)}findAllDependencies(){const directDependencyNames=this.h5p.preloadedDependencies.map(dependency=>this.libraryPath(dependency));return this.loadDependencies(directDependencyNames,[])}async loadDependencies(toFind,alreadyFound){let dependencies=alreadyFound,findNext=[],newDependencies=await Promise.all(toFind.map(libraryName=>this.findLibraryDependencies(libraryName)));return newDependencies.forEach(library=>{dependencies.push(library),library.dependencies.forEach(dependency=>{dependencies.find(foundLibrary=>foundLibrary.libraryPath===dependency)||newDependencies.find(foundLibrary=>foundLibrary.libraryPath===dependency)||findNext.push(dependency)})}),findNext.length>0?this.loadDependencies(findNext,dependencies):dependencies}async findLibraryDependencies(libraryName){const library=await this.getJSONPromise(`${this.path}/${libraryName}/library.json`),libraryPath=this.libraryPath(library);let dependencies=[];return library.preloadedDependencies&&(dependencies=library.preloadedDependencies.map(dependency=>this.libraryPath(dependency))),{libraryPath,dependencies,preloadedCss:library.preloadedCss,preloadedJs:library.preloadedJs}}async sortDependencies(dependencies){const dependencySorter=new Toposort;let CSSDependencies={},JSDependencies={};dependencies.forEach(dependency=>{dependencySorter.add(dependency.libraryPath,dependency.dependencies),dependency.preloadedCss&&(CSSDependencies[dependency.libraryPath]=CSSDependencies[dependency.libraryPath]?CSSDependencies[dependency.libraryPath]:[],dependency.preloadedCss.forEach(style=>{CSSDependencies[dependency.libraryPath].push(`${this.path}/${dependency.libraryPath}/${style.path}`)})),dependency.preloadedJs&&(JSDependencies[dependency.libraryPath]=JSDependencies[dependency.libraryPath]?JSDependencies[dependency.libraryPath]:[],dependency.preloadedJs.forEach(script=>{JSDependencies[dependency.libraryPath].push(`${this.path}/${dependency.libraryPath}/${script.path}`)}))});let styles=[],scripts=[];return dependencySorter.sort().reverse().forEach((function(dependencyName){Array.prototype.push.apply(styles,CSSDependencies[dependencyName]),Array.prototype.push.apply(scripts,JSDependencies[dependencyName])})),Array.prototype.push.apply(styles,this.mainLibrary.preloadedCss.map(style=>`${this.path}/${this.mainLibraryPath}/${style.path}`)),Array.prototype.push.apply(scripts,this.mainLibrary.preloadedJs.map(script=>`${this.path}/${this.mainLibraryPath}/${script.path}`)),{styles,scripts}}}class Toposort{constructor(){this.edges=[]}add(item,deps){if("string"!=typeof item||!item)throw new TypeError("Dependent name must be given as a not empty string");if((deps=Array.isArray(deps)?deps:[deps]).length>0)for(let dep of deps){if("string"!=typeof dep||!dep)throw new TypeError("Dependency name must be given as a not empty string");this.edges.push([item,dep])}else this.edges.push([item]);return this}sort(){let nodes=[];for(let edge of this.edges)for(let node of edge)-1===nodes.indexOf(node)&&nodes.push(node);let place=nodes.length,sorted=new Array(nodes.length);var visit=(node,predecessors)=>{if(0!==predecessors.length&&-1!==predecessors.indexOf(node))throw new Error(`Cyclic dependency found. ${node} is dependent of itself.\nDependency chain: ${predecessors.join(" -> ")} => ${node}`);let index=nodes.indexOf(node);if(-1!==index){let copy=!1;nodes[index]=!1;for(let edge of this.edges)edge[0]===node&&(copy=copy||predecessors.concat([node]),visit(edge[1],copy));sorted[--place]=node}};for(let i=0;i<nodes.length;i++){let node=nodes[i];if(!1!==node){nodes[i]=!1;for(let edge of this.edges)edge[0]===node&&visit(edge[1],[node]);sorted[--place]=node}}return sorted}clear(){return this.edges=[],this}}export{H5PElement,H5PStandalone,Toposort};