const debug=!1,validNodeTypes=[Node.ELEMENT_NODE,Node.TEXT_NODE,Node.DOCUMENT_FRAGMENT_NODE];function isValidNode(node){return validNodeTypes.includes(node.nodeType)}function findNode(s,parentNode,isLeft){const nodes=parentNode.childNodes||parentNode.children;if(!nodes){return parentNode}for(let i=0;i<nodes.length;++i){const j=isLeft?i:nodes.length-1-i,childNode=nodes[j];if(!isValidNode(childNode)){continue}debug&&console.debug("checking child",childNode,"IsLeft",isLeft);if(s.containsNode(childNode,!0)){if(s.containsNode(childNode,!1)){debug&&console.info("found child",childNode);return childNode}debug&&console.info("descending child",childNode);return findNode(s,childNode,isLeft)}debug&&console.info(parentNode,"does NOT contain",childNode)}return parentNode}const addInternalListener=(()=>{const testNode=document.createElement("div"),testRoot=testNode.attachShadow({mode:"open"});if(testRoot.getSelection){document.addEventListener("selectionchange",()=>{document.dispatchEvent(new CustomEvent("-shadow-selectionchange"))});return()=>{}}let withinInternals=!1;const handlers=[];document.addEventListener("selectionchange",ev=>{if(withinInternals){return}document.dispatchEvent(new CustomEvent("-shadow-selectionchange"));withinInternals=!0;window.setTimeout(()=>{withinInternals=!1},0);handlers.forEach(fn=>fn(ev))});return fn=>handlers.push(fn)})();let wasCaret=!1,resolveTask=null;addInternalListener(()=>{const s=window.getSelection();if("Caret"===s.type){wasCaret=!0}else if(wasCaret&&!resolveTask){resolveTask=Promise.resolve(!0).then(()=>{wasCaret=!1;resolveTask=null})}});function containsNextElement(s,node,walkForward){const start=node;while(node=walkFromNode(node,walkForward)){if(!node.contains(start)){break}}if(!node){return!1}return node instanceof Element&&s.containsNode(node,!0)}function getSelectionDirection(s,leftNode,rightNode){if("Range"!==s.type){return}const measure=()=>s.toString().length,initialSize=measure();debug&&console.info(`initial selection: "${s.toString()}"`);if(1===initialSize&&wasCaret&&leftNode===rightNode){debug&&console.debug("resetting size=1");s.extend(leftNode,0);s.collapseToEnd();return}let updatedSize;s.modify("extend","forward","character");updatedSize=measure();debug&&console.info(`forward selection: "${s.toString()}"`);if(updatedSize>initialSize||containsNextElement(s,rightNode,!0)){debug&&console.info("got forward >, moving right");s.modify("extend","backward","character");return!0}else if(updatedSize<initialSize||!s.containsNode(leftNode)){debug&&console.info("got forward <, moving left");s.modify("extend","backward","character");return!1}s.modify("extend","backward","character");updatedSize=measure();debug&&console.info(`backward selection: "${s.toString()}"`);if(updatedSize>initialSize||containsNextElement(s,leftNode,!1)){debug&&console.info("got backwards >, moving left");s.modify("extend","forward","character");return!1}else if(updatedSize<initialSize||!s.containsNode(rightNode)){debug&&console.info("got backwards <, moving right");s.modify("extend","forward","character");return!0}}function walkFromNode(node,walkForward){if(!walkForward){return node.previousSibling||node.parentNode||null}while(node){if(node.nextSibling){return node.nextSibling}node=node.parentNode}return null}function walkTextFromNode(node,isLeft,s){for(;node;node=walkFromNode(node,isLeft)){if(node.nodeType!==Node.TEXT_NODE){continue}const t=node.textContent;if(isLeft){if(s.length<t.length){return{node,offset:s.length}}const prefix=s.substr(0,t.length);if(prefix!==t){console.debug("unexpected string prefix",prefix,"expected",t)}s=s.substr(t.length)}else{if(s.length<t.length){return{node,offset:t.length-s.length}}const suffix=s.substr(s.length-t.length);if(suffix!==t){console.debug("unexpected string suffix",suffix,"expected",t)}s=s.substr(0,s.length-t.length)}}return null}function initialSpace(node){if(node.nodeType!==Node.TEXT_NODE){return 0}return /^\s*/.exec(node.textContent)[0].length}function ignoredTrailingSpace(node){if(node.nodeType!==Node.TEXT_NODE){return 0}const trailingSpaceCount=/\s*$/.exec(node.textContent)[0].length;if(!trailingSpaceCount){return 0}return trailingSpaceCount-1}const cachedRange=new Map;export function getRange(root){if(root.getSelection){const s=root.getSelection();return s.rangeCount?s.getRangeAt(0):null}const thisFrame=cachedRange.get(root);if(thisFrame){return thisFrame}const initialText=window.getSelection().toString(),result=internalGetShadowSelection(root),rs=result.range&&result.range.toString()||null;if(null!==rs&&rs!==initialText){if(rs.replace(/\s/g,"")!==initialText.replace(/\s/g,"")){console.warn("invalid range, initial text:",initialText);console.warn("vs",rs,result.mode,result.range)}}cachedRange.set(root,result.range);window.setTimeout(()=>{cachedRange.delete(root)},0);debug&&console.debug("getRange got",result);return result.range}const fakeSelectionNode=document.createTextNode("");export function internalGetShadowSelection(root){const range=document.createRange(),s=window.getSelection();if(!s.containsNode(root.host,!0)){return{range:null,mode:"none"}}root.insertBefore(fakeSelectionNode,root.childNodes[0]);const includesBeforeRoot=s.containsNode(fakeSelectionNode);fakeSelectionNode.remove();if(includesBeforeRoot){return{range:null,mode:"outside-before"}}root.appendChild(fakeSelectionNode);const includesAfterRoot=s.containsNode(fakeSelectionNode);fakeSelectionNode.remove();if(includesAfterRoot){return{range:null,mode:"outside-after"}}const measure=()=>s.toString().length,initialSelectionContent=s.toString();if(!("Caret"===s.type||"Range"===s.type)){throw new TypeError("unexpected type: "+s.type)}const initialCaret="Caret"===s.type,leftNode=findNode(s,root,!0);let rightNode,isNaturalDirection;if("Range"===s.type){rightNode=findNode(s,root,!1);isNaturalDirection=getSelectionDirection(s,leftNode,rightNode)}if("Caret"===s.type){s.extend(leftNode,0);const at=measure();s.collapseToEnd();range.setStart(leftNode,at);range.setEnd(leftNode,at);return{range,mode:"caret"}}else if(isNaturalDirection===void 0){if("Range"!==s.type){throw new TypeError("unexpected type: "+s.type)}range.setStart(leftNode,0);range.setEnd(rightNode,rightNode.length);return{range,mode:"all"}}const size=measure();let offsetLeft,offsetRight;const validRightLength=rightNode.length-ignoredTrailingSpace(rightNode);if(isNaturalDirection){s.extend(leftNode,0);offsetLeft=measure()+initialSpace(leftNode);s.extend(rightNode,validRightLength);offsetRight=validRightLength-(measure()-size);s.extend(rightNode,offsetRight)}else{s.extend(rightNode,validRightLength);offsetRight=validRightLength-measure();s.extend(leftNode,0);offsetLeft=measure()-size+initialSpace(leftNode);s.extend(leftNode,offsetLeft)}if(debug){if(leftNode===rightNode){console.info("got string",leftNode.textContent.substr(offsetLeft,offsetRight-offsetLeft))}else{console.info(">>> string",leftNode.textContent.substr(offsetLeft));console.info("<<< string",rightNode.textContent.substr(0,offsetRight))}}range.setStart(leftNode,offsetLeft);range.setEnd(rightNode,offsetRight);return{mode:isNaturalDirection?"right":"left",range}}