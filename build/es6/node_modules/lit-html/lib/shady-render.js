import{removeNodes}from"./dom.js";import{insertNodeIntoTemplate,removeNodesFromTemplate}from"./modify-template.js";import{parts,render as litRender}from"./render.js";import{templateCaches}from"./template-factory.js";import{TemplateInstance}from"./template-instance.js";import{TemplateResult}from"./template-result.js";import{marker,Template}from"./template.js";export{html,svg,TemplateResult}from"../lit-html.js";const getTemplateCacheKey=(type,scopeName)=>`${type}--${scopeName}`;let compatibleShadyCSSVersion=!0;void 0===window.ShadyCSS?compatibleShadyCSSVersion=!1:void 0===window.ShadyCSS.prepareTemplateDom&&(console.warn("Incompatible ShadyCSS version detected.Please update to at least @webcomponents/webcomponentsjs@2.0.2 and@webcomponents/shadycss@1.3.1."),compatibleShadyCSSVersion=!1);const shadyTemplateFactory=scopeName=>result=>{const cacheKey=getTemplateCacheKey(result.type,scopeName);let templateCache=templateCaches.get(cacheKey);void 0===templateCache&&(templateCache={stringsArray:new WeakMap,keyString:new Map},templateCaches.set(cacheKey,templateCache));let template=templateCache.stringsArray.get(result.strings);if(void 0!==template)return template;const key=result.strings.join(marker);if(void 0===(template=templateCache.keyString.get(key))){const element=result.getTemplateElement();compatibleShadyCSSVersion&&window.ShadyCSS.prepareTemplateDom(element,scopeName),template=new Template(result,element),templateCache.keyString.set(key,template)}return templateCache.stringsArray.set(result.strings,template),template},TEMPLATE_TYPES=["html","svg"],shadyRenderSet=new Set,prepareTemplateStyles=(renderedDOM,template,scopeName)=>{shadyRenderSet.add(scopeName);const styles=renderedDOM.querySelectorAll("style");if(0===styles.length)return void window.ShadyCSS.prepareTemplateStyles(template.element,scopeName);const condensedStyle=document.createElement("style");for(let i=0;i<styles.length;i++){const style=styles[i];style.parentNode.removeChild(style),condensedStyle.textContent+=style.textContent}if((scopeName=>{TEMPLATE_TYPES.forEach(type=>{const templates=templateCaches.get(getTemplateCacheKey(type,scopeName));void 0!==templates&&templates.keyString.forEach(template=>{const{element:{content:content}}=template,styles=new Set;Array.from(content.querySelectorAll("style")).forEach(s=>{styles.add(s)}),removeNodesFromTemplate(template,styles)})})})(scopeName),insertNodeIntoTemplate(template,condensedStyle,template.element.content.firstChild),window.ShadyCSS.prepareTemplateStyles(template.element,scopeName),window.ShadyCSS.nativeShadow){const style=template.element.content.querySelector("style");renderedDOM.insertBefore(style.cloneNode(!0),renderedDOM.firstChild)}else{template.element.content.insertBefore(condensedStyle,template.element.content.firstChild);const removes=new Set;removes.add(condensedStyle),removeNodesFromTemplate(template,removes)}};export const render=(result,container,options)=>{const scopeName=options.scopeName,hasRendered=parts.has(container),needsScoping=container instanceof ShadowRoot&&compatibleShadyCSSVersion&&result instanceof TemplateResult,firstScopeRender=needsScoping&&!shadyRenderSet.has(scopeName),renderContainer=firstScopeRender?document.createDocumentFragment():container;if(litRender(result,renderContainer,Object.assign({templateFactory:shadyTemplateFactory(scopeName)},options)),firstScopeRender){const part=parts.get(renderContainer);parts.delete(renderContainer),part.value instanceof TemplateInstance&&prepareTemplateStyles(renderContainer,part.value.template,scopeName),removeNodes(container,container.firstChild),container.appendChild(renderContainer),parts.set(container,part)}!hasRendered&&needsScoping&&window.ShadyCSS.styleElement(container.host)};