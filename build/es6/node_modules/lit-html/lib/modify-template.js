/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
import{isTemplatePartActive as e}from"./template.js";export function removeNodesFromTemplate(e,n){const{element:{content:t},parts:r}=e,o=document.createTreeWalker(t,133,null,!1);let l=nextActiveIndexInTemplateParts(r),u=r[l],d=-1,c=0;const i=[];let s=null;for(;o.nextNode();){d++;const e=o.currentNode;for(e.previousSibling===s&&(s=null),n.has(e)&&(i.push(e),null===s&&(s=e)),null!==s&&c++;void 0!==u&&u.index===d;)u.index=null!==s?-1:u.index-c,l=nextActiveIndexInTemplateParts(r,l),u=r[l]}i.forEach(e=>e.parentNode.removeChild(e))}const countNodes=e=>{let n=11===e.nodeType?0:1;const t=document.createTreeWalker(e,133,null,!1);for(;t.nextNode();)n++;return n},nextActiveIndexInTemplateParts=(n,t=-1)=>{for(let r=t+1;r<n.length;r++){const t=n[r];if(e(t))return r}return-1};export function insertNodeIntoTemplate(e,n,t=null){const{element:{content:r},parts:o}=e;if(null==t)return void r.appendChild(n);const l=document.createTreeWalker(r,133,null,!1);let u=nextActiveIndexInTemplateParts(o),d=0,c=-1;for(;l.nextNode();){for(c++,l.currentNode===t&&(d=countNodes(n),t.parentNode.insertBefore(n,t));-1!==u&&o[u].index===c;){if(d>0){for(;-1!==u;)o[u].index+=d,u=nextActiveIndexInTemplateParts(o,u);return}u=nextActiveIndexInTemplateParts(o,u)}}}