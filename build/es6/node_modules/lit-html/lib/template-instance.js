/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
import{isCEPolyfill}from"./dom.js";import{isTemplatePartActive}from"./template.js";export class TemplateInstance{constructor(template,processor,options){this.__parts=[],this.template=template,this.processor=processor,this.options=options}update(values){let i=0;for(const part of this.__parts)void 0!==part&&part.setValue(values[i]),i++;for(const part of this.__parts)void 0!==part&&part.commit()}_clone(){const fragment=isCEPolyfill?this.template.element.content.cloneNode(!0):document.importNode(this.template.element.content,!0),stack=[],parts=this.template.parts,walker=document.createTreeWalker(fragment,133,null,!1);let part,partIndex=0,nodeIndex=0,node=walker.nextNode();for(;partIndex<parts.length;)if(part=parts[partIndex],isTemplatePartActive(part)){for(;nodeIndex<part.index;)nodeIndex++,"TEMPLATE"===node.nodeName&&(stack.push(node),walker.currentNode=node.content),null===(node=walker.nextNode())&&(walker.currentNode=stack.pop(),node=walker.nextNode());if("node"===part.type){const part=this.processor.handleTextExpression(this.options);part.insertAfterNode(node.previousSibling),this.__parts.push(part)}else this.__parts.push(...this.processor.handleAttributeExpressions(node,part.name,part.strings,this.options));partIndex++}else this.__parts.push(void 0),partIndex++;return isCEPolyfill&&(document.adoptNode(fragment),customElements.upgrade(fragment)),fragment}}