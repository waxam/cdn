import{isDirective}from"./directive.js";import{removeNodes}from"./dom.js";import{noChange,nothing}from"./part.js";import{TemplateInstance}from"./template-instance.js";import{TemplateResult}from"./template-result.js";import{createMarker}from"./template.js";export const isPrimitive=value=>null===value||!("object"==typeof value||"function"==typeof value);export class AttributeCommitter{constructor(element,name,strings){this.dirty=!0,this.element=element,this.name=name,this.strings=strings,this.parts=[];for(let i=0;i<strings.length-1;i++)this.parts[i]=this._createPart()}_createPart(){return new AttributePart(this)}_getValue(){const strings=this.strings,l=strings.length-1;let text="";for(let i=0;i<l;i++){text+=strings[i];const part=this.parts[i];if(void 0!==part){const v=part.value;if(null!=v&&(Array.isArray(v)||"string"!=typeof v&&v[Symbol.iterator]))for(const t of v)text+="string"==typeof t?t:String(t);else text+="string"==typeof v?v:String(v)}}return text+=strings[l]}commit(){this.dirty&&(this.dirty=!1,this.element.setAttribute(this.name,this._getValue()))}}export class AttributePart{constructor(comitter){this.value=void 0,this.committer=comitter}setValue(value){value===noChange||isPrimitive(value)&&value===this.value||(this.value=value,isDirective(value)||(this.committer.dirty=!0))}commit(){for(;isDirective(this.value);){const directive=this.value;this.value=noChange,directive(this)}this.value!==noChange&&this.committer.commit()}}export class NodePart{constructor(options){this.value=void 0,this._pendingValue=void 0,this.options=options}appendInto(container){this.startNode=container.appendChild(createMarker()),this.endNode=container.appendChild(createMarker())}insertAfterNode(ref){this.startNode=ref,this.endNode=ref.nextSibling}appendIntoPart(part){part._insert(this.startNode=createMarker()),part._insert(this.endNode=createMarker())}insertAfterPart(ref){ref._insert(this.startNode=createMarker()),this.endNode=ref.endNode,ref.endNode=this.startNode}setValue(value){this._pendingValue=value}commit(){for(;isDirective(this._pendingValue);){const directive=this._pendingValue;this._pendingValue=noChange,directive(this)}const value=this._pendingValue;value!==noChange&&(isPrimitive(value)?value!==this.value&&this._commitText(value):value instanceof TemplateResult?this._commitTemplateResult(value):value instanceof Node?this._commitNode(value):Array.isArray(value)||value[Symbol.iterator]?this._commitIterable(value):value===nothing?(this.value=nothing,this.clear()):this._commitText(value))}_insert(node){this.endNode.parentNode.insertBefore(node,this.endNode)}_commitNode(value){this.value!==value&&(this.clear(),this._insert(value),this.value=value)}_commitText(value){const node=this.startNode.nextSibling;value=null==value?"":value,node===this.endNode.previousSibling&&3===node.nodeType?node.data=value:this._commitNode(document.createTextNode("string"==typeof value?value:String(value))),this.value=value}_commitTemplateResult(value){const template=this.options.templateFactory(value);if(this.value instanceof TemplateInstance&&this.value.template===template)this.value.update(value.values);else{const instance=new TemplateInstance(template,value.processor,this.options),fragment=instance._clone();instance.update(value.values),this._commitNode(fragment),this.value=instance}}_commitIterable(value){Array.isArray(this.value)||(this.value=[],this.clear());const itemParts=this.value;let itemPart,partIndex=0;for(const item of value)void 0===(itemPart=itemParts[partIndex])&&(itemPart=new NodePart(this.options),itemParts.push(itemPart),0===partIndex?itemPart.appendIntoPart(this):itemPart.insertAfterPart(itemParts[partIndex-1])),itemPart.setValue(item),itemPart.commit(),partIndex++;partIndex<itemParts.length&&(itemParts.length=partIndex,this.clear(itemPart&&itemPart.endNode))}clear(startNode=this.startNode){removeNodes(this.startNode.parentNode,startNode.nextSibling,this.endNode)}}export class BooleanAttributePart{constructor(element,name,strings){if(this.value=void 0,this._pendingValue=void 0,2!==strings.length||""!==strings[0]||""!==strings[1])throw new Error("Boolean attributes can only contain a single expression");this.element=element,this.name=name,this.strings=strings}setValue(value){this._pendingValue=value}commit(){for(;isDirective(this._pendingValue);){const directive=this._pendingValue;this._pendingValue=noChange,directive(this)}if(this._pendingValue===noChange)return;const value=!!this._pendingValue;this.value!==value&&(value?this.element.setAttribute(this.name,""):this.element.removeAttribute(this.name)),this.value=value,this._pendingValue=noChange}}export class PropertyCommitter extends AttributeCommitter{constructor(element,name,strings){super(element,name,strings),this.single=2===strings.length&&""===strings[0]&&""===strings[1]}_createPart(){return new PropertyPart(this)}_getValue(){return this.single?this.parts[0].value:super._getValue()}commit(){this.dirty&&(this.dirty=!1,this.element[this.name]=this._getValue())}}export class PropertyPart extends AttributePart{}let eventOptionsSupported=!1;try{const options={get capture(){return eventOptionsSupported=!0,!1}};window.addEventListener("test",options,options),window.removeEventListener("test",options,options)}catch(_e){}export class EventPart{constructor(element,eventName,eventContext){this.value=void 0,this._pendingValue=void 0,this.element=element,this.eventName=eventName,this.eventContext=eventContext,this._boundHandleEvent=e=>this.handleEvent(e)}setValue(value){this._pendingValue=value}commit(){for(;isDirective(this._pendingValue);){const directive=this._pendingValue;this._pendingValue=noChange,directive(this)}if(this._pendingValue===noChange)return;const newListener=this._pendingValue,oldListener=this.value,shouldRemoveListener=null==newListener||null!=oldListener&&(newListener.capture!==oldListener.capture||newListener.once!==oldListener.once||newListener.passive!==oldListener.passive),shouldAddListener=null!=newListener&&(null==oldListener||shouldRemoveListener);shouldRemoveListener&&this.element.removeEventListener(this.eventName,this._boundHandleEvent,this._options),shouldAddListener&&(this._options=getOptions(newListener),this.element.addEventListener(this.eventName,this._boundHandleEvent,this._options)),this.value=newListener,this._pendingValue=noChange}handleEvent(event){"function"==typeof this.value?this.value.call(this.eventContext||this.element,event):this.value.handleEvent(event)}}const getOptions=o=>o&&(eventOptionsSupported?{capture:o.capture,passive:o.passive,once:o.once}:o.capture);