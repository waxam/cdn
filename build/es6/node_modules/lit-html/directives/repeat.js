/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
import{createMarker as e,directive as t,NodePart as n,removeNodes as o,reparentNodes as s}from"../lit-html.js";const createAndInsertPart=(t,o)=>{const s=t.startNode.parentNode,r=void 0===o?t.endNode:o.startNode,l=s.insertBefore(e(),r);s.insertBefore(e(),r);const i=new n(t.options);return i.insertAfterNode(l),i},updatePart=(e,t)=>(e.setValue(t),e.commit(),e),insertPartBefore=(e,t,n)=>{const o=e.startNode.parentNode,r=n?n.startNode:e.endNode,l=t.endNode.nextSibling;l!==r&&s(o,t.startNode,l,r)},removePart=e=>{o(e.startNode.parentNode,e.startNode,e.endNode.nextSibling)},generateMap=(e,t,n)=>{const o=new Map;for(let s=t;s<=n;s++)o.set(e[s],s);return o},r=new WeakMap,l=new WeakMap;export const repeat=t((e,t,o)=>{let s;return void 0===o?o=t:void 0!==t&&(s=t),t=>{if(!(t instanceof n))throw new Error("repeat can only be used in text bindings");const i=r.get(t)||[],d=l.get(t)||[],a=[],f=[],c=[];let N,p,u=0;for(const t of e)c[u]=s?s(t,u):u,f[u]=o(t,u),u++;let g=0,h=i.length-1,w=0,m=f.length-1;for(;g<=h&&w<=m;)if(null===i[g])g++;else if(null===i[h])h--;else if(d[g]===c[w])a[w]=updatePart(i[g],f[w]),g++,w++;else if(d[h]===c[m])a[m]=updatePart(i[h],f[m]),h--,m--;else if(d[g]===c[m])a[m]=updatePart(i[g],f[m]),insertPartBefore(t,i[g],a[m+1]),g++,m--;else if(d[h]===c[w])a[w]=updatePart(i[h],f[w]),insertPartBefore(t,i[h],i[g]),h--,w++;else if(void 0===N&&(N=generateMap(c,w,m),p=generateMap(d,g,h)),N.has(d[g]))if(N.has(d[h])){const e=p.get(c[w]),n=void 0!==e?i[e]:null;if(null===n){const e=createAndInsertPart(t,i[g]);updatePart(e,f[w]),a[w]=e}else a[w]=updatePart(n,f[w]),insertPartBefore(t,n,i[g]),i[e]=null;w++}else removePart(i[h]),h--;else removePart(i[g]),g++;for(;w<=m;){const e=createAndInsertPart(t,a[m+1]);updatePart(e,f[w]),a[w++]=e}for(;g<=h;){const e=i[g++];null!==e&&removePart(e)}r.set(t,a),l.set(t,c)}});