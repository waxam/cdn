var weekdays = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
var months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];

function pad(num) {
  return ('0' + num).slice(-2);
}

function strftime(time, formatString) {
  var day = time.getDay();
  var date = time.getDate();
  var month = time.getMonth();
  var year = time.getFullYear();
  var hour = time.getHours();
  var minute = time.getMinutes();
  var second = time.getSeconds();
  return formatString.replace(/%([%aAbBcdeHIlmMpPSwyYZz])/g, function (_arg) {
    var match = void 0;
    var modifier = _arg[1];

    switch (modifier) {
      case '%':
        return '%';

      case 'a':
        return weekdays[day].slice(0, 3);

      case 'A':
        return weekdays[day];

      case 'b':
        return months[month].slice(0, 3);

      case 'B':
        return months[month];

      case 'c':
        return time.toString();

      case 'd':
        return pad(date);

      case 'e':
        return date;

      case 'H':
        return pad(hour);

      case 'I':
        return pad(strftime(time, '%l'));

      case 'l':
        if (hour === 0 || hour === 12) {
          return 12;
        } else {
          return (hour + 12) % 12;
        }

      case 'm':
        return pad(month + 1);

      case 'M':
        return pad(minute);

      case 'p':
        if (hour > 11) {
          return 'PM';
        } else {
          return 'AM';
        }

      case 'P':
        if (hour > 11) {
          return 'pm';
        } else {
          return 'am';
        }

      case 'S':
        return pad(second);

      case 'w':
        return day;

      case 'y':
        return pad(year % 100);

      case 'Y':
        return year;

      case 'Z':
        match = time.toString().match(/\((\w+)\)$/);
        return match ? match[1] : '';

      case 'z':
        match = time.toString().match(/\w([+-]\d\d\d\d) /);
        return match ? match[1] : '';
    }
  });
}

function makeFormatter(options) {
  var format = void 0;
  return function () {
    if (format) return format;

    if ('Intl' in window) {
      try {
        format = new Intl.DateTimeFormat(undefined, options);
        return format;
      } catch (e) {
        if (!(e instanceof RangeError)) {
          throw e;
        }
      }
    }
  };
}

var dayFirst = null;
var dayFirstFormatter = makeFormatter({
  day: 'numeric',
  month: 'short'
}); // Private: Determine if the day should be formatted before the month name in
// the user's current locale. For example, `9 Jun` for en-GB and `Jun 9`
// for en-US.
//
// Returns true if the day appears before the month.

function isDayFirst() {
  if (dayFirst !== null) {
    return dayFirst;
  }

  var formatter = dayFirstFormatter();

  if (formatter) {
    var output = formatter.format(new Date(0));
    dayFirst = !!output.match(/^\d/);
    return dayFirst;
  } else {
    return false;
  }
}

var yearSeparator = null;
var yearFormatter = makeFormatter({
  day: 'numeric',
  month: 'short',
  year: 'numeric'
}); // Private: Determine if the year should be separated from the month and day
// with a comma. For example, `9 Jun 2014` in en-GB and `Jun 9, 2014` in en-US.
//
// Returns true if the date needs a separator.

function isYearSeparator() {
  if (yearSeparator !== null) {
    return yearSeparator;
  }

  var formatter = yearFormatter();

  if (formatter) {
    var output = formatter.format(new Date(0));
    yearSeparator = !!output.match(/\d,/);
    return yearSeparator;
  } else {
    return true;
  }
} // Private: Determine if the date occurs in the same year as today's date.
//
// date - The Date to test.
//
// Returns true if it's this year.


function isThisYear(date) {
  var now = new Date();
  return now.getUTCFullYear() === date.getUTCFullYear();
}

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};

var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

function _CustomElement() {
  return Reflect.construct(HTMLElement, [], this.__proto__.constructor);
}

Object.setPrototypeOf(_CustomElement.prototype, HTMLElement.prototype);
Object.setPrototypeOf(_CustomElement, HTMLElement);

var ExtendedTimeElement = function (_CustomElement2) {
  inherits(ExtendedTimeElement, _CustomElement2);

  function ExtendedTimeElement() {
    classCallCheck(this, ExtendedTimeElement);
    return possibleConstructorReturn(this, (ExtendedTimeElement.__proto__ || Object.getPrototypeOf(ExtendedTimeElement)).apply(this, arguments));
  }

  createClass(ExtendedTimeElement, [{
    key: 'attributeChangedCallback',
    // Internal: Refresh the time element's formatted date when an attribute changes.
    //
    // Returns nothing.
    value: function attributeChangedCallback(attrName, oldValue, newValue) {
      if (attrName === 'datetime') {
        var millis = Date.parse(newValue);
        this._date = isNaN(millis) ? null : new Date(millis);
      }

      var title = this.getFormattedTitle();

      if (title && !this.hasAttribute('title')) {
        this.setAttribute('title', title);
      }

      var text = this.getFormattedDate();

      if (text) {
        this.textContent = text;
      }
    } // Internal: Format the ISO 8601 timestamp according to the user agent's
    // locale-aware formatting rules. The element's existing `title` attribute
    // value takes precedence over this custom format.
    //
    // Returns a formatted time String.

  }, {
    key: 'getFormattedTitle',
    value: function getFormattedTitle() {
      if (!this._date) {
        return;
      }

      var formatter = titleFormatter();

      if (formatter) {
        return formatter.format(this._date);
      } else {
        try {
          return this._date.toLocaleString();
        } catch (e) {
          if (e instanceof RangeError) {
            return this._date.toString();
          } else {
            throw e;
          }
        }
      }
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['datetime', 'day', 'format', 'hour', 'minute', 'month', 'second', 'title', 'weekday', 'year'];
    }
  }]);
  return ExtendedTimeElement;
}(_CustomElement);

var titleFormatter = makeFormatter({
  day: 'numeric',
  month: 'short',
  year: 'numeric',
  hour: 'numeric',
  minute: '2-digit',
  timeZoneName: 'short'
});
var formatters = new WeakMap();

var LocalTimeElement = function (_ExtendedTimeElement) {
  inherits(LocalTimeElement, _ExtendedTimeElement);

  function LocalTimeElement() {
    classCallCheck(this, LocalTimeElement);
    return possibleConstructorReturn(this, (LocalTimeElement.__proto__ || Object.getPrototypeOf(LocalTimeElement)).apply(this, arguments));
  }

  createClass(LocalTimeElement, [{
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(attrName, oldValue, newValue) {
      if (attrName === 'hour' || attrName === 'minute' || attrName === 'second' || attrName === 'time-zone-name') {
        formatters.delete(this);
      }

      get(LocalTimeElement.prototype.__proto__ || Object.getPrototypeOf(LocalTimeElement.prototype), 'attributeChangedCallback', this).call(this, attrName, oldValue, newValue);
    } // Formats the element's date, in the user's current locale, according to
    // the formatting attribute values. Values are not passed straight through to
    // an Intl.DateTimeFormat instance so that weekday and month names are always
    // displayed in English, for now.
    //
    // Supported attributes are:
    //
    //   weekday - "short", "long"
    //   year    - "numeric", "2-digit"
    //   month   - "short", "long"
    //   day     - "numeric", "2-digit"
    //   hour    - "numeric", "2-digit"
    //   minute  - "numeric", "2-digit"
    //   second  - "numeric", "2-digit"
    //
    // Returns a formatted time String.

  }, {
    key: 'getFormattedDate',
    value: function getFormattedDate() {
      if (!this._date) {
        return;
      }

      var date = formatDate(this) || '';
      var time = formatTime(this) || '';
      return (date + ' ' + time).trim();
    }
  }]);
  return LocalTimeElement;
}(ExtendedTimeElement);

function formatDate(el) {
  // map attribute values to strftime
  var props = {
    weekday: {
      short: '%a',
      long: '%A'
    },
    day: {
      numeric: '%e',
      '2-digit': '%d'
    },
    month: {
      short: '%b',
      long: '%B'
    },
    year: {
      numeric: '%Y',
      '2-digit': '%y' // build a strftime format string

    }
  };
  var format = isDayFirst() ? 'weekday day month year' : 'weekday month day, year';

  for (var prop in props) {
    var value = props[prop][el.getAttribute(prop)];
    format = format.replace(prop, value || '');
  } // clean up year separator comma


  format = format.replace(/(\s,)|(,\s$)/, ''); // squeeze spaces from final string

  return strftime(el._date, format).replace(/\s+/, ' ').trim();
} // Private: Format a time according to the `hour`, `minute`, and `second`
// attribute values.
//
// el - The local-time element to format.
//
// Returns a time String or null if no time formats are provided.


function formatTime(el) {
  // retrieve format settings from attributes
  var options = {
    hour: el.getAttribute('hour'),
    minute: el.getAttribute('minute'),
    second: el.getAttribute('second'),
    timeZoneName: el.getAttribute('time-zone-name') // Remove unset format attributes.

  };

  for (var opt in options) {
    if (!options[opt]) {
      delete options[opt];
    }
  } // No time format attributes provided.


  if (Object.keys(options).length === 0) {
    return;
  }

  var factory = formatters.get(el);

  if (!factory) {
    factory = makeFormatter(options);
    formatters.set(el, factory);
  }

  var formatter = factory();

  if (formatter) {
    // locale-aware formatting of 24 or 12 hour times
    return formatter.format(el._date);
  } else {
    // fall back to strftime for non-Intl browsers
    var timef = options.second ? '%H:%M:%S' : '%H:%M';
    return strftime(el._date, timef);
  }
} // Public: LocalTimeElement constructor.
//
//   var time = new LocalTimeElement()
//   # => <local-time></local-time>
//


if (!window.customElements.get('local-time')) {
  window.LocalTimeElement = LocalTimeElement;
  window.customElements.define('local-time', LocalTimeElement);
}

var RelativeTime = function () {
  function RelativeTime(date) {
    classCallCheck(this, RelativeTime);
    this.date = date;
  }

  createClass(RelativeTime, [{
    key: 'toString',
    value: function toString() {
      var ago = this.timeElapsed();

      if (ago) {
        return ago;
      } else {
        var ahead = this.timeAhead();

        if (ahead) {
          return ahead;
        } else {
          return 'on ' + this.formatDate();
        }
      }
    }
  }, {
    key: 'timeElapsed',
    value: function timeElapsed() {
      var ms = new Date().getTime() - this.date.getTime();
      var sec = Math.round(ms / 1000);
      var min = Math.round(sec / 60);
      var hr = Math.round(min / 60);
      var day = Math.round(hr / 24);

      if (ms >= 0 && day < 30) {
        return this.timeAgoFromMs(ms);
      } else {
        return null;
      }
    }
  }, {
    key: 'timeAhead',
    value: function timeAhead() {
      var ms = this.date.getTime() - new Date().getTime();
      var sec = Math.round(ms / 1000);
      var min = Math.round(sec / 60);
      var hr = Math.round(min / 60);
      var day = Math.round(hr / 24);

      if (ms >= 0 && day < 30) {
        return this.timeUntil();
      } else {
        return null;
      }
    }
  }, {
    key: 'timeAgo',
    value: function timeAgo() {
      var ms = new Date().getTime() - this.date.getTime();
      return this.timeAgoFromMs(ms);
    }
  }, {
    key: 'timeAgoFromMs',
    value: function timeAgoFromMs(ms) {
      var sec = Math.round(ms / 1000);
      var min = Math.round(sec / 60);
      var hr = Math.round(min / 60);
      var day = Math.round(hr / 24);
      var month = Math.round(day / 30);
      var year = Math.round(month / 12);

      if (ms < 0) {
        return 'just now';
      } else if (sec < 10) {
        return 'just now';
      } else if (sec < 45) {
        return sec + ' seconds ago';
      } else if (sec < 90) {
        return 'a minute ago';
      } else if (min < 45) {
        return min + ' minutes ago';
      } else if (min < 90) {
        return 'an hour ago';
      } else if (hr < 24) {
        return hr + ' hours ago';
      } else if (hr < 36) {
        return 'a day ago';
      } else if (day < 30) {
        return day + ' days ago';
      } else if (day < 45) {
        return 'a month ago';
      } else if (month < 12) {
        return month + ' months ago';
      } else if (month < 18) {
        return 'a year ago';
      } else {
        return year + ' years ago';
      }
    }
  }, {
    key: 'microTimeAgo',
    value: function microTimeAgo() {
      var ms = new Date().getTime() - this.date.getTime();
      var sec = Math.round(ms / 1000);
      var min = Math.round(sec / 60);
      var hr = Math.round(min / 60);
      var day = Math.round(hr / 24);
      var month = Math.round(day / 30);
      var year = Math.round(month / 12);

      if (min < 1) {
        return '1m';
      } else if (min < 60) {
        return min + 'm';
      } else if (hr < 24) {
        return hr + 'h';
      } else if (day < 365) {
        return day + 'd';
      } else {
        return year + 'y';
      }
    }
  }, {
    key: 'timeUntil',
    value: function timeUntil() {
      var ms = this.date.getTime() - new Date().getTime();
      return this.timeUntilFromMs(ms);
    }
  }, {
    key: 'timeUntilFromMs',
    value: function timeUntilFromMs(ms) {
      var sec = Math.round(ms / 1000);
      var min = Math.round(sec / 60);
      var hr = Math.round(min / 60);
      var day = Math.round(hr / 24);
      var month = Math.round(day / 30);
      var year = Math.round(month / 12);

      if (month >= 18) {
        return year + ' years from now';
      } else if (month >= 12) {
        return 'a year from now';
      } else if (day >= 45) {
        return month + ' months from now';
      } else if (day >= 30) {
        return 'a month from now';
      } else if (hr >= 36) {
        return day + ' days from now';
      } else if (hr >= 24) {
        return 'a day from now';
      } else if (min >= 90) {
        return hr + ' hours from now';
      } else if (min >= 45) {
        return 'an hour from now';
      } else if (sec >= 90) {
        return min + ' minutes from now';
      } else if (sec >= 45) {
        return 'a minute from now';
      } else if (sec >= 10) {
        return sec + ' seconds from now';
      } else {
        return 'just now';
      }
    }
  }, {
    key: 'microTimeUntil',
    value: function microTimeUntil() {
      var ms = this.date.getTime() - new Date().getTime();
      var sec = Math.round(ms / 1000);
      var min = Math.round(sec / 60);
      var hr = Math.round(min / 60);
      var day = Math.round(hr / 24);
      var month = Math.round(day / 30);
      var year = Math.round(month / 12);

      if (day >= 365) {
        return year + 'y';
      } else if (hr >= 24) {
        return day + 'd';
      } else if (min >= 60) {
        return hr + 'h';
      } else if (min > 1) {
        return min + 'm';
      } else {
        return '1m';
      }
    }
  }, {
    key: 'formatDate',
    value: function formatDate() {
      var format = isDayFirst() ? '%e %b' : '%b %e';

      if (!isThisYear(this.date)) {
        format += isYearSeparator() ? ', %Y' : ' %Y';
      }

      return strftime(this.date, format);
    }
  }, {
    key: 'formatTime',
    value: function formatTime() {
      var formatter = timeFormatter();

      if (formatter) {
        return formatter.format(this.date);
      } else {
        return strftime(this.date, '%l:%M%P');
      }
    }
  }]);
  return RelativeTime;
}();

var timeFormatter = makeFormatter({
  hour: 'numeric',
  minute: '2-digit'
});

var RelativeTimeElement = function (_ExtendedTimeElement) {
  inherits(RelativeTimeElement, _ExtendedTimeElement);

  function RelativeTimeElement() {
    classCallCheck(this, RelativeTimeElement);
    return possibleConstructorReturn(this, (RelativeTimeElement.__proto__ || Object.getPrototypeOf(RelativeTimeElement)).apply(this, arguments));
  }

  createClass(RelativeTimeElement, [{
    key: 'getFormattedDate',
    value: function getFormattedDate() {
      if (this._date) {
        return new RelativeTime(this._date).toString();
      }
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      nowElements.push(this);

      if (!updateNowElementsId) {
        updateNowElements();
        updateNowElementsId = setInterval(updateNowElements, 60 * 1000);
      }
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      var ix = nowElements.indexOf(this);

      if (ix !== -1) {
        nowElements.splice(ix, 1);
      }

      if (!nowElements.length) {
        if (updateNowElementsId) {
          clearInterval(updateNowElementsId);
          updateNowElementsId = null;
        }
      }
    }
  }]);
  return RelativeTimeElement;
}(ExtendedTimeElement);

var nowElements = []; // Internal: Timer ID for `updateNowElements` interval.

var updateNowElementsId = void 0; // Internal: Install a timer to refresh all attached relative-time elements every
// minute.

function updateNowElements() {
  var time = void 0,
      i = void 0,
      len = void 0;

  for (i = 0, len = nowElements.length; i < len; i++) {
    time = nowElements[i];
    time.textContent = time.getFormattedDate();
  }
} // Public: RelativeTimeElement constructor.
//
//   var time = new RelativeTimeElement()
//   # => <relative-time></relative-time>
//


if (!window.customElements.get('relative-time')) {
  window.RelativeTimeElement = RelativeTimeElement;
  window.customElements.define('relative-time', RelativeTimeElement);
}

var TimeAgoElement = function (_RelativeTimeElement) {
  inherits(TimeAgoElement, _RelativeTimeElement);

  function TimeAgoElement() {
    classCallCheck(this, TimeAgoElement);
    return possibleConstructorReturn(this, (TimeAgoElement.__proto__ || Object.getPrototypeOf(TimeAgoElement)).apply(this, arguments));
  }

  createClass(TimeAgoElement, [{
    key: 'getFormattedDate',
    value: function getFormattedDate() {
      if (this._date) {
        var format = this.getAttribute('format');

        if (format === 'micro') {
          return new RelativeTime(this._date).microTimeAgo();
        } else {
          return new RelativeTime(this._date).timeAgo();
        }
      }
    }
  }]);
  return TimeAgoElement;
}(RelativeTimeElement);

if (!window.customElements.get('time-ago')) {
  window.TimeAgoElement = TimeAgoElement;
  window.customElements.define('time-ago', TimeAgoElement);
}

var TimeUntilElement = function (_RelativeTimeElement) {
  inherits(TimeUntilElement, _RelativeTimeElement);

  function TimeUntilElement() {
    classCallCheck(this, TimeUntilElement);
    return possibleConstructorReturn(this, (TimeUntilElement.__proto__ || Object.getPrototypeOf(TimeUntilElement)).apply(this, arguments));
  }

  createClass(TimeUntilElement, [{
    key: 'getFormattedDate',
    value: function getFormattedDate() {
      if (this._date) {
        var format = this.getAttribute('format');

        if (format === 'micro') {
          return new RelativeTime(this._date).microTimeUntil();
        } else {
          return new RelativeTime(this._date).timeUntil();
        }
      }
    }
  }]);
  return TimeUntilElement;
}(RelativeTimeElement);

if (!window.customElements.get('time-until')) {
  window.TimeUntilElement = TimeUntilElement;
  window.customElements.define('time-until', TimeUntilElement);
}