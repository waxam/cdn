define(["exports", "../../tslib/tslib.es6.js", "../form-field/foundation.js", "../mwc-base/base-element.js", "../mwc-base/form-element.js", "../mwc-base/observer.js", "../mwc-base/utils.js", "../../lit-element/lit-element.js", "../../lit-html/directives/class-map.js"], function (_exports, _tslibEs, _foundation, _baseElement, _formElement, _observer, _utils, _litElement, _classMap) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.FormfieldBase = void 0;
  _foundation = babelHelpers.interopRequireDefault(_foundation);

  class FormfieldBase extends _baseElement.BaseElement {
    constructor() {
      super(...arguments);
      this.alignEnd = false;
      this.label = '';
      this.mdcFoundationClass = _foundation.default;
    }

    createAdapter() {
      return {
        registerInteractionHandler: (type, handler) => {
          this.labelEl.addEventListener(type, handler);
        },
        deregisterInteractionHandler: (type, handler) => {
          this.labelEl.removeEventListener(type, handler);
        },
        activateInputRipple: async () => {
          const input = this.input;

          if (input instanceof _formElement.FormElement) {
            const ripple = await input.ripple;

            if (ripple) {
              ripple.activate();
            }
          }
        },
        deactivateInputRipple: async () => {
          const input = this.input;

          if (input instanceof _formElement.FormElement) {
            const ripple = await input.ripple;

            if (ripple) {
              ripple.deactivate();
            }
          }
        }
      };
    }

    get input() {
      return (0, _utils.findAssignedElement)(this.slotEl, '*');
    }

    render() {
      return (0, _litElement.html)`
      <div class="mdc-form-field ${(0, _classMap.classMap)({
        'mdc-form-field--align-end': this.alignEnd
      })}">
        <slot></slot>
        <label class="mdc-label"
               @click="${this._labelClick}">${this.label}</label>
      </div>`;
    }

    _labelClick() {
      const input = this.input;

      if (input) {
        input.focus();
        input.click();
      }
    }

  }

  _exports.FormfieldBase = FormfieldBase;
  (0, _tslibEs.__decorate)([(0, _litElement.property)({
    type: Boolean
  })], FormfieldBase.prototype, "alignEnd", void 0);
  (0, _tslibEs.__decorate)([(0, _litElement.property)({
    type: String
  }), (0, _observer.observer)(async function (label) {
    const input = this.input;

    if (input) {
      if (input.localName === 'input') {
        input.setAttribute('aria-label', label);
      } else if (input instanceof _formElement.FormElement) {
        await input.updateComplete;
        input.setAriaLabel(label);
      }
    }
  })], FormfieldBase.prototype, "label", void 0);
  (0, _tslibEs.__decorate)([(0, _litElement.query)('.mdc-form-field')], FormfieldBase.prototype, "mdcRoot", void 0);
  (0, _tslibEs.__decorate)([(0, _litElement.query)('slot')], FormfieldBase.prototype, "slotEl", void 0);
  (0, _tslibEs.__decorate)([(0, _litElement.query)('label')], FormfieldBase.prototype, "labelEl", void 0);
});