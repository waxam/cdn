define(["exports","../../../simple-colors/simple-colors.js","./haxcms-site-store.js","../../../../mobx/lib/mobx.module.js","../../../../@polymer/polymer/lib/utils/async.js","../../../../@polymer/polymer/lib/legacy/polymer.dom.js","../../../../@polymer/polymer/lib/utils/render-status.js","../../../../@polymer/polymer/lib/mixins/element-mixin.js"],function(_exports,_simpleColors,_haxcmsSiteStore,_mobxModule,_async,_polymerDom,_renderStatus,_elementMixin){"use strict";Object.defineProperty(_exports,"__esModule",{value:!0});_exports.HAXCMSThemeWiring=_exports.HAXCMSTheme=void 0;/**
 * Copyright 2019 The Pennsylvania State University
 * @license Apache-2.0, see License.md for full text.
 */ /**
 * `HAXCMSTheme` mixin class to automatically apply HAXcms theme state
 * Typically an element will be extended from this and while not all,
 * many will want to customize the `contentContainer` property in order
 * to ensure the editable layer is correctly applied visually.
 */const HAXCMSTheme=function(SuperClass){return class extends SuperClass{// leverage the wiring class element; this helps us clean things up smoothly later
// while still keeping it abstract enough for direct usage in PolymerLegacy elements
// as well as those wanting a custom integration methodology
constructor(){super();this.__disposer=[];this.HAXCMSThemeWiring=new HAXCMSThemeWiring(this)}/**
     * This is a render function example. All new HAXcms capable themes need
     * to define a contentcontainer and a slot id wrapper. this allows HAXcms
     * to correctly target the area that will display the HAXeditor when in
     * edit-mode and correctly hide the editor when in normal content presentation.
     * static get template() {
     *  return html`
     *  <style>
     *   :host {
     *     display: block;
     *     background-color: var(--haxcms-color, white);
     *   }
     *   :host([edit-mode]) #slot {
     *     display: none;
     *   }
     *  </style>
     *  <div id="contentcontainer">
     *    <div id="slot"><slot></slot></div>
     *  </div>`;
     *  }
     */static get properties(){return{/**
         * Class for the color
         */hexColor:{type:String,computed:"_getHexColor(color)"},/**
         * Color class work to apply
         */color:{type:String,reflectToAttribute:!0},/**
         * editting state for the page
         */editMode:{type:Boolean,reflectToAttribute:!0,notify:!0,value:!1,observer:"_editModeChanged"},/**
         * DOM node that wraps the slot
         */contentContainer:{type:Object,notify:!0,value:null,observer:"_contentContainerChanged"},/**
         * location as object
         */_location:{type:Object,observer:"_locationChanged"}}}/**
     * Convert color name to HEX
     */_getHexColor(color){// legacy support for materializeCSS names
let name=color.replace("-text",""),tmp=new _simpleColors.SimpleColors;if(tmp.colors[name]){return tmp.colors[name][6]}return"#000000"}/**
     * notice edit changed, make sure we fake a resize because of that container flyout
     */_editModeChanged(newValue,oldValue){if(typeof oldValue!==typeof void 0){// ensure global is kept in sync
_haxcmsSiteStore.store.editMode=newValue;_async.microTask.run(()=>{// trick browser into thinking we just reized
window.dispatchEvent(new Event("resize"));// forcibly update styles via css variables
(0,_elementMixin.updateStyles)()})}}/**
     * private: Notice content container has changed
     */_contentContainerChanged(newValue,oldValue){// test that this hasn't been connected previously
setTimeout(()=>{if(newValue&&null==oldValue){this.HAXCMSThemeWiring.connect(this,newValue)}// previously connected, needs to change to new connection
// this is an edge case at best...
else if(newValue&&oldValue){this.HAXCMSThemeWiring.disconnect(this);this.HAXCMSThemeWiring.connect(this,newValue)}// no longer connected
else if(oldValue&&null==newValue){this.HAXCMSThemeWiring.disconnect(this)}},500)}_locationChanged(newValue,oldValue){if(!newValue||"undefined"===typeof newValue.route)return;const location=newValue,name=location.route.name;if("home"===name||"404"===name){// if we are on the homepage then load the first item in the manifest
// and set it active
const firstItem=_haxcmsSiteStore.store.routerManifest.items.find(i=>"undefined"!==typeof i.id);if(firstItem){_haxcmsSiteStore.store.activeId=firstItem.id}}}/**
     * Connect state and theme wiring
     */connectedCallback(){super.connectedCallback();// we don't have a content container, establish one
if(null===this.contentContainer){this.contentContainer=this.shadowRoot.querySelector("#contentcontainer")}(0,_renderStatus.afterNextRender)(this,function(){// edge case, we just swapped theme faster then content loaded... lol
setTimeout(()=>{if(0===(0,_polymerDom.dom)(this).getEffectiveChildNodes().length){let frag=document.createRange().createContextualFragment(_haxcmsSiteStore.store.activeItemContent);(0,_polymerDom.dom)(this).appendChild(frag)}},50);(0,_elementMixin.updateStyles)();// keep editMode in sync globally
(0,_mobxModule.autorun)(reaction=>{this.editMode=(0,_mobxModule.toJS)(_haxcmsSiteStore.store.editMode);this.__disposer.push(reaction)});// store disposer so we can clean up later
(0,_mobxModule.autorun)(reaction=>{const __routerManifest=(0,_mobxModule.toJS)(_haxcmsSiteStore.store.routerManifest);if(typeof __routerManifest.title!==typeof void 0){document.title=__routerManifest.title}if(typeof __routerManifest.metadata!==typeof void 0&&typeof __routerManifest.metadata.cssVariable!==typeof void 0){// json outline schema changed, allow other things to react
// fake way of forcing an update of these items
let ary=__routerManifest.metadata.cssVariable.replace("--simple-colors-default-theme-","").split("-");ary.pop();// simple colors "accent color" property
this.accentColor=ary.join("-");// set this directly instead of messing w/ accentColor
document.body.style.setProperty("--haxcms-color",__routerManifest.metadata.hexCode)}this.__disposer.push(reaction)});(0,_mobxModule.autorun)(reaction=>{this._location=_haxcmsSiteStore.store.location;this.__disposer.push(reaction)})})}/**
     * Disconnect the wiring for the theme and clean up state
     */disconnectedCallback(){super.disconnectedCallback();// remove our content container var which will disconnect the wiring
delete this.contentContainer;// clean up state
for(var i in this.__disposer){this.__disposer[i].dispose()}}/**
     * Correctly reset state and dispatch event to notify of active item change
     */resetActive(){window.history.pushState(null,null,_haxcmsSiteStore.store.location.baseUrl);window.dispatchEvent(new PopStateEvent("popstate"));this.dispatchEvent(new CustomEvent("haxcms-active-item-changed",{bubbles:!0,composed:!0,cancelable:!0,detail:{}}))}}};/**
 * `HAXCMSThemeWiring` streamline hooking themes up to HAXCMS
 * Directly invoking this class is not advised unless
 * the mixin class `HAXCMSTheme` integration needs modified beyond the norm
 */_exports.HAXCMSTheme=HAXCMSTheme;class HAXCMSThemeWiring{constructor(element,load=!0){if(load){window.addEventListener("haxcms-edit-mode-changed",this._globalEditChanged.bind(element));window.addEventListener("haxcms-active-item-changed",this._activeItemUpdate.bind(element));window.addEventListener("haxcms-trigger-update",this._triggerUpdate.bind(element));// @todo may want to set this to sessionStorage instead...
if(null==window.localStorage.getItem("HAXCMSSystemData")){window.localStorage.setItem("HAXCMSSystemData",JSON.stringify({}))}}}/**
   * connect the theme and see if we have an authoring experience to inject correctly
   */connect(element,injector){// this implies there's the possibility of an authoring experience
_haxcmsSiteStore.store.cmsSiteEditorAvailability(element,injector)}/**
   * detatch element events from whats passed in
   */disconnect(element){window.removeEventListener("haxcms-active-item-changed",this._activeItemUpdate.bind(element));window.removeEventListener("haxcms-edit-mode-changed",this._globalEditChanged.bind(element));window.removeEventListener("haxcms-trigger-update",this._triggerUpdate.bind(element))}/**
   * Global edit state changed
   */_globalEditChanged(e){this.editMode=e.detail}/**
   * HAXcms: Active item has been updated
   */_activeItemUpdate(e){let newValue=e.detail;if(newValue&&typeof newValue.id!==typeof void 0){// dispatch to the store
_haxcmsSiteStore.store.activeId=newValue.id;// dispatch to everything else caring
const evt=new CustomEvent("json-outline-schema-active-item-changed",{bubbles:!0,composed:!0,cancelable:!0,detail:newValue});this.dispatchEvent(evt);// update title as a simple nicity
if(typeof newValue.title!==typeof void 0){document.title=_haxcmsSiteStore.store.routerManifest.title+" - "+newValue.title}else{document.title=_haxcmsSiteStore.store.routerManifest.title}}else{document.title=_haxcmsSiteStore.store.routerManifest.title}}/**
   * Generic event to ensure that the active item change is noticed
   */_triggerUpdate(e){this.dispatchEvent(new CustomEvent("haxcms-active-item-changed",{bubbles:!0,composed:!0,cancelable:!0,detail:{}}))}}_exports.HAXCMSThemeWiring=HAXCMSThemeWiring});