define(["exports","meta","../../../@polymer/polymer/polymer-element.js","../../../@polymer/polymer/lib/utils/render-status.js","../../../@polymer/polymer/lib/utils/resolve-url.js","../../circle-progress/circle-progress.js","../../../@polymer/paper-button/paper-button.js","../../../@polymer/paper-tooltip/paper-tooltip.js","../../../@polymer/paper-styles/paper-styles.js","../../../@polymer/paper-spinner/paper-spinner.js","../../../@polymer/neon-animation/neon-animation.js","../../../@polymer/iron-icons/iron-icons.js"],function(_exports,meta,_polymerElement,_renderStatus,_resolveUrl,_circleProgress,_paperButton,_paperTooltip,_paperStyles,_paperSpinner,_neonAnimation,_ironIcons){"use strict";Object.defineProperty(_exports,"__esModule",{value:!0});_exports.LrnsysProgressCircle=void 0;meta=babelHelpers.interopRequireWildcard(meta);/**
 * Copyright 2018 The Pennsylvania State University
 * @license Apache-2.0, see License.md for full text.
 */ /**
 * `lrnsys-progress-circle`
 * `circle that the outline grows as the percentage ticks up`
 *
 */class LrnsysProgressCircle extends _polymerElement.PolymerElement{static get template(){return _polymerElement.html`
      <custom-style>
        <style is="custom-style" include="paper-material-styles">
          :host {
            --paper-button-ink-color: var(
              --lrnsys-progress-color,
              var(--paper-green-500)
            );
            display: block;
            transition: box-shadow
                var(--lrnsys-progress-circle-transition, 0.5s) linear,
              color var(--lrnsys-progress-circle-transition, 0.5s) ease-in-out,
              background-color var(--lrnsys-progress-circle-transition, 0.5s)
                ease-in-out;
          }
          :host([status="complete"]) .circle-wrapper {
            --paper-button-ink-color: var(
              --lrnsys-progress-complete-color,
              var(--paper-green-500)
            );
            box-shadow: 0px 0px 0px 0.16px
              var(--lrnsys-progress-complete-color, var(--paper-green-900));
          }
          :host([status="disabled"]) .circle-wrapper {
            box-shadow: none;
          }
          :host([status="available"]) .circle-wrapper {
            box-shadow: none;
          }
          :host([active]) .circle-wrapper {
            box-shadow: 0px 0px 0px 0.16px var(--google-grey-500, #555555);
          }
          .circle-wrapper {
            border-radius: 100%;
          }
          .button {
            margin: 0;
            padding: 0;
            display: flex;
            min-width: 40px;
            border-radius: 100%;
          }
          paper-button {
            width: var(--lrnsys-progress-circle-size, 40px);
            height: var(--lrnsys-progress-circle-size, 40px);
          }
          circle-progress {
            margin: 0;
            --circle-progress-width: var(--lrnsys-progress-circle-size, 40px);
            --circle-progress-height: var(--lrnsys-progress-circle-size, 40px);
            --circle-progress-stroke-color: var(
              --lrnsys-progress-color,
              var(--paper-green-500)
            );
            --circle-progress-bg-stroke-color: var(
              --lrnsys-progress-container-color,
              var(--google-grey-300)
            );
            --circle-progress-transition: 0.5s;
            --circle-progress-stroke-linecap: square;
            transition: color 0.5s ease-in-out,
              background-color 0.5s ease-in-out;
          }
          paper-spinner {
            display: block;
            font-size: 16px;
            width: var(--lrnsys-progress-spinner-size, 32px);
            height: var(--lrnsys-progress-spinner-size, 32px);
            position: absolute;
            z-index: 1;
            margin: 4px;
            padding: 0;
            visibility: visible;
            opacity: 1;
            transition: visibility 0.4s, opacity 0.4s ease;
          }
          paper-spinner.multi {
            --paper-spinner-layer-1-color: var(--paper-purple-500);
            --paper-spinner-layer-2-color: var(--paper-cyan-500);
            --paper-spinner-layer-3-color: var(--paper-blue-grey-500);
            --paper-spinner-layer-4-color: var(--paper-amber-500);
          }
          .transition {
            opacity: 0.4;
            width: calc(var(--lrnsys-progress-icon-size, 24px) - 8px);
            height: calc(var(--lrnsys-progress-icon-size, 24px) - 8px);
          }
          iron-icon {
            visibility: visible;
            opacity: 1;
            transition: width 0.1s linear, height 0.1s linear,
              visibility 0.4s ease, opacity 0.4s ease;
            width: var(--lrnsys-progress-icon-size, 24px);
            height: var(--lrnsys-progress-icon-size, 24px);
          }
          .disabled {
            background-color: var(
              --lrnsys-progress-disabled-color,
              var(--google-grey-500)
            );
            color: white;
          }
          .loading {
            background-color: white;
            color: black;
          }
          .finished iron-icon:not(.activeIcon) {
            width: calc(var(--lrnsys-progress-icon-size, 24px) - 8px);
            height: calc(var(--lrnsys-progress-icon-size, 24px) - 8px);
          }
          .available {
            background-color: var(
              --lrnsys-progress-active-color,
              var(--google-grey-300)
            );
            color: var(
              --lrnsys-progress-active-text-color,
              var(--google-grey-500)
            );
          }
          .activeIcon {
            color: black;
          }
          .complete .activeIcon {
            color: white;
          }
          :host([active]) .complete .activeIcon,
          :host([active]) .finished .activeIcon {
            color: black;
          }
          .complete,
          .finished {
            background-color: var(
              --lrnsys-progress-container-color,
              var(--paper-green-500)
            );
            color: white;
          }
          :host([active]) circle-progress {
            background-color: white;
            color: black;
          }
          .listview-title {
            font-size: 16px;
            padding: 0;
            margin: 0;
          }
          .description-content {
            font-size: 8px;
            font-style: italic;
          }
          .circle-wrapper {
            display: inline-block;
          }
          .listview {
            height: 32px;
            padding: 4px 0;
            margin: 0;
            vertical-align: top;
          }
          .link {
            height: 40px;
            width: 100%;
          }
          :host([list-view]) .button {
            margin: 0;
            padding: 0;
            display: block;
            min-width: 40px;
            border-radius: 0;
          }
        </style>
      </custom-style>
      <paper-tooltip
        hidden$="[[!toolTip]]"
        for="button"
        position="bottom"
        offset="8"
        animation-delay="0"
      >
        [[label]]
      </paper-tooltip>
      <paper-button
        id="button"
        class="button"
        disabled$="[[disabled]]"
        title="[[label]]"
      >
        <span class="circle-wrapper">
          <paper-spinner
            active$="[[loading]]"
            hidden$="[[!loading]]"
            class="multi"
            alt$="Loading content for [[label]]"
          ></paper-spinner>
          <circle-progress
            class$="[[status]]"
            value="[[value]]"
            max="[[max]]"
            stroke-width="[[strokeWidth]]"
            angle="180"
          >
            <iron-icon
              id="icon"
              icon="[[activeIcon]]"
              hidden$="[[!activeIcon]]"
            ></iron-icon>
            <slot name="image"></slot>
          </circle-progress>
        </span>
        <span hidden$="[[!listView]]" id="listview" class="listview">
          <h3 class="listview-title">[[label]]</h3>
          <div class="description-content">
            <slot name="description"></slot> <slot></slot>
          </div>
        </span>
      </paper-button>
    `}static get tag(){return"lrnsys-progress-circle"}static get properties(){return{/**
       * Current value.
       */value:{type:Number,value:0,notify:!0,reflectToAttribute:!0,observer:"_testValueComplete"},/**
       * Whether to add a tooltip on hover.
       */toolTip:{type:Boolean,value:!0,reflectToAttribute:!0},/**
       * If this is in a list view, expand the output.
       */listView:{type:Boolean,value:!0,reflectToAttribute:!0},/**
       * Icon.
       */icon:{type:String,value:"icons:description",reflectToAttribute:!0},/**
       * Special icon to use when the item has been completed.
       */iconComplete:{type:String,value:"icons:description",reflectToAttribute:!0},/**
       * Loading icon
       */loadingIcon:{type:String,value:"hourglass-full",reflectToAttribute:!0},/**
       * Finished icon
       */finishedIcon:{type:String,value:"thumb-up",reflectToAttribute:!0},/**
       * Current value.
       */activeIcon:{type:String,notify:!0,computed:"_getActiveIcon(icon, iconComplete, status)"},/**
       * Array position within a larger body of items.
       */step:{type:Number,value:0,reflectToAttribute:!0},/**
       * If this item is active or not in the larger list
       */active:{type:Boolean,value:!1,reflectToAttribute:!0,notify:!0},/**
       * Status of the progression.
       * Possible values are disabled, loading, available, complete
       */status:{type:String,value:"available",reflectToAttribute:!0,notify:!0,observer:"_statusChange"},/**
       * Correctly disable the button if it's status is such.
       */disabled:{type:Boolean,computed:"_disableStatus(status)"},/**
       * Calculate if something is in a loading status which invokes a swirl.
       */loading:{type:Boolean,computed:"_loadingStatus(status)"},/**
       * Boolean to invoke "finished" state. Useful for the last circle
       * in a series.
       */finished:{type:Boolean,computed:"_finishedStatus(status)"},/**
       * Max progression for doing math against.
       */max:{type:String,reflectToAttribute:!0},/**
       * Internal property to ensure we only ding 1x
       */__chimed:{type:Boolean,value:!1},/**
       * Internal property to ensure we only finish 1x
       */__finishchimed:{type:Boolean,value:!1},/**
       * URL to link to on click.
       */url:{type:String,value:"#",reflectToAttribute:!0},/**
       * Data url to bubble up for more advanced implementations.
       */dataUrl:{type:String,value:!1,reflectToAttribute:!0},/**
       * Stroke width.
       */strokeWidth:{type:Number,value:4},/**
       * Tracks if focus state is applied for element consistency
       * when dealing with focus vs hover states.
       */focusState:{type:Boolean,value:!1},/**
       * Play sound status; if this should play sound
       * when it hits certain milestones or not.
       */playSound:{type:Boolean,value:!1,reflectToAttribute:!0},/**
       * Play sound at end; if this should play sound
       * when it hits certain milestones or not.
       */playFinishSound:{type:Boolean,value:!1,reflectToAttribute:!0},/**
       * Play sound on complete.
       */completeSound:{type:String,value:(0,_resolveUrl.pathFromUrl)(decodeURIComponent(meta.url))+"assets/complete.mp3",reflectToAttribute:!0},/**
       * Play sound on complete.
       */finishedSound:{type:String,value:(0,_resolveUrl.pathFromUrl)(decodeURIComponent(meta.url))+"assets/finished.mp3",reflectToAttribute:!0},/**
       * Fire and track milestones towards completion state.
       */_bubbleProgress:{type:Object,value:{25:!1,50:!1,75:!1}}}}/**
   * Ready state
   */ready(){super.ready();// seems odd but if we don't do this we can get issues with
// this field being unified across all circles when really
// we have to track this state per circle.
this._bubbleProgress={25:!1,50:!1,75:!1}}connectedCallback(){super.connectedCallback();(0,_renderStatus.afterNextRender)(this,function(){this.addEventListener("click",this.tapEventOn.bind(this));this.addEventListener("mouseover",this.focusOn.bind(this));this.addEventListener("mouseout",this.focusOff.bind(this));this.addEventListener("focused-changed",this.focusEvent.bind(this))})}disconnectedCallback(){this.removeEventListener("click",this.tapEventOn.bind(this));this.removeEventListener("mouseover",this.focusOn.bind(this));this.removeEventListener("mouseout",this.focusOff.bind(this));this.removeEventListener("focused-changed",this.focusEvent.bind(this));super.disconnectedCallback()}/**
   * Test if the value = max meaning that we hit complete from available
   */_testValueComplete(newValue,oldValue){// ensure we were previously available before marking complete
// this way we don't conflict with the finished state which can
// only be set from outside the circle as the circle doesn't
// know how many items are in the set
if(newValue>=this.max&&"available"==this.status){this.status="complete"}// add events for certain mile stones; this has to be in reverse order
// otherwise we could actuall be passing 75 but it was at 0. This allows
// for jumping ahead and not triggering 25/50/75 all at once and preventing
// over reported percentages upstream
else if(.75<=newValue/this.max&&!this._bubbleProgress[75]){this.dispatchEvent(new CustomEvent("node-percent-milestone",{bubbles:!0,cancelable:!0,composed:!0,detail:{percentage:75}}));this._bubbleProgress[75]=!0}else if(.5<=newValue/this.max&&!this._bubbleProgress[50]){this.dispatchEvent(new CustomEvent("node-percent-milestone",{bubbles:!0,cancelable:!0,composed:!0,detail:{percentage:50}}));this._bubbleProgress[50]=!0}else if(.25<=newValue/this.max&&!this._bubbleProgress[25]){this.dispatchEvent(new CustomEvent("node-percent-milestone",{bubbles:!0,cancelable:!0,composed:!0,detail:{percentage:25}}));this._bubbleProgress[25]=!0}}/**
   * Focus event for UX consistency.
   */focusEvent(e){// see if it has hover classes
if(!this.disabled&&"loading"!=this.status){// focus shows focus
if(this.focusState){// force icon to be set to real one and class added
this.$.icon.icon=this.icon;this.$.icon.classList.add("activeIcon")}else{// if complete set it back to what it was
if("complete"==this.status||"finished"==this.status){this.$.icon.icon=this.activeIcon}// drop the class for active step
this.$.icon.classList.remove("activeIcon")}this.focusState=!this.focusState}}/**
   * Focus event for UX consistency.
   */focusOn(e){// see if it has hover classes
if(!this.disabled&&"loading"!=this.status){// force icon to be set to real one and class added
this.$.icon.icon=this.icon;this.$.icon.classList.add("activeIcon")}}/**
   * Focus event for UX consistency.
   */focusOff(e){// see if it has hover classes
if(!this.disabled&&"loading"!=this.status){// if complete set it back to what it was
if("complete"==this.status||"finished"==this.status){this.$.icon.icon=this.activeIcon}// drop the class for active step
this.$.icon.classList.remove("activeIcon")}}/**
   * Tapped on the item.
   */tapEventOn(e){let target=e.target;this.dispatchEvent(new CustomEvent("node-is-active",{bubbles:!0,cancelable:!0,composed:!0,detail:{target}}))}/**
   * Calculate which icon to present.
   */_getActiveIcon(icon,iconComplete,status){if(typeof icon!==typeof void 0){var tmp=icon;// support for a loading icon while loading
if("loading"==status){tmp=this.loadingIcon;this.$.icon.classList.add("transition")}else if("finished"==status){tmp=this.finishedIcon}else if("complete"==status&&typeof iconComplete!==typeof void 0){if(this.playSound&&!this.__chimed){this._playSound()}tmp=iconComplete}else{this.$.icon.classList.remove("transition")}return tmp}return!1}/**
   * Play the sound effect.
   */_playSound(){// calculate sound to use and ensure it only ever happens once
// via the __chimed flag
if("complete"==this.status){window.audio=new Audio(this.completeSound);this.__chimed=!0}else if("finished"==this.status){window.audio=new Audio(this.finishedSound);this.__finishchimed=!0}else{// shouldn't be possible
window.audio=new Audio}window.audio.play()}/**
   * Calculate loading based on the status of the item.
   */_loadingStatus(status){if("loading"==status){return!0}return!1}/**
   * Calculate loading based on the status of the item.
   */_finishedStatus(status){if("finished"==status){if(this.playFinishSound&&!this.__finishchimed){this._playSound()}return!0}return!1}/**
   * Notice when state changes to fire up an event for others to respond to.
   */_statusChange(newValue,oldValue){// verify this isn't loading up
if(typeof oldValue!==typeof void 0&&newValue!==oldValue){this.dispatchEvent(new CustomEvent("node-status-change",{bubbles:!0,cancelable:!0,composed:!0,detail:{status:newValue}}))}}/**
   * Calculate disable based on the status of the item.
   */_disableStatus(status){if("disabled"==status){return!0}return!1}}_exports.LrnsysProgressCircle=LrnsysProgressCircle;window.customElements.define(LrnsysProgressCircle.tag,LrnsysProgressCircle)});