define(["exports","meta","require","../../../@polymer/polymer/polymer-element.js","../../../@polymer/polymer/lib/utils/render-status.js","../../../@polymer/polymer/lib/legacy/polymer.dom.js","../../../@polymer/polymer/lib/utils/resolve-url.js","../../../@polymer/polymer/lib/utils/settings.js","./shadows-safari.js","./haxutils.js","../../../@polymer/iron-ajax/iron-ajax.js","../../simple-toast/simple-toast.js","../../media-behaviors/media-behaviors.js","../../hax-body-behaviors/hax-body-behaviors.js","../../code-sample/code-sample.js"],function(_exports,meta,_require,_polymerElement,_renderStatus,_polymerDom,_resolveUrl,_settings,_shadowsSafari,_haxutils,_ironAjax,_simpleToast,_mediaBehaviors,_haxBodyBehaviors,_codeSample){"use strict";Object.defineProperty(_exports,"__esModule",{value:!0});_exports.HaxStore=void 0;meta=babelHelpers.interopRequireWildcard(meta);_require=babelHelpers.interopRequireWildcard(_require);class HaxStore extends(0,_haxBodyBehaviors.HAXElement)((0,_mediaBehaviors.MediaBehaviorsVideo)(_polymerElement.PolymerElement)){static get template(){return _polymerElement.html`
      <style>
        :host {
          display: none;
        }
      </style>
      <slot></slot>
      <iron-ajax
        id="appstore"
        url="[[appStore.url]]"
        params="[[appStore.params]]"
        method="GET"
        content-type="application/json"
        handle-as="json"
        last-response="{{__appStoreData}}"
      ></iron-ajax>
      <hal-9000 id="hal" debug="debug" commands="[[voiceCommands]]"></hal-9000>
    `}static get tag(){return"hax-store"}/**
   * Complex observer composites used for initial timing since this is a skeleton setup
   */static get observers(){return["_loadAppStoreData(__ready, __appStoreData, haxAutoloader)","_storePiecesAllHere(haxAutoloader,activeHaxBody, haxPanel, haxToast, haxExport, haxPreferences, haxManager, haxStaxPicker, haxAppPicker)"]}static get properties(){return Object.assign({/**
         * skipHAXConfirmation
         */skipHAXConfirmation:{type:Boolean,value:!1,reflectToAttribute:!0},/**
         * Local storage bridge
         */storageData:{type:Object,value:{},observer:"_storageDataChanged"},/**
         * Hax app picker element.
         */haxAppPicker:{type:Object},/**
         * Hax stax picker element.
         */haxStaxPicker:{type:Object},/**
         * Hax manager element.
         */haxManager:{type:Object},/**
         * Hax autoloader element.
         */haxAutoloader:{type:Object},/**
         * A list of all haxBodies that exist
         */haxBodies:{type:Array,value:[]},/**
         * An active place holder item reference. This is used
         * for inline drag and drop event detection so that we
         * know what element replace in context.
         */activePlaceHolder:{type:Object,value:null},/**
         * The hax-body that is currently active.
         */activeHaxBody:{type:Object},/**
         * Possible appStore endpoint for loading in things dynamically.
         */appStore:{type:Object,observer:"_appStoreChanged"},/**
         * HAX Toast message.
         */haxToast:{type:Object},/**
         * Hax panel element.
         */haxPanel:{type:Object},/**
         * Hax export dialog element.
         */haxExport:{type:Object},/**
         * Hax preferences dialog element.
         */haxPreferences:{type:Object},/**
         * Active HAX Element if we have one we are working on.
         */activeHaxElement:{type:Object},/**
         * Active Node.
         */activeNode:{type:Object},/**
         * Active container Node, 2nd highest parent of activeNode.
         */activeContainerNode:{type:Object},/**
         * Session object bridged in from a session method of some kind
         */sessionObject:{type:Object,value:{}},/**
         * editMode
         */editMode:{type:Boolean,value:!1,observer:"_editModeChanged"},/**
         * Boolean for if this instance has backends that support uploading
         */canSupportUploads:{type:Boolean,value:!1},/**
         * skip the exit trap to prevent losing data
         */skipExitTrap:{type:Boolean,value:!1},/**
         * Default settings that can be overridden as needed
         */defaults:{type:Object,value:{image:{src:"stock.jpg",alt:"A beachfront deep in the heart of Alaska."},iframe:{src:"https://www.wikipedia.org/"}}},/**
         * Available gizmos.
         */gizmoList:{type:Array,value:[]},/**
         * Available elements keyed by tagName and with
         * their haxProperties centrally registered.
         */elementList:{type:Object,value:{}},/**
         * Available apps of things supplying media / content.
         */appList:{type:Array,value:[]},/**
         * Available hax stax which are just re-usable templates
         */staxList:{type:Array,value:[]},/**
         * Available hax blox which are grid plate / layout elements
         */bloxList:{type:Array,value:[]},/**
         * Global preferences that HAX can write to and
         * other elements can use to go off of.
         */globalPreferences:{type:Object,value:{},observer:"_globalPreferencesChanged"},/**
         * Globally active app, used for brokering communications
         */activeApp:{type:Object,value:{}},/**
         * Valid tag list, tag only and including primatives for a baseline.
         */validTagList:{type:Array,value:["p","div","span","table","sup","sub","u","strike","tr","td","ol","ul","li","a","strong","kbd","em","i","b","hr","h1","h2","h3","h4","h5","h6","blockquote","code","figure","img","iframe","video","audio","section","grid-plate","template","webview"]},/**
         * Gizmo types which can be used to bridge apps to gizmos.
         */validGizmoTypes:{type:Array,value:["data","video","audio","text","link","file","pdf","image","csv","doc","content","text","inline","*"]},/**
         * Sandboxed environment test
         */_isSandboxed:{type:Boolean,value:function(){let test=document.createElement("webview");// if this function exists it means that our deploy target
// is in a sandboxed environment and is not able to run iframe
// content with any real stability. This is beyond edge case but
// as this is an incredibly useful tag we want to make sure it
// can mutate to work in chromium and android environments
// which support such sandboxing
if("function"===typeof test.reload){return!0}return!1}},/**
         * Internal app store data property after request
         */__appStoreData:{type:Object},__ready:{type:Boolean},voiceCommands:{type:Object},/**
         * Support for deploy specific rewriting for things like JWTs
         */connectionRewrites:{type:Object,value:{}}},super.properties)}/**
   * Local storage data changed; callback to store this data in user storage
   */_storageDataChanged(newValue){if(newValue&&window.HaxStore.ready&&this.__storageDataProcessed){if(window.localStorage.getItem("haxConfirm")){window.localStorage.setItem("haxUserData",JSON.stringify(newValue))}else if(window.sessionStorage.getItem("haxConfirm")){window.sessionStorage.setItem("haxUserData",JSON.stringify(newValue))}}}/**
   * If this is a text node or not so we know if the inline context
   * operations are valid.
   */isTextElement(node){if(null!=node&&this.validTagList.includes(node.tagName.toLowerCase())){if(["p","ol","ul","li","a","h1","h2","h3","h4","h5","h6","strike","u","b","sub","sup","span","i","bold","em","strong","blockquote","code","figure"].includes(node.tagName.toLowerCase())){return!0}}return!1}/**
   * test for being a valid grid plate, li is here because
   * nested lists make this really complicated
   */isGridPlateElement(node){let tag=node.tagName.toLowerCase();if(this.validTagList.includes(tag)){if(["p","ol","ul","li","div","h1","h2","h3","h4","h5","h6","blockquote","code","figure","grid-plate"].includes(tag)){return!0}}return!1}/**
   * Notice _appStore changed.
   */_appStoreChanged(newValue,oldValue){// if we have an endpoint defined, pull it
if(typeof newValue!==typeof void 0&&null!=newValue){// support having the request or remote loading
// depending on the integration type
if(typeof newValue.apps===typeof void 0){this.shadowRoot.querySelector("#appstore").generateRequest()}else{// directly injected json object into the DOM, allow some time to propagate data
// otherwise we might not have a haxAutoloader object ready in time for the paint
setTimeout(()=>{this.__appStoreData=newValue},500)}}}/**
   * Load and attach items from the app store.
   */_loadAppStoreData(ready,appDataResponse,haxAutoloader){if(ready&&typeof appDataResponse!==typeof void 0&&null!=appDataResponse){var items={};// autoload elements
if(typeof appDataResponse.autoloader!==typeof void 0){// ensure the list is in the right order so we can async dynamic imports
// regardless of if its an array or object of values in the right format
// force this to be an object
appDataResponse.autoloader=Object.assign({},appDataResponse.autoloader);for(var i in appDataResponse.autoloader){let CEname=i,CEimport=appDataResponse.autoloader[i];// helps support array or object based appstore
// array was originally in the standard so this lets us support both
if(!isNaN(CEname)){CEname=appDataResponse.autoloader[i];CEimport=`@lrnwebcomponents/${CEname}/${CEname}.js`}// force this into the valid tag list so early paints will
// correctly include the tag without filtering it out incorrectly
this.push("validTagList",CEname);items[CEname]=CEimport}}// load apps automatically
if(typeof appDataResponse.apps!==typeof void 0){for(var apps=appDataResponse.apps,i=0;i<apps.length;i++){let app=document.createElement("hax-app");app.data=apps[i];// see if anything coming across claims to be a backend for adding items
// and then enable the upload button
if(apps[i].connection.operations.add){window.HaxStore.write("canSupportUploads",!0,this)}window.HaxStore.instance.appendChild(app)}}// load in stax dynamically
if(typeof appDataResponse.stax!==typeof void 0){for(var staxs=appDataResponse.stax,i=0;i<staxs.length;i++){let stax=document.createElement("hax-stax");stax.data=staxs[i];window.HaxStore.instance.appendChild(stax)}}// load in blox dynamically
if(typeof appDataResponse.blox!==typeof void 0){for(var bloxs=appDataResponse.blox,i=0;i<bloxs.length;i++){let blox=document.createElement("hax-blox");blox.data=bloxs[i];window.HaxStore.instance.appendChild(blox)}}this.dispatchEvent(new CustomEvent("hax-store-app-store-loaded",{bubbles:!0,cancelable:!0,composed:!0,detail:!0}));// now process the dynamic imports
this._handleDynamicImports(items,haxAutoloader)}}/**
   * Handle all the dynamic imports of things told to autoload
   * This ensures we get the definitions very quickly as far as
   * what is a safe / valid tag above but then we import in a way
   * that allows us to correctly associate the hax schema to where
   * it came from.
   */async _handleDynamicImports(items,haxAutoloader){const basePath=(0,_resolveUrl.pathFromUrl)(decodeURIComponent(meta.url));for(var i in items){await new Promise((res,rej)=>_require.default([`${basePath}../../../${items[i]}`],res,rej)).then(response=>{for(var cVal in response){// get the custom element definition we used to add that file
let CEClass=response[cVal];if("function"===typeof CEClass.getHaxProperties){this.setHaxProperties(CEClass.getHaxProperties(),i)}else if("function"===typeof CEClass.HAXWiring){this.setHaxProperties(CEClass.HAXWiring.getHaxProperties(),i)}else if(CEClass.haxProperties){this.setHaxProperties(CEClass.haxProperties,i)}else{// this is the less optimized / legacy polymer element method to inlcude
// this item. It's a good reason to skip on this though because you'll
// have a faster boot up time with newer ES6 methods then previous ones.
(0,_polymerDom.dom)(haxAutoloader).appendChild(document.createElement(i))}}}).catch(error=>{/* Error handling */console.log(error)})}}_editModeChanged(newValue){if(newValue&&this.globalPreferences.haxVoiceCommands){this.shadowRoot.querySelector("#hal").auto=!0}else{this.shadowRoot.querySelector("#hal").auto=!1}}_globalPreferencesChanged(newValue,oldValue){// regardless of what it is, reflect it globally but only after setup
if(this.__storageDataProcessed&&newValue&&typeof newValue.haxVoiceCommands!==typeof void 0&&window.HaxStore.ready){let storageData=this.storageData;storageData.globalPreferences=newValue;this.set("storageData",{});this.set("storageData",storageData);if(newValue.haxVoiceCommands&&this.editMode){this.shadowRoot.querySelector("#hal").auto=!0}else{this.shadowRoot.querySelector("#hal").auto=!1}}}/**
   * Detached life cycle
   */disconnectedCallback(){// notice hax property definitions coming from anywhere
window.removeEventListener("hax-register-properties",this._haxStoreRegisterProperties.bind(this));// app registration can come in automatically from app-stores
// or through direct definition in the DOM
document.body.removeEventListener("hax-register-app",this._haxStoreRegisterApp.bind(this));// register stax which are groupings of haxElements
document.body.removeEventListener("hax-register-stax",this._haxStoreRegisterStax.bind(this));// register blox which are grid plate configurations
// with lots of sane visual defaults
document.body.removeEventListener("hax-register-blox",this._haxStoreRegisterBlox.bind(this));// register the pieces of the body of what we call HAX
// think of this like the core of the system required
// to do anything like have buttons or state management
// write data to the store
document.body.removeEventListener("hax-store-write",this._writeHaxStore.bind(this));// register the manager panel / modal
document.body.removeEventListener("hax-register-manager",this._haxStoreRegisterManager.bind(this));// register the autoloader area for elements
document.body.removeEventListener("hax-register-autoloader",this._haxStoreRegisterAutoloader.bind(this));// register a body, kind of a big deal
document.body.removeEventListener("hax-register-body",this._haxStoreRegisterBody.bind(this));// register the interaction panel / menu
document.body.removeEventListener("hax-register-panel",this._haxStoreRegisterPanel.bind(this));// register the app picker for contextual setting / option
document.body.removeEventListener("hax-register-app-picker",this._haxStoreRegisterAppPicker.bind(this));// stax modal
document.body.removeEventListener("hax-register-stax-picker",this._haxStoreRegisterStaxPicker.bind(this));// blox modal
document.body.removeEventListener("hax-register-blox-picker",this._haxStoreRegisterBloxPicker.bind(this));// preferences modal
document.body.removeEventListener("hax-register-preferences",this._haxStoreRegisterPreferences.bind(this));// export modal
document.body.removeEventListener("hax-register-export",this._haxStoreRegisterExport.bind(this));// notice content insert and help it along to the body
document.body.removeEventListener("hax-insert-content",this._haxStoreInsertContent.bind(this));// grid plate add item event
document.body.removeEventListener("grid-plate-add-item",this.haxInsertAnything.bind(this));document.body.removeEventListener("hax-insert-content-array",this._haxStoreInsertMultiple.bind(this));window.removeEventListener("hax-add-voice-command",this._addVoiceCommand.bind(this));// capture events and intercept them globally
window.removeEventListener("onbeforeunload",this._onBeforeUnload.bind(this));window.removeEventListener("hax-consent-tap",this._haxConsentTap.bind(this));window.removeEventListener("paste",this._onPaste.bind(this));// send that hax store is ready to go so now we can setup the rest
this.dispatchEvent(new CustomEvent("hax-store-ready",{bubbles:!0,cancelable:!1,composed:!0,detail:!1}));window.HaxStore.ready=!1;super.disconnectedCallback()}/**
   * This only send if they consented to storage of data locally
   */_haxConsentTap(e){// store for future local storage usage
window.localStorage.setItem("haxConfirm",!0);// most likely nothing but set it anyway
window.localStorage.setItem("haxUserData",JSON.stringify(this.storageData))}/**
   * ready life cycle
   */ready(){super.ready();(0,_renderStatus.afterNextRender)(this,function(){// see if a global was used to prevent this check
// this is useful when in trusted environments where the statement
// has been consented to in the application this is utilized in
if(this.skipHAXConfirmation){window.sessionStorage.setItem("haxConfirm",!0);window.localStorage.setItem("haxConfirm",!0)}// check for local storage object
// if not, then store it in sessionStorage so that all our checks
// and balances are the same. This could allow for storing these
// settings on a server in theory
let haxConfirm=window.sessionStorage.getItem("haxConfirm")||window.localStorage.getItem("haxConfirm");if(!haxConfirm){// this way it isn't shown EVERY reload, but if they didn't confirm
// it will show up in the future
window.sessionStorage.setItem("haxConfirm",!0);let msg=`
      The HAX content editor keeps preferences in order to improve your experience.
      This data is stored in your browser and is never sent anywhere.
      Click to accept.
      `;window.HaxStore.toast(msg,"-1","fit-bottom","I Accept","hax-consent-tap")}else{if(window.sessionStorage.getItem("haxConfirm")&&!window.localStorage.getItem("haxConfirm")){// verify there is something there
try{let globalData=window.sessionStorage.getItem("haxUserData")?JSON.parse(window.sessionStorage.getItem("haxUserData")):{};this.set("storageData",globalData)}catch(e){}}else{try{let globalData=window.localStorage.getItem("haxUserData")?JSON.parse(window.localStorage.getItem("haxUserData")):{};this.set("storageData",globalData)}catch(e){}}}})}/**
   * attached.
   */connectedCallback(){super.connectedCallback();(0,_renderStatus.afterNextRender)(this,function(){// capture events and intercept them globally
window.addEventListener("hax-consent-tap",this._haxConsentTap.bind(this));window.addEventListener("onbeforeunload",this._onBeforeUnload.bind(this));window.addEventListener("paste",this._onPaste.bind(this));// import voice command stuff in the background
// @todo only activate if the setting to use it is in place
new Promise((res,rej)=>_require.default(["../../hal-9000/hal-9000.js"],res,rej));// set this global flag so we know it's safe to start trusting data
// that is written to global preferences / storage bin
setTimeout(()=>{this.__storageDataProcessed=!0;if(this.storageData.globalPreferences){window.HaxStore.write("globalPreferences",this.storageData.globalPreferences,this)}},325)})}_storePiecesAllHere(haxAutoloader,activeHaxBody,haxPanel,haxToast,haxExport,haxPreferences,haxManager,haxStaxPicker,haxAppPicker){if(!this.__ready&&activeHaxBody&&haxAutoloader&&haxPanel&&haxToast&&haxExport&&haxPreferences&&haxManager&&haxStaxPicker&&haxAppPicker){// send that hax store is ready to go so now we can setup the rest
this.dispatchEvent(new CustomEvent("hax-store-ready",{bubbles:!0,cancelable:!1,composed:!0,detail:!0}));window.HaxStore.ready=!0;this.__ready=!0;// register built in primitive definitions
this._buildPrimitiveDefinitions();// initialize voice commands
this.voiceCommands=this._initVoiceCommands()}}/**
   * Build a list of common voice commands
   */_initVoiceCommands(){var commands={};commands[`${this.shadowRoot.querySelector("#hal").respondsTo} scroll up`]=()=>{window.scrollBy({top:-(.5*window.innerHeight),left:0,behavior:"smooth"})};commands[`${this.shadowRoot.querySelector("#hal").respondsTo} scroll (down)`]=()=>{window.scrollBy({top:.5*window.innerHeight,left:0,behavior:"smooth"})};commands[`hey ${this.shadowRoot.querySelector("#hal").respondsTo}`]=()=>{this.shadowRoot.querySelector("#hal").speak("Yeah what do you want")};commands[`${this.shadowRoot.querySelector("#hal").respondsTo} find media`]=()=>{window.HaxStore.write("activeHaxElement",{},window.HaxStore.instance);window.HaxStore.instance.haxManager.resetManager(1);window.HaxStore.instance.haxManager.toggleDialog(!1)};return commands}/**
   * allow uniform method of adding voice commands
   */addVoiceCommand(command){this.push("voiceCommands",command);this.notifyPath("voiceCommands.*")}/**
   * event driven version
   */_addVoiceCommand(e){this.addVoiceCommand(e.detail)}/**
   * Before the browser closes / changes paths, ask if they are sure they want to leave
   */_onBeforeUnload(e){// ensure we don't leave DURING edit mode
if(!window.HaxStore.instance.skipExitTrap&&window.HaxStore.instance.editMode){return"Are you sure you want to leave? Your work will not be saved!"}}/**
   * Intercept paste event and clean it up before inserting the contents
   */_onPaste(e){// only perform this on a text element that is active
if(window.HaxStore.instance.isTextElement(window.HaxStore.instance.activeNode)&&!window.HaxStore.instance.haxManager.opened){e.preventDefault();e.stopPropagation();e.stopImmediatePropagation();let pasteContent="";// intercept paste event
if(e.clipboardData||e.originalEvent.clipboardData){pasteContent=(e.originalEvent||e).clipboardData.getData("text/html");// trap for partial content / pure text based
if(""==pasteContent){pasteContent="<span>"+(e.originalEvent||e).clipboardData.getData("text/plain")+"</span>"}}else if(window.clipboardData){pasteContent=window.clipboardData.getData("Text")}// edges that some things preserve empty white space needlessly
pasteContent=pasteContent.replace(/<span> <\/span>/g," ");pasteContent=pasteContent.replace(/<span><\/span>/g,"");let haxElements=window.HaxStore.htmlToHaxElements((0,_haxutils.stripMSWord)(pasteContent));// stupid but we need to reverse these
haxElements.reverse();let newContent="";for(var i in haxElements){// special traps for word / other styles bleeding through
delete haxElements[i].properties.style;delete haxElements[i].properties.start;delete haxElements[i].properties.align;// this is not the right function.
let node=window.HaxStore.haxElementToNode(haxElements[i].tag,haxElements[i].content.replace(/<span>&nbsp;<\/span>/g," ").trim(),haxElements[i].properties);newContent+=window.HaxStore.nodeToContent(node)}try{// get the range that's active and selection
let range=window.HaxStore.getRange(),sel=window.HaxStore.getSelection(),newNodes=document.createElement("div");newNodes.innerHTML=newContent;if(range&&sel){range.deleteContents();while(newNodes.firstChild){range.insertNode(newNodes.firstChild)}}}catch(e){console.log(e)}}}/**
   * Created life-cycle to ensure a single global store.
   */constructor(){super();(0,_settings.setPassiveTouchGestures)(!0);new Promise((res,rej)=>_require.default(["./hax-app.js"],res,rej));new Promise((res,rej)=>_require.default(["./hax-stax.js"],res,rej));new Promise((res,rej)=>_require.default(["./hax-stax-browser.js"],res,rej));new Promise((res,rej)=>_require.default(["./hax-blox.js"],res,rej));new Promise((res,rej)=>_require.default(["./hax-blox-browser.js"],res,rej));// claim the instance spot. This way we can easily
// be referenced globally
if(null==window.HaxStore.instance){window.HaxStore.instance=this}this.haxToast=window.SimpleToast.requestAvailability();// notice hax property definitions coming from anywhere
window.addEventListener("hax-register-properties",this._haxStoreRegisterProperties.bind(this));// app registration can come in automatically from app-stores
// or through direct definition in the DOM
document.body.addEventListener("hax-register-app",this._haxStoreRegisterApp.bind(this));// register stax which are groupings of haxElements
document.body.addEventListener("hax-register-stax",this._haxStoreRegisterStax.bind(this));// register blox which are grid plate configurations
// with lots of sane visual defaults
document.body.addEventListener("hax-register-blox",this._haxStoreRegisterBlox.bind(this));// register the pieces of the body of what we call HAX
// think of this like the core of the system required
// to do anything like have buttons or state management
// write data to the store
document.body.addEventListener("hax-store-write",this._writeHaxStore.bind(this));// register the manager panel / modal
document.body.addEventListener("hax-register-manager",this._haxStoreRegisterManager.bind(this));// register the autoloader area for elements
document.body.addEventListener("hax-register-autoloader",this._haxStoreRegisterAutoloader.bind(this));// register a body, kind of a big deal
document.body.addEventListener("hax-register-body",this._haxStoreRegisterBody.bind(this));// register the interaction panel / menu
document.body.addEventListener("hax-register-panel",this._haxStoreRegisterPanel.bind(this));// register the app picker for contextual setting / option
document.body.addEventListener("hax-register-app-picker",this._haxStoreRegisterAppPicker.bind(this));// stax modal
document.body.addEventListener("hax-register-stax-picker",this._haxStoreRegisterStaxPicker.bind(this));// blox modal
document.body.addEventListener("hax-register-blox-picker",this._haxStoreRegisterBloxPicker.bind(this));// preferences modal
document.body.addEventListener("hax-register-preferences",this._haxStoreRegisterPreferences.bind(this));// export modal
document.body.addEventListener("hax-register-export",this._haxStoreRegisterExport.bind(this));// grid plate add item event
document.body.addEventListener("grid-plate-add-item",this.haxInsertAnything.bind(this));// notice content insert and help it along to the body
document.body.addEventListener("hax-insert-content",this._haxStoreInsertContent.bind(this));document.body.addEventListener("hax-insert-content-array",this._haxStoreInsertMultiple.bind(this));window.addEventListener("hax-add-voice-command",this._addVoiceCommand.bind(this));document.body.style.setProperty("--hax-ui-headings","#d4ff77")}/**
   * Build HAX property definitions for primitives that we support.
   */_buildPrimitiveDefinitions(){// sandboxes need a webview definition
// we don't want people making them but we need to
// know how to edit them if asked
if(window.HaxStore.instance._isSandboxed){let webview={canScale:!0,canPosition:!0,canEditSource:!1,settings:{quick:[{attribute:"src",title:"Source",description:"The URL for this video.",inputMethod:"textfield",icon:"link",required:!0,validationType:"url"}],configure:[{attribute:"src",title:"Source",description:"The URL for this video.",inputMethod:"textfield",icon:"link",required:!0,validationType:"url"}],advanced:[]}};this.setHaxProperties(webview,"webview")}let iframe={canScale:!0,canPosition:!0,canEditSource:!0,gizmo:{title:"Basic iframe",description:"A basic iframe",icon:"icons:fullscreen",color:"grey",groups:["Content"],handles:[{type:"link",source:"src",height:"height",width:"width"}],meta:{author:"W3C"}},settings:{quick:[{attribute:"src",title:"Source",description:"The URL for this video.",inputMethod:"textfield",icon:"link",required:!0,validationType:"url"}],configure:[{attribute:"src",title:"Source",description:"The URL for this video.",inputMethod:"textfield",icon:"link",required:!0,validationType:"url"}],advanced:[]}};this.setHaxProperties(iframe,"iframe");let img={canScale:!0,canPosition:!0,canEditSource:!1,gizmo:{title:"Image",description:"A basic img tag",icon:"image:image",color:"grey",groups:["Image","Media"],handles:[{type:"link",source:"src"},{type:"image",source:"src",height:"height",width:"width"}],meta:{author:"W3C"}},settings:{quick:[{attribute:"src",title:"Source",description:"The URL for this video.",inputMethod:"textfield",icon:"link",required:!0,validationType:"url"},{attribute:"alt",title:"Alt text",description:"Useful for screen readers and improved SEO.",inputMethod:"alt",icon:"accessibility"},{attribute:"height",title:"Height",description:"height in pixels of the item",inputMethod:"textfield",icon:"icons:swap-vert"},{attribute:"width",title:"Width",description:"width in pixels of the item",inputMethod:"textfield",icon:"icons:swap-horiz"}],configure:[{attribute:"src",title:"Source",description:"The URL for this video.",inputMethod:"haxupload",icon:"link",required:!0,validationType:"url"},{attribute:"alt",title:"Alt text",description:"Useful for screen readers and improved SEO.",inputMethod:"alt",icon:"accessibility"},{attribute:"height",title:"Height",description:"height in pixels of the item",inputMethod:"textfield",icon:"icons:swap-vert"},{attribute:"width",title:"Width",description:"width in pixels of the item",inputMethod:"textfield",icon:"icons:swap-horiz"}],advanced:[]}};this.setHaxProperties(img,"img");let ahref={canScale:!1,canPosition:!1,canEditSource:!0,gizmo:{title:"Basic link",description:"A basic a tag",icon:"icons:link",color:"grey",groups:["Link"],handles:[{type:"link",source:"href",title:"innerText",alt:"title"}],meta:{author:"W3C"}},settings:{quick:[{attribute:"href",title:"Link",description:"The URL for this video.",inputMethod:"textfield",icon:"icons:link",required:!0,validationType:"url"},{attribute:"title",title:"Title text",description:"Useful for screen readers and improved SEO.",inputMethod:"textfield",icon:"icons:accessibility"}],configure:[{attribute:"innerText",title:"Text",description:"Text of the link",inputMethod:"textfield",required:!0},{attribute:"href",title:"Link",description:"The URL for this video.",inputMethod:"haxupload",icon:"icons:link",required:!0,validationType:"url"},{attribute:"title",title:"Title text",description:"Useful for screen readers and improved SEO.",inputMethod:"textfield",icon:"icons:accessibility"},{attribute:"target",title:"Target",description:"Where to place the link.",inputMethod:"select",icon:"icons:launch",options:{"":"Same window",_blank:"New window",_top:"Top window",_parent:"Parent window"}}],advanced:[]}};this.setHaxProperties(ahref,"a");let p={canScale:!1,canPosition:!1,canEditSource:!0,gizmo:{title:"Paragraph",description:"A basic text area",icon:"editor:short-text",color:"grey",groups:["Text"],handles:[{type:"content",content:""}],meta:{author:"W3C"}},settings:{quick:[],configure:[{slot:"",title:"Content",description:"Internal content",inputMethod:"code-editor",icon:"icons:code"}],advanced:[]}};this.setHaxProperties(p,"p");let hr={canScale:!0,canPosition:!0,canEditSource:!1,settings:{quick:[],configure:[],advanced:[]}};this.setHaxProperties(hr,"hr");this.setHaxProperties(_codeSample.CodeSample.haxProperties,_codeSample.CodeSample.tag)}/**
   * Set the haxManager node so we can interface with it.
   * This also allows for using a different manager that supplies
   * the same functions if that would be desired at some point.
   */_haxStoreRegisterManager(e){if(e.detail&&typeof this.haxManager===typeof void 0){this.haxManager=e.detail}}/**
   * Register autoloader so we can ship to it from app-store spec
   */_haxStoreRegisterAutoloader(e){if(e.detail&&typeof this.haxAutoloader===typeof void 0){this.haxAutoloader=e.detail}}/**
   * Set the appPicker node so we can interface with it.
   * This helps with picking between multiple options when we need the user
   * to decide between a sub-set of options
   */_haxStoreRegisterAppPicker(e){if(e.detail&&typeof this.haxAppPicker===typeof void 0){this.haxAppPicker=e.detail}}/**
   * Set the stax picker so that we have an element in charge
   * of the listing of available stax.
   */_haxStoreRegisterStaxPicker(e){if(e.detail&&typeof this.haxStaxPicker===typeof void 0){this.haxStaxPicker=e.detail}}/**
   * Set the blox picker so that we have an element in charge
   * of the listing of available blox.
   */_haxStoreRegisterBloxPicker(e){if(e.detail&&typeof this.haxBloxPicker===typeof void 0){this.haxBloxPicker=e.detail}}/**
   * Close all drawers
   */closeAllDrawers(active=!1){// walk all drawers, close everything
// except active. This also will allow them
// to close everything then.
let drawers=["haxManager","haxBloxPicker","haxStaxPicker","haxPreferences","haxExport"];for(var i in drawers){if(active===this[drawers[i]]){active.open();if("haxManager"===drawers[i]){setTimeout(()=>{if(null!=active.querySelector("#activepage .iron-selected paper-input")){active.querySelector("#activepage .iron-selected paper-input").focus()}},325)}else{setTimeout(()=>{if(null!=active.querySelector("paper-checkbox,paper-input,textarea,paper-button")){active.querySelector("paper-checkbox,paper-input,textarea,paper-button").focus()}},325)}}else{this[drawers[i]].close()}}}/**
   * Insert content in the body.
   */_haxStoreInsertContent(e){if(e.detail){let details=e.detail;if(window.customElements.get(details.tag)){let prototype=Object.getPrototypeOf(document.createElement(details.tag));// support for deep API call to clean up special elements
if(typeof prototype.preProcessHaxInsertContent!==typeof void 0){details=prototype.preProcessHaxInsertContent(details)}}var properties={};// support for properties to be set automatically optionally
if(typeof details.properties!==typeof void 0){properties=details.properties}// support / clean up properties / attributes that have innerHTML / innerText
// these are reserved words but required for certain bindings
if(properties.innerHTML){if(""==details.content){details.content=properties.innerHTML}delete properties.innerHTML}if(properties.innerText){if(""==details.content){details.content=properties.innerText}delete properties.innerText}// ensure better UX for text based operations
this.activeHaxBody.__activeHover=null;// invoke insert or replacement on body, same function so it's easier to trace
if(details.replace&&details.replacement){let node=window.HaxStore.haxElementToNode(details.tag,details.content,properties);if(this.activePlaceHolder){this.activeHaxBody.haxReplaceNode(this.activePlaceHolder,node,this.activePlaceHolder.parentNode);this.activePlaceHolder=null}else{this.activeHaxBody.haxReplaceNode(this.activeNode,node,this.activeNode.parentNode)}}else if(typeof details.__type!==typeof void 0&&"inline"===details.__type){let node=window.HaxStore.haxElementToNode(details.tag,details.content,properties);// replace what WAS the active selection w/ this new node
if(null!==this.activePlaceHolder){this.activePlaceHolder.deleteContents();this.activePlaceHolder.insertNode(node)}// set it to nothing
this.activePlaceHolder=null}else if(null!=this.activeContainerNode){let node=window.HaxStore.haxElementToNode(details.tag,details.content,properties);// allow for inserting things into things but not grid plate
if(this.activeContainerNode&&"GRID-PLATE"===this.activeContainerNode.tagName){// support slot if we have one on the activeNode (most likely)
if(null!=this.activeNode.getAttribute("slot")){node.setAttribute("slot",this.activeNode.getAttribute("slot"))}(0,_polymerDom.dom)(this.activeContainerNode).appendChild(node);this.activeHaxBody.$.textcontextmenu.highlightOps=!1;this.activeHaxBody.__updateLockFocus=node;// wait so that the DOM can have the node to then attach to
setTimeout(()=>{this.activeHaxBody.breakUpdateLock()},50)}else{this.activeHaxBody.haxInsert(details.tag,details.content,properties)}}else{this.activeHaxBody.haxInsert(details.tag,details.content,properties)}}}/**
   * Present all elements to potentially insert
   */haxInsertAnything(e){let haxElements=[];for(var i in window.HaxStore.instance.gizmoList){haxElements.push(window.HaxStore.haxElementPrototype(window.HaxStore.instance.gizmoList[i],e.detail.properties,""))}// hand off to hax-app-picker to deal with the rest of this
window.HaxStore.instance.haxAppPicker.presentOptions(haxElements,"element","Add an element","gizmo")}/**
   * Optional send array, to improve performance and event bubbling better
   */_haxStoreInsertMultiple(e){if(e.detail){var properties;for(var i in e.detail){properties={};// support for properties to be set automatically optionally
if(typeof e.detail[i].properties!==typeof void 0){properties=e.detail[i].properties}this.activeHaxBody.haxInsert(e.detail[i].tag,e.detail[i].content,properties,!1)}setTimeout(()=>{this.activeHaxBody.breakUpdateLock()},300)}}/**
   * Set the activeHaxBody and add to the list so we know what to insert into.
   */_haxStoreRegisterBody(e){if(e.detail){this.haxBodies.push(e.detail);// default active the whatever is last here
this.activeHaxBody=e.detail;// needed so that higher order things can respond to us having a body
window.HaxStore.write("activeHaxBody",this.activeHaxBody,this);window.HaxStore.write("editMode",this.editMode,this)}}/**
   * Set the haxPanel so we know what to insert into.
   */_haxStoreRegisterPanel(e){if(e.detail&&typeof this.haxPanel===typeof void 0){this.haxPanel=e.detail}}/**
   * Set the haxExport so we know who to call for exporting
   */_haxStoreRegisterExport(e){if(e.detail&&typeof this.haxExport===typeof void 0){this.haxExport=e.detail}}/**
   * Set the haxPreferences so we know what has global preferences
   */_haxStoreRegisterPreferences(e){if(e.detail&&typeof this.haxPreferences===typeof void 0){this.haxPreferences=e.detail}}/**
   * Feature detect on the bar.
   */computePolyfillSafe(){/**
     * These are our bad actors in polyfill'ed browsers.
     * This means that https://github.com/webcomponents/webcomponentsjs/commit/ce464bb533bf39b544c312906499a6044ee0d30d
     * explains things but basically if shadow-dom is polyfilled
     * then we can't safely execute a DOM manipulating execCommand.
     * This
     */if(document.head.createShadowRoot||document.head.attachShadow){return!0}else{console.log("Shadow DOM missing, certain operations hidden");return!1}}/**
   * Write store event callback.
   */_writeHaxStore(e){// ensure we have a valid store write
if(e.detail&&typeof e.detail.value!==typeof void 0&&e.detail.property&&e.detail.owner){if("object"===typeof e.detail.value){this.set(e.detail.property,{})}this.set(e.detail.property,e.detail.value);this.dispatchEvent(new CustomEvent("hax-store-property-updated",{bubbles:!0,composed:!0,cancelable:!1,detail:{property:e.detail.property,value:e.detail.value,owner:e.detail.owner}}))}}/**
   * Notice that an app was set in HAX; register it
   */_haxStoreRegisterApp(e){if(e.detail){e.detail.index=this.appList.length;this.push("appList",e.detail);window.HaxStore.write("appList",this.appList,this);// preconnect apps at registration time
if(e.detail.connection&&e.detail.connection.protocol&&e.detail.connection.url){let preconnectlink=document.createElement("link");preconnectlink.rel="preconnect";preconnectlink.href=e.detail.connection.protocol+"://"+e.detail.connection.url;document.head.appendChild(preconnectlink)}// we don't care about this after it's launched
if(typeof e.target.parentElement!==typeof void 0&&"HAX-STORE"===e.target.parentElement.tagName){(0,_polymerDom.dom)(e.target.parentElement).removeChild(e.target)}}}/**
   * Notice that a stax was set in HAX; register it
   */_haxStoreRegisterStax(e){if(e.detail){e.detail.index=this.staxList.length;this.push("staxList",e.detail);window.HaxStore.write("staxList",this.staxList,this);// we don't care about this after it's launched
if(typeof e.target.parentElement!==typeof void 0&&"HAX-STORE"===e.target.parentElement.tagName){(0,_polymerDom.dom)(e.target.parentElement).removeChild(e.target)}}}/**
   * Notice that a blox was set in HAX; register it
   */_haxStoreRegisterBlox(e){if(e.detail){e.detail.index=this.bloxList.length;this.push("bloxList",e.detail);window.HaxStore.write("bloxList",this.bloxList,this);// we don't care about this after it's launched
if(typeof e.target.parentElement!==typeof void 0&&"HAX-STORE"===e.target.parentElement.tagName){(0,_polymerDom.dom)(e.target.parentElement).removeChild(e.target)}}}/**
   * Notice that a property off an element was set in HAX some place; register it here
   */_haxStoreRegisterProperties(e){if(e.detail&&e.detail.properties&&e.detail.tag){// only register tag if we don't know about it already
if(typeof this.elementList[e.detail.tag]===typeof void 0){// look for a gizmo; it's not required, technically.
let gizmo=e.detail.properties.gizmo;if(gizmo){gizmo.tag=e.detail.tag;let gizmos=this.gizmoList;gizmos.push(gizmo);window.HaxStore.write("gizmoList",gizmos,this)}this.set("elementList."+e.detail.tag,e.detail.properties);// only push new values on if we got something new
if(!this.validTagList.find(element=>{return element===e.detail.tag})){this.push("validTagList",e.detail.tag)}}// delete this tag if it was in the autoloader as it has served it's purpose.
if(typeof e.target.parentElement!==typeof void 0&&"HAX-AUTOLOADER"===e.target.parentElement.tagName){(0,_polymerDom.dom)(this.haxAutoloader).removeChild(e.target)}}}}/**
 * Trick to write the store to the DOM if it wasn't there already.
 * This is not used yet but could be if you wanted to dynamically
 * load the store based on something else calling for it. Like
 * store lazy loading but it isn't tested.
 */_exports.HaxStore=HaxStore;window.HaxStore=window.HaxStore||{};window.HaxStore.instance=null;window.HaxStore.requestAvailability=function(){if(!window.HaxStore.instance){window.HaxStore.instance=document.createElement("hax-store");document.body.appendChild(window.HaxStore.instance)}return window.HaxStore.instance};/**
 * Simple Array smashing function to ensure Object is array.
 */window.HaxStore.toArray=obj=>{return Object.keys(obj).map(function(key){return obj[key]})};/**
 * Helper to convert camel case to dash; important when setting attributes.
 */window.HaxStore.camelToDash=str=>{return str.replace(/\W+/g,"-").replace(/([a-z\d])([A-Z])/g,"$1-$2").toLowerCase()};/**
 * Helper to convert dash to camel; important when reading attributes.
 */window.HaxStore.dashToCamel=str=>{return str.replace(/-([a-z])/g,function(g){return g[1].toUpperCase()})};/**
 * Convert HTML into HAX Elements
 */window.HaxStore.htmlToHaxElements=html=>{let elements=[];const validTags=window.HaxStore.instance.validTagList;let fragment=document.createElement("div");fragment.innerHTML=html;const children=fragment.childNodes;// loop over the new nodes
for(var i=0;i<children.length;i++){// verify this tag is a valid one
if(typeof children[i].tagName!==typeof void 0&&validTags.includes(children[i].tagName.toLowerCase())){elements.push(window.HaxStore.nodeToHaxElement(children[i],null))}}return elements};/**
 * Convert a node to a HAX element. Hax elements ensure
 * a certain level of sanitization by verifying tags and
 * properties / attributes that have values.
 */window.HaxStore.nodeToHaxElement=(node,eventName="insert-element")=>{if(!node){return null}// build out the properties to send along
var props={};// support basic styles
if(typeof node.style!==typeof void 0){props.style=node.getAttribute("style")}// don't set a null style
if(null===props.style||"null"===props.style){delete props.style}// test if a class exists, not everything scopes
if(typeof node.attributes.class!==typeof void 0){props.class=node.attributes.class.nodeValue.replace("hax-active","")}// test if a id exists as its a special case in attributes... of course
if(typeof node.attributes.id!==typeof void 0){props.id=node.getAttribute("id")}let tmpProps;// relatively cross library
if(customElements.get(node.tagName.toLowerCase())){tmpProps=customElements.get(node.tagName.toLowerCase()).properties}// weak fallback
if(typeof tmpProps===typeof void 0){tmpProps=node.__data}// complex elements need complex support
if(typeof tmpProps!==typeof void 0){// run through attributes, though non-reflected props won't be here
// run through props, we always defer to property values
for(var property in tmpProps){// make sure we only set things that have a value
if("class"!=property&&"style"!=property&&tmpProps.hasOwnProperty(property)&&typeof node[property]!==void 0&&null!=node[property]&&""!=node[property]){props[property]=node[property]}// special support for false boolean
else if(!1===node[property]){props[property]=node[property]}else{}}for(var attribute in node.attributes){// make sure we only set things that have a value
if(typeof node.attributes[attribute].name!==typeof void 0&&"class"!=node.attributes[attribute].name&&"style"!=node.attributes[attribute].name&&"id"!=node.attributes[attribute].name&&node.attributes.hasOwnProperty(attribute)&&typeof node.attributes[attribute].value!==void 0&&null!=node.attributes[attribute].value&&""!=node.attributes[attribute].value&&!tmpProps.hasOwnProperty(window.HaxStore.dashToCamel(node.attributes[attribute].name))){props[window.HaxStore.dashToCamel(node.attributes[attribute].name)]=node.attributes[attribute].value}else{// note: debug here if experiencing attributes that won't bind
}}}else{// much easier case, usually just in primatives
for(var attribute in node.attributes){// make sure we only set things that have a value
if(typeof node.attributes[attribute].name!==typeof void 0&&"class"!=node.attributes[attribute].name&&"style"!=node.attributes[attribute].name&&"id"!=node.attributes[attribute].name&&node.attributes.hasOwnProperty(attribute)&&typeof node.attributes[attribute].value!==void 0&&null!=node.attributes[attribute].value&&""!=node.attributes[attribute].value){props[window.HaxStore.dashToCamel(node.attributes[attribute].name)]=node.attributes[attribute].value}}}// support sandboxed environments which
// will hate iframe tags but love webview
let tag=node.tagName.toLowerCase();if(window.HaxStore.instance._isSandboxed&&"iframe"===tag){tag="webview"}let slotContent=window.HaxStore.getHAXSlot(node);// support fallback on inner text if there were no nodes
if(""==slotContent){slotContent=node.innerText}// special edge case for slot binding in primatives
if("a"===tag){props.innerText=slotContent}else if("p"===tag||"ol"===tag||"ul"===tag||"div"===tag){props.innerHTML=slotContent}let element={tag:tag,properties:props,content:slotContent};if(null!==eventName){element.eventName=eventName}return element};/**
 * Convert a haxElement to a DOM node.
 */window.HaxStore.haxElementToNode=(tag,content,properties)=>{// support sandboxed environments which
// will hate iframe tags but love webview
if(window.HaxStore.instance._isSandboxed&&"iframe"===tag){tag="webview"}var frag=document.createElement(tag);frag.innerHTML=content;// clone the fragment which will force an escalation to full node
var newNode=frag.cloneNode(!0);// support for properties if they exist
for(var property in properties){let attributeName=window.HaxStore.camelToDash(property);if(properties.hasOwnProperty(property)){// special supporting for boolean because html is weird :p
if(!0===properties[property]){newNode.setAttribute(attributeName,properties[property])}else if(!1===properties[property]){newNode.removeAttribute(attributeName)}else if(null!=properties[property]&&properties[property].constructor===Array){// do nothing if we have additional data to suggest this is actually readOnly
// polymer / typed specific thing
if(frag.properties&&frag.properties[property]&&frag.properties[property].readOnly){}else{newNode.set(attributeName,properties[property])}}else if(null!=properties[property]&&properties[property].constructor===Object){// do nothing if we have additional data to suggest this is actually readOnly
// polymer / typed specific thing
if(frag.properties&&frag.properties[property]&&frag.properties[property].readOnly){}else{newNode.set(attributeName,properties[property])}}else{newNode.setAttribute(attributeName,properties[property])}}}return newNode};/**
 * Convert a node to the correct content object for saving.
 * This DOES NOT acccept a HAXElement which is similar
 */window.HaxStore.nodeToContent=node=>{if(window.HaxStore.instance.activeHaxBody.globalPreferences.haxDeveloperMode){console.log(node)}// ensure we have access to all the member functions of the custom element
let prototype=Object.getPrototypeOf(node);// support for deep API call
if(typeof prototype.preProcessHaxNodeToContent!==typeof void 0){let clone=node.cloneNode(!0);node=prototype.preProcessHaxNodeToContent(clone)}let tag=node.tagName.toLowerCase();// support sandboxed environments which
// will hate iframe tags but love webview
if(window.HaxStore.instance._isSandboxed&&"webview"===tag){tag="iframe"}var content="";// start to rebuild the same tag we got in a generalized way
content+="<"+tag;// account for things that say NOT to save slot values
// grab all of the original's attributes, and pass them to the replacement
for(var props=window.HaxStore.instance.elementList[tag],propvals={},j=0,l=node.attributes.length;j<l;++j){var nodeName=node.attributes.item(j).nodeName,value=node.attributes.item(j).value;// encode objects and arrays because they are special
if("style"!=nodeName&&(typeof value===typeof Object||value.constructor===Array)){propvals[nodeName]=JSON.stringify(value).replace(/"/g,"&quot;")}// only write things that aren't empty
else if(null!=value&&"null"!=value){if(!0===value||"true"===value){propvals[nodeName]=!0}else if(!1===value){// do nothing, no reason to record false unless written as text
// in which case below will capture it
}else{// ensure that value doesn't have " in it unencoded
if("string"===typeof value&&""!==value){value=value.replace(/"/g,"&quot;");propvals[nodeName]=value}// special handling for empty string cause it might mean boolean
// or it might be a string
else if(""===value){if(""==value&&""!=node.attributes.item(j).value){value=node.attributes.item(j).value}propvals[nodeName]=value}else{propvals[nodeName]=value}}}}// now look through properties
let tmpProps;// relatively cross library
if(customElements.get(tag)){tmpProps=customElements.get(tag).properties}// weak fallback
if(typeof tmpProps===typeof void 0){tmpProps=node.__data}if(typeof tmpProps!==typeof void 0){for(var j in tmpProps){var nodeName=window.HaxStore.camelToDash(j),value=null;// prefer local value over properties object if possible
if(typeof node[j]!==typeof void 0){value=node[j]}// never allow read only things to recorded as they
// are run-time creation 99% of the time
// this is very polymer specific but it allows readOnly and computed props
if(!tmpProps[j].readOnly&&!tmpProps[j].computed&&value!==tmpProps[j].value){// encode objects and arrays because they are special
if(null!=value&&(typeof value===typeof Object||value.constructor===Array)){propvals[nodeName]=JSON.stringify(value).replace(/"/g,"&quot;")}// only write things that aren't empty
else if(null!=value&&"null"!=value){if(!0===value||"true"===value){propvals[nodeName]=!0}else if(!1===value){// do nothing, no reason to record false unless written as text
// in which case below will capture it
}else{// ensure that value doesn't have " in it unencoded
if("string"===typeof value&&""!==value){value=value.replace(/"/g,"&quot;");propvals[nodeName]=value}// special handling for empty string cause it might mean boolean
// or it might be a string
else if(""===value){if(""==value&&""!=tmpProps[j].value){value=tmpProps[j].value}else if(""===value&&""==tmpProps[j].value){// do nothing, the default value is empty
// so lets record less data
}}else{propvals[nodeName]=value}}}}}}// support for tag defining which properties NOT to save
// for simplification, everything is an attribute during this
// operation
if(typeof props!==typeof void 0&&typeof props.saveOptions.unsetAttributes!==typeof void 0){for(var i in props.saveOptions.unsetAttributes){delete propvals[props.saveOptions.unsetAttributes[i]]}}// specialized clean up for some that can leak through from above
// and are edge case things because #hashtag gotta love HTML attributes
// and the webview tag. facepalm.
let delProps=["inner-text","inner-html","tabindex","guestinstance"];for(var delProp in delProps){if(typeof propvals[delProps[delProp]]!==typeof void 0){delete propvals[delProps[delProp]]}}// remove id attribute if it's empty, somehow misses above
if(typeof propvals.id!==typeof void 0&&""===propvals.id){delete propvals.id}// run through the properties
for(var i in propvals){if(!0===propvals[i]){content+=" "+i}else{content+=" "+i+"=\""+propvals[i]+"\""}}// set the opening tag, support self-closing void tags
let voidTags=["area","base","br","col","embed","hr","img","input","keygen","link","meta","param","source","track","wbr"];if(voidTags.includes(tag)){content+="/>"}else{content+=">"}// try and work against anything NOT a P tag
if(typeof props===typeof void 0||!props.saveOptions.wipeSlot){// get content that is in the slots
let slotnodes=(0,_polymerDom.dom)(node).getEffectiveChildNodes();// ensure there's something inside of this
if(0<slotnodes.length){// loop through everything found in the slotted area and put it back in
for(var j=0,len2=slotnodes.length;j<len2;j++){if(typeof slotnodes[j].tagName!==typeof void 0){// if we're a custom element, keep digging, otherwise a simple
// self append is fine unless template tag cause it's a special
// case for the web in general as it'll register as not a primative
// even though it is...
if(!window.HaxStore.HTMLPrimativeTest(slotnodes[j].tagName)&&"TEMPLATE"!==slotnodes[j].tagName){content+=window.HaxStore.nodeToContent(slotnodes[j])}else{slotnodes[j].setAttribute("data-editable",!1);slotnodes[j].removeAttribute("data-hax-ray");slotnodes[j].contentEditable=!1;content+=slotnodes[j].outerHTML}}// keep comments with a special case since they need wrapped
else if(8===slotnodes[j].nodeType){content+="<!-- "+slotnodes[j].textContent+" -->"}// keep everything NOT an element at this point, this helps
// preserve whitespace because we're crazy about accuracy
else if(1!==slotnodes[j].nodeType&&typeof slotnodes[j].textContent!==typeof void 0&&"undefined"!==slotnodes[j].textContent){content+=slotnodes[j].textContent}}}}// don't put return for span since it's an inline tag
if("span"===tag){content+="</"+tag+">"}else if("hr"===tag||"br"===tag||"img"===tag){}// do nothing for self-closing tags they'll resolve themselves
// close the tag, placing a return in output for block elements
else{content+="</"+tag+">"+"\n"}if(window.HaxStore.instance.activeHaxBody.globalPreferences.haxDeveloperMode){console.log(content)}// support postProcess text rewriting for the node that's been
// converted to a string for storage
if("function"===node.postProcesshaxNodeToContent){content=node.postProcesshaxNodeToContent(content)}return content};/**
 * Basic HTML Primitives test
 */window.HaxStore.HTMLPrimativeTest=node=>{if(typeof node.tagName!==typeof void 0&&-1==node.tagName.indexOf("-")){return!0}return!1};/**
 * Slot content w/ support for custom elements in slot.
 */window.HaxStore.getHAXSlot=node=>{// we can skip all of this if we have a text element / HTML prim!
if(window.HaxStore.instance.isTextElement(node)){return node.innerHTML}let content="";var slotnodes=(0,_polymerDom.dom)(node).children;// ensure there's something inside of this
if(0<slotnodes.length){// loop through everything found in the slotted area and put it back in
for(var j=0,len2=slotnodes.length;j<len2;j++){if(typeof slotnodes[j].tagName!==typeof void 0){// if we're a custom element, keep digging, otherwise a simple
// self append is fine.
if(0<slotnodes[j].tagName.indexOf("-")){content+="  "+window.HaxStore.nodeToContent(slotnodes[j])+"\n"}else{content+="  "+slotnodes[j].outerHTML+"\n"}}// keep comments with a special case since they need wrapped
else if(8===slotnodes[j].nodeType){content+="<!-- "+slotnodes[j].textContent+" -->"}// keep everything NOT an element at this point, this helps
// preserve whitespace because we're crazy about accuracy
else if(1!==slotnodes[j].nodeType&&typeof slotnodes[j].textContent!==typeof void 0&&"undefined"!==slotnodes[j].textContent){content+=slotnodes[j].textContent}}}return content};/**
 * Shortcut to standardize the write / read process.
 */window.HaxStore.write=(prop,value,obj)=>{obj.dispatchEvent(new CustomEvent("hax-store-write",{composed:!0,bubbles:!0,cancelable:!1,detail:{property:prop,value:value,owner:obj}}))};/**
 * Guess the type of Gizmo when given some information about what we have.
 */window.HaxStore.guessGizmoType=guess=>{if(typeof guess.source!==typeof void 0){if(-1!=guess.source.indexOf(".mp3")){return"audio"}else if(-1!=guess.source.indexOf(".png")||-1!=guess.source.indexOf(".jpg")||-1!=guess.source.indexOf(".jpeg")||-1!=guess.source.indexOf(".gif")){return"image"}else if(-1!=guess.source.indexOf(".pdf")){return"pdf"}else if(-1!=guess.source.indexOf(".svg")){return"svg"}else if(-1!=guess.source.indexOf(".csv")){return"csv"}// if it's external we can't assume what it actually is
else if("external"!=window.HaxStore.instance.getVideoType(guess.source)){return"video"}else{// we don't know how to handle this so let's just
// try ANYTHING that matches
return"*"}}};/**
 * Try and guess the Gizmo based on what we were just handed
 */window.HaxStore.guessGizmo=(guess,values,skipPropMatch=!1)=>{var matches=[];if(typeof guess!==typeof void 0){var store=window.HaxStore.instance;// verify type
if(store.validGizmoTypes.includes(guess)){// now we can look through them
// look for a match
for(var gizmoposition in store.gizmoList){var gizmo=store.gizmoList[gizmoposition],props={},match=!1;if(gizmo.handles){for(var i=0;i<gizmo.handles.length;i++){// WHAT!??!?!?!?!
if(guess===gizmo.handles[i].type||"*"===guess&&!match){for(var property in gizmo.handles[i]){// ignore type.. but again.. WHAT?!?!?!
if("type"!==property){// check the values that came across to see if there's a match
// of any kind, we only need one but can then bind to multiple
if(typeof values[property]!==typeof void 0){match=!0;props[gizmo.handles[i][property]]=values[property]}}}// omg... we just found a match on a property from who knows where!
if(match||skipPropMatch){matches.push(window.HaxStore.haxElementPrototype(gizmo,props,""))}}}}}}}return matches};/**
 * Filter app store apps to those that accept this file source.
 */window.HaxStore.getHaxAppStoreTargets=type=>{let targets=window.HaxStore.instance.appList.filter(app=>{if(typeof app.connection.operations.add!==typeof void 0){let add=app.connection.operations.add;if(typeof add.acceptsGizmoTypes!==typeof void 0&&add.acceptsGizmoTypes.includes(type)){return!0}}return!1});return targets};/**
 * Generate Hax Element prototype.
 */window.HaxStore.haxElementPrototype=(gizmo,properties,content="")=>{return{tag:gizmo.tag,properties:properties,content:content,gizmo:gizmo}};/**
 * Wipe out the slot of an element.
 */window.HaxStore.wipeSlot=(element,slot="")=>{(0,_haxutils.wipeSlot)(element,slot)};/**
 * HTML encapsulation of a string on script and style tags
 */window.HaxStore.encapScript=html=>{return(0,_haxutils.encapScript)(html)};/**
 * Global toast bridge so we don't have to keep writing custom event
 */window.HaxStore.toast=(message,duration=4e3,classStyle="",closeText=null,eventCallback=null)=>{const evt=new CustomEvent("simple-toast-show",{bubbles:!0,composed:!0,cancelable:!0,detail:{text:message,duration:duration,classStyle:classStyle,closeText:closeText,eventCallback:eventCallback}});window.dispatchEvent(evt)};/**
 * Selection normalizer
 */window.HaxStore.getSelection=()=>{// try and obtain the selection from the nearest shadow
// which would give us the selection object when running native ShadowDOM
// with fallback support for the entire window which would imply Shady
if(window.HaxStore.instance.activeHaxBody.parentNode){// native API
if(window.HaxStore.instance.activeHaxBody.parentNode.getSelection){return window.HaxStore.instance.activeHaxBody.parentNode.getSelection()}// ponyfill from google
else if((0,_shadowsSafari.getRange)(window.HaxStore.instance.activeHaxBody.parentNode)){return(0,_shadowsSafari.getRange)(window.HaxStore.instance.activeHaxBody.parentNode)}}// missed on both, hope the normal one will work
return window.getSelection()};/**
 * Get a normalized range based on current selection
 */window.HaxStore.getRange=()=>{let sel=window.HaxStore.getSelection();if(sel.getRangeAt&&sel.rangeCount){return sel.getRangeAt(0)}else if(sel){return sel}else!1};window.customElements.define(HaxStore.tag,HaxStore)});