define(["exports"], function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.toArray = toArray;
  _exports.log = log;
  _exports.logValue = logValue;
  _exports.ensureRoute = ensureRoute;
  _exports.ensureRoutes = ensureRoutes;
  _exports.loadBundle = loadBundle;
  _exports.fireRouterEvent = fireRouterEvent;
  _exports.isObject = isObject;
  _exports.isFunction = isFunction;
  _exports.isString = isString;
  _exports.getNotFoundError = getNotFoundError;
  _exports.notFoundResult = void 0;

  function toArray(objectOrArray) {
    objectOrArray = objectOrArray || [];
    return Array.isArray(objectOrArray) ? objectOrArray : [objectOrArray];
  }

  function log(msg) {
    return `[Vaadin.Router] ${msg}`;
  }

  function logValue(value) {
    if (typeof value !== 'object') {
      return String(value);
    }

    const stringType = Object.prototype.toString.call(value).match(/ (.*)\]$/)[1];

    if (stringType === 'Object' || stringType === 'Array') {
      return `${stringType} ${JSON.stringify(value)}`;
    } else {
      return stringType;
    }
  }

  const MODULE = 'module';
  const NOMODULE = 'nomodule';
  const bundleKeys = [MODULE, NOMODULE];

  function ensureBundle(src) {
    if (!src.match(/.+\.[m]?js$/)) {
      throw new Error(log(`Unsupported type for bundle "${src}": .js or .mjs expected.`));
    }
  }

  function ensureRoute(route) {
    if (!route || !isString(route.path)) {
      throw new Error(log(`Expected route config to be an object with a "path" string property, or an array of such objects`));
    }

    const bundle = route.bundle;
    const stringKeys = ['component', 'redirect', 'bundle'];

    if (!isFunction(route.action) && !Array.isArray(route.children) && !isFunction(route.children) && !isObject(bundle) && !stringKeys.some(key => isString(route[key]))) {
      throw new Error(log(`Expected route config "${route.path}" to include either "${stringKeys.join('", "')}" ` + `or "action" function but none found.`));
    }

    if (bundle) {
      if (isString(bundle)) {
        ensureBundle(bundle);
      } else if (!bundleKeys.some(key => key in bundle)) {
        throw new Error(log('Expected route bundle to include either "' + NOMODULE + '" or "' + MODULE + '" keys, or both'));
      } else {
        bundleKeys.forEach(key => key in bundle && ensureBundle(bundle[key]));
      }
    }

    if (route.redirect) {
      ['bundle', 'component'].forEach(overriddenProp => {
        if (overriddenProp in route) {
          console.warn(log(`Route config "${route.path}" has both "redirect" and "${overriddenProp}" properties, ` + `and "redirect" will always override the latter. Did you mean to only use "${overriddenProp}"?`));
        }
      });
    }
  }

  function ensureRoutes(routes) {
    toArray(routes).forEach(route => ensureRoute(route));
  }

  function loadScript(src, key) {
    let script = document.head.querySelector('script[src="' + src + '"][async]');

    if (!script) {
      script = document.createElement('script');
      script.setAttribute('src', src);

      if (key === MODULE) {
        script.setAttribute('type', MODULE);
      } else if (key === NOMODULE) {
        script.setAttribute(NOMODULE, '');
      }

      script.async = true;
    }

    return new Promise((resolve, reject) => {
      script.onreadystatechange = script.onload = e => {
        script.__dynamicImportLoaded = true;
        resolve(e);
      };

      script.onerror = e => {
        if (script.parentNode) {
          script.parentNode.removeChild(script);
        }

        reject(e);
      };

      if (script.parentNode === null) {
        document.head.appendChild(script);
      } else if (script.__dynamicImportLoaded) {
        resolve();
      }
    });
  }

  function loadBundle(bundle) {
    if (isString(bundle)) {
      return loadScript(bundle);
    } else {
      return Promise.race(bundleKeys.filter(key => key in bundle).map(key => loadScript(bundle[key], key)));
    }
  }

  function fireRouterEvent(type, detail) {
    return !window.dispatchEvent(new CustomEvent(`vaadin-router-${type}`, {
      cancelable: type === 'go',
      detail
    }));
  }

  function isObject(o) {
    // guard against null passing the typeof check
    return typeof o === 'object' && !!o;
  }

  function isFunction(f) {
    return typeof f === 'function';
  }

  function isString(s) {
    return typeof s === 'string';
  }

  function getNotFoundError(context) {
    const error = new Error(log(`Page not found (${context.pathname})`));
    error.context = context;
    error.code = 404;
    return error;
  }

  const notFoundResult = new class NotFoundResult {}();
  _exports.notFoundResult = notFoundResult;
});