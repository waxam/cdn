define(["exports", "./path-to-regexp.js"], function (_exports, _pathToRegexp) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = void 0;
  _pathToRegexp = babelHelpers.interopRequireDefault(_pathToRegexp);

  /**
   * Universal Router (https://www.kriasoft.com/universal-router/)
   *
   * Copyright (c) 2015-present Kriasoft.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.txt file in the root directory of this source tree.
   */
  const {
    hasOwnProperty
  } = Object.prototype;
  const cache = new Map(); // see https://github.com/pillarjs/path-to-regexp/issues/148

  cache.set('|false', {
    keys: [],
    pattern: /(?:)/
  });

  function decodeParam(val) {
    try {
      return decodeURIComponent(val);
    } catch (err) {
      return val;
    }
  }

  function matchPath(routepath, path, exact, parentKeys, parentParams) {
    exact = !!exact;
    const cacheKey = `${routepath}|${exact}`;
    let regexp = cache.get(cacheKey);

    if (!regexp) {
      const keys = [];
      regexp = {
        keys,
        pattern: (0, _pathToRegexp.default)(routepath, keys, {
          end: exact,
          strict: routepath === ''
        })
      };
      cache.set(cacheKey, regexp);
    }

    const m = regexp.pattern.exec(path);

    if (!m) {
      return null;
    }

    const params = Object.assign({}, parentParams);

    for (let i = 1; i < m.length; i++) {
      const key = regexp.keys[i - 1];
      const prop = key.name;
      const value = m[i];

      if (value !== undefined || !hasOwnProperty.call(params, prop)) {
        if (key.repeat) {
          params[prop] = value ? value.split(key.delimiter).map(decodeParam) : [];
        } else {
          params[prop] = value ? decodeParam(value) : value;
        }
      }
    }

    return {
      path: m[0],
      keys: (parentKeys || []).concat(regexp.keys),
      params
    };
  }

  var _default = matchPath;
  _exports.default = _default;
});