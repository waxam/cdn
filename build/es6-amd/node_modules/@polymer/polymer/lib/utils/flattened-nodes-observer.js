define(["exports","./boot.js","./array-splice.js","./async.js","./wrap.js"],(function(_exports,_boot,_arraySplice,_async,_wrap){
/**
  @license
  Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
  Code distributed by Google as part of the polymer project is also
  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
  */
function isSlot(node){return"slot"===node.localName}Object.defineProperty(_exports,"__esModule",{value:!0}),_exports.FlattenedNodesObserver=void 0;_exports.FlattenedNodesObserver=class{static getFlattenedNodes(node){const wrapped=(0,_wrap.wrap)(node);return isSlot(node)?(node=node,wrapped.assignedNodes({flatten:!0})):Array.from(wrapped.childNodes).map(node=>isSlot(node)?(node=node,(0,_wrap.wrap)(node).assignedNodes({flatten:!0})):[node]).reduce((a,b)=>a.concat(b),[])}constructor(target,callback){this._shadyChildrenObserver=null,this._nativeChildrenObserver=null,this._connected=!1,this._target=target,this.callback=callback,this._effectiveNodes=[],this._observer=null,this._scheduled=!1,this._boundSchedule=()=>{this._schedule()},this.connect(),this._schedule()}connect(){isSlot(this._target)?this._listenSlots([this._target]):(0,_wrap.wrap)(this._target).children&&(this._listenSlots((0,_wrap.wrap)(this._target).children),window.ShadyDOM?this._shadyChildrenObserver=window.ShadyDOM.observeChildren(this._target,mutations=>{this._processMutations(mutations)}):(this._nativeChildrenObserver=new MutationObserver(mutations=>{this._processMutations(mutations)}),this._nativeChildrenObserver.observe(this._target,{childList:!0}))),this._connected=!0}disconnect(){isSlot(this._target)?this._unlistenSlots([this._target]):(0,_wrap.wrap)(this._target).children&&(this._unlistenSlots((0,_wrap.wrap)(this._target).children),window.ShadyDOM&&this._shadyChildrenObserver?(window.ShadyDOM.unobserveChildren(this._shadyChildrenObserver),this._shadyChildrenObserver=null):this._nativeChildrenObserver&&(this._nativeChildrenObserver.disconnect(),this._nativeChildrenObserver=null)),this._connected=!1}_schedule(){this._scheduled||(this._scheduled=!0,_async.microTask.run(()=>this.flush()))}_processMutations(mutations){this._processSlotMutations(mutations),this.flush()}_processSlotMutations(mutations){if(mutations)for(let i=0;i<mutations.length;i++){let mutation=mutations[i];mutation.addedNodes&&this._listenSlots(mutation.addedNodes),mutation.removedNodes&&this._unlistenSlots(mutation.removedNodes)}}flush(){if(!this._connected)return!1;window.ShadyDOM&&ShadyDOM.flush(),this._nativeChildrenObserver?this._processSlotMutations(this._nativeChildrenObserver.takeRecords()):this._shadyChildrenObserver&&this._processSlotMutations(this._shadyChildrenObserver.takeRecords()),this._scheduled=!1;let info={target:this._target,addedNodes:[],removedNodes:[]},newNodes=this.constructor.getFlattenedNodes(this._target),splices=(0,_arraySplice.calculateSplices)(newNodes,this._effectiveNodes);for(let s,i=0;i<splices.length&&(s=splices[i]);i++)for(let n,j=0;j<s.removed.length&&(n=s.removed[j]);j++)info.removedNodes.push(n);for(let s,i=0;i<splices.length&&(s=splices[i]);i++)for(let j=s.index;j<s.index+s.addedCount;j++)info.addedNodes.push(newNodes[j]);this._effectiveNodes=newNodes;let didFlush=!1;return(info.addedNodes.length||info.removedNodes.length)&&(didFlush=!0,this.callback.call(this._target,info)),didFlush}_listenSlots(nodeList){for(let i=0;i<nodeList.length;i++){let n=nodeList[i];isSlot(n)&&n.addEventListener("slotchange",this._boundSchedule)}}_unlistenSlots(nodeList){for(let i=0;i<nodeList.length;i++){let n=nodeList[i];isSlot(n)&&n.removeEventListener("slotchange",this._boundSchedule)}}}}));