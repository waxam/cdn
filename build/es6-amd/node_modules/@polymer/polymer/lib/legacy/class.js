define(["exports","./legacy-element-mixin.js","../utils/settings.js"],function(_exports,_legacyElementMixin,_settings){Object.defineProperty(_exports,"__esModule",{value:!0}),_exports.mixinBehaviors=function mixinBehaviors(behaviors,klass){return GenerateClassFromInfo({},(0,_legacyElementMixin.LegacyElementMixin)(klass),behaviors)},_exports.Class=void 0;const lifecycleProps={attached:!0,detached:!0,ready:!0,created:!0,beforeRegister:!0,registered:!0,attributeChanged:!0,listeners:!0,hostAttributes:!0},excludeOnInfo={attached:!0,detached:!0,ready:!0,created:!0,beforeRegister:!0,registered:!0,attributeChanged:!0,behaviors:!0,_noAccessors:!0},excludeOnBehaviors=Object.assign({listeners:!0,hostAttributes:!0,properties:!0,observers:!0},excludeOnInfo);function applyInfo(proto,info,lifecycle,excludeProps){!function copyProperties(source,target,excludeProps){const noAccessors=source._noAccessors,propertyNames=Object.getOwnPropertyNames(source);for(let i=0;i<propertyNames.length;i++){let p=propertyNames[i];if(!(p in excludeProps))if(noAccessors)target[p]=source[p];else{let pd=Object.getOwnPropertyDescriptor(source,p);pd&&(pd.configurable=!0,Object.defineProperty(target,p,pd))}}}(info,proto,excludeProps);for(let p in lifecycleProps)info[p]&&(lifecycle[p]=lifecycle[p]||[],lifecycle[p].push(info[p]))}function mergeProperties(target,source){for(const p in source){const targetInfo=target[p],sourceInfo=source[p];target[p]=!("value"in sourceInfo)&&targetInfo&&"value"in targetInfo?Object.assign({value:targetInfo.value},sourceInfo):sourceInfo}}function GenerateClassFromInfo(info,Base,behaviors){let behaviorList;const lifecycle={};class PolymerGenerated extends Base{static _finalizeClass(){if(this.hasOwnProperty(JSCompiler_renameProperty("generatedFrom",this))){if(behaviorList)for(let b,i=0;i<behaviorList.length;i++)(b=behaviorList[i]).properties&&this.createProperties(b.properties),b.observers&&this.createObservers(b.observers,b.properties);info.properties&&this.createProperties(info.properties),info.observers&&this.createObservers(info.observers,info.properties),this._prepareTemplate()}else super._finalizeClass()}static get properties(){const properties={};if(behaviorList)for(let i=0;i<behaviorList.length;i++)mergeProperties(properties,behaviorList[i].properties);return mergeProperties(properties,info.properties),properties}static get observers(){let observers=[];if(behaviorList)for(let b,i=0;i<behaviorList.length;i++)(b=behaviorList[i]).observers&&(observers=observers.concat(b.observers));return info.observers&&(observers=observers.concat(info.observers)),observers}created(){super.created();const list=lifecycle.created;if(list)for(let i=0;i<list.length;i++)list[i].call(this)}_registered(){const generatedProto=PolymerGenerated.prototype;if(!generatedProto.hasOwnProperty("__hasRegisterFinished")){generatedProto.__hasRegisterFinished=!0,super._registered(),_settings.legacyOptimizations&&copyPropertiesToProto(generatedProto);const proto=Object.getPrototypeOf(this);let list=lifecycle.beforeRegister;if(list)for(let i=0;i<list.length;i++)list[i].call(proto);if(list=lifecycle.registered)for(let i=0;i<list.length;i++)list[i].call(proto)}}_applyListeners(){super._applyListeners();const list=lifecycle.listeners;if(list)for(let i=0;i<list.length;i++){const listeners=list[i];if(listeners)for(let l in listeners)this._addMethodEventListenerToNode(this,l,listeners[l])}}_ensureAttributes(){const list=lifecycle.hostAttributes;if(list)for(let i=list.length-1;i>=0;i--){const hostAttributes=list[i];for(let a in hostAttributes)this._ensureAttribute(a,hostAttributes[a])}super._ensureAttributes()}ready(){super.ready();let list=lifecycle.ready;if(list)for(let i=0;i<list.length;i++)list[i].call(this)}attached(){super.attached();let list=lifecycle.attached;if(list)for(let i=0;i<list.length;i++)list[i].call(this)}detached(){super.detached();let list=lifecycle.detached;if(list)for(let i=0;i<list.length;i++)list[i].call(this)}attributeChanged(name,old,value){super.attributeChanged();let list=lifecycle.attributeChanged;if(list)for(let i=0;i<list.length;i++)list[i].call(this,name,old,value)}}if(behaviors){Array.isArray(behaviors)||(behaviors=[behaviors]);let superBehaviors=Base.prototype.behaviors;behaviorList=function flattenBehaviors(behaviors,list,exclude){list=list||[];for(let i=behaviors.length-1;i>=0;i--){let b=behaviors[i];b?Array.isArray(b)?flattenBehaviors(b,list):list.indexOf(b)<0&&(!exclude||exclude.indexOf(b)<0)&&list.unshift(b):console.warn("behavior is null, check for missing or 404 import")}return list}(behaviors,null,superBehaviors),PolymerGenerated.prototype.behaviors=superBehaviors?superBehaviors.concat(behaviors):behaviorList}const copyPropertiesToProto=proto=>{behaviorList&&function applyBehaviors(proto,behaviors,lifecycle){for(let i=0;i<behaviors.length;i++)applyInfo(proto,behaviors[i],lifecycle,excludeOnBehaviors)}(proto,behaviorList,lifecycle),applyInfo(proto,info,lifecycle,excludeOnInfo)};return _settings.legacyOptimizations||copyPropertiesToProto(PolymerGenerated.prototype),PolymerGenerated.generatedFrom=info,PolymerGenerated}_exports.Class=function(info,mixin){info||console.warn("Polymer.Class requires `info` argument");let klass=mixin?mixin((0,_legacyElementMixin.LegacyElementMixin)(HTMLElement)):(0,_legacyElementMixin.LegacyElementMixin)(HTMLElement);return(klass=GenerateClassFromInfo(info,klass,info.behaviors)).is=klass.prototype.is=info.is,klass}});