define(["exports", "../../../lit/index.js", "../../simple-icon/lib/simple-icon-button.js"], function (_exports, _index, _simpleIconButton) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.StarRating = void 0;

  var _templateObject_a67173b0feb911eb8439e3eec9305af7, _templateObject2_a67173b0feb911eb8439e3eec9305af7, _templateObject3_a67173b0feb911eb8439e3eec9305af7, _templateObject4_a67173b0feb911eb8439e3eec9305af7, _templateObject5_a67173b0feb911eb8439e3eec9305af7, _templateObject6_a67173b0feb911eb8439e3eec9305af7;

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  //import simpleicon
  var StarRating = /*#__PURE__*/function (_LitElement) {
    babelHelpers.inherits(StarRating, _LitElement);

    var _super = _createSuper(StarRating);

    // these defaults in constructor assume that it's an empty star rating by default
    function StarRating() {
      var _this;

      babelHelpers.classCallCheck(this, StarRating);
      _this = _super.call(this);
      _this._calPercent = 0;
      _this.numStars = 5;
      _this.score = 0;
      _this.possible = 100;
      _this.interactive = false; // add support for this.ineractive

      return _this;
    } // there are 3 possible icons for these stars: https://webcomponents.psu.edu/styleguide/?path=/story/media-icons--simple-iconset-story
    // star-border is an empty star
    // star-half is a 1/2 filled in
    // star is filled in
    // there's a few differnet ways we could achieve this below which can make for a good discussion topic tomorrow.
    // if you can think of how to use this code to successfully fill in the stars w/ the appropriate icon name
    // based on the value of this._numStars then give it a shot!
    // Conditional rendering is probably how I'd approach this
    // also style="background-color:black;" is something I'd do via .star { background-color: var(--good-variable-name, black);}
    // dark and contrast we'll use in class as a discussion point around SimpleColors baseClass and data binding.


    babelHelpers.createClass(StarRating, [{
      key: "render",
      value: function render() {
        return (0, _index.html)(_templateObject_a67173b0feb911eb8439e3eec9305af7 || (_templateObject_a67173b0feb911eb8439e3eec9305af7 = babelHelpers.taggedTemplateLiteral(["\n      <div class=\"star-rating\">\n        <div id=\"stars\">\n          ", "\n        </div>\n        <div id=\"rating\">\n          <h2>", " (", "/", ")</h2>\n        </div>\n      </div>\n    "])), this.renderStar(this.numStars, this.interactive), this._calPercent, this.score, this.possible);
      }
    }, {
      key: "renderStar",
      value: function renderStar(amount, interactive) {
        if (amount === 0) {
          return (0, _index.html)(_templateObject2_a67173b0feb911eb8439e3eec9305af7 || (_templateObject2_a67173b0feb911eb8439e3eec9305af7 = babelHelpers.taggedTemplateLiteral([""])));
        }

        var count = 0;
        var content = [];

        while (count < amount) {
          if (count + 1 < amount * this._calPercent) {
            content.push((0, _index.html)(_templateObject3_a67173b0feb911eb8439e3eec9305af7 || (_templateObject3_a67173b0feb911eb8439e3eec9305af7 = babelHelpers.taggedTemplateLiteral(["<simple-icon-button\n            icon=\"star\"\n            dark\n            contrast=\"1\"\n            class=\"star\"\n            ?disabled=\"", "\"\n          ></simple-icon-button>"])), !interactive));
          } else if (amount * this._calPercent - (count + 1) < -0.01 && amount * this._calPercent - (count + 1) >= -0.5) {
            content.push((0, _index.html)(_templateObject4_a67173b0feb911eb8439e3eec9305af7 || (_templateObject4_a67173b0feb911eb8439e3eec9305af7 = babelHelpers.taggedTemplateLiteral(["<simple-icon-button\n            icon=\"star-half\"\n            dark\n            contrast=\"1\"\n            class=\"star\"\n            ?disabled=\"", "\"\n          ></simple-icon-button>"])), !interactive));
          } else {
            content.push((0, _index.html)(_templateObject5_a67173b0feb911eb8439e3eec9305af7 || (_templateObject5_a67173b0feb911eb8439e3eec9305af7 = babelHelpers.taggedTemplateLiteral(["<simple-icon-button\n            icon=\"star-border\"\n            dark\n            contrast=\"1\"\n            class=\"star\"\n            ?disabled=\"", "\"\n          ></simple-icon-button>"])), !interactive));
          }

          count++;
        }

        return content;
      }
      /**
       * LitElement Life-cycle - https://lit.dev/docs/components/lifecycle/#reactive-update-cycle-completing
       */

    }, {
      key: "updated",
      value: function updated(changedProperties) {
        var _this2 = this;

        // run through properties that have changed in this change record. Probably just 1 but at initial setup
        // it could be all of them at the same time
        changedProperties.forEach(function (oldValue, propName) {
          // check for score and possible being changed
          // also sanity check that it's NOT 0 so we don't bust our Math via division by 0
          // https://stackoverflow.com/questions/6137986/javascript-roundoff-number-to-nearest-0-5
          if (["score", "possible"].includes(propName) && _this2.possible !== 0) {
            // this way when score or possible update, numStars will update automatically
            _this2._calPercent = Math.round(_this2.score / _this2.possible * 100) / 100;
          }
        });
      }
    }], [{
      key: "styles",
      get: // #star-rating I'd make something like .wrapper
      // the ID is confusing bc it's the name of the element itself
      // #rating and #stars and #star I'd make classes like .rating and .stars (stylistic / convention, and also a11y)
      // while #star works as an id and probably renders how you were looking for, this is an a11y issue because every renderRoot can only have 1 id value the same
      // avoiding this pitfall (accidentally using same id twice) is often why I use classes so that I never run into that
      // and then only if I absolutely am doing it for a reason do I use an id
      // padding-left: 20px I'd make a css variable so it can be overidden
      // h2 { margin:0} I'd also make a vss variable
      // also keep in mind headings can be impacted by global font-size, font-weight and line-height
      function get() {
        return (0, _index.css)(_templateObject6_a67173b0feb911eb8439e3eec9305af7 || (_templateObject6_a67173b0feb911eb8439e3eec9305af7 = babelHelpers.taggedTemplateLiteral(["\n      :host {\n        display: block;\n        padding: 25px;\n        color: var(--star-rating-text-color, #000);\n      }\n      #star-rating {\n        display: inline-flex;\n      }\n      .star {\n        background-color: black;\n      }\n      #rating {\n        padding-left: 20px; //responsive sizes weren't working well\n      }\n      h2 {\n        margin: 0; //keeps them both on the same line\n      }\n      :host(:not([interactive])) simple-icon-button::part(button) {\n        cursor: unset;\n      }\n    "])));
      } // wasnt sure how to allow for changes in number
      // maybe make it a form to allow input?
      // rename this as the capital is a more React-ism convention
      // think of these as attributes living in the page far as how we implement them
      // so <star-rating number="4"> for example
      // I might think of it as a kind of score and possible value
      // then the number of stars is a rounded number that's computed from there

    }, {
      key: "properties",
      get: function get() {
        return {
          score: {
            type: Number
          },
          // so like <star-rating score="50" possible="100">
          possible: {
            type: Number
          },
          interactive: {
            type: Boolean,
            reflect: true
          },
          numStars: {
            type: Number,
            attribute: "num-stars"
          },
          _calPercent: {
            type: Number
          } // this value we'll calculate based on changes to score and possible

        };
      }
    }]);
    return StarRating;
  }(_index.LitElement);

  _exports.StarRating = StarRating;
  customElements.define("star-rating", StarRating);
});