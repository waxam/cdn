define(["exports","require","../../lit-element/lit-element.js","../simple-colors/simple-colors.js","../utils/utils.js"],function(_exports,_require,_litElement,_simpleColors,_utils){"use strict";Object.defineProperty(_exports,"__esModule",{value:!0});_exports.HaxBody=void 0;_require=babelHelpers.interopRequireWildcard(_require);function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);if(enumerableOnly)symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable});keys.push.apply(keys,symbols)}return keys}function _objectSpread(target){for(var i=1,source;i<arguments.length;i++){source=null!=arguments[i]?arguments[i]:{};if(i%2){ownKeys(Object(source),!0).forEach(function(key){babelHelpers.defineProperty(target,key,source[key])})}else if(Object.getOwnPropertyDescriptors){Object.defineProperties(target,Object.getOwnPropertyDescriptors(source))}else{ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key))})}}return target}function _templateObject2_649212307ae711ea9f6d454984daed83(){var data=babelHelpers.taggedTemplateLiteral(["\n      <div id=\"bodycontainer\" class=\"ignore-activation\">\n        <slot id=\"body\"></slot>\n      </div>\n      <hax-text-context\n        id=\"textcontextmenu\"\n        class=\"hax-context-menu ignore-activation\"\n      ></hax-text-context>\n      <hax-ce-context\n        id=\"cecontextmenu\"\n        class=\"hax-context-menu ignore-activation\"\n      ></hax-ce-context>\n      <hax-plate-context\n        id=\"platecontextmenu\"\n        class=\"hax-context-menu ignore-activation\"\n      ></hax-plate-context>\n    "]);_templateObject2_649212307ae711ea9f6d454984daed83=function _templateObject2_649212307ae711ea9f6d454984daed83(){return data};return data}function _templateObject_649212307ae711ea9f6d454984daed83(){var data=babelHelpers.taggedTemplateLiteral(["\n        :host,\n        :host * ::slotted(*) {\n          line-height: 1.8;\n        }\n        :host ul,\n        :host * ::slotted(ul),\n        :host ol,\n        :host * ::slotted(ol) {\n          padding-left: 20px;\n          margin-left: 20px;\n        }\n        :host ul,\n        :host * ::slotted(ul) {\n          list-style-type: disc;\n        }\n        :host li,\n        :host * ::slotted(li) {\n          margin-bottom: 6px;\n        }\n        :host {\n          display: block;\n          position: relative;\n          min-height: 32px;\n          min-width: 32px;\n          outline: none;\n          --hax-contextual-action-text-color: var(\n            --simple-colors-default-theme-grey-1,\n            #fff\n          );\n          --hax-contextual-action-hover-color: var(\n            --simple-colors-default-theme-cyan-7,\n            #009dc7\n          );\n          --hax-contextual-action-color: var(\n            --simple-colors-default-theme-cyan-8,\n            #007999\n          );\n          --hax-body-editable-outline: 1px solid\n            var(--simple-colors-default-theme-deep-orange, #ff8a64);\n          --hax-body-active-outline-hover: 1px solid\n            var(\n              --hax-contextual-action-hover-color,\n              var(--simple-colors-default-theme-cyan-7, #009dc7)\n            );\n          --hax-body-active-outline: 3px solid\n            var(\n              --hax-contextual-action-hover-color,\n              var(--simple-colors-default-theme-cyan-7, #009dc7)\n            );\n          --hax-body-target-background-color: var(\n            --simple-colors-default-theme-cyan-2,\n            #9beaff\n          );\n          --hax-body-possible-target-background-color: var(\n            --simple-colors-default-theme-grey-2,\n            #dddddd;\n          );\n        }\n        .hax-context-menu {\n          padding: 0;\n          margin-left: -5000px;\n          position: fixed;\n          visibility: hidden;\n          opacity: 0;\n          z-index: 1000;\n          float: left;\n          display: block;\n          pointer-events: none;\n          transition: 0.2s top ease-in-out, 0.2s left ease-in-out,\n            0.2s visibility ease-in-out, 0.2s opacity ease-in-out;\n        }\n        #textcontextmenu.hax-context-menu {\n          z-index: 1000;\n        }\n        .hax-context-visible {\n          position: absolute;\n          visibility: visible;\n          pointer-events: all;\n          opacity: 1;\n        }\n        .hax-context-visible.hax-active-hover {\n          margin-left: unset;\n        }\n        :host #bodycontainer ::slotted(h1) {\n          font-size: var(--hax-base-styles-h1-font-size, 2.5em);\n          line-height: var(--hax-base-styles-h1-line-height, 2.5em);\n        }\n        :host #bodycontainer ::slotted(h2) {\n          font-size: var(--hax-base-styles-h2-font-size, 2em);\n        }\n        :host #bodycontainer ::slotted(h3) {\n          font-size: var(--hax-base-styles-h3-font-size, 1.75em);\n        }\n        :host #bodycontainer ::slotted(h4) {\n          font-size: var(--hax-base-styles-h4-font-size, 1.5em);\n        }\n        :host #bodycontainer ::slotted(h5) {\n          font-size: var(--hax-base-styles-h5-font-size, 1.25em);\n        }\n        :host #bodycontainer ::slotted(h6) {\n          font-size: var(--hax-base-styles-h6-font-size, 1.25em);\n        }\n        :host #bodycontainer ::slotted(p) {\n          min-height: var(--hax-base-styles-p-min-height, 43px);\n          font-size: var(--hax-base-styles-p-font-size, 24px);\n          line-height: var(--hax-base-styles-p-line-height, 1.8);\n          letter-spacing: var(--hax-base-styles-p-letter-spacing, 0.5px);\n        }\n        :host #bodycontainer ::slotted(a) {\n          color: var(\n            --hax-base-styles-a-color,\n            var(--simple-colors-default-theme-grey-12, #000)\n          );\n          font-size: var(--hax-base-styles-a-font-size, 24px);\n          font-weight: var(--hax-base-styles-a-font-weight, normal);\n        }\n        :host #bodycontainer ::slotted(a:visited) {\n          color: var(\n            --hax-base-styles-a-color-visited,\n            var(--simple-colors-default-theme-light-blue, #007ffc)\n          );\n        }\n        :host #bodycontainer ::slotted(a:active),\n        :host #bodycontainer ::slotted(a:focus),\n        :host #bodycontainer ::slotted(a:hover) {\n          color: var(\n            --hax-base-styles-a-color-active,\n            var(--simple-colors-default-theme-light-blue, #007ffc)\n          );\n          font-weight: var(--hax-base-styles-a-font-weight-active, normal);\n        }\n        :host #bodycontainer ::slotted(ol),\n        :host #bodycontainer ::slotted(ul),\n        :host #bodycontainer ::slotted(li) {\n          padding-bottom: var(--hax-base-styles-list-padding-bottom, 1.5em);\n          line-height: var(--hax-base-styles-list-line-height, 40px);\n          font-size: var(--hax-base-styles-list-font-size, 24px);\n          max-width: var(--hax-base-styles-list-max-width, 28em);\n        }\n        :host #bodycontainer ::slotted(ol > li:last-child),\n        :host #bodycontainer ::slotted(ul > li:last-child) {\n          padding-bottom: var(\n            --hax-base-styles-list-last-child-padding-bottom,\n            1em\n          );\n        }\n        :host #bodycontainer ::slotted(ul),\n        :host #bodycontainer ::slotted(ol) {\n          padding-left: var(--hax-base-styles-list-padding-left, 20px);\n          padding-left: var(--hax-base-styles-list-margin-left, 20px);\n        }\n\n        :host([edit-mode]) #bodycontainer ::slotted(*[data-editable]) {\n          outline: none;\n          caret-color: var(--hax-color-text);\n        }\n        :host([edit-mode])\n          #bodycontainer\n          ::slotted(*:not(grid-plate)[data-editable]:hover) {\n          outline: var(--hax-body-active-outline-hover);\n          caret-color: #000000;\n        }\n        :host([edit-mode])\n          #bodycontainer\n          ::slotted(*.hax-active[data-editable]:hover) {\n          cursor: text !important;\n          outline: var(--hax-body-active-outline-hover);\n        }\n        :host([edit-mode])\n          #bodycontainer\n          ::slotted(*:not(grid-plate)[data-editable] .hax-active:hover) {\n          cursor: text !important;\n          outline: var(--hax-body-active-outline-hover);\n        }\n        :host([edit-mode])\n          #bodycontainer\n          ::slotted(code.hax-active[data-editable]) {\n          display: block;\n        }\n        :host([edit-mode])\n          #bodycontainer\n          ::slotted(*.hax-active[data-editable]) {\n          outline: var(--hax-body-active-outline) !important;\n        }\n        :host([edit-mode]) #bodycontainer ::slotted(hr[data-editable]) {\n          height: 2px;\n          background-color: #eeeeee;\n          padding-top: 4px;\n          padding-bottom: 4px;\n        }\n        /** Fix to support safari as it defaults to none */\n        :host([edit-mode]) #bodycontainer ::slotted(*[data-editable]) {\n          -webkit-user-select: text;\n          cursor: pointer;\n        }\n\n        :host([edit-mode])\n          #bodycontainer\n          ::slotted(*[data-editable]::-moz-selection),\n        :host([edit-mode])\n          #bodycontainer\n          ::slotted(*[data-editable] *::-moz-selection) {\n          background-color: var(--hax-body-highlight, --paper-yellow-300);\n          color: black;\n        }\n        :host([edit-mode])\n          #bodycontainer\n          ::slotted(*[data-editable]::selection),\n        :host([edit-mode])\n          #bodycontainer\n          ::slotted(*[data-editable] *::selection) {\n          background-color: var(--hax-body-highlight, --paper-yellow-300);\n          color: black;\n        }\n        #bodycontainer {\n          -webkit-user-select: text;\n          user-select: text;\n        }\n        :host([edit-mode][hax-ray-mode])\n          #bodycontainer\n          ::slotted(*[data-editable]):before {\n          content: attr(data-hax-ray) \" \" attr(resource) \" \" attr(typeof) \" \"\n            attr(property) \" \" attr(content);\n          font-size: 12px;\n          line-height: 12px;\n          left: unset;\n          right: unset;\n          top: unset;\n          background-color: var(--simple-colors-default-theme-cyan-7, #3b97e3);\n          color: #ffffff;\n          bottom: unset;\n          width: auto;\n          padding: 6px;\n          margin: -2px;\n          z-index: 1;\n          margin: 0;\n          float: right;\n        }\n        /* drag and drop */\n        :host([edit-mode]) #bodycontainer ::slotted(*.hax-mover):before {\n          outline: var(--hax-body-editable-outline);\n          background-color: var(--hax-body-possible-target-background-color);\n          content: \" \";\n          width: 100%;\n          display: block;\n          position: relative;\n          margin: -30px 0 0 0;\n          z-index: 2;\n          height: 30px;\n        }\n        :host([edit-mode]) #bodycontainer ::slotted(*.hax-moving) {\n          outline: var(--hax-body-active-outline);\n          background-color: #eeeeee;\n        }\n        :host([edit-mode]) #bodycontainer ::slotted(*.hax-hovered):before {\n          background-color: var(--hax-body-target-background-color) !important;\n          outline: var(--hax-body-active-outline);\n        }\n        .hax-context-menu:not(:defined) {\n          display: none;\n        }\n      "]);_templateObject_649212307ae711ea9f6d454984daed83=function _templateObject_649212307ae711ea9f6d454984daed83(){return data};return data}// variables required as part of the gravity drag and scroll
var gravityScrollTimer=null,maxStep=25,edgeSize=100,HaxBody=/*#__PURE__*/function(_SimpleColors){babelHelpers.inherits(HaxBody,_SimpleColors);babelHelpers.createClass(HaxBody,null,[{key:"styles",/**
   * LitElement constructable styles enhancement
   */get:function get(){return[].concat(babelHelpers.toConsumableArray(babelHelpers.get(babelHelpers.getPrototypeOf(HaxBody),"styles",this)),[(0,_litElement.css)(_templateObject_649212307ae711ea9f6d454984daed83())])}/**
   * HTMLElement
   */}]);function HaxBody(){var _this;babelHelpers.classCallCheck(this,HaxBody);_this=babelHelpers.possibleConstructorReturn(this,babelHelpers.getPrototypeOf(HaxBody).call(this));// lock to ensure we don't flood events on hitting the up / down arrows
// as we use a mutation observer to manage draggable bindings
_this.___moveLock=!1;_this.editMode=!1;_this.globalPreferences={};// xray goggles for tags visualized in context, developer thing
_this.haxRayMode=!1;_this.activeNode=null;_this.haxSelectedText="";_this.activeContainerNode=null;setTimeout(function(){new Promise(function(res,rej){return _require.default(["./lib/hax-text-context.js"],res,rej)});new Promise(function(res,rej){return _require.default(["./lib/hax-ce-context.js"],res,rej)});new Promise(function(res,rej){return _require.default(["./lib/hax-plate-context.js"],res,rej)});new Promise(function(res,rej){return _require.default(["../grid-plate/grid-plate.js"],res,rej)});_this.polyfillSafe=window.HaxStore.instance.computePolyfillSafe();_this.addEventListener("hax-context-item-selected",_this._haxContextOperation.bind(babelHelpers.assertThisInitialized(_this)));_this.addEventListener("place-holder-replace",_this.replacePlaceholder.bind(babelHelpers.assertThisInitialized(_this)));_this.addEventListener("focusin",_this._focusIn.bind(babelHelpers.assertThisInitialized(_this)));_this.addEventListener("mousedown",_this._focusIn.bind(babelHelpers.assertThisInitialized(_this)));_this.addEventListener("dragenter",_this.dragEnterBody.bind(babelHelpers.assertThisInitialized(_this)));_this.addEventListener("drop",_this.dropEvent.bind(babelHelpers.assertThisInitialized(_this)))},0);return _this}babelHelpers.createClass(HaxBody,[{key:"dragEnterBody",/**
   * Activation allowed from outside this grid as far as drop areas
   */value:function dragEnterBody(e){var children=this.childNodes;// walk the children and apply the draggable state needed
for(var i in children){if(children[i].classList&&children[i]!==this.activeItem){children[i].classList.add("hax-mover")}}}/**
   * LitElement render
   */},{key:"render",value:function render(){return(0,_litElement.html)(_templateObject2_649212307ae711ea9f6d454984daed83())}/**
   * LitElement / popular convention
   */},{key:"firstUpdated",/**
   * LitElement life cycle - ready
   */value:function firstUpdated(changedProperties){var _this2=this;this.dispatchEvent(new CustomEvent("hax-register-body",{bubbles:!0,cancelable:!0,composed:!0,detail:this}));// try to normalize paragraph insert on enter
try{document.execCommand("enableObjectResizing",!1,!1);document.execCommand("defaultParagraphSeparator",!1,"p")}catch(e){console.warn(e)}this.shadowRoot.querySelector("slot").addEventListener("mousemove",this.hoverEvent.bind(this));this.shadowRoot.querySelector("slot").addEventListener("mouseup",function(e){if(!_this2.openDrawer&&_this2.editMode){setTimeout(function(){var tmp=window.HaxStore.getSelection();window.HaxStore._tmpSelection=tmp;window.HaxStore.write("haxSelectedText",tmp.toString(),_this2);try{var range=window.HaxStore.getRange();if(range.cloneRange){window.HaxStore._tmpRange=range.cloneRange()}}catch(e){console.warn(e)}},10)}});// in case we miss this on the initial setup. possible in auto opening environments.
this.editMode=window.HaxStore.instance.editMode;// ensure this resets every append
this.__tabTrap=!1;this.__ready=!0}/**
   * LitElement life cycle - properties changed callback
   */},{key:"updated",value:function updated(changedProperties){var _this3=this;changedProperties.forEach(function(oldValue,propName){if("editMode"==propName){_this3._editModeChanged(_this3[propName],oldValue)}if("globalPreferences"==propName){_this3._globalPreferencesUpdated(_this3[propName],oldValue)}if("activeNode"==propName&&_this3.__ready){_this3._activeNodeChanged(_this3[propName],oldValue);// notify
_this3.dispatchEvent(new CustomEvent("active-node-changed",{detail:{value:_this3[propName]}}))}if("activeContainerNode"==propName&&_this3.__ready){_this3._activeContainerNodeChanged(_this3[propName],oldValue);// notify
_this3.dispatchEvent(new CustomEvent("active-container-node-changed",{detail:{value:_this3[propName]}}))}})}/**
   * HTMLElement
   */},{key:"connectedCallback",value:function connectedCallback(){var _this4=this;babelHelpers.get(babelHelpers.getPrototypeOf(HaxBody.prototype),"connectedCallback",this).call(this);// mutation observer that ensures state of hax applied correctly
this._observer=new MutationObserver(function(mutations){var mutFind=!1;mutations.forEach(function(mutation){// if we've got new nodes, we have to react to that
if(0<mutation.addedNodes.length){mutation.addedNodes.forEach(function(node){if(_this4._validElementTest(node)){// edge case, thing is moved around in the dom so let's do the opposite
// this is something that has PART of these applies
// let's make sure that we maintain state associated with contenteditable
if(_this4.editMode&&("true"==node.getAttribute("contenteditable")||!0===node.getAttribute("contenteditable")||"contenteditable"==node.getAttribute("contenteditable"))){_this4.__applyNodeEditableState(node,!_this4.editMode)}_this4.__applyNodeEditableState(node,_this4.editMode);_this4.dispatchEvent(new CustomEvent("hax-body-tag-added",{bubbles:!0,cancelable:!0,composed:!0,detail:{node:node}}));// special support for Header tags showing up w.o. identifiers
// this way it's easier to anchor to them in the future
if(["H1","H2","H3","H4","H5","H6"].includes(node.tagName)&&null==node.getAttribute("id")){node.setAttribute("id",(0,_utils.generateResourceID)("header-"))}// set new nodes to be the active one
// only if we didn't just do a grid plate move
// if multiple mutations, only accept the 1st one in a group
if(!_this4.___moveLock&&!mutFind){mutFind=!0;_this4.activeNode=node;window.HaxStore.write("activeNode",node,_this4)}else{_this4.___moveLock=!1}}})}// if we dropped nodes via the UI (delete event basically)
if(0<mutation.removedNodes.length){// handle removing items... not sure we need to do anything here
mutation.removedNodes.forEach(function(node){if(_this4._validElementTest(node)&&!node.classList.contains("hax-active")){_this4.dispatchEvent(new CustomEvent("hax-body-tag-removed",{bubbles:!0,cancelable:!0,composed:!0,detail:{node:node}}))}})}})});this._observer.observe(this,{childList:!0});setTimeout(function(){window.addEventListener("keydown",_this4._onKeyDown.bind(_this4));window.addEventListener("keypress",_this4._onKeyPress.bind(_this4));document.body.addEventListener("hax-store-property-updated",_this4._haxStorePropertyUpdated.bind(_this4));window.addEventListener("scroll",_this4._keepContextVisible.bind(_this4));window.addEventListener("resize",_this4._keepContextVisible.bind(_this4))},0)}/**
   * HTMLElement
   */},{key:"disconnectedCallback",value:function disconnectedCallback(){window.removeEventListener("keydown",this._onKeyDown.bind(this));window.removeEventListener("keypress",this._onKeyPress.bind(this));document.body.removeEventListener("hax-store-property-updated",this._haxStorePropertyUpdated.bind(this));window.removeEventListener("scroll",this._keepContextVisible.bind(this));window.removeEventListener("resize",this._keepContextVisible.bind(this));this._observer.disconnect();babelHelpers.get(babelHelpers.getPrototypeOf(HaxBody.prototype),"disconnectedCallback",this).call(this)}/**
   * Keep the context menu visible if needed
   */},{key:"_keepContextVisible",value:function _keepContextVisible(){var _this5=this,e=0<arguments.length&&arguments[0]!==void 0?arguments[0]:null;if(!this.openDrawer&&this.editMode){clearTimeout(this.__contextVisibleLock);this.__contextVisibleLock=setTimeout(function(){// see if the text context menu is visible
var el=!1;if(_this5.shadowRoot.querySelector("#textcontextmenu").classList.contains("hax-context-visible")){el=_this5.shadowRoot.querySelector("#textcontextmenu")}else if(_this5.shadowRoot.querySelector("#cecontextmenu").classList.contains("hax-context-visible")){el=_this5.shadowRoot.querySelector("#cecontextmenu")}// if we see it, ensure we don't have the pin
if(el){if(_this5.elementMidViewport()){el.classList.add("hax-context-pin-top");_this5.shadowRoot.querySelector("#platecontextmenu").classList.add("hax-context-pin-top")}else{el.classList.remove("hax-context-pin-top");_this5.shadowRoot.querySelector("#platecontextmenu").classList.remove("hax-context-pin-top")}_this5.positionContextMenus()}},50)}}},{key:"_onKeyDown",value:function _onKeyDown(e){var _this6=this;if(!this.openDrawer&&this.editMode&&this.getAttribute("contenteditable")){var sel=window.HaxStore.getSelection();if(null!=sel.anchorNode){switch(e.key){case"Tab":if(window.HaxStore.instance.isTextElement(this.activeNode)){if(e.detail.keyboardEvent){e.detail.keyboardEvent.preventDefault();e.detail.keyboardEvent.stopPropagation();e.detail.keyboardEvent.stopImmediatePropagation()}e.preventDefault();e.stopPropagation();e.stopImmediatePropagation();if(e.shiftKey){this._tabBackKeyPressed()}else{this._tabKeyPressed()}}break;case"Enter":this.setAttribute("contenteditable",!0);case"Backspace":case"Delete":case"ArrowUp":case"ArrowDown":case"ArrowLeft":case"ArrowRight":clearTimeout(this.__keyPress);this.__keyPress=setTimeout(function(){var tmp=window.HaxStore.getSelection();window.HaxStore._tmpSelection=tmp;window.HaxStore.write("haxSelectedText",tmp.toString(),_this6);var rng=window.HaxStore.getRange();if(rng.commonAncestorContainer&&_this6.activeNode!==rng.commonAncestorContainer&&"function"===typeof rng.commonAncestorContainer.focus){if("HAX-BODY"!==rng.commonAncestorContainer.tagName){if(window.HaxStore.instance.isTextElement(rng.commonAncestorContainer)){_this6.setAttribute("contenteditable",!0)}else{_this6.removeAttribute("contenteditable")}rng.commonAncestorContainer.focus();_this6.__focusLogic(rng.commonAncestorContainer)}}// need to check on the parent too if this was a text node
else if(rng.commonAncestorContainer&&rng.commonAncestorContainer.parentNode&&_this6.activeNode!==rng.commonAncestorContainer.parentNode&&"function"===typeof rng.commonAncestorContainer.parentNode.focus){if("HAX-BODY"!==rng.commonAncestorContainer.parentNode.tagName){if(window.HaxStore.instance.isTextElement(rng.commonAncestorContainer.parentNode)){_this6.setAttribute("contenteditable",!0)}else{_this6.removeAttribute("contenteditable")}rng.commonAncestorContainer.parentNode.focus();_this6.__focusLogic(rng.commonAncestorContainer.parentNode)}else{_this6.activeNode=rng.commonAncestorContainer;_this6.activeContainerNode=_this6.activeNode;window.HaxStore.write("activeNode",rng.commonAncestorContainer,_this6);window.HaxStore.write("activeContainerNode",rng.commonAncestorContainer,_this6);setTimeout(function(){_this6.positionContextMenus()},0)}}else{}},50);break;}if(this.shadowRoot.querySelector("#platecontextmenu").classList.contains("hax-active-hover")){this.__dropActiveHover()}}}}},{key:"_onKeyPress",value:function _onKeyPress(e){var _this7=this;clearTimeout(this.__keyPress);this.__keyPress=setTimeout(function(){if(!_this7.openDrawer&&_this7.editMode&&_this7.shadowRoot.querySelector("#textcontextmenu").classList.contains("hax-active-hover")&&_this7.activeNode&&window.HaxStore.instance.isTextElement(_this7.activeNode)){_this7.__dropActiveHover()}else if(!_this7.openDrawer&&_this7.editMode&&_this7.activeNode&&window.HaxStore.instance.isTextElement(_this7.activeNode)){// If the user has paused for awhile, show the menu
clearTimeout(_this7.__positionContextTimer);_this7.__positionContextTimer=setTimeout(function(){// always on active if we were just typing
_this7.positionContextMenus()},1500)}},50)}/**
   * on mouse over then fire the hax ray value if we have one
   */},{key:"hoverEvent",value:function hoverEvent(e){if(!this.openDrawer&&this.editMode){if(e.target&&null!=e.target.getAttribute("data-hax-ray")){this.__activeHover=e.target}else if(e.target&&e.target.parentNode&&null!=e.target.parentNode.getAttribute("data-hax-ray")){this.__activeHover=e.target.parentNode}if(!this.shadowRoot.querySelector("#platecontextmenu").classList.contains("hax-active-hover")){var local=e.target;// see if the target is relevent when showing the edit menu operations
if(e.target===this.shadowRoot.querySelector("#cecontextmenu")||e.target===this.shadowRoot.querySelector("#textcontextmenu")||e.target===this.shadowRoot.querySelector("#platecontextmenu")||local===this.activeNode||local===this.activeContainerNode||e.target===this.activeNode||e.target===this.activeContainerNode||local.parentNode===this.activeContainerNode||local.parentNode.parentNode===this.activeContainerNode||local.parentNode.parentNode.parentNode===this.activeContainerNode){this.positionContextMenus();this.__addActiveHover();this.__typeLock=!1}else{this.__dropActiveHover()}}}}},{key:"__addActiveHover",value:function __addActiveHover(){this.shadowRoot.querySelector("#cecontextmenu").classList.add("hax-active-hover");this.shadowRoot.querySelector("#textcontextmenu").classList.add("hax-active-hover");this.shadowRoot.querySelector("#platecontextmenu").classList.add("hax-active-hover")}},{key:"__dropActiveHover",value:function __dropActiveHover(){this.shadowRoot.querySelector("#cecontextmenu").classList.remove("hax-active-hover");this.shadowRoot.querySelector("#textcontextmenu").classList.remove("hax-active-hover");this.shadowRoot.querySelector("#platecontextmenu").classList.remove("hax-active-hover")}/**
   * Only true if we are scrolling and part way through an element
   */},{key:"elementMidViewport",value:function elementMidViewport(){var y=this.activeNode.getBoundingClientRect().y;return 0>y&&y>-1*this.activeNode.offsetHeight+140}/**
   * Replace place holder after an event has called for it in the element itself
   */},{key:"replacePlaceholder",value:function replacePlaceholder(e){var _this8=this;// generate a paragraph of text here on click
if("text"===e.detail){// make sure text just escalates to a paragraph tag
var p=document.createElement("p");p.innerHTML="<br/>";this.haxReplaceNode(this.activeNode,p);// allow swap out to happen
setTimeout(function(){// set active to this p tag
_this8.activeNode=p;window.HaxStore.write("activeNode",p,_this8);_this8.activeContainerNode.setAttribute("contenteditable",!0);// focus on it
p.focus();_this8.__focusLogic(p)},210)}else{this.replaceElementWorkflow()}}},{key:"canTansformNode",value:function canTansformNode(){var node=0<arguments.length&&arguments[0]!==void 0?arguments[0]:null;return 0<this.replaceElementWorkflow(node,!0).length?!0:!1}/**
   * Whole workflow of replacing something in place contextually.
   * This can fire for things like events needing this workflow to
   * invoke whether it's a "convert" event or a "replace placeholder" event
   */},{key:"replaceElementWorkflow",value:function replaceElementWorkflow(){var activeNode=0<arguments.length&&arguments[0]!==void 0?arguments[0]:null,testOnly=1<arguments.length&&arguments[1]!==void 0?arguments[1]:!1;// support for tests with things other than activeNode
if(null==activeNode){activeNode=this.activeNode}var element=window.HaxStore.nodeToHaxElement(activeNode,null),type="*",skipPropMatch=!1;// special support for place holder which defines exactly
// what the user wants this replaced with
if("place-holder"===element.tag&&babelHelpers.typeof(element.properties.type)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){type=element.properties.type;skipPropMatch=!0}var props={};// see if we have a gizmo as it's not a requirement to registration
// as well as having handlers since mapping is not required either
if(babelHelpers.typeof(window.HaxStore.instance.elementList[element.tag])!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))&&!1!==window.HaxStore.instance.elementList[element.tag].gizmo&&babelHelpers.typeof(window.HaxStore.instance.elementList[element.tag].gizmo.handles)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))&&0<window.HaxStore.instance.elementList[element.tag].gizmo.handles.length){// get the haxProperties for this item
// walk through each handler
for(var gizmo=window.HaxStore.instance.elementList[element.tag].gizmo,i=0;i<gizmo.handles.length;i++){// walk the properties defined as they would be to the
// left side of the ledger and tell us which property to
// mesh with. This effectively rehydrates / inverts that
// relationship where we have an element and want to say
// "oh ya, but what could have handled this" so that we
// can use that translation to offer up convertion to a
// new element. This is insane.
for(var prop in gizmo.handles[i]){// type is a reserved handler but any other property
// which we actually have in our element let's go for it
if("type"!==prop&&babelHelpers.typeof(element.properties[gizmo.handles[i][prop]])!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){// The cake is a lie... oh wait... no it's not.
// This will completely bend your mind when it comes to
// what HTML is, how it should operate and what universe
// we can now contort as a result. This effectively allows
// reverse engineering any element on the page into any
// other compatible element based on the properties in
// each element claiming to be compatible.
props[prop]=element.properties[gizmo.handles[i][prop]]}}}}var haxElements=window.HaxStore.guessGizmo(type,props,skipPropMatch);// see if we got anything
if(0<haxElements.length){// hand off to hax-app-picker to deal with the rest of this
var tag=activeNode.tagName.toLowerCase(),humanName=tag.replace("-"," ");if(babelHelpers.typeof(window.HaxStore.instance.elementList[tag])!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))&&!1!==window.HaxStore.instance.elementList[tag].gizmo){humanName=window.HaxStore.instance.elementList[tag].gizmo.title}if(!testOnly){window.HaxStore.instance.activePlaceHolder=this.activeNode;window.HaxStore.instance.haxAppPicker.presentOptions(haxElements,"__convert","Transform ".concat(humanName," to.."),"gizmo")}}else{if(!testOnly){window.HaxStore.toast("Sorry, this can not be transformed!",5e3)}}return haxElements}/**
   * Global prefs updated, let's visualize stuff from hax-ray
   */},{key:"_globalPreferencesUpdated",value:function _globalPreferencesUpdated(newValue,oldValue){if(babelHelpers.typeof(newValue)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))&&null!=newValue){this.haxRayMode=newValue.haxRayMode}}/**
   * Store updated, sync.
   */},{key:"_haxStorePropertyUpdated",value:function _haxStorePropertyUpdated(e){if(e.detail&&babelHelpers.typeof(e.detail.value)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))&&e.detail.property){this[e.detail.property]=e.detail.value}}/**
   * Clear area.
   */},{key:"haxClearBody",value:function haxClearBody(){var confirm=0<arguments.length&&arguments[0]!==void 0?arguments[0]:!0,status=!0;// only confirm if asked so we can support wipes without it
if(confirm){status=prompt("Are you sure you want to delete all content?")}// ensure they said yes
if(status){(0,_utils.wipeSlot)(this)}}/**
   * Insert new tag + content into the local DOM as a node.
   */},{key:"haxInsert",value:function haxInsert(tag,content){var _this9=this,properties=2<arguments.length&&arguments[2]!==void 0?arguments[2]:{};this.__activeHover=null;// verify this tag is a valid one
// create a new element fragment w/ content in it
// if this is a custom-element it won't expand though
var frag=document.createElement(tag);// set text forcibly
//frag.innerText = content;
// now set html forcibly which would overwrite the other one
frag.innerHTML=content;// clone the fragment which will force an escalation to full node
var newNode=frag.cloneNode(!0);// support for properties if they exist
for(var property in properties){var attributeName=window.HaxStore.camelToDash(property);if(properties.hasOwnProperty(property)){// special supporting for boolean because html is weird :p
if(!0===properties[property]){newNode.setAttribute(attributeName,attributeName)}else if(!1===properties[property]){newNode.removeAttribute(attributeName)}else if(null!=properties[property]&&properties[property].constructor===Array){if(newNode.properties&&newNode.properties[property].readOnly){}else{if(newNode.set){newNode.set(attributeName,properties[property])}else{newNode[attributeName]=properties[property]}}}else if(null!=properties[property]&&properties[property].constructor===Object){if(newNode.properties&&newNode.properties[property].readOnly){}else{if(newNode.set){newNode.set(attributeName,properties[property])}else{newNode[attributeName]=properties[property]}}}else{newNode.setAttribute(attributeName,properties[property])}}}// special support for a drag and drop into a place-holder tag
// as this is a more aggressive operation then the others
if(null!==window.HaxStore.instance.activePlaceHolder&&babelHelpers.typeof(window.HaxStore.instance.activePlaceHolder.style)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){// replicate styles so that it doesn't jar the UI
newNode.style.width=window.HaxStore.instance.activePlaceHolder.style.width;newNode.style.float=window.HaxStore.instance.activePlaceHolder.style.float;newNode.style.margin=window.HaxStore.instance.activePlaceHolder.style.margin;newNode.style.display=window.HaxStore.instance.activePlaceHolder.style.display;this.haxReplaceNode(window.HaxStore.instance.activePlaceHolder,newNode);window.HaxStore.instance.activePlaceHolder=null}// insert at active insert point if we have one
else if(null!=this.activeContainerNode){// allow for inserting things into things but not grid plate
if("GRID-PLATE"===this.activeContainerNode.tagName&&this.activeContainerNode!==this.activeNode){if(null!=this.activeNode.getAttribute("slot")){newNode.setAttribute("slot",this.activeNode.getAttribute("slot"))}if(this.activeNode.parentNode==this.activeContainerNode){this.activeContainerNode.insertBefore(newNode,this.activeNode)}else{this.activeContainerNode.appendChild(newNode)}}else{if(this.activeContainerNode&&this.activeContainerNode.nextElementSibling){this.activeContainerNode.nextElementSibling.parentNode.insertBefore(newNode,this.activeContainerNode.nextElementSibling)}else if(this.activeContainerNode.parentNode){this.activeContainerNode.parentNode.insertBefore(newNode,this.activeContainerNode)}else if(this.activeNode.parentNode){this.activeNode.parentNode.insertBefore(newNode,this.activeNode)}else{// something odd happened let's just make sure we insert this safely
this.appendChild(newNode)}}}else{// send this into the root, which should filter it back down into the slot
this.appendChild(newNode)}this.shadowRoot.querySelector("#textcontextmenu").highlightOps=!1;this.activeContainerNode=newNode.parentNode;this.activeNode=newNode;window.HaxStore.write("activeContainerNode",newNode.parentNode,this);window.HaxStore.write("activeNode",newNode,this);// wait so that the DOM can have the node to then attach to
setTimeout(function(){// scroll to it
if("function"===typeof newNode.scrollIntoViewIfNeeded){newNode.scrollIntoViewIfNeeded(!0)}else{newNode.scrollIntoView({behavior:"smooth",inline:"center"})}_this9.positionContextMenus()},10);return!0}/**
   * Return the current hax content area as text that could be
   * inserted into something.
   */},{key:"haxToContent",value:function haxToContent(){this.hideContextMenus();var __active=this.activeNode;// null this to drop hax based classes
this.activeNode=null;this.activeContainerNode=null;window.HaxStore.write("activeNode",null,this);window.HaxStore.write("activeContainerNode",null,this);for(var children="slot"===this.shadowRoot.querySelector("#body").localName?this.shadowRoot.querySelector("#body").assignedNodes({flatten:!0}):[],content="",i=0,len=children.length;i<len;i++){// some mild front-end sanitization
if(this._validElementTest(children[i])){children[i].removeAttribute("data-editable");children[i].removeAttribute("data-hax-ray");// remove some of the protected classes though they shouldn't leak through
children[i].classList.remove("hax-mover","hax-moving","hax-hovered","grid-plate-active-item");children[i].contentEditable=!1;content+=window.HaxStore.nodeToContent(children[i]);if("grid-plate"===children[i].tagName.toLowerCase()){this._applyContentEditable(this.editMode,children[i])}}// keep comments with a special case since they need wrapped
else if(8===children[i].nodeType){content+="<!-- "+children[i].textContent+" -->"}// keep everything NOT an element at this point, this helps
// preserve whitespace because we're crazy about accuracy
else if(1!==children[i].nodeType&&babelHelpers.typeof(children[i].textContent)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))&&"undefined"!==children[i].textContent){content+=children[i].textContent}}// remove the contenteditable attribute
content=content.replace(/\scontenteditable=\"false\"/g,"");// remove the data-editable attribute
content=content.replace(/\sdata-editable=\"true\"/g,"");content=content.replace(/\sdata-editable=\"false\"/g,"");content=content.replace(/\sdata-editable=\""/g,"");// remove other attributes that can linger in slots
content=content.replace(/\sdata-editable/g,"");content=content.replace(/\scontenteditable/g,"");content=content.replace(/\sdraggable/g,"");// clean up stray hax-ray leftovers
content=content.replace(/\sdata-hax-ray=\".*?\"/g,"");// remove HAX specific classes / scoping classes
if(this.parentNode.tagName){var parentTag=this.parentNode.tagName.toLowerCase(),string="style-scope "+parentTag+" x-scope",re=new RegExp(string,"g");content=content.replace(re,"");// remove without the deeeper scope as well for primitives
string="style-scope "+parentTag;re=new RegExp(string,"g");content=content.replace(re,"");// remove the last common one unpacked
string="x-scope "+parentTag+"-0";re=new RegExp(string,"g");content=content.replace(re,"");// now all tags we have defined as valid
var tags=window.HaxStore.instance.validTagList;for(var i in tags){string="style-scope "+tags[i];re=new RegExp(string,"g");content=content.replace(re,"");string="x-scope "+tags[i]+"-0 ";re=new RegExp(string,"g");content=content.replace(re,"");string="x-scope "+tags[i]+"-0";re=new RegExp(string,"g");content=content.replace(re,"")}}// remove empty class structures
content=content.replace(/\sclass=\"\"/g,"");content=content.replace(/\sclass=\"\s\"/g,"");// re-apply contenteditable if needed
this._applyContentEditable(this.editMode);// set active again
window.HaxStore.write("activeNode",__active,this);window.HaxStore.write("activeContainerNode",__active,this);// oh one last thing. escape all script/style tags
content=(0,_utils.encapScript)(content);return content}/**
   * Duplicate node into the local DOM below the current item if we can.
   */},{key:"haxDuplicateNode",value:function haxDuplicateNode(node){var _this10=this,parent=1<arguments.length&&arguments[1]!==void 0?arguments[1]:this;// move the context menu before duplicating!!!!
this.hideContextMenus(!1);// convert the node to a hax element
var haxElement=window.HaxStore.nodeToHaxElement(node,null);// support for deep API call to clean up special elements
if(babelHelpers.typeof(node.preProcessHaxInsertContent)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){haxElement=node.preProcessHaxInsertContent(haxElement)}if(haxElement.content==haxElement.properties.innerHTML){delete haxElement.properties.innerHTML}// convert it back to a clone, seems odd I'm sure but this ensures that all props are copied
// correctly and that we get a brand new object
var nodeClone=window.HaxStore.haxElementToNode(haxElement.tag,haxElement.content,haxElement.properties);if("webview"===nodeClone.tagName.toLowerCase()&&window.HaxStore.instance._isSandboxed&&babelHelpers.typeof(nodeClone.guestinstance)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){delete nodeClone.guestinstance}// shouldn't be possible but might as well check
if(null!==node){parent.insertBefore(nodeClone,node.nextSibling)}else{parent.appendChild(nodeClone)}setTimeout(function(){// test for a grid plate clone
if(parent===_this10){window.HaxStore.write("activeContainerNode",nodeClone,_this10)}window.HaxStore.write("activeNode",nodeClone,_this10)},100);return!0}/**
   * Hide all context menus.
   */},{key:"hideContextMenus",value:function hideContextMenus(){var hidePlate=0<arguments.length&&arguments[0]!==void 0?arguments[0]:!0;// clear the timeouts for anything that could cause these to reapear
clearTimeout(gravityScrollTimer);clearTimeout(this.__keyPress);clearTimeout(this.__contextVisibleLock);clearTimeout(this.__positionContextTimer);// primary context menus
this._hideContextMenu(this.shadowRoot.querySelector("#textcontextmenu"));this._hideContextMenu(this.shadowRoot.querySelector("#cecontextmenu"));// secondary menus and clean up areas
if(hidePlate){this._hideContextMenu(this.shadowRoot.querySelector("#platecontextmenu"))}// force context menu state to closed
this.shadowRoot.querySelector("#textcontextmenu").highlightOps=!1}/**
   * Reposition context menus to match an element.
   */},{key:"positionContextMenus",value:function positionContextMenus(){var _this11=this,node=0<arguments.length&&arguments[0]!==void 0?arguments[0]:this.activeNode,container=1<arguments.length&&arguments[1]!==void 0?arguments[1]:this.activeNode;// sanity chekc and ensure we are not told to lock position of all menus
clearTimeout(this.__positionContextTimer);this.__positionContextTimer=setTimeout(function(){if(node&&!window.HaxStore.instance._lockContextPosition&&_this11.__ready){// menu width starts out w/ the plate context which is a set size
var menuWidth=140,tag=node.tagName.toLowerCase();if(window.HaxStore.instance._isSandboxed&&"webview"===tag){tag="iframe"}var props=window.HaxStore.instance.elementList[tag];// try and work against anything NOT a P tag
if(babelHelpers.typeof(props)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))&&!window.HaxStore.instance.isTextElement(node)){_this11._hideContextMenu(_this11.shadowRoot.querySelector("#textcontextmenu"));props.element=node;_this11._positionContextMenu(_this11.shadowRoot.querySelector("#cecontextmenu"),container,-1,-30);menuWidth+=28}else{_this11._hideContextMenu(_this11.shadowRoot.querySelector("#cecontextmenu"));_this11._positionContextMenu(_this11.shadowRoot.querySelector("#textcontextmenu"),container,-1,-30);// text menu can expand based on selection
var textRect=_this11.shadowRoot.querySelector("#textcontextmenu").getBoundingClientRect();menuWidth+=textRect.width}if(container){var activeRect=container.getBoundingClientRect();// need to account for the item being small than the menu
if(Math.round(menuWidth)>=Math.round(activeRect.width)){_this11._positionContextMenu(_this11.shadowRoot.querySelector("#platecontextmenu"),container,-1,-58)}else{_this11._positionContextMenu(_this11.shadowRoot.querySelector("#platecontextmenu"),container,activeRect.width-_this11.shadowRoot.querySelector("#platecontextmenu").getBoundingClientRect().width+2,-28)}}// special case for node not matching container yet it being editable
if(container&&!window.HaxStore.instance.isTextElement(node)&&node!==container){container.removeAttribute("contenteditable")}else if(container){container.setAttribute("contenteditable",!0)}}},10)}/**
   * Move grid plate around
   */},{key:"haxMoveGridPlate",value:function haxMoveGridPlate(direction,node,container){var _this12=this;// menu is actually in the element for render purposes
// support moving things multiple directions
this.___moveLock=!0;switch(direction){case"first":// ensure we can go up, first being a mode of up
if(null!==container.previousElementSibling){this.insertBefore(container,this.firstChild)}break;case"up":// ensure we can go up
if(null!==container.previousElementSibling){this.insertBefore(container,container.previousElementSibling)}break;case"down":if(null!==container.nextElementSibling){this.insertBefore(container.nextElementSibling,container)}break;case"last":if(null!==container.nextElementSibling){this.appendChild(container)}break;}setTimeout(function(){if("function"===typeof node.scrollIntoViewIfNeeded){node.scrollIntoViewIfNeeded(!0)}else{node.scrollIntoView({behavior:"smooth",inline:"center"})}_this12.positionContextMenus(node,node)},10);return!0}/**
   * Inject / modify a grid plate where something currently lives
   */},{key:"haxGridPlateOps",value:function(){var _haxGridPlateOps=babelHelpers.asyncToGenerator(/*#__PURE__*/regeneratorRuntime.mark(function _callee(node,side){var _this13=this,add,changed,cloneEl,platecontextmenu,right,rightremove,grid,col,_args=arguments;return regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:add=2<_args.length&&_args[2]!==void 0?_args[2]:!0;// allow splitting the grid plate that is already there
changed=!1;if(!("GRID-PLATE"===node.tagName)){_context.next=51;break}if(!add){_context.next=24;break}_context.t0=node.layout;_context.next="1"===_context.t0?7:"1-1"===_context.t0?10:"1-1-1"===_context.t0?13:"1-1-1-1"===_context.t0?16:"1-1-1-1-1"===_context.t0?19:22;break;case 7:node.layout="1-1";changed=!0;return _context.abrupt("break",22);case 10:node.layout="1-1-1";changed=!0;return _context.abrupt("break",22);case 13:node.layout="1-1-1-1";changed=!0;return _context.abrupt("break",22);case 16:node.layout="1-1-1-1-1";changed=!0;return _context.abrupt("break",22);case 19:node.layout="1-1-1-1-1-1";changed=!0;return _context.abrupt("break",22);case 22:_context.next=48;break;case 24:_context.t1=node.layout;_context.next="1-1"===_context.t1?27:"1-1-1"===_context.t1?36:"1-1-1-1"===_context.t1?39:"1-1-1-1-1"===_context.t1?42:"1-1-1-1-1-1"===_context.t1?45:48;break;case 27:_context.next=29;return node.childNodes.forEach(function(el){// verify its a tag
if(el.tagName){// remove slot name
cloneEl=el.cloneNode(!0);cloneEl.removeAttribute("slot");cloneEl.classList.remove("hax-mover");cloneEl.classList.remove("hax-moving");node.parentNode.insertBefore(cloneEl,node)}});case 29:// whatever was moved out last use as active now
this.activeNode=cloneEl;this.activeContainerNode=cloneEl;window.HaxStore.write("activeNode",cloneEl,this);window.HaxStore.write("activeContainerNode",cloneEl,this);setTimeout(function(){node.remove()},0);changed=!0;return _context.abrupt("break",48);case 36:node.layout="1-1";changed=!0;return _context.abrupt("break",48);case 39:node.layout="1-1-1";changed=!0;return _context.abrupt("break",48);case 42:node.layout="1-1-1-1";changed=!0;return _context.abrupt("break",48);case 45:node.layout="1-1-1-1-1";changed=!0;return _context.abrupt("break",48);case 48:// if left, nudge everything over 1, right simple
if(changed){platecontextmenu=this.shadowRoot.querySelector("#platecontextmenu");right=platecontextmenu.shadowRoot.querySelector("#right");rightremove=platecontextmenu.shadowRoot.querySelector("#rightremove");right.disabled=!1;rightremove.disabled=!1;if("1-1-1-1-1-1"==node.layout){right.disabled=!0}if("left"==side){node.childNodes.forEach(function(el){if(el.tagName){var s=parseInt(el.getAttribute("slot").replace("col-",""),10)+1;el.setAttribute("slot","col-".concat(s))}})}}_context.next=57;break;case 51:grid=document.createElement("grid-plate");grid.layout="1-1";this.insertBefore(grid,node);col="2";if("right"==side){col="1"}setTimeout(function(){grid.appendChild(node);_this13.activeContainerNode=grid;window.HaxStore.write("activeContainerNode",grid,_this13);node.setAttribute("slot","col-"+col)},0);case 57:case"end":return _context.stop();}}},_callee,this)}));function haxGridPlateOps(_x,_x2){return _haxGridPlateOps.apply(this,arguments)}return haxGridPlateOps}()/**
   * Convert an element from one tag to another.
   */},{key:"haxReplaceNode",value:function haxReplaceNode(node,replacement){// Switch, try loop in case we screwed up elsewhere
try{if(null==node){node=this.__oldActiveNode}node.replaceWith(replacement);// test for slots to match
if(node&&node.getAttribute&&null!=node.getAttribute("slot")){replacement.setAttribute("slot",node.getAttribute("slot"))}}catch(e){console.warn(e)}return replacement}/**
   * Convert an element from one tag to another.
   */},{key:"haxChangeTagName",value:function haxChangeTagName(node,tagName){// Create a replacement tag of the desired type
// Grab all of the original's attributes, and pass them to the replacement
for(var replacement=document.createElement(tagName),i=0,l=node.attributes.length;i<l;++i){var nodeName=node.attributes.item(i).nodeName,value=node.attributes.item(i).value;replacement.setAttribute(nodeName,value)}// Persist contents
// account for empty list and ordered list items
replacement.innerHTML=node.innerHTML.trim();if("ul"==tagName||"ol"==tagName){if(""==replacement.innerHTML){replacement.innerHTML="<li></li>"}else if(!("ul"==node.tagName.toLowerCase()||"ol"==node.tagName.toLowerCase())){replacement.innerHTML="<li>"+node.innerHTML.trim().replace(/<br\/>/g,"</li>\n<li>").replace(/<br>/g,"</li>\n<li>")+"</li>"}}else if("ul"==node.tagName.toLowerCase()||"ol"==node.tagName.toLowerCase()){// if we're coming from ul or ol strip out the li tags
replacement.innerHTML=replacement.innerHTML.replace(/<ul>/g,"").replace(/<\/ul>/g,"").replace(/<li><\/li>/g,"").replace(/<li>/g,"").replace(/<\/li>/g,"<br/>")}// Switch!
try{node.replaceWith(replacement);// focus on the thing switched to
setTimeout(function(){var children=replacement.children;// see if there's a child element and focus that instead if there is
if(children[0]&&children.tagName){children[0].focus()}else{replacement.focus()}},50)}catch(e){console.warn(e);console.warn(replacement);console.warn(node)}return replacement}/**
   * Delete the node passed in
   */},{key:"haxDeleteNode",value:function haxDeleteNode(node){var parent=1<arguments.length&&arguments[1]!==void 0?arguments[1]:this;// move the context menu before deleting!!!!
this.hideContextMenus();this.activeNode=null;this.activeContainerNode=null;window.HaxStore.write("activeNode",null,this);window.HaxStore.write("activeContainerNode",null,this);try{return node.remove()}catch(e){console.warn(e)}}/**
   * Bulk import HTML with option to clear what is currently
   * in the slot of this tag. This also validates tags
   * that are being inserted for security based on the
   * internal whitelist.
   */},{key:"importContent",value:function importContent(html){var _this14=this,clear=1<arguments.length&&arguments[1]!==void 0?arguments[1]:!0;// kill the slot of the active body, all of it
if(clear){(0,_utils.wipeSlot)(this,"*")}// pause quickly to ensure wipe goes through successfully
setTimeout(function(){html=(0,_utils.encapScript)(html);var fragment=document.createElement("div");fragment.insertAdjacentHTML("beforeend",html);while(null!==fragment.firstChild){if(babelHelpers.typeof(fragment.firstChild.tagName)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){// ensure import doesn't import non-sandbox safe things!
if(window.HaxStore.instance._isSandboxed&&"iframe"===fragment.firstChild.tagName.toLowerCase()){// Create a replacement tag of the desired type
// Grab all of the original's attributes, and pass them to the replacement
for(var replacement=document.createElement("webview"),j=0,l=fragment.firstChild.attributes.length;j<l;++j){var nodeName=fragment.firstChild.attributes.item(j).nodeName,value=fragment.firstChild.attributes.item(j).value;if("height"===nodeName||"width"===nodeName){replacement.style[nodeName]==value}replacement.setAttribute(nodeName,value)}_this14.appendChild(replacement)}else{_this14.appendChild(fragment.firstChild)}}else{// @todo might want to support appending or keeping track of comments / non tags
// but this is not a must have
fragment.removeChild(fragment.firstChild)}}},50)}/**
   * Respond to hax operations.
   */},{key:"_haxContextOperation",value:function _haxContextOperation(e){var _this15=this,detail=e.detail;// support a simple insert event to bubble up or everything else
switch(detail.eventName){// text based operations for primatives
case"text-tag":// trigger the default selected value in context menu to match
this.shadowRoot.querySelector("#textcontextmenu").realSelectedValue=detail.value;this.activeNode=this.haxChangeTagName(this.activeNode,detail.value);window.HaxStore.write("activeNode",this.activeNode,this);setTimeout(function(){_this15.positionContextMenus()},100);break;case"text-tag-ul":// trigger the default selected value in context menu to match
this.shadowRoot.querySelector("#textcontextmenu").realSelectedValue="ul";this.activeNode=this.haxChangeTagName(this.activeNode,"ul");window.HaxStore.write("activeNode",this.activeNode,this);setTimeout(function(){_this15.positionContextMenus()},100);break;case"text-tag-ol":// trigger the default selected value in context menu to match
this.shadowRoot.querySelector("#textcontextmenu").realSelectedValue="ol";this.activeNode=this.haxChangeTagName(this.activeNode,"ol");window.HaxStore.write("activeNode",this.activeNode,this);setTimeout(function(){_this15.positionContextMenus()},100);break;case"hax-plate-add-element":// support for the Other call, otherwise its a specific element + props
if("other"==detail.value){window.HaxStore.instance.haxInsertAnything({});return!0}// insert from here
var addData=JSON.parse(detail.value);this.haxInsert(addData.tag,addData.content,addData.properties,!1);// focus on 1st row w/ cursor if this a text element
if(window.HaxStore.instance.isTextElement(addData)){setTimeout(function(){try{var range=document.createRange(),sel=window.HaxStore.getSelection();range.setStart(_this15.activeNode,0);range.collapse(!0);sel.removeAllRanges();sel.addRange(range);_this15.activeNode.focus();_this15.activeContainerNode=_this15.activeNode;window.HaxStore.write("activeContainerNode",_this15.activeContainerNode,_this15)}catch(e){console.warn(e)}},0)}break;case"text-align-left":this.activeNode.style.textAlign=null;break;// grid plate based operations
// allow for transforming this haxElement into another one
case"hax-transform-node":this.replaceElementWorkflow();break;// grid plate based operations
// allow for transforming this haxElement into another one
case"hax-plate-create-right":this.haxGridPlateOps(this.activeContainerNode,"right");break;case"hax-plate-remove-right":this.haxGridPlateOps(this.activeContainerNode,"right",!1);break;// duplicate the active item or container
case"hax-plate-duplicate":if(this.activeNode===this.activeContainerNode){this.haxDuplicateNode(this.activeNode)}else{this.haxDuplicateNode(this.activeNode,this.activeContainerNode)}break;case"hax-plate-delete":if(null!=this.activeNode){var options=[{icon:"thumb-up",color:"green",title:"Yes"},{icon:"thumb-down",color:"red",title:"No"}],tag=this.activeNode.tagName.toLowerCase(),humanName=tag.replace("-"," ");if(babelHelpers.typeof(window.HaxStore.instance.elementList[tag])!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))&&!1!==window.HaxStore.instance.elementList[tag].gizmo){humanName=window.HaxStore.instance.elementList[tag].gizmo.title}window.HaxStore.instance.haxAppPicker.presentOptions(options,"","Remove this `".concat(humanName,"`?"),"delete")}break;case"hax-plate-first":this.haxMoveGridPlate("first",this.activeNode,this.activeContainerNode);break;case"hax-plate-up":this.haxMoveGridPlate("up",this.activeNode,this.activeContainerNode);break;case"hax-plate-down":this.haxMoveGridPlate("down",this.activeNode,this.activeContainerNode);break;case"hax-plate-last":this.haxMoveGridPlate("last",this.activeNode,this.activeContainerNode);break;case"close-menu":this.activeNode=null;this.activeContainerNode=null;window.HaxStore.write("activeNode",null,this);window.HaxStore.write("activeContainerNode",null,this);break;}}/**
   * Item has gained focus, change active element to match
   */},{key:"_focusIn",value:function _focusIn(e){if(this.__focusLogic(e.target)){e.stopPropagation()}}/**
   * Focus a target and update the data model to reflect this.
   * This helps ensure that keyboard and non click based focusing
   * registers the same as click events
   */},{key:"__focusLogic",value:function __focusLogic(target){var _this16=this,stopProp=!1;// only worry about these when we are in edit mode
// and there is no drawer open
if(!this.openDrawer&&this.editMode&&!this.__tabTrap){var containerNode=target;// edge case, thing selected is inside a paragraph tag
// HTML is stupid and allows this
if("SPAN"===containerNode.tagName&&window.HaxStore.instance.isTextElement(target.parentNode)){containerNode=target.parentNode}var activeNode=null;// ensure this is valid
if(this._validElementTest(containerNode)&&containerNode.parentNode&&containerNode.parentNode.tagName){// keep looking til we are juuuust below the container
// @notice this is where we force a selection on highest level
// of the document
while(containerNode.parentNode.tagName&&"HAX-BODY"!=containerNode.parentNode.tagName){// make sure active is set after closest legit element
if(null===activeNode&&"LI"!==containerNode.tagName&&"B"!==containerNode.tagName&&"I"!==containerNode.tagName&&"STRONG"!==containerNode.tagName&&"EM"!==containerNode.tagName){activeNode=containerNode}containerNode=containerNode.parentNode}// case with simple element
if(null===activeNode){activeNode=containerNode}// we only allow disconnected node from container when
// the container is a grid plate
else if(!window.HaxStore.instance.isGridPlateElement(containerNode)){activeNode=containerNode}// won't deal with lists inside of p tags
else if(["UL","OL","LI","P","GRID-PLATE"].includes(containerNode.tagName)&&["UL","OL","LI"].includes(activeNode.tagName)){activeNode=containerNode}// ensure this is a tag we care about / have support for and
// that it is a new value
if(this.activeContainerNode!==containerNode&&!containerNode.classList.contains("ignore-activation")){this.activeContainerNode=containerNode;window.HaxStore.write("activeContainerNode",containerNode,this);stopProp=!0}else if(containerNode.classList.contains("ignore-activation")){stopProp=!0}// test for active node changing
if(this.activeNode!==activeNode&&!activeNode.classList.contains("ignore-activation")){this.activeNode=activeNode;window.HaxStore.write("activeNode",activeNode,this);setTimeout(function(){_this16.positionContextMenus(activeNode,activeNode)},0);stopProp=!0}}}else{this.__tabTrap=!1}return stopProp}/**
   * Notice the change between states for editing.
   */},{key:"_editModeChanged",value:function _editModeChanged(newValue,oldValue){var _this17=this;// fire above that we have changed states so things can react if needed
if(babelHelpers.typeof(oldValue)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){this._applyContentEditable(newValue);if(newValue){// minor timeout here to see if we have children or not. the slight delay helps w/
// timing in scenarios where this is inside of other systems which are setting default
// attributes and what not
setTimeout(function(){if(_this17.children&&_this17.children[0]&&_this17.children[0].focus){_this17.activeNode=_this17.children[0];_this17.activeContainerNode=_this17.activeNode;window.HaxStore.write("activeNode",_this17.children[0],_this17);window.HaxStore.write("activeContainerNode",_this17.children[0],_this17);setTimeout(function(){if(window.HaxStore.instance.isTextElement(_this17.activeNode)){try{var range=document.createRange(),sel=window.HaxStore.getSelection();range.setStart(_this17.activeNode,0);range.collapse(!0);sel.removeAllRanges();sel.addRange(range);_this17.activeNode.focus()}catch(e){console.warn(e)}_this17.positionContextMenus()}},0)}else{_this17.haxInsert("p","",{},!1);setTimeout(function(){try{var range=document.createRange(),sel=window.HaxStore.getSelection();range.setStart(_this17.activeNode,0);range.collapse(!0);sel.removeAllRanges();sel.addRange(range);_this17.activeNode.focus();_this17.activeContainerNode=_this17.activeNode;window.HaxStore.write("activeContainerNode",_this17.activeContainerNode,_this17)}catch(e){console.warn(e)}_this17.positionContextMenus()},0)}},100)}}// hide menus when state changes
if(!1==newValue){this.removeAttribute("contenteditable");setTimeout(function(){_this17.hideContextMenus()},50)}}/**
   * Test if this is a HAX element or not
   */},{key:"_haxResolvePreviousElement",value:function _haxResolvePreviousElement(node){node=node.previousElementSibling;while(null!=node&&babelHelpers.typeof(node.tagName)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))&&"HAX-"===node.tagName.substring(0,4)){node=node.previousElementSibling}return node}/**
   * Test if this is a HAX element or not
   * true means its a valid element for selection
   * We have special support for the hax-logo because it's hax.
   */},{key:"_validElementTest",value:function _validElementTest(node){if(babelHelpers.typeof(node.tagName)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){if("HAX-"!==node.tagName.substring(0,4)||"HAX-LOGO"===node.tagName){return!0}}return!1}/**
   * Test if this is an HTML primative
   */},{key:"_HTMLPrimativeTest",value:function _HTMLPrimativeTest(node){if(null!=node&&babelHelpers.typeof(node.tagName)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))&&-1==node.tagName.indexOf("-")){return!0}return!1}/**
   * Walk everything we find and either enable or disable editable state.
   */},{key:"_applyContentEditable",value:function _applyContentEditable(status){var target=1<arguments.length&&arguments[1]!==void 0?arguments[1]:this.shadowRoot.querySelector("#body"),children="slot"===target.localName?target.assignedNodes({flatten:!0}):[];// fallback for content nodes if not polymer managed nodes above
if(0===children.length){children=target.children}for(var i=0,len=children.length;i<len;i++){// sanity check for being a valid element / not a "hax" element
if(this._validElementTest(children[i])){// correctly add or remove listeners
if(!status||!0!==children[i].getAttribute("contenteditable")&&"true"!=children[i].getAttribute("contenteditable")&&"contenteditable"!=children[i].getAttribute("contenteditable")){this.__applyNodeEditableState(children[i],status)}}}}/**
   * Apply the node editable state correctly so we can do drag and drop / editing uniformly
   */},{key:"__applyNodeEditableState",value:function __applyNodeEditableState(node){var status=1<arguments.length&&arguments[1]!==void 0?arguments[1]:!0,listenerMethod,haxRay=node.tagName.replace("-"," ").toLowerCase(),i=window.HaxStore.instance.gizmoList.findIndex(function(j){if(j){return j.tag===node.tagName.toLowerCase()}});if(-1!==i){haxRay=window.HaxStore.instance.gizmoList[i].title}// oooooo snap, drag and drop..
if(status){node.setAttribute("data-editable",status);node.setAttribute("data-hax-ray",haxRay);listenerMethod="addEventListener"}else{node.removeAttribute("data-editable");node.removeAttribute("data-hax-ray");listenerMethod="removeEventListener"}node[listenerMethod]("drop",this.dropEvent.bind(this));node[listenerMethod]("dragenter",this.dragEnter.bind(this));node[listenerMethod]("dragleave",this.dragLeave.bind(this));node[listenerMethod]("dragover",function(e){e.preventDefault()});// additional things for text based elements
if(this._HTMLPrimativeTest(node)){if(status){node.setAttribute("contenteditable",status)}else{node.removeAttribute("contenteditable")}if(0<node.querySelectorAll("a").length){for(var links=node.querySelectorAll("a"),j=0,len2=links.length;j<len2;j++){if(status){links[j].setAttribute("contenteditable",status);links[j].setAttribute("data-editable",status)}else{links[j].removeAttribute("contenteditable");links[j].removeAttribute("data-editable")}links[j][listenerMethod]("click",function(e){e.preventDefault();e.stopPropagation();e.stopImmediatePropagation()})}}}}/**
   * Drop an item onto another
   */},{key:"dropEvent",value:function dropEvent(e){var _this18=this;if(!this.openDrawer&&this.editMode){window.HaxStore.instance._lockContextPosition=!1;// trick the tray into forcing active to be Configure
window.HaxStore.instance.haxTray.activeTab="item-1";// establish an activeNode /container based on drop poisition
this.activeNode=e.path[0];window.HaxStore.write("activeNode",e.path[0],this);if(e.path[0].parentNode&&"GRID-PLATE"===e.path[0].parentNode.tagName){this.activeContainerNode=e.path[0].parentNode;window.HaxStore.write("activeContainerNode",e.path[0].parentNode,this)}else{this.activeContainerNode=e.path[0].parentNode;window.HaxStore.write("activeContainerNode",e.path[0],this)}// esnure we clear the gravity scrolling drag effect
clearTimeout(gravityScrollTimer);// walk the children and remove the draggable state needed
setTimeout(function(){var children=_this18.querySelectorAll(".hax-mover, .hax-hovered, .hax-moving, .grid-plate-active-item");for(var i in children){if(babelHelpers.typeof(children[i].classList)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){children[i].classList.remove("hax-mover","hax-hovered","hax-moving","grid-plate-active-item");// special support for grid plates as they manage internal drag/drop
if("GRID-PLATE"===children[i].tagName){children[i].dropEvent(e);for(var j=1;j<=children[i].columns;j++){if(children[i].shadowRoot.querySelector("#col"+j)!==void 0){children[i].shadowRoot.querySelector("#col"+j).classList.remove("hax-mover")}}}}}},100);// this helps ensure that what gets drag and dropped is a file
// this prevents issues with selecting and dragging text (which triggers drag/drop)
// as well as compatibility with things that are legit in a draggable state
try{// see if we are dropping a file
if(e.dataTransfer&&e.dataTransfer.items&&0<e.dataTransfer.items.length&&"file"===e.dataTransfer.items[0].kind){e.preventDefault();e.stopPropagation();e.stopImmediatePropagation();// inject a placeholder P tag which we will then immediately replace
var tmp=document.createElement("p");this.activeNode.parentNode.insertBefore(tmp,this.activeNode);// this placeholder will be immediately replaced
e.placeHolderElement=tmp;// fire this specialized event up so things like HAX can intercept
this.dispatchEvent(new CustomEvent("place-holder-file-drop",{bubbles:!0,cancelable:!0,composed:!0,detail:e}))}else{// set taget based on drag target
var target=window.HaxStore.instance.__dragTarget,local=e.target;// if we have a slot on what we dropped into then we need to mirror that item
// and place ourselves below it in the DOM
if(target&&target.removeAttribute&&null!==target&&babelHelpers.typeof(local)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))&&target!==local&&target!==local.parentNode&&target.parentNode===this||local.parentNode===this){// incase this came from a grid plate, drop the slot so it works
target.removeAttribute("slot");try{local.parentNode.insertBefore(target,local)}catch(e){console.warn(e)}// ensure that if we caught this event we process it
e.preventDefault();e.stopPropagation()}// position arrows / set focus in case the DOM got updated above
if(target&&"function"===typeof target.focus){this.activeNode=target;if(this.activeNode&&this.activeNode.parentNode&&"GRID-PLATE"===this.activeNode.parentNode.tagName){this.activeContainerNode=this.activeNode.parentNode}window.HaxStore.write("activeNode",this.activeNode,this);window.HaxStore.write("activeContainerNode",this.activeContainerNode,this);setTimeout(function(){_this18.positionContextMenus()},100)}}}catch(e){console.warn(e)}}}/**
   * Enter an element, meaning we've over it while dragging
   */},{key:"dragEnter",value:function dragEnter(e){if(!this.openDrawer&&this.editMode&&e.target){e.preventDefault();e.target.classList.add("hax-hovered");// perform check for edge of screen
this.handleMousemove(e)}}// refactored from https://github.com/bennadel/JavaScript-Demos/blob/master/demos/window-edge-scrolling/index.htm
// I adjust the window scrolling in response to the given mousemove event.
},{key:"handleMousemove",value:function handleMousemove(e){// NOTE: Much of the information here, with regard to document dimensions,
// viewport dimensions, and window scrolling is derived from JavaScript.info.
// I am consuming it here primarily as NOTE TO SELF.
// --
// Read More: https://javascript.info/size-and-scroll-window
// --
// CAUTION: The viewport and document dimensions can all be CACHED and then
// recalculated on window-resize events (for the most part). I am keeping it
// all here in the mousemove event handler to remove as many of the moving
// parts as possible and keep the demo as simple as possible.
// Get the viewport-relative coordinates of the mousemove event.
var viewportX=e.clientX,viewportY=e.clientY,viewportWidth=document.documentElement.clientWidth,viewportHeight=document.documentElement.clientHeight,edgeTop=edgeSize,edgeLeft=edgeSize,edgeBottom=viewportHeight-edgeSize,edgeRight=viewportWidth-edgeSize,isInLeftEdge=viewportX<edgeLeft,isInRightEdge=viewportX>edgeRight,isInTopEdge=viewportY<edgeTop,isInBottomEdge=viewportY>edgeBottom;// If the mouse is not in the viewport edge, there's no need to calculate
// anything else.
if(!(isInLeftEdge||isInRightEdge||isInTopEdge||isInBottomEdge)){clearTimeout(gravityScrollTimer);return}// If we made it this far, the user's mouse is located within the edge of the
// viewport. As such, we need to check to see if scrolling needs to be done.
// Get the document dimensions.
// --
// NOTE: The various property reads here are for cross-browser compatibility
// as outlined in the JavaScript.info site (link provided above).
var documentWidth=Math.max(document.body.scrollWidth,document.body.offsetWidth,document.body.clientWidth,document.documentElement.scrollWidth,document.documentElement.offsetWidth,document.documentElement.clientWidth),documentHeight=Math.max(document.body.scrollHeight,document.body.offsetHeight,document.body.clientHeight,document.documentElement.scrollHeight,document.documentElement.offsetHeight,document.documentElement.clientHeight),maxScrollX=documentWidth-viewportWidth,maxScrollY=documentHeight-viewportHeight;// As we examine the mousemove event, we want to adjust the window scroll in
// immediate response to the event; but, we also want to continue adjusting
// the window scroll if the user rests their mouse in the edge boundary. To
// do this, we'll invoke the adjustment logic immediately. Then, we'll setup
// a timer that continues to invoke the adjustment logic while the window can
// still be scrolled in a particular direction.
// --
// NOTE: There are probably better ways to handle the ongoing animation
// check. But, the point of this demo is really about the math logic, not so
// much about the interval logic.
(function checkForWindowScroll(){clearTimeout(gravityScrollTimer);if(adjustWindowScroll()){gravityScrollTimer=setTimeout(checkForWindowScroll,30)}})();// Adjust the window scroll based on the user's mouse position. Returns True
// or False depending on whether or not the window scroll was changed.
function adjustWindowScroll(){// Get the current scroll position of the document.
var currentScrollX=window.pageXOffset,currentScrollY=window.pageYOffset,canScrollUp=0<currentScrollY,canScrollDown=currentScrollY<maxScrollY,canScrollLeft=0<currentScrollX,canScrollRight=currentScrollX<maxScrollX,nextScrollX=currentScrollX,nextScrollY=currentScrollY;// As we examine the mouse position within the edge, we want to make the
// incremental scroll changes more "intense" the closer that the user
// gets the viewport edge. As such, we'll calculate the percentage that
// the user has made it "through the edge" when calculating the delta.
// Then, that use that percentage to back-off from the "max" step value.
// Should we scroll left?
if(isInLeftEdge&&canScrollLeft){var intensity=(edgeLeft-viewportX)/edgeSize;nextScrollX=nextScrollX-maxStep*intensity;// Should we scroll right?
}else if(isInRightEdge&&canScrollRight){var intensity=(viewportX-edgeRight)/edgeSize;nextScrollX=nextScrollX+maxStep*intensity}// Should we scroll up?
if(isInTopEdge&&canScrollUp){var intensity=(edgeTop-viewportY)/edgeSize;nextScrollY=nextScrollY-maxStep*intensity;// Should we scroll down?
}else if(isInBottomEdge&&canScrollDown){var intensity=(viewportY-edgeBottom)/edgeSize;nextScrollY=nextScrollY+maxStep*intensity}// Sanitize invalid maximums. An invalid scroll offset won't break the
// subsequent .scrollTo() call; however, it will make it harder to
// determine if the .scrollTo() method should have been called in the
// first place.
nextScrollX=Math.max(0,Math.min(maxScrollX,nextScrollX));nextScrollY=Math.max(0,Math.min(maxScrollY,nextScrollY));if(nextScrollX!==currentScrollX||nextScrollY!==currentScrollY){window.scrollTo(nextScrollX,nextScrollY);return!0}else{return!1}}}/**
   * Leaving an element while dragging.
   */},{key:"dragLeave",value:function dragLeave(e){if(!this.openDrawer&&this.editMode){e.target.classList.remove("hax-hovered")}}/**
   * Container has changed
   */},{key:"_activeContainerNodeChanged",value:function _activeContainerNodeChanged(newValue,oldValue){if(this.editMode&&babelHelpers.typeof(newValue)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))&&null!=newValue&&null!=newValue.tagName){if(window.HaxStore.instance.isTextElement(newValue)||window.HaxStore.instance.isGridPlateElement(newValue)){newValue.setAttribute("contenteditable",!0);this.setAttribute("contenteditable",!0)}else{newValue.removeAttribute("contenteditable");this.removeAttribute("contenteditable")}// @notice this is a bit of a state hack between grid plate and hax
// this forces the active item to be dropped so that we can
// correctly regain focus with the keyboard
if(oldValue&&"GRID-PLATE"==oldValue.tagName){oldValue.activeItem=null}var tag=newValue.tagName.toLowerCase();// special case for the grid plate since it brings in nodes
// nested in it and needs to be put into an editMode
if("grid-plate"===tag){newValue.editMode=this.editMode;this._applyContentEditable(this.editMode,newValue)}}}/**
   * React to a new node being set to active.
   */},{key:"_activeNodeChanged",value:function _activeNodeChanged(newValue,oldValue){// remove anything currently with the active class
this.querySelectorAll(".hax-active").forEach(function(el){el.classList.remove("hax-active")});if(this.editMode&&babelHelpers.typeof(newValue)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))&&null!==newValue&&newValue.parentNode){var tag=newValue.tagName.toLowerCase();// remove the menu, establish the new active, then reapply
// this is nessecary because the context menu gets appended into
// the document
// only hide if we change containers
newValue.classList.add("hax-active");if(window.HaxStore.instance.isTextElement(newValue)||window.HaxStore.instance.isGridPlateElement(newValue)){newValue.setAttribute("contenteditable",!0);this.setAttribute("contenteditable",!0)}else{newValue.removeAttribute("contenteditable");this.removeAttribute("contenteditable")}// why you no position yo?
this.positionContextMenus();this.shadowRoot.querySelector("#textcontextmenu").realSelectedValue=tag}// just hide menus if we don't have an active item
else if(null===newValue){this.hideContextMenus();this.__oldActiveNode=oldValue}}/**
   * Get position from top and left of the page based on position:relative; being
   * set in a parent.
   *
   * @notice This only works correctly across browsers because hax-body
   * is position:relative in :host.
   */},{key:"_getPosition",value:function _getPosition(element){var xPosition=element.offsetLeft-element.scrollLeft+element.clientLeft,yPosition=element.offsetTop-element.scrollTop+element.clientTop;return{x:xPosition,y:yPosition}}/**
   * Handle display and position of the context menu
   */},{key:"_positionContextMenu",value:function _positionContextMenu(menu,target,xoffset,yoffset){// make it account for the offset if it's floated over to one side
// or inside of something that's over that way
if(null!=target){var pos=this._getPosition(target);if(null!=xoffset){menu.style.left=pos.x+xoffset+"px"}else{menu.style.left=pos.x+"px"}if(null!=yoffset){menu.style.top=pos.y+yoffset+"px"}else{menu.style.top=pos.y+"px"}}menu.setAttribute("on-screen","on-screen");menu.classList.add("hax-context-visible");// text we want to operate this way
if(this.__activeHover){menu.classList.add("hax-active-hover");menu.style.marginLeft="";this.__typeLock=!1}}/**
   * Simple hide / reset of whatever menu it's handed.
   */},{key:"_hideContextMenu",value:function _hideContextMenu(menu){menu.removeAttribute("on-screen");menu.classList.remove("hax-context-visible","hax-active-hover","hax-context-pin-top")}/**
   * Find the next thing to tab forward to.
   */},{key:"_tabKeyPressed",value:function _tabKeyPressed(){var focus=!1,node=this.activeContainerNode,activeNodeTagName=this.activeContainerNode.tagName;// try selection / tab block since range can cause issues
if(window.HaxStore.getRange().cloneRange){try{var range=window.HaxStore.getRange().cloneRange(),tagTest=range.commonAncestorContainer.tagName;if(babelHelpers.typeof(tagTest)===("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){tagTest=range.commonAncestorContainer.parentNode.tagName}if(["UL","OL","LI"].includes(activeNodeTagName)||["UL","OL","LI"].includes(tagTest)){if(this.polyfillSafe){document.execCommand("indent");this.__tabTrap=!0}}else{while(!focus){// do nothing
if(null==node.nextSibling){focus=!0}else if("function"===node.nextSibling.focus){node.nextSibling.focus();focus=!0}else{node=node.nextSibling}}}}catch(e){console.warn(e)}}}/**
   * Move back through things when tab back pressed
   */},{key:"_tabBackKeyPressed",value:function _tabBackKeyPressed(){var node=this.activeContainerNode,activeNodeTagName=this.activeContainerNode.tagName;// try selection / tab block since range can cause issues
if(window.HaxStore.getRange().cloneRange){try{var range=window.HaxStore.getRange().cloneRange(),tagTest=range.commonAncestorContainer.tagName;if(babelHelpers.typeof(tagTest)===("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){tagTest=range.commonAncestorContainer.parentNode.tagName}if(["UL","OL","LI"].includes(activeNodeTagName)||["UL","OL","LI"].includes(tagTest)){if(this.polyfillSafe){document.execCommand("outdent");this.__tabTrap=!0}}else{if(null!=node){// step back ignoring hax- prefixed elements
while(null!=node&&!this._validElementTest(node)){node=node.previousSibling}}if(null!=node){setTimeout(function(){node.focus()},50)}}}catch(e){console.warn(e)}}}}],[{key:"tag",get:function get(){return"hax-body"}},{key:"properties",get:function get(){return _objectSpread({},babelHelpers.get(babelHelpers.getPrototypeOf(HaxBody),"properties",this),{openDrawer:{type:Object},/**
       * Text hax-store has detected is selected currently.
       */haxSelectedText:{type:String},/**
       * State of if we are editing or not.
       */editMode:{type:Boolean,reflect:!0,attribute:"edit-mode"},/**
       * Bust out the HAX Ray mode
       */haxRayMode:{type:Boolean,reflect:!0,attribute:"hax-ray-mode"},/**
       * Access to the global properties object.
       */globalPreferences:{type:Object},/**
       * A reference to the active node in the slot.
       */activeNode:{type:Object},/**
       * A reference to the active node in the slot.
       */activeContainerNode:{type:Object}})}}]);return HaxBody}(_simpleColors.SimpleColors);_exports.HaxBody=HaxBody;window.customElements.define(HaxBody.tag,HaxBody)});