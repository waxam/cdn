define(["exports", "require", "../../lit-element/lit-element.js", "../simple-colors/simple-colors.js", "../utils/utils.js"], function (_exports, _require, _litElement, _simpleColors, _utils) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.HaxBody = void 0;
  _require = babelHelpers.interopRequireWildcard(_require);

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  function _templateObject2_59762940d34d11ea880ba1e93364c49c() {
    var data = babelHelpers.taggedTemplateLiteral(["\n      <div id=\"bodycontainer\" class=\"ignore-activation\">\n        <slot id=\"body\"></slot>\n      </div>\n      <hax-text-context\n        id=\"textcontextmenu\"\n        class=\"hax-context-menu ignore-activation\"\n      ></hax-text-context>\n      <hax-ce-context\n        id=\"cecontextmenu\"\n        class=\"hax-context-menu ignore-activation\"\n      ></hax-ce-context>\n      <hax-plate-context\n        id=\"platecontextmenu\"\n        class=\"hax-context-menu ignore-activation\"\n      ></hax-plate-context>\n    "]);

    _templateObject2_59762940d34d11ea880ba1e93364c49c = function _templateObject2_59762940d34d11ea880ba1e93364c49c() {
      return data;
    };

    return data;
  }

  function _templateObject_59762940d34d11ea880ba1e93364c49c() {
    var data = babelHelpers.taggedTemplateLiteral(["\n        :host([edit-mode]),\n        :host([edit-mode]) * ::slotted(*) {\n          line-height: 1.8;\n        }\n        :host([edit-mode]) ul,\n        :host([edit-mode]) ol {\n          padding-left: 20px;\n          margin-left: 20px;\n        }\n        :host([edit-mode]) ul {\n          list-style-type: disc;\n        }\n        :host([edit-mode]) li {\n          margin-bottom: 6px;\n        }\n        :host {\n          display: block;\n          position: relative;\n          min-height: 32px;\n          min-width: 32px;\n          outline: none;\n          --hax-contextual-action-text-color: var(\n            --simple-colors-default-theme-grey-1,\n            #fff\n          );\n          --hax-contextual-action-hover-color: var(\n            --simple-colors-default-theme-cyan-7,\n            #009dc7\n          );\n          --hax-contextual-action-color: var(\n            --simple-colors-default-theme-cyan-8,\n            #007999\n          );\n          --hax-body-editable-outline: 1px solid\n            var(--simple-colors-default-theme-deep-orange, #ff8a64);\n          --hax-body-active-outline-hover: 1px solid\n            var(\n              --hax-contextual-action-hover-color,\n              var(--simple-colors-default-theme-cyan-7, #009dc7)\n            );\n          --hax-body-active-outline: 3px solid\n            var(\n              --hax-contextual-action-hover-color,\n              var(--simple-colors-default-theme-cyan-7, #009dc7)\n            );\n          --hax-body-target-background-color: var(\n            --simple-colors-default-theme-cyan-2,\n            #9beaff\n          );\n          --hax-body-possible-target-background-color: var(\n            --simple-colors-default-theme-grey-2,\n            #dddddd;\n          );\n        }\n        .hax-context-menu {\n          padding: 0;\n          margin-left: -5000px;\n          position: fixed;\n          visibility: hidden;\n          opacity: 0;\n          z-index: 1000;\n          float: left;\n          display: block;\n          pointer-events: none;\n          transition: 0.2s top ease-in-out, 0.2s left ease-in-out,\n            0.2s visibility ease-in-out, 0.2s opacity ease-in-out;\n        }\n        #textcontextmenu.hax-context-menu {\n          z-index: 1000;\n        }\n        .hax-context-visible {\n          position: absolute;\n          visibility: visible;\n          pointer-events: all;\n          opacity: 1;\n        }\n        .hax-context-visible.hax-active-hover {\n          margin-left: unset;\n        }\n        :host([edit-mode]) #bodycontainer ::slotted(p) {\n          min-height: var(--hax-base-styles-p-min-height, 1rem);\n          font-size: var(--hax-base-styles-p-font-size);\n          line-height: var(--hax-base-styles-p-line-height);\n          letter-spacing: var(--hax-base-styles-p-letter-spacing);\n        }\n        :host([edit-mode]) #bodycontainer ::slotted(a) {\n          color: var(--hax-base-styles-a-color);\n          font-size: var(\n            --hax-base-styles-a-font-size,\n            var(--hax-base-styles-p-font-size)\n          );\n          font-weight: var(--hax-base-styles-a-font-weight);\n        }\n        :host([edit-mode]) #bodycontainer ::slotted(a:visited) {\n          color: var(--hax-base-styles-a-color-visited);\n        }\n        :host([edit-mode]) #bodycontainer ::slotted(a:active),\n        :host([edit-mode]) #bodycontainer ::slotted(a:focus),\n        :host([edit-mode]) #bodycontainer ::slotted(a:hover) {\n          color: var(--hax-base-styles-a-color-active);\n          font-weight: var(--hax-base-styles-a-font-weight-active);\n        }\n        :host([edit-mode]) #bodycontainer ::slotted(ol),\n        :host([edit-mode]) #bodycontainer ::slotted(ul),\n        :host([edit-mode]) #bodycontainer ::slotted(li) {\n          padding-bottom: var(--hax-base-styles-list-padding-bottom);\n          line-height: var(\n            --hax-base-styles-list-line-height,\n            var(--hax-base-styles-p-line-height)\n          );\n          font-size: var(\n            --hax-base-styles-list-font-size,\n            var(--hax-base-styles-p-font-size)\n          );\n        }\n        :host([edit-mode]) #bodycontainer ::slotted(ol > li:last-child),\n        :host([edit-mode]) #bodycontainer ::slotted(ul > li:last-child) {\n          padding-bottom: var(--hax-base-styles-list-last-child-padding-bottom);\n        }\n        :host([edit-mode]) #bodycontainer ::slotted(img[data-editable]) {\n          max-width: 100%;\n        }\n        :host([edit-mode]) #bodycontainer ::slotted(*[data-editable]) {\n          outline: none;\n          transition: 0.8s ease-in-out outline;\n          caret-color: var(--hax-color-text);\n        }\n        :host([edit-mode]) #bodycontainer ::slotted(*.blinkfocus) {\n          outline: 8px solid var(--hax-contextual-action-hover-color);\n        }\n        :host([edit-mode])\n          #bodycontainer\n          ::slotted(*:not(grid-plate)[data-editable]:hover) {\n          outline: var(--hax-body-active-outline-hover);\n          caret-color: #000000;\n        }\n        :host([edit-mode])\n          #bodycontainer\n          ::slotted(*.hax-active[data-editable]:hover) {\n          cursor: text !important;\n          outline: var(--hax-body-active-outline-hover);\n        }\n        :host([edit-mode])\n          #bodycontainer\n          ::slotted(*:not(grid-plate)[data-editable] .hax-active:hover) {\n          cursor: text !important;\n          outline: var(--hax-body-active-outline-hover);\n        }\n        :host([edit-mode])\n          #bodycontainer\n          ::slotted(code.hax-active[data-editable]) {\n          display: block;\n        }\n        :host([edit-mode])\n          #bodycontainer\n          ::slotted(*.hax-active[data-editable]) {\n          outline: var(--hax-body-active-outline) !important;\n        }\n        :host([edit-mode]) #bodycontainer ::slotted(hr[data-editable]) {\n          height: 2px;\n          background-color: #eeeeee;\n          padding-top: 4px;\n          padding-bottom: 4px;\n        }\n        /** Fix to support safari as it defaults to none */\n        :host([edit-mode]) #bodycontainer ::slotted(*[data-editable]) {\n          -webkit-user-select: text;\n          cursor: pointer;\n        }\n\n        :host([edit-mode])\n          #bodycontainer\n          ::slotted(*[data-editable]::-moz-selection),\n        :host([edit-mode])\n          #bodycontainer\n          ::slotted(*[data-editable] *::-moz-selection) {\n          background-color: var(--hax-body-highlight, --paper-yellow-300);\n          color: black;\n        }\n        :host([edit-mode])\n          #bodycontainer\n          ::slotted(*[data-editable]::selection),\n        :host([edit-mode])\n          #bodycontainer\n          ::slotted(*[data-editable] *::selection) {\n          background-color: var(--hax-body-highlight, --paper-yellow-300);\n          color: black;\n        }\n        #bodycontainer {\n          -webkit-user-select: text;\n          user-select: text;\n        }\n        :host([edit-mode][hax-ray-mode])\n          #bodycontainer\n          ::slotted(*[data-editable]):before {\n          content: attr(data-hax-ray) \" \" attr(resource) \" \" attr(typeof) \" \"\n            attr(property) \" \" attr(content);\n          font-size: 12px;\n          line-height: 12px;\n          left: unset;\n          right: unset;\n          top: unset;\n          background-color: var(--simple-colors-default-theme-cyan-7, #3b97e3);\n          color: #ffffff;\n          bottom: unset;\n          width: auto;\n          padding: 6px;\n          margin: -2px;\n          z-index: 1;\n          margin: 0;\n          float: right;\n        }\n        .hax-context-menu:not(:defined) {\n          display: none;\n        }\n        /* drag and drop */\n        :host([edit-mode]) #bodycontainer ::slotted(*.hax-moving) {\n          outline: var(--hax-body-active-outline);\n          background-color: #eeeeee;\n        }\n        :host([edit-mode]) #bodycontainer ::slotted(*.hax-mover):before {\n          outline: var(--hax-body-editable-outline);\n          background-color: var(--hax-body-possible-target-background-color);\n          content: \" \";\n          width: 100%;\n          display: block;\n          position: relative;\n          margin: -30px 0 0 0;\n          z-index: 2;\n          height: 30px;\n        }\n        :host([edit-mode]) #bodycontainer ::slotted(*.hax-hovered):before {\n          background-color: var(--hax-body-target-background-color) !important;\n          outline: var(--hax-body-active-outline);\n        }\n        @media screen and (min-color-index: 0) and(-webkit-min-device-pixel-ratio:0) {\n          /*\n            Define here the CSS styles applied only to Safari browsers\n            (any version and any device) via https://solvit.io/bcf61b6\n          */\n          :host([edit-mode]) #bodycontainer ::slotted(*.hax-mover) {\n            outline: var(--hax-body-editable-outline);\n            background-color: var(--hax-body-possible-target-background-color);\n          }\n          :host([edit-mode]) #bodycontainer ::slotted(*.hax-hovered) {\n            background-color: var(\n              --hax-body-target-background-color\n            ) !important;\n            outline: var(--hax-body-active-outline);\n          }\n        }\n      "]);

    _templateObject_59762940d34d11ea880ba1e93364c49c = function _templateObject_59762940d34d11ea880ba1e93364c49c() {
      return data;
    };

    return data;
  }

  // variables required as part of the gravity drag and scroll
  var gravityScrollTimer = null;
  var maxStep = 25;
  var edgeSize = 100;
  /**
   * `hax-body`
   * Manager of the body area that can be modified
   * 
  ### Styling
  `<hax-bodys>` provides following custom properties
  for styling:
  
  Custom property | Description | Default
  ----------------|-------------|--------
  --haxcms-base-styles-body-font-size |   | 16px
  --haxcms-base-styles-body-font-family, 'Noto Serif' |   | serif
  --haxcms-base-styles-body-line-height |   | 1.8
  --haxcms-base-styles-body-letter-spacing |   | .5px
  --hax-ui-headings |   | #d4ff77;
  --hax-color-text | default text color | #000
  --hax-contextual-action-text-color |  | --simple-colors-default-theme-grey-1
  --hax-contextual-action-color |  | --simple-colors-default-theme-cyan-7
  --hax-contextual-action-hover-color |  | 
  --hax-body-target-background-color: --simple-colors-default-theme-cyan-2
  --hax-body-possible-target-background-color: --simple-colors-default-theme-grey-2
  
  ####Outlines
  Custom property | Description | Default
  ----------------|-------------|--------
  --hax-body-editable-outline |   | 1px solid --simple-colors-default-theme-deep-orange
  --hax-body-active-outline-hover: 1px solid --hax-contextual-action-color
  --hax-body-active-outline: 3px solid  --hax-contextual-action-color
  
  ####Headings
  Custom property | Description | Default
  ----------------|-------------|--------
  --hax-base-styles-h1-font-size |   | 2.5em
  --hax-base-styles-h1-line-height |   | 2.5em
  --hax-base-styles-h2-font-size |   | 2em
  --hax-base-styles-h3-font-size |   | 1.75em
  --hax-base-styles-h4-font-size |   | 1.5em
  --hax-base-styles-h5-font-size |   | 1.25em
  --hax-base-styles-h6-font-size |   | 1.25em
  --hax-base-styles-p-min-height |   | 43px
  --hax-base-styles-p-font-size |   | 24px
  --hax-base-styles-p-line-height |   | 1.8
  --hax-base-styles-p-letter-spacing |   | 0.5px
  
  ####Links
  Custom property | Description | Default
  ----------------|-------------|--------
  --hax-base-styles-a-color |  | --simple-colors-default-theme-grey-12
  --hax-base-styles-a-font-size |   | 24px
  --hax-base-styles-a-font-weight |   | normal
  --hax-base-styles-a-color-visited |   | --simple-colors-default-theme-light-blue
  --hax-base-styles-a-color-active |   | --simple-colors-default-theme-light-blue
  --hax-base-styles-a-font-weight-active |   | normal
  
  ####Lists
  Custom property | Description | Default
  ----------------|-------------|--------
  --hax-base-styles-list-padding-bottom |   | 1.5em
  --hax-base-styles-list-line-height |   | 40px
  --hax-base-styles-list-font-size |   | 24px
  --hax-base-styles-list-last-child-padding-bottom |   | 1em
  --hax-base-styles-list-padding-left |   | 20px
  --hax-base-styles-list-margin-left |   | 20px
   * 
   * @microcopy - the mental model for this element
   *  - body is effectively a body of content that can be manipulated in the browser. This is for other HAX elements ultimately to interface with and reside in. It is the controller of input and output for all of HAX as it exists in a document. body is not the <body> tag but we need a similar mental model container for all our other elements.
   *  - text-context - the context menu that shows up when an item is active so it can have text based operations performed to it.
   *  - plate/grid plate - a plate or grid plate is a container that we can operate on in HAX. it can also have layout / "global" type of body operations performed on it such as delete, duplicate and higher level format styling.
   * 
   * @demo demo/index.html
   * @LitElement
   * @element hax-body
   */

  var HaxBody =
  /*#__PURE__*/
  function (_SimpleColors) {
    babelHelpers.inherits(HaxBody, _SimpleColors);
    babelHelpers.createClass(HaxBody, null, [{
      key: "styles",

      /**
       * LitElement constructable styles enhancement
       */
      get: function get() {
        return [].concat(babelHelpers.toConsumableArray(babelHelpers.get(babelHelpers.getPrototypeOf(HaxBody), "styles", this)), [(0, _litElement.css)(_templateObject_59762940d34d11ea880ba1e93364c49c())]);
      }
      /**
       * HTMLElement
       */

    }]);

    function HaxBody() {
      var _this;

      babelHelpers.classCallCheck(this, HaxBody);
      _this = babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(HaxBody).call(this)); // lock to ensure we don't flood events on hitting the up / down arrows
      // as we use a mutation observer to manage draggable bindings

      _this.___moveLock = false;
      _this.editMode = false;
      _this.globalPreferences = {}; // xray goggles for tags visualized in context, developer thing

      _this.haxRayMode = false;
      _this.activeNode = null;
      _this.haxSelectedText = "";
      _this.activeContainerNode = null;
      setTimeout(function () {
        new Promise(function (res, rej) {
          return _require.default(["./lib/hax-text-context.js"], res, rej);
        });
        new Promise(function (res, rej) {
          return _require.default(["./lib/hax-ce-context.js"], res, rej);
        });
        new Promise(function (res, rej) {
          return _require.default(["./lib/hax-plate-context.js"], res, rej);
        });
        new Promise(function (res, rej) {
          return _require.default(["../grid-plate/grid-plate.js"], res, rej);
        });
        _this.polyfillSafe = window.HaxStore.instance.computePolyfillSafe();

        _this.addEventListener("hax-context-item-selected", _this._haxContextOperation.bind(babelHelpers.assertThisInitialized(_this)));

        _this.addEventListener("place-holder-replace", _this.replacePlaceholder.bind(babelHelpers.assertThisInitialized(_this)));

        _this.addEventListener("focusin", _this._focusIn.bind(babelHelpers.assertThisInitialized(_this)));

        _this.addEventListener("mousedown", _this._focusIn.bind(babelHelpers.assertThisInitialized(_this)));

        _this.addEventListener("mouseup", _this._mouseUp.bind(babelHelpers.assertThisInitialized(_this)));

        _this.addEventListener("dragenter", _this.dragEnterBody.bind(babelHelpers.assertThisInitialized(_this)));

        _this.addEventListener("drop", _this.dropEvent.bind(babelHelpers.assertThisInitialized(_this)));

        _this.addEventListener("click", _this.clickEvent.bind(babelHelpers.assertThisInitialized(_this)));
      }, 0);
      return _this;
    }
    /**
     * On mouse release, dump any scroller and the end cap element
     */


    babelHelpers.createClass(HaxBody, [{
      key: "_mouseUp",
      value: function _mouseUp(e) {
        // failsafe to clear to the gravity scrolling
        clearTimeout(gravityScrollTimer);

        this.__manageFakeEndCap(false);
      }
    }, {
      key: "clickEvent",
      value: function clickEvent(e) {
        // failsafe to clear to the gravity scrolling
        clearTimeout(gravityScrollTimer);
      }
      /**
       * Make a fake end cap element so we can drop in the last position
       * @note This is much easier logic than the alternatives to account for.
       */

    }, {
      key: "__manageFakeEndCap",
      value: function __manageFakeEndCap() {
        var create = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

        if (create && !this.__fakeEndCap) {
          var fake = document.createElement("fake-hax-body-end");
          fake.style.width = "100%";
          fake.style.height = "20px";
          fake.style.display = "block";
          fake.classList.add("hax-move");
          this.__fakeEndCap = fake;
          this.appendChild(this.__fakeEndCap);
        } else if (!create && this.__fakeEndCap) {
          this.__fakeEndCap.remove();

          this.__fakeEndCap = null;
        }
      }
      /**
       * Activation allowed from outside this grid as far as drop areas
       */

    }, {
      key: "dragEnterBody",
      value: function dragEnterBody(e) {
        var children = this.childNodes; // insert a fake child at the end

        this.__manageFakeEndCap(true); // walk the children and apply the draggable state needed


        for (var i in children) {
          if (children[i].classList && children[i] !== this.activeItem) {
            children[i].classList.add("hax-mover");
          }
        }
      }
      /**
       * LitElement render
       */

    }, {
      key: "render",
      value: function render() {
        return (0, _litElement.html)(_templateObject2_59762940d34d11ea880ba1e93364c49c());
      }
      /**
       * LitElement / popular convention
       */

    }, {
      key: "firstUpdated",

      /**
       * LitElement life cycle - ready
       */
      value: function firstUpdated(changedProperties) {
        var _this2 = this;

        if (babelHelpers.get(babelHelpers.getPrototypeOf(HaxBody.prototype), "firstUpdated", this)) {
          babelHelpers.get(babelHelpers.getPrototypeOf(HaxBody.prototype), "firstUpdated", this).call(this, changedProperties);
        }

        this.dispatchEvent(new CustomEvent("hax-register-body", {
          bubbles: true,
          cancelable: true,
          composed: true,
          detail: this
        })); // try to normalize paragraph insert on enter

        try {
          document.execCommand("enableObjectResizing", false, false);
          document.execCommand("defaultParagraphSeparator", false, "p");
        } catch (e) {
          console.warn(e);
        }

        this.shadowRoot.querySelector("slot").addEventListener("mousemove", this.hoverEvent.bind(this));
        this.shadowRoot.querySelector("slot").addEventListener("mouseup", function (e) {
          if (!_this2.openDrawer && _this2.editMode) {
            setTimeout(function () {
              var tmp = window.HaxStore.getSelection();
              window.HaxStore._tmpSelection = tmp;
              window.HaxStore.write("haxSelectedText", tmp.toString(), _this2);

              try {
                var range = window.HaxStore.getRange();

                if (range.cloneRange) {
                  window.HaxStore._tmpRange = range.cloneRange();
                }
              } catch (e) {
                console.warn(e);
              }
            }, 10);
          }
        }); // in case we miss this on the initial setup. possible in auto opening environments.

        this.editMode = window.HaxStore.instance.editMode; // ensure this resets every append

        this.__tabTrap = false;
        this.__ready = true;
      }
      /**
       * LitElement life cycle - properties changed callback
       */

    }, {
      key: "updated",
      value: function updated(changedProperties) {
        var _this3 = this;

        if (babelHelpers.get(babelHelpers.getPrototypeOf(HaxBody.prototype), "updated", this)) {
          babelHelpers.get(babelHelpers.getPrototypeOf(HaxBody.prototype), "updated", this).call(this, changedProperties);
        }

        changedProperties.forEach(function (oldValue, propName) {
          if (propName == "editMode") {
            _this3._editModeChanged(_this3[propName], oldValue);
          }

          if (propName == "globalPreferences") {
            _this3._globalPreferencesUpdated(_this3[propName], oldValue);
          }

          if (propName == "activeNode" && _this3.__ready) {
            _this3._activeNodeChanged(_this3[propName], oldValue); // notify


            _this3.dispatchEvent(new CustomEvent("active-node-changed", {
              detail: {
                value: _this3[propName]
              }
            }));
          }

          if (propName == "activeContainerNode" && _this3.__ready) {
            _this3._activeContainerNodeChanged(_this3[propName], oldValue); // notify


            _this3.dispatchEvent(new CustomEvent("active-container-node-changed", {
              detail: {
                value: _this3[propName]
              }
            }));
          }
        });
      }
      /**
       * HTMLElement
       */

    }, {
      key: "connectedCallback",
      value: function connectedCallback() {
        var _this4 = this;

        babelHelpers.get(babelHelpers.getPrototypeOf(HaxBody.prototype), "connectedCallback", this).call(this); // mutation observer that ensures state of hax applied correctly

        this._observer = new MutationObserver(function (mutations) {
          var mutFind = false;
          mutations.forEach(function (mutation) {
            // if we've got new nodes, we have to react to that
            if (mutation.addedNodes.length > 0) {
              mutation.addedNodes.forEach(function (node) {
                if (_this4._validElementTest(node)) {
                  // edge case, thing is moved around in the dom so let's do the opposite
                  // this is something that has PART of these applies
                  // let's make sure that we maintain state associated with contenteditable
                  if (_this4.editMode && (node.getAttribute("contenteditable") == "true" || node.getAttribute("contenteditable") === true || node.getAttribute("contenteditable") == "contenteditable")) {
                    _this4.__applyNodeEditableState(node, !_this4.editMode);
                  }

                  _this4.__applyNodeEditableState(node, _this4.editMode);

                  _this4.dispatchEvent(new CustomEvent("hax-body-tag-added", {
                    bubbles: true,
                    cancelable: true,
                    composed: true,
                    detail: {
                      node: node
                    }
                  })); // special support for Header tags showing up w.o. identifiers
                  // this way it's easier to anchor to them in the future


                  if (["H1", "H2", "H3", "H4", "H5", "H6"].includes(node.tagName) && node.getAttribute("id") == null) {
                    node.setAttribute("id", (0, _utils.generateResourceID)("header-"));
                  } // set new nodes to be the active one
                  // only if we didn't just do a grid plate move
                  // if multiple mutations, only accept the 1st one in a group


                  if (!_this4.___moveLock && !mutFind) {
                    mutFind = true;
                    _this4.activeNode = node;
                    window.HaxStore.write("activeNode", node, _this4);
                  } else {
                    _this4.___moveLock = false;
                  }
                }
              });
            } // if we dropped nodes via the UI (delete event basically)


            if (mutation.removedNodes.length > 0) {
              // handle removing items... not sure we need to do anything here
              mutation.removedNodes.forEach(function (node) {
                if (_this4._validElementTest(node) && !node.classList.contains("hax-active")) {
                  _this4.dispatchEvent(new CustomEvent("hax-body-tag-removed", {
                    bubbles: true,
                    cancelable: true,
                    composed: true,
                    detail: {
                      node: node
                    }
                  }));
                }
              });
            }
          });
        });

        this._observer.observe(this, {
          childList: true
        });

        setTimeout(function () {
          window.addEventListener("keydown", _this4._onKeyDown.bind(_this4));
          window.addEventListener("keypress", _this4._onKeyPress.bind(_this4));
          document.body.addEventListener("hax-store-property-updated", _this4._haxStorePropertyUpdated.bind(_this4));
          window.addEventListener("scroll", _this4._keepContextVisible.bind(_this4));
          window.addEventListener("resize", _this4._keepContextVisible.bind(_this4));
        }, 0);
      }
      /**
       * HTMLElement
       */

    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        window.removeEventListener("keydown", this._onKeyDown.bind(this));
        window.removeEventListener("keypress", this._onKeyPress.bind(this));
        document.body.removeEventListener("hax-store-property-updated", this._haxStorePropertyUpdated.bind(this));
        window.removeEventListener("scroll", this._keepContextVisible.bind(this));
        window.removeEventListener("resize", this._keepContextVisible.bind(this));

        this._observer.disconnect();

        babelHelpers.get(babelHelpers.getPrototypeOf(HaxBody.prototype), "disconnectedCallback", this).call(this);
      }
      /**
       * Keep the context menu visible if needed
       */

    }, {
      key: "_keepContextVisible",
      value: function _keepContextVisible() {
        var _this5 = this;

        var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

        if (!this.openDrawer && this.editMode) {
          clearTimeout(this.__contextVisibleLock);
          this.__contextVisibleLock = setTimeout(function () {
            // see if the text context menu is visible
            var el = false;

            if (_this5.shadowRoot.querySelector("#textcontextmenu").classList.contains("hax-context-visible")) {
              el = _this5.shadowRoot.querySelector("#textcontextmenu");
            } else if (_this5.shadowRoot.querySelector("#cecontextmenu").classList.contains("hax-context-visible")) {
              el = _this5.shadowRoot.querySelector("#cecontextmenu");
            } // if we see it, ensure we don't have the pin


            if (el) {
              if (_this5.elementMidViewport()) {
                el.classList.add("hax-context-pin-top");

                _this5.shadowRoot.querySelector("#platecontextmenu").classList.add("hax-context-pin-top");
              } else {
                el.classList.remove("hax-context-pin-top");

                _this5.shadowRoot.querySelector("#platecontextmenu").classList.remove("hax-context-pin-top");
              }

              _this5.positionContextMenus();
            }
          }, 50);
        }
      }
    }, {
      key: "_onKeyDown",
      value: function _onKeyDown(e) {
        var _this6 = this;

        if (!this.openDrawer && this.editMode && this.getAttribute("contenteditable")) {
          var sel = window.HaxStore.getSelection();

          if (sel.anchorNode != null) {
            switch (e.key) {
              case "Tab":
                if (window.HaxStore.instance.isTextElement(this.activeNode)) {
                  if (e.detail.keyboardEvent) {
                    e.detail.keyboardEvent.preventDefault();
                    e.detail.keyboardEvent.stopPropagation();
                    e.detail.keyboardEvent.stopImmediatePropagation();
                  }

                  e.preventDefault();
                  e.stopPropagation();
                  e.stopImmediatePropagation();

                  if (e.shiftKey) {
                    this._tabBackKeyPressed();
                  } else {
                    this._tabKeyPressed();
                  }
                }

                break;

              case "Enter":
                this.setAttribute("contenteditable", true);

              case "Backspace":
              case "Delete":
              case "ArrowUp":
              case "ArrowDown":
              case "ArrowLeft":
              case "ArrowRight":
                clearTimeout(this.__keyPress);
                this.__keyPress = setTimeout(function () {
                  var tmp = window.HaxStore.getSelection();
                  window.HaxStore._tmpSelection = tmp;
                  window.HaxStore.write("haxSelectedText", tmp.toString(), _this6);
                  var rng = window.HaxStore.getRange();

                  if (rng.commonAncestorContainer && _this6.activeNode !== rng.commonAncestorContainer && typeof rng.commonAncestorContainer.focus === "function") {
                    if (rng.commonAncestorContainer.tagName !== "HAX-BODY") {
                      if (window.HaxStore.instance.isTextElement(rng.commonAncestorContainer)) {
                        _this6.setAttribute("contenteditable", true);
                      } else {
                        _this6.removeAttribute("contenteditable");
                      }

                      rng.commonAncestorContainer.focus();

                      _this6.__focusLogic(rng.commonAncestorContainer);
                    }
                  } // need to check on the parent too if this was a text node
                  else if (rng.commonAncestorContainer && rng.commonAncestorContainer.parentNode && _this6.activeNode !== rng.commonAncestorContainer.parentNode && typeof rng.commonAncestorContainer.parentNode.focus === "function") {
                      if (rng.commonAncestorContainer.parentNode.tagName !== "HAX-BODY") {
                        if (window.HaxStore.instance.isTextElement(rng.commonAncestorContainer.parentNode)) {
                          _this6.setAttribute("contenteditable", true);
                        } else {
                          _this6.removeAttribute("contenteditable");
                        }

                        rng.commonAncestorContainer.parentNode.focus();

                        _this6.__focusLogic(rng.commonAncestorContainer.parentNode);
                      } else {
                        _this6.activeNode = rng.commonAncestorContainer;
                        _this6.activeContainerNode = _this6.activeNode;
                        window.HaxStore.write("activeNode", rng.commonAncestorContainer, _this6);
                        window.HaxStore.write("activeContainerNode", rng.commonAncestorContainer, _this6);
                        setTimeout(function () {
                          _this6.positionContextMenus();
                        }, 0);
                      }
                    } else {}
                }, 50);
                break;
            }

            if (this.shadowRoot.querySelector("#platecontextmenu").classList.contains("hax-active-hover")) {
              this.__dropActiveHover();
            }
          }
        }
      }
    }, {
      key: "_onKeyPress",
      value: function _onKeyPress(e) {
        var _this7 = this;

        clearTimeout(this.__keyPress);
        this.__keyPress = setTimeout(function () {
          if (!_this7.openDrawer && _this7.editMode && _this7.shadowRoot.querySelector("#textcontextmenu").classList.contains("hax-active-hover") && _this7.activeNode && window.HaxStore.instance.isTextElement(_this7.activeNode)) {
            _this7.__dropActiveHover();
          } else if (!_this7.openDrawer && _this7.editMode && _this7.activeNode && window.HaxStore.instance.isTextElement(_this7.activeNode)) {
            // If the user has paused for awhile, show the menu
            clearTimeout(_this7.__positionContextTimer);
            _this7.__positionContextTimer = setTimeout(function () {
              // always on active if we were just typing
              _this7.positionContextMenus();
            }, 1500);
          }
        }, 50);
      }
      /**
       * on mouse over then fire the hax ray value if we have one
       */

    }, {
      key: "hoverEvent",
      value: function hoverEvent(e) {
        if (!this.openDrawer && this.editMode) {
          if (e.target && e.target.getAttribute("data-hax-ray") != null) {
            this.__activeHover = e.target;
          } else if (e.target && e.target.parentNode && e.target.parentNode.getAttribute("data-hax-ray") != null) {
            this.__activeHover = e.target.parentNode;
          }

          if (!this.shadowRoot.querySelector("#platecontextmenu").classList.contains("hax-active-hover")) {
            var local = e.target; // see if the target is relevent when showing the edit menu operations

            if (e.target === this.shadowRoot.querySelector("#cecontextmenu") || e.target === this.shadowRoot.querySelector("#textcontextmenu") || e.target === this.shadowRoot.querySelector("#platecontextmenu") || local === this.activeNode || local === this.activeContainerNode || e.target === this.activeNode || e.target === this.activeContainerNode || local.parentNode === this.activeContainerNode || local.parentNode.parentNode === this.activeContainerNode || local.parentNode.parentNode.parentNode === this.activeContainerNode) {
              this.positionContextMenus();

              this.__addActiveHover();

              this.__typeLock = false;
            } else {
              this.__dropActiveHover();
            }
          }
        }
      }
    }, {
      key: "__addActiveHover",
      value: function __addActiveHover() {
        this.shadowRoot.querySelector("#cecontextmenu").classList.add("hax-active-hover");
        this.shadowRoot.querySelector("#textcontextmenu").classList.add("hax-active-hover");
        this.shadowRoot.querySelector("#platecontextmenu").classList.add("hax-active-hover");
      }
    }, {
      key: "__dropActiveHover",
      value: function __dropActiveHover() {
        this.shadowRoot.querySelector("#cecontextmenu").classList.remove("hax-active-hover");
        this.shadowRoot.querySelector("#textcontextmenu").classList.remove("hax-active-hover");
        this.shadowRoot.querySelector("#platecontextmenu").classList.remove("hax-active-hover");
      }
      /**
       * Only true if we are scrolling and part way through an element
       */

    }, {
      key: "elementMidViewport",
      value: function elementMidViewport() {
        var y = this.activeNode.getBoundingClientRect().y;
        return y < 0 && y > -1 * this.activeNode.offsetHeight + 140;
      }
      /**
       * Replace place holder after an event has called for it in the element itself
       */

    }, {
      key: "replacePlaceholder",
      value: function replacePlaceholder(e) {
        var _this8 = this;

        // generate a paragraph of text here on click
        if (e.detail === "text") {
          // make sure text just escalates to a paragraph tag
          var p = document.createElement("p");
          p.innerHTML = "<br/>";
          this.haxReplaceNode(this.activeNode, p); // allow swap out to happen

          setTimeout(function () {
            // set active to this p tag
            _this8.activeNode = p;
            window.HaxStore.write("activeNode", p, _this8);

            _this8.activeContainerNode.setAttribute("contenteditable", true); // focus on it


            p.focus();

            _this8.__focusLogic(p);
          }, 210);
        } else {
          this.replaceElementWorkflow();
        }
      }
    }, {
      key: "canTansformNode",
      value: function canTansformNode() {
        var node = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        return this.replaceElementWorkflow(node, true).length > 0 ? true : false;
      }
      /**
       * Whole workflow of replacing something in place contextually.
       * This can fire for things like events needing this workflow to
       * invoke whether it's a "convert" event or a "replace placeholder" event
       */

    }, {
      key: "replaceElementWorkflow",
      value: function replaceElementWorkflow() {
        var activeNode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        var testOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        // support for tests with things other than activeNode
        if (activeNode == null) {
          activeNode = this.activeNode;
        }

        var element = (0, _utils.nodeToHaxElement)(activeNode, null);
        var type = "*";
        var skipPropMatch = false; // special support for place holder which defines exactly
        // what the user wants this replaced with

        if (element.tag === "place-holder" && babelHelpers.typeof(element.properties["type"]) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
          type = element.properties["type"];
          skipPropMatch = true;
        }

        var props = {}; // see if we have a gizmo as it's not a requirement to registration
        // as well as having handlers since mapping is not required either

        if (babelHelpers.typeof(window.HaxStore.instance.elementList[element.tag]) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && window.HaxStore.instance.elementList[element.tag].gizmo !== false && babelHelpers.typeof(window.HaxStore.instance.elementList[element.tag].gizmo.handles) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && window.HaxStore.instance.elementList[element.tag].gizmo.handles.length > 0) {
          // get the haxProperties for this item
          var gizmo = window.HaxStore.instance.elementList[element.tag].gizmo; // walk through each handler

          for (var i = 0; i < gizmo.handles.length; i++) {
            // walk the properties defined as they would be to the
            // left side of the ledger and tell us which property to
            // mesh with. This effectively rehydrates / inverts that
            // relationship where we have an element and want to say
            // "oh ya, but what could have handled this" so that we
            // can use that translation to offer up convertion to a
            // new element. This is insane.
            for (var prop in gizmo.handles[i]) {
              // type is a reserved handler but any other property
              // which we actually have in our element let's go for it
              if (prop !== "type" && babelHelpers.typeof(element.properties[gizmo.handles[i][prop]]) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
                // The cake is a lie... oh wait... no it's not.
                // This will completely bend your mind when it comes to
                // what HTML is, how it should operate and what universe
                // we can now contort as a result. This effectively allows
                // reverse engineering any element on the page into any
                // other compatible element based on the properties in
                // each element claiming to be compatible.
                props[prop] = element.properties[gizmo.handles[i][prop]];
              }
            }
          }
        }

        var haxElements = window.HaxStore.guessGizmo(type, props, skipPropMatch); // see if we got anything

        if (haxElements.length > 0) {
          // hand off to hax-app-picker to deal with the rest of this
          var tag = activeNode.tagName.toLowerCase();
          var humanName = tag.replace("-", " ");

          if (babelHelpers.typeof(window.HaxStore.instance.elementList[tag]) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && window.HaxStore.instance.elementList[tag].gizmo !== false) {
            humanName = window.HaxStore.instance.elementList[tag].gizmo.title;
          }

          if (!testOnly) {
            window.HaxStore.instance.activePlaceHolder = this.activeNode;
            window.HaxStore.instance.haxAppPicker.presentOptions(haxElements, "__convert", "Transform ".concat(humanName, " to.."), "gizmo");
          }
        } else {
          if (!testOnly) {
            window.HaxStore.toast("Sorry, this can not be transformed!", 5000);
          }
        }

        return haxElements;
      }
      /**
       * Global prefs updated, let's visualize stuff from hax-ray
       */

    }, {
      key: "_globalPreferencesUpdated",
      value: function _globalPreferencesUpdated(newValue, oldValue) {
        if (babelHelpers.typeof(newValue) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && newValue != null) {
          this.haxRayMode = newValue.haxRayMode;
        }
      }
      /**
       * Store updated, sync.
       */

    }, {
      key: "_haxStorePropertyUpdated",
      value: function _haxStorePropertyUpdated(e) {
        if (e.detail && babelHelpers.typeof(e.detail.value) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && e.detail.property) {
          this[e.detail.property] = e.detail.value;
        }
      }
      /**
       * Clear area.
       */

    }, {
      key: "haxClearBody",
      value: function haxClearBody() {
        var confirm = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        var status = true; // only confirm if asked so we can support wipes without it

        if (confirm) {
          status = prompt("Are you sure you want to delete all content?");
        } // ensure they said yes


        if (status) {
          (0, _utils.wipeSlot)(this);
        }
      }
      /**
       * Insert new tag + content into the local DOM as a node.
       */

    }, {
      key: "haxInsert",
      value: function haxInsert(tag, content) {
        var _this9 = this;

        var properties = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        this.__activeHover = null; // verify this tag is a valid one
        // create a new element fragment w/ content in it
        // if this is a custom-element it won't expand though

        var frag = document.createElement(tag); // set text forcibly
        //frag.innerText = content;
        // now set html forcibly which would overwrite the other one

        frag.innerHTML = content; // clone the fragment which will force an escalation to full node

        var newNode = frag.cloneNode(true); // support for properties if they exist

        for (var property in properties) {
          var attributeName = window.HaxStore.camelToDash(property);

          if (properties.hasOwnProperty(property)) {
            // special supporting for boolean because html is weird :p
            if (properties[property] === true) {
              newNode.setAttribute(attributeName, attributeName);
            } else if (properties[property] === false) {
              newNode.removeAttribute(attributeName);
            } else if (properties[property] != null && properties[property].constructor === Array) {
              if (newNode.properties && newNode.properties[property].readOnly) {} else {
                if (newNode.set) {
                  newNode.set(attributeName, properties[property]);
                } else {
                  newNode[attributeName] = properties[property];
                }
              }
            } else if (properties[property] != null && properties[property].constructor === Object) {
              if (newNode.properties && newNode.properties[property].readOnly) {} else {
                if (newNode.set) {
                  newNode.set(attributeName, properties[property]);
                } else {
                  newNode[attributeName] = properties[property];
                }
              }
            } else {
              newNode.setAttribute(attributeName, properties[property]);
            }
          }
        } // special support for a drag and drop into a place-holder tag
        // as this is a more aggressive operation then the others


        if (window.HaxStore.instance.activePlaceHolder !== null && babelHelpers.typeof(window.HaxStore.instance.activePlaceHolder.style) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
          // replicate styles so that it doesn't jar the UI
          newNode.style.width = window.HaxStore.instance.activePlaceHolder.style.width;
          newNode.style.float = window.HaxStore.instance.activePlaceHolder.style.float;
          newNode.style.margin = window.HaxStore.instance.activePlaceHolder.style.margin;
          newNode.style.display = window.HaxStore.instance.activePlaceHolder.style.display;
          this.haxReplaceNode(window.HaxStore.instance.activePlaceHolder, newNode);
          window.HaxStore.instance.activePlaceHolder = null;
        } // insert at active insert point if we have one
        else if (this.activeContainerNode != null) {
            // allow for inserting things into things but not grid plate
            if (this.activeContainerNode.tagName === "GRID-PLATE" && this.activeContainerNode !== this.activeNode) {
              if (this.activeNode.getAttribute("slot") != null) {
                newNode.setAttribute("slot", this.activeNode.getAttribute("slot"));
              }

              if (this.activeNode.parentNode == this.activeContainerNode) {
                this.activeContainerNode.insertBefore(newNode, this.activeNode);
              } else {
                this.activeContainerNode.appendChild(newNode);
              }
            } else {
              if (this.activeContainerNode && this.activeContainerNode.nextElementSibling) {
                this.activeContainerNode.nextElementSibling.parentNode.insertBefore(newNode, this.activeContainerNode.nextElementSibling);
              } else if (this.activeNode.parentNode) {
                this.activeNode.parentNode.insertBefore(newNode, this.activeNode);
              } else {
                // something odd happened let's just make sure we insert this safely
                this.appendChild(newNode);
              }
            }
          } else {
            // send this into the root, which should filter it back down into the slot
            this.appendChild(newNode);
          }

        this.shadowRoot.querySelector("#textcontextmenu").highlightOps = false;
        this.activeContainerNode = newNode.parentNode;
        this.activeNode = newNode;
        window.HaxStore.write("activeContainerNode", newNode.parentNode, this);
        window.HaxStore.write("activeNode", newNode, this); // wait so that the DOM can have the node to then attach to

        setTimeout(function () {
          // scroll to it
          if (typeof newNode.scrollIntoViewIfNeeded === "function") {
            newNode.scrollIntoViewIfNeeded(true);
          } else {
            newNode.scrollIntoView({
              behavior: "smooth",
              inline: "center"
            });
          }

          _this9.positionContextMenus();
        }, 10);
        return true;
      }
      /**
       * Return the current hax content area as text that could be
       * inserted into something.
       */

    }, {
      key: "haxToContent",
      value: function haxToContent() {
        this.hideContextMenus();
        var __active = this.activeNode; // null this to drop hax based classes

        this.activeNode = null;
        this.activeContainerNode = null;
        window.HaxStore.write("activeNode", null, this);
        window.HaxStore.write("activeContainerNode", null, this);
        var children = this.shadowRoot.querySelector("#body").localName === "slot" ? this.shadowRoot.querySelector("#body").assignedNodes({
          flatten: true
        }) : [];
        var content = "";

        for (var i = 0, len = children.length; i < len; i++) {
          // some mild front-end sanitization
          if (this._validElementTest(children[i])) {
            children[i].removeAttribute("data-editable");
            children[i].removeAttribute("data-hax-ray"); // remove some of the protected classes though they shouldn't leak through

            children[i].classList.remove("hax-mover", "hax-moving", "hax-hovered", "grid-plate-active-item");
            children[i].contentEditable = false;
            content += window.HaxStore.nodeToContent(children[i]);

            if (children[i].tagName.toLowerCase() === "grid-plate") {
              this._applyContentEditable(this.editMode, children[i]);
            }
          } // keep comments with a special case since they need wrapped
          else if (children[i].nodeType === 8) {
              content += "<!-- " + children[i].textContent + " -->";
            } // keep everything NOT an element at this point, this helps
            // preserve whitespace because we're crazy about accuracy
            else if (children[i].nodeType !== 1 && babelHelpers.typeof(children[i].textContent) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && children[i].textContent !== "undefined") {
                content += children[i].textContent;
              }
        } // remove the contenteditable attribute


        content = content.replace(/\scontenteditable=\"false\"/g, ""); // remove the data-editable attribute

        content = content.replace(/\sdata-editable=\"true\"/g, "");
        content = content.replace(/\sdata-editable=\"false\"/g, "");
        content = content.replace(/\sdata-editable=\""/g, ""); // remove other attributes that can linger in slots

        content = content.replace(/\sdata-editable/g, "");
        content = content.replace(/\scontenteditable/g, "");
        content = content.replace(/\sdraggable/g, ""); // clean up stray hax-ray leftovers

        content = content.replace(/\sdata-hax-ray=\".*?\"/g, ""); // remove HAX specific classes / scoping classes

        if (this.parentNode.tagName) {
          var parentTag = this.parentNode.tagName.toLowerCase();
          var string = "style-scope " + parentTag + " x-scope";
          var re = new RegExp(string, "g");
          content = content.replace(re, ""); // remove without the deeeper scope as well for primitives

          string = "style-scope " + parentTag;
          re = new RegExp(string, "g");
          content = content.replace(re, ""); // remove the last common one unpacked

          string = "x-scope " + parentTag + "-0";
          re = new RegExp(string, "g");
          content = content.replace(re, ""); // now all tags we have defined as valid

          var tags = window.HaxStore.instance.validTagList;

          for (var i in tags) {
            string = "style-scope " + tags[i];
            re = new RegExp(string, "g");
            content = content.replace(re, "");
            string = "x-scope " + tags[i] + "-0 ";
            re = new RegExp(string, "g");
            content = content.replace(re, "");
            string = "x-scope " + tags[i] + "-0";
            re = new RegExp(string, "g");
            content = content.replace(re, "");
          }
        } // remove empty class structures


        content = content.replace(/\sclass=\"\"/g, "");
        content = content.replace(/\sclass=\"\s\"/g, ""); // re-apply contenteditable if needed

        this._applyContentEditable(this.editMode); // set active again


        window.HaxStore.write("activeNode", __active, this);
        window.HaxStore.write("activeContainerNode", __active, this); // oh one last thing. escape all script/style tags

        content = (0, _utils.encapScript)(content);
        return content;
      }
      /**
       * Duplicate node into the local DOM below the current item if we can.
       */

    }, {
      key: "haxDuplicateNode",
      value: function haxDuplicateNode(node) {
        var _this10 = this;

        var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this;
        // move the context menu before duplicating!!!!
        this.hideContextMenus(false); // convert the node to a hax element

        var haxElement = (0, _utils.nodeToHaxElement)(node, null); // support for deep API call to clean up special elements

        if (babelHelpers.typeof(node.preProcessHaxInsertContent) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
          haxElement = node.preProcessHaxInsertContent(haxElement);
        }

        if (haxElement.content == haxElement.properties.innerHTML) {
          delete haxElement.properties.innerHTML;
        } // convert it back to a clone, seems odd I'm sure but this ensures that all props are copied
        // correctly and that we get a brand new object


        var nodeClone = (0, _utils.haxElementToNode)({
          tag: haxElement.tag,
          content: haxElement.content,
          properties: haxElement.properties
        });

        if (nodeClone.tagName.toLowerCase() === "webview" && window.HaxStore.instance._isSandboxed && babelHelpers.typeof(nodeClone.guestinstance) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
          delete nodeClone.guestinstance;
        } // shouldn't be possible but might as well check


        if (node !== null) {
          parent.insertBefore(nodeClone, node.nextSibling);
        } else {
          parent.appendChild(nodeClone);
        }

        setTimeout(function () {
          // test for a grid plate clone
          if (parent === _this10) {
            window.HaxStore.write("activeContainerNode", nodeClone, _this10);
          }

          window.HaxStore.write("activeNode", nodeClone, _this10);
        }, 100);
        return true;
      }
      /**
       * Hide all context menus.
       */

    }, {
      key: "hideContextMenus",
      value: function hideContextMenus() {
        var hidePlate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        // clear the timeouts for anything that could cause these to reapear
        clearTimeout(gravityScrollTimer);
        clearTimeout(this.__keyPress);
        clearTimeout(this.__contextVisibleLock);
        clearTimeout(this.__positionContextTimer); // primary context menus

        this._hideContextMenu(this.shadowRoot.querySelector("#textcontextmenu"));

        this._hideContextMenu(this.shadowRoot.querySelector("#cecontextmenu")); // secondary menus and clean up areas


        if (hidePlate) {
          this._hideContextMenu(this.shadowRoot.querySelector("#platecontextmenu"));
        } // force context menu state to closed


        this.shadowRoot.querySelector("#textcontextmenu").highlightOps = false;
      }
      /**
       * Reposition context menus to match an element.
       */

    }, {
      key: "positionContextMenus",
      value: function positionContextMenus() {
        var _this11 = this;

        var node = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.activeNode;
        var container = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.activeNode;
        // sanity chekc and ensure we are not told to lock position of all menus
        clearTimeout(this.__positionContextTimer);
        this.__positionContextTimer = setTimeout(function () {
          if (node && !window.HaxStore.instance._lockContextPosition && _this11.__ready) {
            // menu width starts out w/ the plate context which is a set size
            var menuWidth = 140;
            var tag = node.tagName.toLowerCase();

            if (window.HaxStore.instance._isSandboxed && tag === "webview") {
              tag = "iframe";
            }

            var props = window.HaxStore.instance.elementList[tag]; // try and work against anything NOT a P tag

            if (babelHelpers.typeof(props) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && !window.HaxStore.instance.isTextElement(node)) {
              _this11._hideContextMenu(_this11.shadowRoot.querySelector("#textcontextmenu"));

              props.element = node;

              _this11._positionContextMenu(_this11.shadowRoot.querySelector("#cecontextmenu"), container, -1, -30);

              menuWidth += 28;
            } else {
              _this11._hideContextMenu(_this11.shadowRoot.querySelector("#cecontextmenu"));

              _this11._positionContextMenu(_this11.shadowRoot.querySelector("#textcontextmenu"), container, -1, -30); // text menu can expand based on selection


              var textRect = _this11.shadowRoot.querySelector("#textcontextmenu").getBoundingClientRect();

              menuWidth += textRect.width;
            }

            if (container) {
              var activeRect = container.getBoundingClientRect(); // need to account for the item being small than the menu

              if (Math.round(menuWidth) >= Math.round(activeRect.width)) {
                _this11._positionContextMenu(_this11.shadowRoot.querySelector("#platecontextmenu"), container, -1, -58);
              } else {
                _this11._positionContextMenu(_this11.shadowRoot.querySelector("#platecontextmenu"), container, activeRect.width - _this11.shadowRoot.querySelector("#platecontextmenu").getBoundingClientRect().width + 2, -28);
              }
            } // special case for node not matching container yet it being editable


            if (container && !window.HaxStore.instance.isTextElement(node) && node !== container) {
              container.removeAttribute("contenteditable");
            } else if (container) {
              container.setAttribute("contenteditable", true);
            }
          }
        }, 10);
      }
      /**
       * Move grid plate around
       */

    }, {
      key: "haxMoveGridPlate",
      value: function haxMoveGridPlate(direction, node, container) {
        var _this12 = this;

        // menu is actually in the element for render purposes
        // support moving things multiple directions
        this.___moveLock = true;

        switch (direction) {
          case "first":
            // ensure we can go up, first being a mode of up
            if (container.previousElementSibling !== null) {
              this.insertBefore(container, this.firstChild);
            }

            break;

          case "up":
            // ensure we can go up
            if (container.previousElementSibling !== null) {
              this.insertBefore(container, container.previousElementSibling);
            }

            break;

          case "down":
            if (container.nextElementSibling !== null) {
              this.insertBefore(container.nextElementSibling, container);
            }

            break;

          case "last":
            if (container.nextElementSibling !== null) {
              this.appendChild(container);
            }

            break;
        }

        setTimeout(function () {
          if (typeof node.scrollIntoViewIfNeeded === "function") {
            node.scrollIntoViewIfNeeded(true);
          } else {
            node.scrollIntoView({
              behavior: "smooth",
              inline: "center"
            });
          }

          _this12.positionContextMenus(node, node);
        }, 10);
        return true;
      }
      /**
       * Inject / modify a grid plate where something currently lives
       */

    }, {
      key: "haxGridPlateOps",
      value: function () {
        var _haxGridPlateOps = babelHelpers.asyncToGenerator(
        /*#__PURE__*/
        regeneratorRuntime.mark(function _callee(node, side) {
          var _this13 = this;

          var add,
              changed,
              cloneEl,
              platecontextmenu,
              right,
              rightremove,
              grid,
              col,
              _args = arguments;
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  add = _args.length > 2 && _args[2] !== undefined ? _args[2] : true;
                  // allow splitting the grid plate that is already there
                  changed = false;

                  if (!(node.tagName === "GRID-PLATE")) {
                    _context.next = 51;
                    break;
                  }

                  if (!add) {
                    _context.next = 24;
                    break;
                  }

                  _context.t0 = node.layout;
                  _context.next = _context.t0 === "1" ? 7 : _context.t0 === "1-1" ? 10 : _context.t0 === "1-1-1" ? 13 : _context.t0 === "1-1-1-1" ? 16 : _context.t0 === "1-1-1-1-1" ? 19 : 22;
                  break;

                case 7:
                  node.layout = "1-1";
                  changed = true;
                  return _context.abrupt("break", 22);

                case 10:
                  node.layout = "1-1-1";
                  changed = true;
                  return _context.abrupt("break", 22);

                case 13:
                  node.layout = "1-1-1-1";
                  changed = true;
                  return _context.abrupt("break", 22);

                case 16:
                  node.layout = "1-1-1-1-1";
                  changed = true;
                  return _context.abrupt("break", 22);

                case 19:
                  node.layout = "1-1-1-1-1-1";
                  changed = true;
                  return _context.abrupt("break", 22);

                case 22:
                  _context.next = 48;
                  break;

                case 24:
                  _context.t1 = node.layout;
                  _context.next = _context.t1 === "1-1" ? 27 : _context.t1 === "1-1-1" ? 36 : _context.t1 === "1-1-1-1" ? 39 : _context.t1 === "1-1-1-1-1" ? 42 : _context.t1 === "1-1-1-1-1-1" ? 45 : 48;
                  break;

                case 27:
                  _context.next = 29;
                  return node.childNodes.forEach(function (el) {
                    // verify its a tag
                    if (el.tagName) {
                      // remove slot name
                      cloneEl = el.cloneNode(true);
                      cloneEl.removeAttribute("slot");
                      cloneEl.classList.remove("hax-mover");
                      cloneEl.classList.remove("hax-moving");
                      node.parentNode.insertBefore(cloneEl, node);
                    }
                  });

                case 29:
                  // whatever was moved out last use as active now
                  this.activeNode = cloneEl;
                  this.activeContainerNode = cloneEl;
                  window.HaxStore.write("activeNode", cloneEl, this);
                  window.HaxStore.write("activeContainerNode", cloneEl, this);
                  setTimeout(function () {
                    node.remove();
                  }, 0);
                  changed = true;
                  return _context.abrupt("break", 48);

                case 36:
                  node.layout = "1-1";
                  changed = true;
                  return _context.abrupt("break", 48);

                case 39:
                  node.layout = "1-1-1";
                  changed = true;
                  return _context.abrupt("break", 48);

                case 42:
                  node.layout = "1-1-1-1";
                  changed = true;
                  return _context.abrupt("break", 48);

                case 45:
                  node.layout = "1-1-1-1-1";
                  changed = true;
                  return _context.abrupt("break", 48);

                case 48:
                  // if left, nudge everything over 1, right simple
                  if (changed) {
                    platecontextmenu = this.shadowRoot.querySelector("#platecontextmenu");
                    right = platecontextmenu.shadowRoot.querySelector("#right");
                    rightremove = platecontextmenu.shadowRoot.querySelector("#rightremove");
                    right.disabled = false;
                    rightremove.disabled = false;

                    if (node.layout == "1-1-1-1-1-1") {
                      right.disabled = true;
                    }

                    if (side == "left") {
                      node.childNodes.forEach(function (el) {
                        if (el.tagName) {
                          var s = parseInt(el.getAttribute("slot").replace("col-", ""), 10) + 1;
                          el.setAttribute("slot", "col-".concat(s));
                        }
                      });
                    }
                  }

                  _context.next = 58;
                  break;

                case 51:
                  // make a new grid plate, default to 2 col and disable
                  // responsive by default as this is what many will expect
                  grid = document.createElement("grid-plate");
                  grid.layout = "1-1";
                  grid.disableResponsive = true;
                  node.parentNode.insertBefore(grid, node);
                  col = "2";

                  if (side == "right") {
                    col = "1";
                  }

                  setTimeout(function () {
                    grid.appendChild(node);
                    _this13.activeContainerNode = grid;
                    window.HaxStore.write("activeContainerNode", grid, _this13);
                    node.setAttribute("slot", "col-" + col);
                  }, 0);

                case 58:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));

        function haxGridPlateOps(_x, _x2) {
          return _haxGridPlateOps.apply(this, arguments);
        }

        return haxGridPlateOps;
      }()
      /**
       * Convert an element from one tag to another.
       */

    }, {
      key: "haxReplaceNode",
      value: function haxReplaceNode(node, replacement) {
        // Switch, try loop in case we screwed up elsewhere
        try {
          if (node == null) {
            node = this.__oldActiveNode;
          }

          node.replaceWith(replacement); // test for slots to match

          if (node && node.getAttribute && node.getAttribute("slot") != null) {
            replacement.setAttribute("slot", node.getAttribute("slot"));
          }
        } catch (e) {
          console.warn(e);
        }

        return replacement;
      }
      /**
       * Convert an element from one tag to another.
       */

    }, {
      key: "haxChangeTagName",
      value: function haxChangeTagName(node, tagName) {
        // Create a replacement tag of the desired type
        var replacement = document.createElement(tagName); // Grab all of the original's attributes, and pass them to the replacement

        for (var i = 0, l = node.attributes.length; i < l; ++i) {
          var nodeName = node.attributes.item(i).nodeName;
          var value = node.attributes.item(i).value;
          replacement.setAttribute(nodeName, value);
        } // Persist contents
        // account for empty list and ordered list items


        replacement.innerHTML = node.innerHTML.trim();

        if (tagName == "ul" || tagName == "ol") {
          if (replacement.innerHTML == "") {
            replacement.innerHTML = "<li></li>";
          } else if (!(node.tagName.toLowerCase() == "ul" || node.tagName.toLowerCase() == "ol")) {
            replacement.innerHTML = "<li>" + node.innerHTML.trim().replace(/<br\/>/g, "</li>\n<li>").replace(/<br>/g, "</li>\n<li>") + "</li>";
          }
        } else if (node.tagName.toLowerCase() == "ul" || node.tagName.toLowerCase() == "ol") {
          // if we're coming from ul or ol strip out the li tags
          replacement.innerHTML = replacement.innerHTML.replace(/<ul>/g, "").replace(/<\/ul>/g, "").replace(/<li><\/li>/g, "").replace(/<li>/g, "").replace(/<\/li>/g, "<br/>");
        } // Switch!


        try {
          node.replaceWith(replacement); // focus on the thing switched to

          setTimeout(function () {
            var children = replacement.children; // see if there's a child element and focus that instead if there is

            if (children[0] && children.tagName) {
              children[0].focus();
            } else {
              replacement.focus();
            }
          }, 50);
        } catch (e) {
          console.warn(e);
          console.warn(replacement);
          console.warn(node);
        }

        return replacement;
      }
      /**
       * Delete the node passed in
       */

    }, {
      key: "haxDeleteNode",
      value: function haxDeleteNode(node) {
        var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this;
        // move the context menu before deleting!!!!
        this.hideContextMenus();
        this.activeNode = null;
        this.activeContainerNode = null;
        window.HaxStore.write("activeNode", null, this);
        window.HaxStore.write("activeContainerNode", null, this);

        try {
          return node.remove();
        } catch (e) {
          console.warn(e);
        }
      }
      /**
       * Bulk import HTML with option to clear what is currently
       * in the slot of this tag. This also validates tags
       * that are being inserted for security based on the
       * internal whitelist.
       */

    }, {
      key: "importContent",
      value: function importContent(html) {
        var _this14 = this;

        var clear = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

        // kill the slot of the active body, all of it
        if (clear) {
          (0, _utils.wipeSlot)(this, "*");
        } // pause quickly to ensure wipe goes through successfully


        setTimeout(function () {
          html = (0, _utils.encapScript)(html);
          var fragment = document.createElement("div");
          fragment.insertAdjacentHTML("beforeend", html);

          while (fragment.firstChild !== null) {
            if (babelHelpers.typeof(fragment.firstChild.tagName) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
              // ensure import doesn't import non-sandbox safe things!
              if (window.HaxStore.instance._isSandboxed && fragment.firstChild.tagName.toLowerCase() === "iframe") {
                // Create a replacement tag of the desired type
                var replacement = document.createElement("webview"); // Grab all of the original's attributes, and pass them to the replacement

                for (var j = 0, l = fragment.firstChild.attributes.length; j < l; ++j) {
                  var nodeName = fragment.firstChild.attributes.item(j).nodeName;
                  var value = fragment.firstChild.attributes.item(j).value;

                  if (nodeName === "height" || nodeName === "width") {
                    replacement.style[nodeName] == value;
                  }

                  replacement.setAttribute(nodeName, value);
                }

                _this14.appendChild(replacement);
              } else {
                _this14.appendChild(fragment.firstChild);
              }
            } else {
              // @todo might want to support appending or keeping track of comments / non tags
              // but this is not a must have
              fragment.removeChild(fragment.firstChild);
            }
          }
        }, 50);
      }
      /**
       * Respond to hax operations.
       */

    }, {
      key: "_haxContextOperation",
      value: function _haxContextOperation(e) {
        var _this15 = this;

        var detail = e.detail; // support a simple insert event to bubble up or everything else

        switch (detail.eventName) {
          // text based operations for primatives
          case "text-tag":
            // trigger the default selected value in context menu to match
            this.shadowRoot.querySelector("#textcontextmenu").realSelectedValue = detail.value;
            this.activeNode = this.haxChangeTagName(this.activeNode, detail.value);
            window.HaxStore.write("activeNode", this.activeNode, this);
            setTimeout(function () {
              _this15.positionContextMenus();
            }, 100);
            break;

          case "text-tag-ul":
            // trigger the default selected value in context menu to match
            this.shadowRoot.querySelector("#textcontextmenu").realSelectedValue = "ul";
            this.activeNode = this.haxChangeTagName(this.activeNode, "ul");
            window.HaxStore.write("activeNode", this.activeNode, this);
            setTimeout(function () {
              _this15.positionContextMenus();
            }, 100);
            break;

          case "text-tag-ol":
            // trigger the default selected value in context menu to match
            this.shadowRoot.querySelector("#textcontextmenu").realSelectedValue = "ol";
            this.activeNode = this.haxChangeTagName(this.activeNode, "ol");
            window.HaxStore.write("activeNode", this.activeNode, this);
            setTimeout(function () {
              _this15.positionContextMenus();
            }, 100);
            break;

          case "hax-plate-add-element":
            // support for the Other call, otherwise its a specific element + props
            if (detail.value == "other") {
              window.HaxStore.instance.haxInsertAnything({});
              return true;
            } // insert from here


            var addData = JSON.parse(detail.value);
            this.haxInsert(addData.tag, addData.content, addData.properties, false); // focus on 1st row w/ cursor if this a text element

            if (window.HaxStore.instance.isTextElement(addData)) {
              setTimeout(function () {
                try {
                  var range = document.createRange();
                  var sel = window.HaxStore.getSelection();
                  range.setStart(_this15.activeNode, 0);
                  range.collapse(true);
                  sel.removeAllRanges();
                  sel.addRange(range);

                  _this15.activeNode.focus();

                  _this15.activeContainerNode = _this15.activeNode;
                  window.HaxStore.write("activeContainerNode", _this15.activeContainerNode, _this15);
                } catch (e) {
                  console.warn(e);
                }
              }, 0);
            }

            break;

          case "text-align-left":
            this.activeNode.style.textAlign = null;
            break;
          // grid plate based operations
          // allow for transforming this haxElement into another one

          case "hax-transform-node":
            this.replaceElementWorkflow();
            break;
          // grid plate based operations
          // allow for transforming this haxElement into another one

          case "hax-plate-create-right":
            this.haxGridPlateOps(this.activeContainerNode, "right");
            break;

          case "hax-plate-remove-right":
            this.haxGridPlateOps(this.activeContainerNode, "right", false);
            break;
          // duplicate the active item or container

          case "hax-plate-duplicate":
            if (this.activeNode === this.activeContainerNode) {
              this.haxDuplicateNode(this.activeNode);
            } else {
              this.haxDuplicateNode(this.activeNode, this.activeContainerNode);
            }

            break;

          case "hax-plate-delete":
            if (this.activeNode != null) {
              var options = [{
                icon: "thumb-up",
                color: "green",
                title: "Yes"
              }, {
                icon: "thumb-down",
                color: "red",
                title: "No"
              }];
              var tag = this.activeNode.tagName.toLowerCase();
              var humanName = tag.replace("-", " ");

              if (babelHelpers.typeof(window.HaxStore.instance.elementList[tag]) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && window.HaxStore.instance.elementList[tag].gizmo !== false) {
                humanName = window.HaxStore.instance.elementList[tag].gizmo.title;
              }

              window.HaxStore.instance.haxAppPicker.presentOptions(options, "", "Remove this `".concat(humanName, "`?"), "delete");
            }

            break;

          case "hax-plate-first":
            this.haxMoveGridPlate("first", this.activeNode, this.activeContainerNode);
            break;

          case "hax-plate-up":
            this.haxMoveGridPlate("up", this.activeNode, this.activeContainerNode);
            break;

          case "hax-plate-down":
            this.haxMoveGridPlate("down", this.activeNode, this.activeContainerNode);
            break;

          case "hax-plate-last":
            this.haxMoveGridPlate("last", this.activeNode, this.activeContainerNode);
            break;

          case "close-menu":
            this.activeNode = null;
            this.activeContainerNode = null;
            window.HaxStore.write("activeNode", null, this);
            window.HaxStore.write("activeContainerNode", null, this);
            break;
        }
      }
      /**
       * Item has gained focus, change active element to match
       */

    }, {
      key: "_focusIn",
      value: function _focusIn(e) {
        if (this.__focusLogic(e.target)) {
          e.stopPropagation();
        }
      }
      /**
       * Focus a target and update the data model to reflect this.
       * This helps ensure that keyboard and non click based focusing
       * registers the same as click events
       */

    }, {
      key: "__focusLogic",
      value: function __focusLogic(target) {
        var _this16 = this;

        var stopProp = false; // only worry about these when we are in edit mode
        // and there is no drawer open

        if (!this.openDrawer && this.editMode && !this.__tabTrap) {
          var containerNode = target; // edge case, thing selected is inside a paragraph tag
          // HTML is stupid and allows this

          if (containerNode.tagName === "SPAN" && window.HaxStore.instance.isTextElement(target.parentNode)) {
            containerNode = target.parentNode;
          }

          var activeNode = null; // ensure this is valid

          if (this._validElementTest(containerNode) && containerNode.parentNode && containerNode.parentNode.tagName) {
            // keep looking til we are juuuust below the container
            // @notice this is where we force a selection on highest level
            // of the document
            while (containerNode.parentNode.tagName && containerNode.parentNode.tagName != "HAX-BODY") {
              // make sure active is set after closest legit element
              if (activeNode === null && containerNode.tagName !== "LI" && containerNode.tagName !== "B" && containerNode.tagName !== "I" && containerNode.tagName !== "STRONG" && containerNode.tagName !== "EM") {
                activeNode = containerNode;
              }

              containerNode = containerNode.parentNode;
            } // case with simple element


            if (activeNode === null) {
              activeNode = containerNode;
            } // we only allow disconnected node from container when
            // the container is a grid plate
            else if (!window.HaxStore.instance.isGridPlateElement(containerNode)) {
                activeNode = containerNode;
              } // ensure this is a tag we care about / have support for and
            // that it is a new value


            if (this.activeContainerNode !== containerNode && !containerNode.classList.contains("ignore-activation")) {
              this.activeContainerNode = containerNode;
              window.HaxStore.write("activeContainerNode", containerNode, this);
              stopProp = true;
            } else if (containerNode.classList.contains("ignore-activation")) {
              stopProp = true;
            } // test for active node changing


            if (this.activeNode !== activeNode && !activeNode.classList.contains("ignore-activation")) {
              this.activeNode = activeNode;
              window.HaxStore.write("activeNode", activeNode, this);
              setTimeout(function () {
                _this16.positionContextMenus(activeNode, activeNode);
              }, 0);
              stopProp = true;
            }
          }
        } else {
          this.__tabTrap = false;
        }

        return stopProp;
      }
      /**
       * Notice the change between states for editing.
       */

    }, {
      key: "_editModeChanged",
      value: function _editModeChanged(newValue, oldValue) {
        var _this17 = this;

        // fire above that we have changed states so things can react if needed
        if (babelHelpers.typeof(oldValue) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
          this._applyContentEditable(newValue);

          if (newValue) {
            // minor timeout here to see if we have children or not. the slight delay helps w/
            // timing in scenarios where this is inside of other systems which are setting default
            // attributes and what not
            setTimeout(function () {
              if (_this17.children && _this17.children[0] && _this17.children[0].focus) {
                _this17.activeNode = _this17.children[0];
                _this17.activeContainerNode = _this17.activeNode;
                window.HaxStore.write("activeNode", _this17.children[0], _this17);
                window.HaxStore.write("activeContainerNode", _this17.children[0], _this17);
                setTimeout(function () {
                  if (window.HaxStore.instance.isTextElement(_this17.activeNode)) {
                    try {
                      var range = document.createRange();
                      var sel = window.HaxStore.getSelection();
                      range.setStart(_this17.activeNode, 0);
                      range.collapse(true);
                      sel.removeAllRanges();
                      sel.addRange(range);

                      _this17.activeNode.focus();
                    } catch (e) {
                      console.warn(e);
                    }

                    _this17.positionContextMenus();
                  }
                }, 0);
              } else {
                _this17.haxInsert("p", "", {}, false);

                setTimeout(function () {
                  try {
                    var range = document.createRange();
                    var sel = window.HaxStore.getSelection();
                    range.setStart(_this17.activeNode, 0);
                    range.collapse(true);
                    sel.removeAllRanges();
                    sel.addRange(range);

                    _this17.activeNode.focus();

                    _this17.activeContainerNode = _this17.activeNode;
                    window.HaxStore.write("activeContainerNode", _this17.activeContainerNode, _this17);
                  } catch (e) {
                    console.warn(e);
                  }

                  _this17.positionContextMenus();
                }, 0);
              }
            }, 100);
          }
        } // hide menus when state changes


        if (newValue == false) {
          this.removeAttribute("contenteditable");
          setTimeout(function () {
            _this17.hideContextMenus();
          }, 50);
        }
      }
      /**
       * Test if this is a HAX element or not
       */

    }, {
      key: "_haxResolvePreviousElement",
      value: function _haxResolvePreviousElement(node) {
        node = node.previousElementSibling;

        while (node != null && babelHelpers.typeof(node.tagName) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && node.tagName.substring(0, 4) === "HAX-") {
          node = node.previousElementSibling;
        }

        return node;
      }
      /**
       * Test if this is a HAX element or not
       * true means its a valid element for selection
       * We have special support for the hax-logo because it's hax.
       */

    }, {
      key: "_validElementTest",
      value: function _validElementTest(node) {
        if (babelHelpers.typeof(node.tagName) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
          if ( // ignore hax internal tags
          node.tagName.substring(0, 4) !== "HAX-" || // hax logo is special cause
          node.tagName === "HAX-LOGO" || // special place holder in drag and drop
          node.tagName !== "FAKE-HAX-BODY-END") {
            return true;
          }
        }

        return false;
      }
      /**
       * Test if this is an HTML primative
       */

    }, {
      key: "_HTMLPrimativeTest",
      value: function _HTMLPrimativeTest(node) {
        if (node != null && babelHelpers.typeof(node.tagName) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && node.tagName.indexOf("-") == -1) {
          return true;
        }

        return false;
      }
      /**
       * Walk everything we find and either enable or disable editable state.
       */

    }, {
      key: "_applyContentEditable",
      value: function _applyContentEditable(status) {
        var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.shadowRoot.querySelector("#body");
        var children = target.localName === "slot" ? target.assignedNodes({
          flatten: true
        }) : []; // fallback for content nodes if not polymer managed nodes above

        if (children.length === 0) {
          children = target.children;
        }

        for (var i = 0, len = children.length; i < len; i++) {
          // sanity check for being a valid element / not a "hax" element
          if (this._validElementTest(children[i])) {
            // correctly add or remove listeners
            if (!status || children[i].getAttribute("contenteditable") !== true && children[i].getAttribute("contenteditable") != "true" && children[i].getAttribute("contenteditable") != "contenteditable") {
              this.__applyNodeEditableState(children[i], status);
            }
          }
        }
      }
      /**
       * Apply the node editable state correctly so we can do drag and drop / editing uniformly
       */

    }, {
      key: "__applyNodeEditableState",
      value: function __applyNodeEditableState(node) {
        var status = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        var listenerMethod; // create the hax-ray x ray googles thing

        var haxRay = node.tagName.replace("-", " ").toLowerCase();
        var i = window.HaxStore.instance.gizmoList.findIndex(function (j) {
          if (j) {
            return j.tag === node.tagName.toLowerCase();
          }
        });

        if (i !== -1) {
          haxRay = window.HaxStore.instance.gizmoList[i].title;
        } // oooooo snap, drag and drop..


        if (status) {
          node.setAttribute("data-editable", status);
          node.setAttribute("data-hax-ray", haxRay);
          listenerMethod = "addEventListener";
        } else {
          node.removeAttribute("data-editable");
          node.removeAttribute("data-hax-ray");
          listenerMethod = "removeEventListener";
        }

        node[listenerMethod]("drop", this.dropEvent.bind(this));
        node[listenerMethod]("dragenter", this.dragEnter.bind(this));
        node[listenerMethod]("dragleave", this.dragLeave.bind(this));
        node[listenerMethod]("dragover", function (e) {
          e.preventDefault();
        }); // additional things for text based elements

        if (this._HTMLPrimativeTest(node)) {
          if (status) {
            node.setAttribute("contenteditable", status);
          } else {
            node.removeAttribute("contenteditable");
          }

          if (node.querySelectorAll("a").length > 0) {
            var links = node.querySelectorAll("a");

            for (var j = 0, len2 = links.length; j < len2; j++) {
              if (status) {
                links[j].setAttribute("contenteditable", status);
                links[j].setAttribute("data-editable", status);
              } else {
                links[j].removeAttribute("contenteditable");
                links[j].removeAttribute("data-editable");
              }

              links[j][listenerMethod]("click", function (e) {
                e.preventDefault();
                e.stopPropagation();
                e.stopImmediatePropagation();
              });
            }
          }
        }
      }
      /**
       * Drop an item onto another
       */

    }, {
      key: "dropEvent",
      value: function dropEvent(e) {
        var _this18 = this;

        if (!this.openDrawer && this.editMode) {
          // esnure we clear the gravity scrolling drag effect
          clearTimeout(gravityScrollTimer);
          window.HaxStore.instance._lockContextPosition = false; // trick the tray into forcing active to be Configure

          window.HaxStore.instance.haxTray.activeTab = "item-1";
          var target = null;

          if (e.path && e.path[0]) {
            target = e.path[0];
          } else if (e.originalTarget) {
            target = e.originalTarget;
          } else {
            target = e.target;
          } // establish an activeNode /container based on drop poisition


          this.activeNode = target;
          window.HaxStore.write("activeNode", target, this);

          if (target.parentNode && target.parentNode.tagName === "GRID-PLATE") {
            this.activeContainerNode = target.parentNode;
            window.HaxStore.write("activeContainerNode", target.parentNode, this);
          } else {
            this.activeContainerNode = target.parentNode;
            window.HaxStore.write("activeContainerNode", target, this);
          } // walk the children and remove the draggable state needed


          setTimeout(function () {
            var children = _this18.querySelectorAll(".hax-mover, .hax-hovered, .hax-moving, .grid-plate-active-item");

            for (var i in children) {
              if (babelHelpers.typeof(children[i].classList) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
                children[i].classList.remove("hax-mover", "hax-hovered", "hax-moving", "grid-plate-active-item"); // special support for grid plates as they manage internal drag/drop

                if (children[i].tagName === "GRID-PLATE") {
                  children[i].dropEvent(e);

                  for (var j = 1; j <= children[i].columns; j++) {
                    if (children[i].shadowRoot.querySelector("#col" + j) !== undefined) {
                      children[i].shadowRoot.querySelector("#col" + j).classList.remove("hax-mover");
                    }
                  }
                }
              }
            }
          }, 100); // this helps ensure that what gets drag and dropped is a file
          // this prevents issues with selecting and dragging text (which triggers drag/drop)
          // as well as compatibility with things that are legit in a draggable state

          try {
            // see if we are dropping a file
            if (e.dataTransfer && e.dataTransfer.items && e.dataTransfer.items.length > 0 && e.dataTransfer.items[0].kind === "file") {
              e.preventDefault();
              e.stopPropagation();
              e.stopImmediatePropagation(); // inject a placeholder P tag which we will then immediately replace

              var tmp = document.createElement("p");
              this.activeNode.parentNode.insertBefore(tmp, this.activeNode); // this placeholder will be immediately replaced

              e.placeHolderElement = tmp; // fire this specialized event up so things like HAX can intercept

              this.dispatchEvent(new CustomEvent("place-holder-file-drop", {
                bubbles: true,
                cancelable: true,
                composed: true,
                detail: e
              }));
            } else {
              // set taget based on drag target
              target = window.HaxStore.instance.__dragTarget;
              var local = e.target; // if we have a slot on what we dropped into then we need to mirror that item
              // and place ourselves below it in the DOM

              if (target && target != null && typeof target.removeAttribute === "function" && babelHelpers.typeof(local) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && target !== local && target !== local.parentNode && target.parentNode === this || local.parentNode === this) {
                // incase this came from a grid plate, drop the slot so it works
                try {
                  target.removeAttribute("slot");
                  local.parentNode.insertBefore(target, local);
                } catch (e) {
                  console.warn(e);
                } // ensure that if we caught this event we process it


                e.preventDefault();
                e.stopPropagation();
              } // position arrows / set focus in case the DOM got updated above


              if (target && typeof target.focus === "function") {
                this.activeNode = target;

                if (this.activeNode && this.activeNode.parentNode && this.activeNode.parentNode.tagName === "GRID-PLATE") {
                  this.activeContainerNode = this.activeNode.parentNode;
                } else {
                  this.activeContainerNode = this.activeNode;
                }

                window.HaxStore.write("activeNode", this.activeNode, this);
                window.HaxStore.write("activeContainerNode", this.activeContainerNode, this); // fire event saying that we dropped an item and gained
                // focus which should prioritize certain actions over a
                // normal focus shift

                this.dispatchEvent(new CustomEvent("hax-drop-focus-event", {
                  bubbles: true,
                  cancelable: true,
                  composed: true,
                  detail: this.activeNode
                }));
                setTimeout(function () {
                  if (typeof _this18.activeNode.scrollIntoViewIfNeeded === "function") {
                    _this18.activeNode.scrollIntoViewIfNeeded(true);
                  } else {
                    _this18.activeNode.scrollIntoView({
                      behavior: "smooth",
                      inline: "center"
                    });
                  }

                  _this18.positionContextMenus();
                }, 250);
              }
            }
          } catch (e) {
            console.warn(e);
          }
        } // reset this after the drop happens


        window.HaxStore.instance.__dragTarget = null;

        this.__manageFakeEndCap(false);
      }
      /**
       * Enter an element, meaning we've over it while dragging
       */

    }, {
      key: "dragEnter",
      value: function dragEnter(e) {
        if (!this.openDrawer && this.editMode && e.target) {
          e.preventDefault();

          if (e.target && e.target.classList) {
            e.target.classList.add("hax-hovered");
          } // perform check for edge of screen


          this.handleMousemove(e);
        }
      } // refactored from https://github.com/bennadel/JavaScript-Demos/blob/master/demos/window-edge-scrolling/index.htm
      // I adjust the window scrolling in response to the given mousemove event.

    }, {
      key: "handleMousemove",
      value: function handleMousemove(e) {
        // NOTE: Much of the information here, with regard to document dimensions,
        // viewport dimensions, and window scrolling is derived from JavaScript.info.
        // I am consuming it here primarily as NOTE TO SELF.
        // --
        // Read More: https://javascript.info/size-and-scroll-window
        // --
        // CAUTION: The viewport and document dimensions can all be CACHED and then
        // recalculated on window-resize events (for the most part). I am keeping it
        // all here in the mousemove event handler to remove as many of the moving
        // parts as possible and keep the demo as simple as possible.
        // Get the viewport-relative coordinates of the mousemove event.
        var viewportX = e.clientX;
        var viewportY = e.clientY; // Get the viewport dimensions.

        var viewportWidth = document.documentElement.clientWidth;
        var viewportHeight = document.documentElement.clientHeight; // Next, we need to determine if the mouse is within the "edge" of the
        // viewport, which may require scrolling the window. To do this, we need to
        // calculate the boundaries of the edge in the viewport (these coordinates
        // are relative to the viewport grid system).

        var edgeTop = edgeSize;
        var edgeLeft = edgeSize;
        var edgeBottom = viewportHeight - edgeSize;
        var edgeRight = viewportWidth - edgeSize;
        var isInLeftEdge = viewportX < edgeLeft;
        var isInRightEdge = viewportX > edgeRight;
        var isInTopEdge = viewportY < edgeTop;
        var isInBottomEdge = viewportY > edgeBottom; // If the mouse is not in the viewport edge, there's no need to calculate
        // anything else.

        if (!(isInLeftEdge || isInRightEdge || isInTopEdge || isInBottomEdge)) {
          clearTimeout(gravityScrollTimer);
          return;
        } // If we made it this far, the user's mouse is located within the edge of the
        // viewport. As such, we need to check to see if scrolling needs to be done.
        // Get the document dimensions.
        // --
        // NOTE: The various property reads here are for cross-browser compatibility
        // as outlined in the JavaScript.info site (link provided above).


        var documentWidth = Math.max(document.body.scrollWidth, document.body.offsetWidth, document.body.clientWidth, document.documentElement.scrollWidth, document.documentElement.offsetWidth, document.documentElement.clientWidth);
        var documentHeight = Math.max(document.body.scrollHeight, document.body.offsetHeight, document.body.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight, document.documentElement.clientHeight); // Calculate the maximum scroll offset in each direction. Since you can only
        // scroll the overflow portion of the document, the maximum represents the
        // length of the document that is NOT in the viewport.

        var maxScrollX = documentWidth - viewportWidth;
        var maxScrollY = documentHeight - viewportHeight; // As we examine the mousemove event, we want to adjust the window scroll in
        // immediate response to the event; but, we also want to continue adjusting
        // the window scroll if the user rests their mouse in the edge boundary. To
        // do this, we'll invoke the adjustment logic immediately. Then, we'll setup
        // a timer that continues to invoke the adjustment logic while the window can
        // still be scrolled in a particular direction.
        // --
        // NOTE: There are probably better ways to handle the ongoing animation
        // check. But, the point of this demo is really about the math logic, not so
        // much about the interval logic.

        (function checkForWindowScroll() {
          clearTimeout(gravityScrollTimer);

          if (adjustWindowScroll()) {
            gravityScrollTimer = setTimeout(checkForWindowScroll, 30);
          }
        })(); // Adjust the window scroll based on the user's mouse position. Returns True
        // or False depending on whether or not the window scroll was changed.


        function adjustWindowScroll() {
          // Get the current scroll position of the document.
          var currentScrollX = window.pageXOffset;
          var currentScrollY = window.pageYOffset; // Determine if the window can be scrolled in any particular direction.

          var canScrollUp = currentScrollY > 0;
          var canScrollDown = currentScrollY < maxScrollY;
          var canScrollLeft = currentScrollX > 0;
          var canScrollRight = currentScrollX < maxScrollX; // Since we can potentially scroll in two directions at the same time,
          // let's keep track of the next scroll, starting with the current scroll.
          // Each of these values can then be adjusted independently in the logic
          // below.

          var nextScrollX = currentScrollX;
          var nextScrollY = currentScrollY; // As we examine the mouse position within the edge, we want to make the
          // incremental scroll changes more "intense" the closer that the user
          // gets the viewport edge. As such, we'll calculate the percentage that
          // the user has made it "through the edge" when calculating the delta.
          // Then, that use that percentage to back-off from the "max" step value.
          // Should we scroll left?

          if (isInLeftEdge && canScrollLeft) {
            var intensity = (edgeLeft - viewportX) / edgeSize;
            nextScrollX = nextScrollX - maxStep * intensity; // Should we scroll right?
          } else if (isInRightEdge && canScrollRight) {
            var intensity = (viewportX - edgeRight) / edgeSize;
            nextScrollX = nextScrollX + maxStep * intensity;
          } // Should we scroll up?


          if (isInTopEdge && canScrollUp) {
            var intensity = (edgeTop - viewportY) / edgeSize;
            nextScrollY = nextScrollY - maxStep * intensity; // Should we scroll down?
          } else if (isInBottomEdge && canScrollDown) {
            var intensity = (viewportY - edgeBottom) / edgeSize;
            nextScrollY = nextScrollY + maxStep * intensity;
          } // Sanitize invalid maximums. An invalid scroll offset won't break the
          // subsequent .scrollTo() call; however, it will make it harder to
          // determine if the .scrollTo() method should have been called in the
          // first place.


          nextScrollX = Math.max(0, Math.min(maxScrollX, nextScrollX));
          nextScrollY = Math.max(0, Math.min(maxScrollY, nextScrollY));

          if (nextScrollX !== currentScrollX || nextScrollY !== currentScrollY) {
            window.scrollTo(nextScrollX, nextScrollY);
            return true;
          } else {
            return false;
          }
        }
      }
      /**
       * Leaving an element while dragging.
       */

    }, {
      key: "dragLeave",
      value: function dragLeave(e) {
        if (!this.openDrawer && this.editMode && e.target && e.target.classList) {
          e.target.classList.remove("hax-hovered");
        }
      }
      /**
       * Container has changed
       */

    }, {
      key: "_activeContainerNodeChanged",
      value: function _activeContainerNodeChanged(newValue, oldValue) {
        if (this.editMode && babelHelpers.typeof(newValue) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && newValue != null && newValue.tagName != null) {
          if (window.HaxStore.instance.isTextElement(newValue) || window.HaxStore.instance.isGridPlateElement(newValue)) {
            newValue.setAttribute("contenteditable", true);
            this.setAttribute("contenteditable", true);
          } else {
            newValue.removeAttribute("contenteditable");
            this.removeAttribute("contenteditable");
          } // @notice this is a bit of a state hack between grid plate and hax
          // this forces the active item to be dropped so that we can
          // correctly regain focus with the keyboard


          if (oldValue && oldValue.tagName == "GRID-PLATE") {
            oldValue.activeItem = null;
          }

          var tag = newValue.tagName.toLowerCase(); // special case for the grid plate since it brings in nodes
          // nested in it and needs to be put into an editMode

          if (tag === "grid-plate") {
            newValue.editMode = this.editMode;

            this._applyContentEditable(this.editMode, newValue);
          }
        }
      }
      /**
       * React to a new node being set to active.
       */

    }, {
      key: "_activeNodeChanged",
      value: function _activeNodeChanged(newValue, oldValue) {
        // remove anything currently with the active class
        this.querySelectorAll(".hax-active").forEach(function (el) {
          el.classList.remove("hax-active");
        });

        if (this.editMode && babelHelpers.typeof(newValue) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && newValue !== null && newValue.parentNode) {
          var tag = newValue.tagName.toLowerCase(); // remove the menu, establish the new active, then reapply
          // this is nessecary because the context menu gets appended into
          // the document
          // only hide if we change containers

          newValue.classList.add("hax-active");

          if (window.HaxStore.instance.isTextElement(newValue) || window.HaxStore.instance.isGridPlateElement(newValue)) {
            newValue.setAttribute("contenteditable", true);
            this.setAttribute("contenteditable", true);
          } else {
            newValue.removeAttribute("contenteditable");
            this.removeAttribute("contenteditable");
          } // why you no position yo?


          this.positionContextMenus();
          this.shadowRoot.querySelector("#textcontextmenu").realSelectedValue = tag;
        } // just hide menus if we don't have an active item
        else if (newValue === null) {
            this.hideContextMenus();
            this.__oldActiveNode = oldValue;
          }
      }
      /**
       * Get position from top and left of the page based on position:relative; being
       * set in a parent.
       *
       * @notice This only works correctly across browsers because hax-body
       * is position:relative in :host.
       */

    }, {
      key: "_getPosition",
      value: function _getPosition(element) {
        var xPosition = element.offsetLeft - element.scrollLeft + element.clientLeft;
        var yPosition = element.offsetTop - element.scrollTop + element.clientTop;
        return {
          x: xPosition,
          y: yPosition
        };
      }
      /**
       * Handle display and position of the context menu
       */

    }, {
      key: "_positionContextMenu",
      value: function _positionContextMenu(menu, target, xoffset, yoffset) {
        // make it account for the offset if it's floated over to one side
        // or inside of something that's over that way
        if (target != null) {
          var pos = this._getPosition(target);

          if (xoffset != null) {
            menu.style["left"] = pos.x + xoffset + "px";
          } else {
            menu.style["left"] = pos.x + "px";
          }

          if (yoffset != null) {
            menu.style["top"] = pos.y + yoffset + "px";
          } else {
            menu.style["top"] = pos.y + "px";
          }
        }

        menu.setAttribute("on-screen", "on-screen");
        menu.classList.add("hax-context-visible"); // text we want to operate this way

        if (this.__activeHover) {
          menu.classList.add("hax-active-hover");
          menu.style.marginLeft = "";
          this.__typeLock = false;
        }
      }
      /**
       * Simple hide / reset of whatever menu it's handed.
       */

    }, {
      key: "_hideContextMenu",
      value: function _hideContextMenu(menu) {
        menu.removeAttribute("on-screen");
        menu.classList.remove("hax-context-visible", "hax-active-hover", "hax-context-pin-top");
      }
      /**
       * Find the next thing to tab forward to.
       */

    }, {
      key: "_tabKeyPressed",
      value: function _tabKeyPressed() {
        var focus = false;
        var node = this.activeContainerNode;
        var activeNodeTagName = this.activeContainerNode.tagName; // try selection / tab block since range can cause issues

        if (window.HaxStore.getRange().cloneRange) {
          try {
            var range = window.HaxStore.getRange().cloneRange();
            var tagTest = range.commonAncestorContainer.tagName;

            if (babelHelpers.typeof(tagTest) === (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
              tagTest = range.commonAncestorContainer.parentNode.tagName;
            }

            if (["UL", "OL", "LI"].includes(activeNodeTagName) || ["UL", "OL", "LI"].includes(tagTest)) {
              if (this.polyfillSafe) {
                document.execCommand("indent");
                this.__tabTrap = true;
              }
            } else {
              while (!focus) {
                // do nothing
                if (node.nextSibling == null) {
                  focus = true;
                } else if (node.nextSibling.focus === "function") {
                  node.nextSibling.focus();
                  focus = true;
                } else {
                  node = node.nextSibling;
                }
              }
            }
          } catch (e) {
            console.warn(e);
          }
        }
      }
      /**
       * Move back through things when tab back pressed
       */

    }, {
      key: "_tabBackKeyPressed",
      value: function _tabBackKeyPressed() {
        var node = this.activeContainerNode;
        var activeNodeTagName = this.activeContainerNode.tagName; // try selection / tab block since range can cause issues

        if (window.HaxStore.getRange().cloneRange) {
          try {
            var range = window.HaxStore.getRange().cloneRange();
            var tagTest = range.commonAncestorContainer.tagName;

            if (babelHelpers.typeof(tagTest) === (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
              tagTest = range.commonAncestorContainer.parentNode.tagName;
            }

            if (["UL", "OL", "LI"].includes(activeNodeTagName) || ["UL", "OL", "LI"].includes(tagTest)) {
              if (this.polyfillSafe) {
                document.execCommand("outdent");
                this.__tabTrap = true;
              }
            } else {
              if (node != null) {
                // step back ignoring hax- prefixed elements
                while (node != null && !this._validElementTest(node)) {
                  node = node.previousSibling;
                }
              }

              if (node != null) {
                setTimeout(function () {
                  node.focus();
                }, 50);
              }
            }
          } catch (e) {
            console.warn(e);
          }
        }
      }
    }], [{
      key: "tag",
      get: function get() {
        return "hax-body";
      }
    }, {
      key: "properties",
      get: function get() {
        return _objectSpread({}, babelHelpers.get(babelHelpers.getPrototypeOf(HaxBody), "properties", this), {
          openDrawer: {
            type: Object
          },

          /**
           * Text hax-store has detected is selected currently.
           */
          haxSelectedText: {
            type: String
          },

          /**
           * State of if we are editing or not.
           */
          editMode: {
            type: Boolean,
            reflect: true,
            attribute: "edit-mode"
          },

          /**
           * Bust out the HAX Ray mode
           */
          haxRayMode: {
            type: Boolean,
            reflect: true,
            attribute: "hax-ray-mode"
          },

          /**
           * Access to the global properties object.
           */
          globalPreferences: {
            type: Object
          },

          /**
           * A reference to the active node in the slot.
           */
          activeNode: {
            type: Object
          },

          /**
           * A reference to the active node in the slot.
           */
          activeContainerNode: {
            type: Object
          }
        });
      }
    }]);
    return HaxBody;
  }(_simpleColors.SimpleColors);

  _exports.HaxBody = HaxBody;
  window.customElements.define(HaxBody.tag, HaxBody);
});