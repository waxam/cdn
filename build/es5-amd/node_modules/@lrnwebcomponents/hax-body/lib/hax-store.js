define(["exports","meta","require","../../../lit-element/lit-element.js","../../utils/utils.js","../../hax-body-behaviors/hax-body-behaviors.js","../../../undoer/undoer.js"],function(_exports,meta,_require,_litElement,_utils,_haxBodyBehaviors,_undoer){"use strict";Object.defineProperty(_exports,"__esModule",{value:!0});_exports.UndoerElement=_exports.HaxStore=void 0;meta=babelHelpers.interopRequireWildcard(meta);_require=babelHelpers.interopRequireWildcard(_require);function _templateObject2_78bf41a079d011eab2fff3f0fe734e4a(){var data=babelHelpers.taggedTemplateLiteral(["\n        :host {\n          display: none;\n        }\n      "]);_templateObject2_78bf41a079d011eab2fff3f0fe734e4a=function _templateObject2_78bf41a079d011eab2fff3f0fe734e4a(){return data};return data}function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);if(enumerableOnly)symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable});keys.push.apply(keys,symbols)}return keys}function _objectSpread(target){for(var i=1,source;i<arguments.length;i++){source=null!=arguments[i]?arguments[i]:{};if(i%2){ownKeys(Object(source),!0).forEach(function(key){babelHelpers.defineProperty(target,key,source[key])})}else if(Object.getOwnPropertyDescriptors){Object.defineProperties(target,Object.getOwnPropertyDescriptors(source))}else{ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key))})}}return target}function _templateObject_78bf41a079d011eab2fff3f0fe734e4a(){var data=babelHelpers.taggedTemplateLiteral(["\n      <slot></slot>\n      <undoer-element></undoer-element>\n      <iron-ajax\n        id=\"appstore\"\n        url=\"","\"\n        .params=\"","\"\n        method=\"GET\"\n        content-type=\"application/json\"\n        handle-as=\"json\"\n        @last-response-changed=\"","\"\n      ></iron-ajax>\n      <hal-9000\n        id=\"hal\"\n        .responds-to=\"","\"\n        .debug=\"","\"\n      ></hal-9000>\n    "]);_templateObject_78bf41a079d011eab2fff3f0fe734e4a=function _templateObject_78bf41a079d011eab2fff3f0fe734e4a(){return data};return data}/**
 * @element hax-store
 */var HaxStore=/*#__PURE__*/function(_winEventsElement){babelHelpers.inherits(HaxStore,_winEventsElement);babelHelpers.createClass(HaxStore,[{key:"render",/**
   * LitElement render
   */value:function render(){return(0,_litElement.html)(_templateObject_78bf41a079d011eab2fff3f0fe734e4a(),this.appStore.url,this.appStore.params,this.__appStoreDataChanged,this.voiceRespondsTo,this.voiceDebug)}},{key:"__appStoreDataChanged",value:function __appStoreDataChanged(e){this.__appStoreData=e.detail.value}/**
   * convention
   */},{key:"_storageDataChanged",/**
   * Local storage data changed; callback to store this data in user storage
   */value:function _storageDataChanged(newValue){if(newValue&&window.HaxStore.ready&&this.__storageDataProcessed){if(window.localStorage.getItem("haxConfirm")){window.localStorage.setItem("haxUserData",JSON.stringify(newValue))}else if(window.sessionStorage.getItem("haxConfirm")){window.sessionStorage.setItem("haxUserData",JSON.stringify(newValue))}}}/**
   * If this is a text node or not so we know if the inline context
   * operations are valid.
   */},{key:"isTextElement",value:function isTextElement(node){var tag;// resolve HAXelements vs nodes
if(null!=node&&node.tagName){tag=node.tagName.toLowerCase()}else if(null!=node&&node.tag){tag=node.tag.toLowerCase()}if(tag&&this.validTagList.includes(tag)){if(["p","ol","ul","li","a","h1","h2","h3","h4","h5","h6","strike","u","b","sub","sup","span","i","bold","em","strong","blockquote","code","figure"].includes(tag)){return!0}}return!1}/**
   * test for being a valid grid plate, li is here because
   * nested lists make this really complicated
   */},{key:"isGridPlateElement",value:function isGridPlateElement(node){var tag;// resolve HAXelements vs nodes
if(node&&node.tagName){tag=node.tagName.toLowerCase()}else if(node&&node.tag){tag=node.tag.toLowerCase()}if(tag&&this.validTagList.includes(tag)){if(["p","ol","ul","li","div","h1","h2","h3","h4","h5","h6","blockquote","code","figure","grid-plate"].includes(tag)){return!0}}return!1}/**
   * Notice _appStore changed.
   */},{key:"_appStoreChanged",value:function _appStoreChanged(newValue,oldValue){// if we have an endpoint defined, pull it
if(babelHelpers.typeof(newValue)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))&&null!=newValue&&babelHelpers.typeof(oldValue)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){// support having the request or remote loading
// depending on the integration type
if(babelHelpers.typeof(newValue.apps)===("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))&&this.shadowRoot&&this.shadowRoot.querySelector("#appstore")&&this.shadowRoot.querySelector("#appstore").generateRequest){this.shadowRoot.querySelector("#appstore").generateRequest()}else{// directly injected json object into the DOM
this.__appStoreData=newValue}}}/**
   * Load and attach items from the app store.
   */},{key:"_loadAppStoreData",value:function _loadAppStoreData(ready,appDataResponse,haxAutoloader){if(ready&&babelHelpers.typeof(appDataResponse)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))&&null!=appDataResponse){var items={};// autoload elements
if(babelHelpers.typeof(appDataResponse.autoloader)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){// ensure the list is in the right order so we can async dynamic imports
// regardless of if its an array or object of values in the right format
// force this to be an object
appDataResponse.autoloader=Object.assign({},appDataResponse.autoloader);for(var i in appDataResponse.autoloader){var CEname=i,CEimport=appDataResponse.autoloader[i];// helps support array or object based app store spec
// array was originally in the standard so this lets us support both
if(!isNaN(CEname)){CEname=appDataResponse.autoloader[i];CEimport="@lrnwebcomponents/".concat(CEname,"/").concat(CEname,".js")}// force this into the valid tag list so early paints will
// correctly include the tag without filtering it out incorrectly
this.validTagList.push(CEname);items[CEname]=CEimport}}// load apps automatically
if(babelHelpers.typeof(appDataResponse.apps)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){for(var apps=appDataResponse.apps,i=0,app;i<apps.length;i++){app=document.createElement("hax-app");app.data=apps[i];window.HaxStore.instance.appendChild(app)}}// load in stax dynamically
if(babelHelpers.typeof(appDataResponse.stax)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){for(var staxs=appDataResponse.stax,i=0,stax;i<staxs.length;i++){stax=document.createElement("hax-stax");stax.data=staxs[i];window.HaxStore.instance.appendChild(stax)}}// load in blox dynamically
if(babelHelpers.typeof(appDataResponse.blox)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){for(var bloxs=appDataResponse.blox,i=0,blox;i<bloxs.length;i++){blox=document.createElement("hax-blox");blox.data=bloxs[i];window.HaxStore.instance.appendChild(blox)}}this.dispatchEvent(new CustomEvent("hax-store-app-store-loaded",{bubbles:!0,cancelable:!0,composed:!0,detail:!0}));// now process the dynamic imports
this._handleDynamicImports(items,haxAutoloader)}}// simple path from a url modifier
},{key:"pathFromUrl",value:function pathFromUrl(url){return url.substring(0,url.lastIndexOf("/")+1)}/**
   * Handle all the dynamic imports of things told to autoload
   * This ensures we get the definitions very quickly as far as
   * what is a safe / valid tag above but then we import in a way
   * that allows us to correctly associate the hax schema to where
   * it came from.
   */},{key:"_handleDynamicImports",value:function(){var _handleDynamicImports2=babelHelpers.asyncToGenerator(/*#__PURE__*/regeneratorRuntime.mark(function _callee(items,haxAutoloader){var _this2=this,basePath,i,CEClass;return regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:basePath=this.pathFromUrl(decodeURIComponent(meta.url));_context.t0=regeneratorRuntime.keys(items);case 2:if((_context.t1=_context.t0()).done){_context.next=13;break}i=_context.t1.value;if(window.customElements.get(i)){_context.next=9;break}_context.next=7;return new Promise(function(res,rej){return _require.default(["".concat(basePath,"../../../").concat(items[i])],res,rej)}).then(function(response){for(var cVal in response){// get the custom element definition we used to add that file
var CEClass=response[cVal];if("function"===typeof CEClass.getHaxProperties){_this2.setHaxProperties(CEClass.getHaxProperties(),i)}else if("function"===typeof CEClass.HAXWiring){_this2.setHaxProperties(CEClass.HAXWiring.getHaxProperties(),i)}else if(CEClass.haxProperties){_this2.setHaxProperties(CEClass.haxProperties,i)}else{// this is the less optimized / legacy polymer element or an element
// that did not provide an export
try{var el=document.createElement(i);haxAutoloader.appendChild(el)}catch(e){console.warn(e)}}}}).catch(function(error){/* Error handling */console.warn(error)});case 7:_context.next=11;break;case 9:// get the custom element definition we used to add that file
CEClass=window.customElements.get(i);if("function"===typeof CEClass.getHaxProperties){this.setHaxProperties(CEClass.getHaxProperties(),i)}else if("function"===typeof CEClass.HAXWiring){this.setHaxProperties(CEClass.HAXWiring.getHaxProperties(),i)}else if(CEClass.haxProperties){this.setHaxProperties(CEClass.haxProperties,i)}else{// this is the less optimized / legacy polymer element method to inlcude
// this item. It's a good reason to skip on this though because you'll
// have a faster boot up time with newer ES6 methods then previous ones.
haxAutoloader.appendChild(document.createElement(i))}case 11:_context.next=2;break;case 13:case"end":return _context.stop();}}},_callee,this)}));function _handleDynamicImports(_x,_x2){return _handleDynamicImports2.apply(this,arguments)}return _handleDynamicImports}()},{key:"_editModeChanged",value:function _editModeChanged(newValue){if(newValue&&this.globalPreferences.haxVoiceCommands){this.__hal.auto=!0}else{this.__hal.auto=!1}}},{key:"_globalPreferencesChanged",value:function _globalPreferencesChanged(newValue,oldValue){// regardless of what it is, reflect it globally but only after setup
if(this.__storageDataProcessed&&newValue&&babelHelpers.typeof(newValue.haxVoiceCommands)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))&&window.HaxStore.ready){var storageData=this.storageData;storageData.globalPreferences=newValue;this.storageData=storageData;this._storageDataChanged(this.storageData);if(newValue.haxVoiceCommands&&this.editMode){this.__hal.auto=!0}else{this.__hal.auto=!1}}}/**
   * A handful of context operations need to bubble up to the top
   * because we don't know where they originate from
   */},{key:"_haxContextOperation",value:function _haxContextOperation(e){var _this3=this,detail=e.detail;if(this.activeNode){var changed=!1;// support a simple insert event to bubble up or everything else
switch(detail.eventName){// directional / proportion operations
case"hax-align-left":this.activeNode.style.float=null;this.activeNode.style.margin=null;this.activeNode.style.display=null;changed=!0;break;case"hax-align-center":this.activeNode.style.float=null;this.activeNode.style.margin="0 auto";this.activeNode.style.display="block";changed=!0;break;case"hax-align-right":this.activeNode.style.float="right";this.activeNode.style.margin="0 auto";this.activeNode.style.display="block";changed=!0;break;case"hax-size-change":if(100==detail.value){this.activeNode.style.width=null}else{this.activeNode.style.width=detail.value+"%"}changed=!0;break;}if(changed){setTimeout(function(){_this3.activeHaxBody.positionContextMenus()},0)}}}/**
   * This only send if they consented to storage of data locally
   */},{key:"_haxConsentTap",value:function _haxConsentTap(e){// store for future local storage usage
window.localStorage.setItem("haxConfirm",!0);// most likely nothing but set it anyway
window.localStorage.setItem("haxUserData",JSON.stringify(this.storageData))}},{key:"updated",value:function updated(changedProperties){var _this4=this,loadAppStoreData=!1;changedProperties.forEach(function(oldValue,propName){if("openDrawer"==propName){_this4.openDrawersCallback(_this4[propName],oldValue)}if("appStore"==propName){_this4._appStoreChanged(_this4[propName],oldValue)}if("globalPreferences"==propName){_this4._globalPreferencesChanged(_this4[propName],oldValue)}if("editMode"==propName){_this4._editModeChanged(_this4[propName],oldValue)}if("activeNode"==propName){_this4.activeGizmo=_this4._calculateActiveGizmo(_this4[propName]);window.HaxStore.write("activeGizmo",_this4.activeGizmo,_this4)}// composite obervation
if(["__ready","__appStoreData","haxAutoloader"].includes(propName)){loadAppStoreData=!0}if(["haxAutoloader","activeHaxBody","haxToast","haxExport","haxPreferences","haxAppPicker","haxTray"].includes(propName)){// allow this to verify if everything is here or not
_this4._storePiecesAllHere(_this4.haxAutoloader,_this4.activeHaxBody,_this4.haxToast,_this4.haxExport,_this4.haxPreferences,_this4.haxAppPicker,_this4.haxTray)}});if(loadAppStoreData){this._loadAppStoreData(this.__ready,this.__appStoreData,this.haxAutoloader)}}},{key:"_calculateActiveGizmo",value:function _calculateActiveGizmo(activeNode){if(null==activeNode){return null}for(var gizmoposition in this.gizmoList){var gizmo=this.gizmoList[gizmoposition];if(gizmo.tag===activeNode.tagName.toLowerCase()){return gizmo}}}/**
   * ready life cycle
   */},{key:"firstUpdated",value:function firstUpdated(changedProperties){var _this5=this;new Promise(function(res,rej){return _require.default(["../../../@polymer/iron-ajax/iron-ajax.js"],res,rej)}).then(function(esModule){if(_this5.shadowRoot.querySelector("#appstore")){_this5.shadowRoot.querySelector("#appstore").generateRequest()}});// import voice command stuff in the background
// @todo only activate if the setting to use it is in place
new Promise(function(res,rej){return _require.default(["../../hal-9000/hal-9000.js"],res,rej)}).then(function(esModule){_this5.__hal=_this5.shadowRoot.querySelector("#hal")});// set this global flag so we know it's safe to start trusting data
// that is written to global preferences / storage bin
setTimeout(function(){_this5.__storageDataProcessed=!0;if(_this5.storageData.globalPreferences){window.HaxStore.write("globalPreferences",_this5.storageData.globalPreferences,_this5)}},100);// see if a global was used to prevent this check
// this is useful when in trusted environments where the statement
// has been consented to in the application this is utilized in
if(this.skipHAXConfirmation){window.sessionStorage.setItem("haxConfirm",!0);window.localStorage.setItem("haxConfirm",!0)}// check for local storage object
// if not, then store it in sessionStorage so that all our checks
// and balances are the same. This could allow for storing these
// settings on a server in theory
var haxConfirm=window.sessionStorage.getItem("haxConfirm")||window.localStorage.getItem("haxConfirm");if(!haxConfirm){// this way it isn't shown EVERY reload, but if they didn't confirm
// it will show up in the future
window.sessionStorage.setItem("haxConfirm",!0);var msg="\n    The HAX content editor keeps preferences in order to improve your experience.\n    This data is stored in your browser and is never sent anywhere.\n    Click to accept.\n    ";window.HaxStore.toast(msg,"-1","fit-bottom","I Accept","hax-consent-tap")}else{if(window.sessionStorage.getItem("haxConfirm")&&!window.localStorage.getItem("haxConfirm")){// verify there is something there
try{var globalData=window.sessionStorage.getItem("haxUserData")?JSON.parse(window.sessionStorage.getItem("haxUserData")):{};this.storageData=globalData;this._storageDataChanged(this.storageData)}catch(e){}}else{try{var _globalData=window.localStorage.getItem("haxUserData")?JSON.parse(window.localStorage.getItem("haxUserData")):{};this.storageData=_globalData;this._storageDataChanged(this.storageData)}catch(e){}}}}},{key:"_storePiecesAllHere",value:function _storePiecesAllHere(haxAutoloader,activeHaxBody,haxToast,haxExport,haxPreferences,haxAppPicker,haxTray){if(!this.__ready&&activeHaxBody&&haxAutoloader&&haxToast&&haxExport&&haxPreferences&&haxAppPicker&&haxTray){// send that hax store is ready to go so now we can setup the rest
this.dispatchEvent(new CustomEvent("hax-store-ready",{bubbles:!0,cancelable:!1,composed:!0,detail:!0}));window.HaxStore.ready=!0;this.__ready=!0;// register built in primitive definitions
this._buildPrimitiveDefinitions();// initialize voice commands
this._initVoiceCommands();this.__hal.commands=_objectSpread({},this.voiceCommands)}}/**
   * Build a list of common voice commands
   */},{key:"_initVoiceCommands",value:function _initVoiceCommands(){var _this6=this;this.__voiceInit=!0;this.voiceCommands["scroll up ".concat(this.voiceRespondsTo)]=function(){window.scrollBy({top:-(.5*window.innerHeight),left:0,behavior:"smooth"})};this.voiceCommands["scroll (down) ".concat(this.voiceRespondsTo)]=function(){window.scrollBy({top:.5*window.innerHeight,left:0,behavior:"smooth"})};this.voiceCommands["scroll to bottom ".concat(this.voiceRespondsTo)]=function(){window.scrollTo(0,document.body.scrollHeight)};this.voiceCommands["scroll to top ".concat(this.voiceRespondsTo)]=function(){window.scrollTo(0,0)};/**
     * Support for focusing active content and typing in it
     */this.voiceCommands["".concat(this.voiceRespondsTo," (show)(focus) active (element)(content)")]=function(){try{_this6._positionCursorInNode(_this6.activeNode)}catch(e){}};this.voiceCommands["".concat(this.voiceRespondsTo," (focus) previous (element)(content)")]=function(){if(_this6.activeNode.previousElementSibling){_this6.activeNode=_this6.activeNode.previousElementSibling;window.HaxStore.write("activeNode",_this6.activeNode,_this6);_this6.activeContainerNode=_this6.activeNode;window.HaxStore.write("activeContainerNode",_this6.activeNode,_this6);_this6._positionCursorInNode(_this6.activeNode)}else{_this6.speak("You are at the top of the document")}};this.voiceCommands["".concat(this.voiceRespondsTo," (focus) next (element)(content)")]=function(){if(_this6.activeNode.nextElementSibling){_this6.activeNode=_this6.activeNode.nextElementSibling;window.HaxStore.write("activeNode",_this6.activeNode,_this6);_this6.activeContainerNode=_this6.activeNode;window.HaxStore.write("activeContainerNode",_this6.activeNode,_this6);_this6._positionCursorInNode(_this6.activeNode)}else{_this6.speak("You are at the bottom of the document")}};this.voiceCommands["".concat(this.voiceRespondsTo," type *mycontent")]=function(e){if(window.HaxStore.instance.isTextElement(_this6.activeNode)){try{var range=_this6._positionCursorInNode(_this6.activeNode),text=document.createTextNode(e);range.deleteContents();range.insertNode(text)}catch(e){_this6.speak("That didn't work");console.warn(e)}}else{_this6.speak("I'm sorry but I can only type in text areas. Try saying Insert Paragraph and try again.")}};// trolling
this.voiceCommands["hey ".concat(this.voiceRespondsTo)]=function(){_this6.speak("Yeah what do you want")};// trolling
this.voiceCommands["".concat(this.voiceRespondsTo," now your name is *splat")]=function(text){var past=_this6.voiceRespondsTo;_this6.speak("I used to be named ".concat(past," but you can call me ").concat(text," now."));_this6.voiceRespondsTo="(".concat(text,")");// @todo this needs to now update the previous commands somehow to match
// the new activation name
};this.voiceCommands["".concat(this.voiceRespondsTo," close")]=function(){window.HaxStore.write("openDrawer",!1,_this6)}}/**
   * Speak wrapper on hal to present as text too
   */},{key:"speak",value:function speak(text){if(this.__hal&&this.__hal.speak){this.__hal.speak(text)}// always show for accessibility
window.HaxStore.toast("".concat(this.voiceRespondsTo,": ").concat(text))}/**
   * allow uniform method of adding voice commands
   */},{key:"addVoiceCommand",value:function addVoiceCommand(command,context,callback){if(context){command=command.replace(":name:",this.voiceRespondsTo).toLowerCase();this.voiceCommands[command]=context[callback].bind(context);if(this.__voiceInit){this.__hal.commands=_objectSpread({},this.voiceCommands)}}}/**
   * event driven version
   */},{key:"_addVoiceCommand",value:function _addVoiceCommand(e){// without context it's almost worthless so try to fallback on where it came from
var target=e.detail.context;if(!target){target=e.target}this.addVoiceCommand(e.detail.command,target,e.detail.callback)}/**
   * Position cursor at the start of the position of the requested node
   */},{key:"_positionCursorInNode",value:function _positionCursorInNode(node){var position=1<arguments.length&&arguments[1]!==void 0?arguments[1]:0;this.activeHaxBody.positionContextMenus();var range=document.createRange(),sel=window.HaxStore.getSelection();range.setStart(node,position);range.collapse(!0);sel.removeAllRanges();sel.addRange(range);return range}/**
   * Before the browser closes / changes paths, ask if they are sure they want to leave
   */},{key:"_onBeforeUnload",value:function _onBeforeUnload(e){// ensure we don't leave DURING edit mode
if(!window.HaxStore.instance.skipExitTrap&&window.HaxStore.instance.editMode){return"Are you sure you want to leave? Your work will not be saved!"}}/**
   * Intercept paste event and clean it up before inserting the contents
   */},{key:"_onPaste",value:function _onPaste(e){// only perform this on a text element that is active
if(window.HaxStore.instance.isTextElement(window.HaxStore.instance.activeNode)){var pasteContent="";// intercept paste event
if(e.clipboardData||e.originalEvent.clipboardData){pasteContent=(e.originalEvent||e).clipboardData.getData("text/html")}else if(window.clipboardData){pasteContent=window.clipboardData.getData("Text")}// detect word garbage
var mswTest=pasteContent.replace(/(class=(")?Mso[a-zA-Z]+(")?)/g,""),wordPaste=!1,newContent="";mswTest=mswTest.replace("mso-style-","");if(pasteContent!=mswTest){wordPaste=!0}// clear empty span tags that can pop up
pasteContent=pasteContent.replace(/<span>\s*?<\/span>/g," ");// clean up div tags that can come in from contenteditable pastes
// p tags make more sense in the content area
pasteContent=pasteContent.replace(/<div/g,"<p");pasteContent=pasteContent.replace(/<\/div>/g,"</p>");// NOW we can safely handle paste from word cases
pasteContent=(0,_utils.stripMSWord)(pasteContent);// edges that some things preserve empty white space needlessly
var haxElements=window.HaxStore.htmlToHaxElements(pasteContent);// if interpretation as HTML fails then let's ignore this whole thing
// as we allow normal contenteditable to handle the paste
// we only worry about HTML structures
if(0===haxElements.length){// wrap in a paragraph tag if there is any this ensures it correctly imports
// as it might not have evaluated above as having elements bc of the scrubber
if(wordPaste){newContent=pasteContent}else{return!1}}// account for incredibly basic pastes of single groups of characters
else if(1===haxElements.length&&"p"===haxElements[0].tag){return!1}// account for broken pastes in resolution, just let browser handle it
else if(!this.isGridPlateElement(haxElements[0])){return!1}else{for(var i in haxElements){// special traps for word / other styles bleeding through
delete haxElements[i].properties.style;delete haxElements[i].properties.start;delete haxElements[i].properties.align;// this is not the right function.
var node=window.HaxStore.haxElementToNode(haxElements[i].tag,haxElements[i].content.replace(/<span>&nbsp;<\/span>/g," ").trim(),haxElements[i].properties);newContent+=window.HaxStore.nodeToContent(node)}}// if we got here then we have HTML structures to pull together
// this ensures that the below works out
e.preventDefault();e.stopPropagation();e.stopImmediatePropagation();try{// get the range that's active and selection
var range=window.HaxStore.getRange(),sel=window.HaxStore.getSelection(),newNodes=document.createElement("div");newNodes.innerHTML=newContent;if(range&&sel&&"function"===typeof range.deleteContents){range.deleteContents();while(newNodes.lastChild){range.insertNode(newNodes.lastChild)}}}catch(e){console.warn(e)}}}},{key:"__validTags",value:function __validTags(){return["p","div","span","table","caption","sup","sub","u","strike","tr","th","td","ol","ul","li","a","strong","kbd","em","i","b","hr","h1","h2","h3","h4","h5","h6","blockquote","code","figure","img","iframe","video","audio","section","grid-plate","template","webview"]}},{key:"__validGizmoTypes",value:function __validGizmoTypes(){return["data","video","audio","text","link","file","pdf","image","csv","doc","archive","markdown","html","wikipedia","content","text","inline","*"]}/**
   * Created life-cycle to ensure a single global store.
   */}],[{key:"styles",/**
   * LitElement constructable styles enhancement
   */get:function get(){return[(0,_litElement.css)(_templateObject2_78bf41a079d011eab2fff3f0fe734e4a())]}},{key:"tag",get:function get(){return"hax-store"}/**
   * LitElement / popular convention
   */},{key:"properties",get:function get(){return _objectSpread({},babelHelpers.get(babelHelpers.getPrototypeOf(HaxStore),"properties",this),{openDrawer:{type:Object},voiceDebug:{type:Boolean,attribute:"voice-debug"},activeGizmo:{type:Object},voiceRespondsTo:{type:String,attribute:"voice-responses-to"},/**
       * skipHAXConfirmation
       */skipHAXConfirmation:{type:Boolean,reflect:!0,attribute:"skip-hax-confirmation"},/**
       * Local storage bridge
       */storageData:{type:Object},/**
       * Hax tray
       */haxTray:{type:Object},/**
       * Hax app picker element.
       */haxAppPicker:{type:Object},/**
       * Hax stax picker element.
       */haxStaxPicker:{type:Object},/**
       * Hax stax picker element.
       */haxBloxPicker:{type:Object},/**
       * Hax autoloader element.
       */haxAutoloader:{type:Object},/**
       * A list of all haxBodies that exist
       */haxBodies:{type:Array},/**
       * An active place holder item reference. This is used
       * for inline drag and drop event detection so that we
       * know what element replace in context.
       */activePlaceHolder:{type:Object},/**
       * The hax-body that is currently active.
       */activeHaxBody:{type:Object},/**
       * Possible appStore endpoint for loading in things dynamically.
       */appStore:{type:Object},/**
       * HAX Toast message.
       */haxToast:{type:Object},/**
       * Hax export dialog element.
       */haxExport:{type:Object},/**
       * Hax preferences dialog element.
       */haxPreferences:{type:Object},/**
       * Active Node.
       */activeNode:{type:Object},/**
       * Active container Node, 2nd highest parent of activeNode.
       */activeContainerNode:{type:Object},/**
       * Session object bridged in from a session method of some kind
       */sessionObject:{type:Object},/**
       * editMode
       */editMode:{type:Boolean},/**
       * skip the exit trap to prevent losing data
       */skipExitTrap:{type:Boolean},/**
       * Available gizmos.
       */gizmoList:{type:Array},/**
       * Available elements keyed by tagName and with
       * their haxProperties centrally registered.
       */elementList:{type:Object},/**
       * Available apps of things supplying media / content.
       */appList:{type:Array},/**
       * Available hax stax which are just re-usable templates
       */staxList:{type:Array},/**
       * Available hax blox which are grid plate / layout elements
       */bloxList:{type:Array},/**
       * Global preferences that HAX can write to and
       * other elements can use to go off of.
       */globalPreferences:{type:Object},/**
       * Globally active app, used for brokering communications
       */activeApp:{type:Object},/**
       * Valid tag list, tag only and including primatives for a baseline.
       */validTagList:{type:Array},/**
       * Gizmo types which can be used to bridge apps to gizmos.
       */validGizmoTypes:{type:Array},/**
       * Sandboxed environment test
       */_isSandboxed:{type:Boolean},/**
       * Internal app store data property after request
       */__appStoreData:{type:Object},__ready:{type:Boolean},/**
       * Support for deploy specific rewriting for things like JWTs
       */connectionRewrites:{type:Object}})}}]);function HaxStore(){var _this;babelHelpers.classCallCheck(this,HaxStore);_this=babelHelpers.possibleConstructorReturn(this,babelHelpers.getPrototypeOf(HaxStore).call(this));_this.__winEvents={"hax-register-properties":"_haxStoreRegisterProperties","hax-consent-tap":"_haxConsentTap","hax-context-item-selected":"_haxContextOperation",onbeforeunload:"_onBeforeUnload",paste:"_onPaste","hax-register-app":"_haxStoreRegisterApp","hax-register-stax":"_haxStoreRegisterStax","hax-register-blox":"_haxStoreRegisterBlox","hax-store-write":"_writeHaxStore","hax-register-core-piece":"_haxStorePieceRegistrationManager","hax-register-body":"_haxStoreRegisterBody","hax-insert-content":"_haxStoreInsertContent","hax-insert-content-array":"_haxStoreInsertMultiple","hax-add-voice-command":"_addVoiceCommand"};_this.voiceRespondsTo="(worker)";_this.voiceCommands={};_this.skipHAXConfirmation=!1;_this.storageData={};_this.appStore={url:"",params:{}};_this.activeContainerNode=null;_this.activeNode=null;_this.haxBodies=[];_this.activePlaceHolder=null;_this.sessionObject={};_this.editMode=!1;_this.skipExitTrap=!1;_this.gizmoList=[];_this.elementList={};_this.appList=[];_this.staxList=[];_this.bloxList=[];_this.globalPreferences={};_this.activeApp={};_this.connectionRewrites={};// change this in order to debug voice commands
_this.voiceDebug=!1;_this.validTagList=_this.__validTags();_this.validGizmoTypes=_this.__validGizmoTypes();// test for sandboxed env
var test=document.createElement("webview");_this._isSandboxed="function"===typeof test.reload;// claim the instance spot. This way we can easily
// be referenced globally
if(null==window.HaxStore.instance){window.HaxStore.instance=babelHelpers.assertThisInitialized(_this)}// imports app, blox, stax definitions
new Promise(function(res,rej){return _require.default(["./hax-app.js"],res,rej)});new Promise(function(res,rej){return _require.default(["../../../@polymer/polymer/lib/utils/settings.js"],res,rej)}).then(function(esModule){esModule.setPassiveTouchGestures(!0)});new Promise(function(res,rej){return _require.default(["../../simple-toast/simple-toast.js"],res,rej)}).then(function(){_this.haxToast=window.SimpleToast.requestAvailability()});new Promise(function(res,rej){return _require.default(["../../media-behaviors/media-behaviors.js"],res,rej)});document.body.style.setProperty("--hax-ui-headings","#d4ff77");return _this}/**
   * Build HAX property definitions for primitives that we support.
   */babelHelpers.createClass(HaxStore,[{key:"_buildPrimitiveDefinitions",value:function _buildPrimitiveDefinitions(){// sandboxes need a webview definition
// we don't want people making them but we need to
// know how to edit them if asked
if(window.HaxStore.instance._isSandboxed){var webview={canScale:!0,canPosition:!0,canEditSource:!1,settings:{quick:[{attribute:"src",title:"Source",description:"The URL for this video.",inputMethod:"textfield",icon:"link",required:!0,validationType:"url"}],configure:[{attribute:"src",title:"Source",description:"The URL for this video.",inputMethod:"textfield",icon:"link",required:!0,validationType:"url"}],advanced:[]}};this.setHaxProperties(webview,"webview")}var iframe={canScale:!0,canPosition:!0,canEditSource:!0,gizmo:{title:"Basic iframe",description:"A basic iframe",icon:"icons:fullscreen",color:"blue-grey",groups:["Content"],handles:[{type:"link",source:"src",height:"height",width:"width"}],meta:{author:"W3C"}},settings:{quick:[{attribute:"src",title:"Source",description:"The URL for this video.",inputMethod:"textfield",icon:"link",required:!0,validationType:"url"}],configure:[{attribute:"src",title:"Source",description:"The URL for this video.",inputMethod:"textfield",icon:"link",required:!0,validationType:"url"}],advanced:[{attribute:"loading",title:"Loading method",description:"Whether or not to lazy load this",inputMethod:"select",options:{lazy:"Load when visible",auto:"Automatic"}}]}};this.setHaxProperties(iframe,"iframe");var img={canScale:{min:10,step:5},canPosition:!0,canEditSource:!0,gizmo:{title:"Image",description:"A basic img tag",icon:"image:image",color:"blue-grey",groups:["Image","Media"],handles:[{type:"link",source:"src"},{type:"image",type_exclusive:!0,source:"src",height:"height",width:"width"}],meta:{author:"W3C"}},settings:{quick:[{attribute:"alt",title:"Alt text",description:"Useful for screen readers and improved SEO.",inputMethod:"alt",icon:"accessibility"},{attribute:"height",title:"Height",description:"height in pixels of the item. Leave blank to respond to the natural resolution",inputMethod:"textfield",icon:"icons:swap-vert"}],configure:[{attribute:"src",title:"Source",description:"The URL for this video.",inputMethod:"haxupload",icon:"link",required:!0,validationType:"url"},{attribute:"alt",title:"Alt text",description:"Useful for screen readers and improved SEO.",inputMethod:"alt",icon:"accessibility"},{attribute:"height",title:"Height",description:"height in pixels of the item. Leave blank to respond to the natural resolution",inputMethod:"textfield",icon:"icons:swap-vert"}],advanced:[{attribute:"loading",title:"Loading method",description:"Whether or not to lazy load this",inputMethod:"select",options:{lazy:"Load when visible",auto:"Automatic"}}]}};this.setHaxProperties(img,"img");var ahref={canScale:!1,canPosition:!1,canEditSource:!0,gizmo:{title:"Basic link",description:"A basic a tag",icon:"icons:link",color:"blue-grey",groups:["Link"],handles:[],meta:{author:"W3C",hidden:!0}},settings:{quick:[{attribute:"href",title:"Link",description:"The URL for this video.",inputMethod:"textfield",icon:"icons:link",required:!0,validationType:"url"},{attribute:"title",title:"Title text",description:"Useful for screen readers and improved SEO.",inputMethod:"textfield",icon:"icons:accessibility"}],configure:[{attribute:"innerText",title:"Text",description:"Text of the link",inputMethod:"textfield",required:!0},{attribute:"href",title:"Link",description:"The URL for this video.",inputMethod:"haxupload",icon:"icons:link",required:!0,validationType:"url"},{attribute:"title",title:"Title text",description:"Useful for screen readers and improved SEO.",inputMethod:"textfield",icon:"icons:accessibility"},{attribute:"target",title:"Target",description:"Where to place the link.",inputMethod:"select",icon:"icons:launch",options:{"":"Same window",_blank:"New window",_top:"Top window",_parent:"Parent window"}}],advanced:[]}};// anything can be presented as a link
this.validGizmoTypes.forEach(function(val){ahref.gizmo.handles.push({type:val,source:"href",title:"innerText",alt:"title"})});this.setHaxProperties(ahref,"a");var p={canScale:!1,canPosition:!1,canEditSource:!0,gizmo:{title:"Paragraph",description:"A basic text area",icon:"hax:paragraph",color:"blue-grey",groups:["Text"],handles:[{type:"content",content:""}],meta:{author:"W3C",hidden:!0}},settings:{quick:[],configure:[],advanced:[]}};this.setHaxProperties(p,"p");var table={canScale:!0,canPosition:!0,canEditSource:!0,gizmo:{title:"Table",description:"A table for displaying data",icon:"image:grid-on",color:"blue-grey",groups:["Text"],meta:{author:"W3C"}},settings:{quick:[],configure:[{slot:"",title:"Body",description:"Tags that make up the table",inputMethod:"code-editor",slotWrapper:""}],advanced:[]}};this.setHaxProperties(table,"table");var prims={caption:{title:"Caption",icon:"av:call-to-action"},video:{title:"Video",icon:"av:play-circle-filled"},audio:{title:"Audio",icon:"image:music-note"},section:{title:"Section",icon:"image:crop-landscape"},ol:{title:"Numbered list",icon:"editor:format-list-numbered"},ul:{title:"Bulleted list",icon:"editor:format-list-bulleted"},li:{title:"List item",icon:"editor:format-list-bulleted"},h1:{title:"Heading",icon:"hax:h1"},h2:{title:"Heading",icon:"hax:h2"},h3:{title:"Heading",icon:"hax:h3"},h4:{title:"Heading",icon:"hax:h4"},h5:{title:"Heading",icon:"hax:h5"},h6:{title:"Heading",icon:"hax:h6"},strike:{title:"Cross out",icon:"editor:format-strikethrough"},u:{title:"Underline",icon:"editor:format-underlined"},sub:{title:"Subscript",icon:"mdextra:subscript"},sup:{title:"Superscript",icon:"mdextra:superscript"},div:{title:"DIV",icon:"image:crop-landscape"},span:{title:"SPAN",icon:"editor:short-text"},i:{title:"Italic",icon:"editor:format-italic"},em:{title:"Emphasis",icon:"editor:format-italic"},strong:{title:"Bold",icon:"editor:format-bold"},b:{title:"Bold",icon:"editor:format-bold"},blockquote:{title:"Block quote",icon:"editor:format-quote"},code:{title:"Code",icon:"icons:code"},figure:{title:"Figure",icon:"icons:label-outline"},embed:{title:"Embedded object",icon:"icons:fullscreen"}};for(var tag in prims){this.setHaxProperties({canScale:!1,canPosition:!1,canEditSource:!0,gizmo:{title:prims[tag].title,icon:prims[tag].icon,meta:{hidden:!0}},settings:{quick:[],configure:[],advanced:[]}},tag)}var hr={canScale:{min:25,step:25},gizmo:{title:"Horizontal line",icon:"hax:hr",meta:{hidden:!0}},canPosition:!1,canEditSource:!1,settings:{quick:[],configure:[],advanced:[]}};this.setHaxProperties(hr,"hr")}/**
   * A standard event for registering the different pieces of HAX that check in
   * at run time. This allows for additional flexibility down the road as well as
   * registering pieces we never thought of for custom environments.
   *
   * @param {CustomEvent} e an event that has the piece to register and the object
   */},{key:"_haxStorePieceRegistrationManager",value:function _haxStorePieceRegistrationManager(e){if(e.detail&&e.detail.piece&&e.detail.object){this[e.detail.piece]=e.detail.object}}/**
   * Close all drawers
   */},{key:"openDrawersCallback",value:function openDrawersCallback(){var active=0<arguments.length&&arguments[0]!==void 0?arguments[0]:!1,oldValue=1<arguments.length?arguments[1]:void 0,drawers=["haxAppPicker","haxPreferences","haxExport"];for(var i in drawers){if(active===this[drawers[i]]){active.open();setTimeout(function(){if(null!=active.querySelector("simple-fields-field,textarea,paper-button,hax-tray-button")){active.querySelector("simple-fields-field,textarea,paper-button,hax-tray-button").focus()}var evt=document.createEvent("UIEvents");evt.initUIEvent("resize",!0,!1,window,0);window.dispatchEvent(evt)},325)}else{this[drawers[i]].close()}}}/**
   * Insert content in the body.
   */},{key:"_haxStoreInsertContent",value:function _haxStoreInsertContent(e){var _this7=this;if(e.detail){var details=e.detail;if(window.customElements.get(details.tag)){var prototype=Object.getPrototypeOf(document.createElement(details.tag));// support for deep API call to clean up special elements
if(babelHelpers.typeof(prototype.preProcessHaxInsertContent)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){details=prototype.preProcessHaxInsertContent(details)}}var properties={};// support for properties to be set automatically optionally
if(babelHelpers.typeof(details.properties)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){properties=details.properties}// support / clean up properties / attributes that have innerHTML / innerText
// these are reserved words but required for certain bindings
if(properties.innerHTML){if(""==details.content){details.content=properties.innerHTML}delete properties.innerHTML}if(properties.innerText){if(""==details.content){details.content=properties.innerText}delete properties.innerText}// ensure better UX for text based operations
this.activeHaxBody.__activeHover=null;// invoke insert or replacement on body, same function so it's easier to trace
if(details.replace&&details.replacement){var node=window.HaxStore.haxElementToNode(details.tag,details.content,properties);if(this.activePlaceHolder){this.activeHaxBody.haxReplaceNode(this.activePlaceHolder,node);this.activePlaceHolder=null}else{this.activeHaxBody.haxReplaceNode(this.activeNode,node)}}else if(babelHelpers.typeof(details.__type)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))&&"inline"===details.__type){var _node=window.HaxStore.haxElementToNode(details.tag,details.content,properties);// replace what WAS the active selection w/ this new node
if(null!==this.activePlaceHolder){this.activePlaceHolder.deleteContents();this.activePlaceHolder.insertNode(_node)}// set it to nothing
this.activePlaceHolder=null}else if(null!=this.activeContainerNode){var _node2=window.HaxStore.haxElementToNode(details.tag,details.content,properties);// allow for inserting things into things but not grid plate
if(this.activeContainerNode&&"GRID-PLATE"===this.activeContainerNode.tagName){// support slot if we have one on the activeNode (most likely)
if(null!=this.activeNode.getAttribute("slot")){_node2.setAttribute("slot",this.activeNode.getAttribute("slot"))}this.activeHaxBody.haxInsert(details.tag,details.content,properties,!1);this.activeHaxBody.shadowRoot.querySelector("#textcontextmenu").highlightOps=!1}else{this.activeHaxBody.haxInsert(details.tag,details.content,properties,!1)}}else{this.activeHaxBody.haxInsert(details.tag,details.content,properties,!1)}// shift the last used thing to the front of the array
// that way the list is actually sorted based on usage
// delay though in the event other things depend on the array
// as it currently exists
setTimeout(function(){var gizmoList=_this7.gizmoList;for(var gizmoposition in gizmoList){var gizmo=gizmoList[gizmoposition];// find the tag and then move this position to the front of the array
if(gizmo.tag===details.tag){var tmp=gizmoList[gizmoposition];delete gizmoList[gizmoposition];_this7.gizmoList.unshift(tmp)}}// spread for accurate data usage locally, then write store globally
_this7.gizmoList=babelHelpers.toConsumableArray(gizmoList);window.HaxStore.write("gizmoList",gizmoList,_this7)},10)}}/**
   * Optional send array, to improve performance and event bubbling better
   */},{key:"_haxStoreInsertMultiple",value:function _haxStoreInsertMultiple(e){if(e.detail){var properties;for(var i in e.detail){properties={};// support for properties to be set automatically optionally
if(babelHelpers.typeof(e.detail[i].properties)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){properties=e.detail[i].properties}this.activeHaxBody.haxInsert(e.detail[i].tag,e.detail[i].content,properties,!1)}}}/**
   * Set the activeHaxBody and add to the list so we know what to insert into.
   */},{key:"_haxStoreRegisterBody",value:function _haxStoreRegisterBody(e){if(e.detail){this.haxBodies.push(e.detail);// default active the whatever is last here
this.activeHaxBody=e.detail;// needed so that higher order things can respond to us having a body
window.HaxStore.write("activeHaxBody",this.activeHaxBody,this);window.HaxStore.write("editMode",this.editMode,this)}}/**
   * Feature detect on the bar.
   */},{key:"computePolyfillSafe",value:function computePolyfillSafe(){/**
     * These are our bad actors in polyfill'ed browsers.
     * This means that https://github.com/webcomponents/webcomponentsjs/commit/ce464bb533bf39b544c312906499a6044ee0d30d
     * explains things but basically if shadow-dom is polyfilled
     * then we can't safely execute a DOM manipulating execCommand.
     * This
     */if(document.head.createShadowRoot||document.head.attachShadow){return!0}else{console.warn("Shadow DOM missing, certain operations hidden");return!1}}/**
   * Write store event callback.
   */},{key:"_writeHaxStore",value:function _writeHaxStore(e){// ensure we have a valid store write
if(e.detail&&babelHelpers.typeof(e.detail.value)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))&&e.detail.property&&e.detail.owner){if(null==e.detail.value){this[e.detail.property]=null}else if("object"===babelHelpers.typeof(e.detail.value)){this[e.detail.property]={}}this[e.detail.property]=e.detail.value;this.dispatchEvent(new CustomEvent("hax-store-property-updated",{bubbles:!0,composed:!0,cancelable:!1,detail:{property:e.detail.property,value:e.detail.value,owner:e.detail.owner}}))}}/**
   * Notice that an app was set in HAX; register it
   */},{key:"_haxStoreRegisterApp",value:function _haxStoreRegisterApp(e){if(e.detail){e.detail.index=this.appList.length;this.appList=[].concat(babelHelpers.toConsumableArray(this.appList),[e.detail]);window.HaxStore.write("appList",this.appList,this);// preconnect apps at registration time
if(e.detail.connection&&e.detail.connection.protocol&&e.detail.connection.url){var preconnectlink=document.createElement("link");preconnectlink.rel="preconnect";preconnectlink.href=e.detail.connection.protocol+"://"+e.detail.connection.url;document.head.appendChild(preconnectlink)}// we don't care about this after it's launched
if(babelHelpers.typeof(e.target.parentElement)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))&&"HAX-STORE"===e.target.parentElement.tagName){e.target.parentElement.removeChild(e.target)}}}/**
   * Notice that a stax was set in HAX; register it
   */},{key:"_haxStoreRegisterStax",value:function _haxStoreRegisterStax(e){if(e.detail){e.detail.index=this.staxList.length;this.staxList=[].concat(babelHelpers.toConsumableArray(this.staxList),[e.detail]);window.HaxStore.write("staxList",this.staxList,this);// we don't care about this after it's launched
if(babelHelpers.typeof(e.target.parentElement)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))&&"HAX-STORE"===e.target.parentElement.tagName){e.target.parentElement.removeChild(e.target)}}}/**
   * Notice that a blox was set in HAX; register it
   */},{key:"_haxStoreRegisterBlox",value:function _haxStoreRegisterBlox(e){if(e.detail){e.detail.index=this.bloxList.length;this.bloxList=[].concat(babelHelpers.toConsumableArray(this.bloxList),[e.detail]);window.HaxStore.write("bloxList",this.bloxList,this);// we don't care about this after it's launched
if(babelHelpers.typeof(e.target.parentElement)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))&&"HAX-STORE"===e.target.parentElement.tagName){e.target.parentElement.removeChild(e.target)}}}/**
   * Notice that a property off an element was set in HAX some place; register it here
   */},{key:"_haxStoreRegisterProperties",value:function _haxStoreRegisterProperties(e){if(e.detail&&e.detail.properties&&e.detail.tag){// only register tag if we don't know about it already
if(babelHelpers.typeof(this.elementList[e.detail.tag])===("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){// look for a gizmo; it's not required, technically.
var gizmo=e.detail.properties.gizmo;if(gizmo){gizmo.tag=e.detail.tag;var gizmos=this.gizmoList;gizmos.push(gizmo);window.HaxStore.write("gizmoList",gizmos,this)}this.elementList[e.detail.tag]=e.detail.properties;// only push new values on if we got something new
if(!this.validTagList.find(function(element){return element===e.detail.tag})){this.validTagList.push(e.detail.tag)}}// delete this tag if it was in the autoloader as it has served it's purpose.
if(babelHelpers.typeof(e.target.parentElement)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))&&"HAX-AUTOLOADER"===e.target.parentElement.tagName){this.haxAutoloader.removeChild(e.target)}}}}]);return HaxStore}((0,_utils.winEventsElement)((0,_haxBodyBehaviors.HAXElement)(_litElement.LitElement)));_exports.HaxStore=HaxStore;window.customElements.define(HaxStore.tag,HaxStore);/**
 * Trick to write the store to the DOM if it wasn't there already.
 * This is not used yet but could be if you wanted to dynamically
 * load the store based on something else calling for it. Like
 * store lazy loading but it isn't tested.
 */window.HaxStore=window.HaxStore||{};window.HaxStore.instance=null;window.HaxStore.requestAvailability=function(){if(!window.HaxStore.instance){window.HaxStore.instance=document.createElement("hax-store");document.body.appendChild(window.HaxStore.instance)}return window.HaxStore.instance};/**
 * Simple Array smashing function to ensure Object is array.
 */window.HaxStore.toArray=function(obj){return Object.keys(obj).map(function(key){return obj[key]})};/**
 * Helper to convert camel case to dash; important when setting attributes.
 */window.HaxStore.camelToDash=function(str){return str.replace(/\W+/g,"-").replace(/([a-z\d])([A-Z])/g,"$1-$2").toLowerCase()};/**
 * Helper to convert dash to camel; important when reading attributes.
 */window.HaxStore.dashToCamel=function(str){return str.replace(/-([a-z])/g,function(g){return g[1].toUpperCase()})};/**
 * Convert HTML into HAX Elements
 */window.HaxStore.htmlToHaxElements=function(html){var elements=[],validTags=window.HaxStore.instance.validTagList,fragment=document.createElement("div");fragment.innerHTML=html;// loop over the new nodes
for(var children=fragment.childNodes,i=0;i<children.length;i++){// verify this tag is a valid one
if(babelHelpers.typeof(children[i].tagName)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))&&validTags.includes(children[i].tagName.toLowerCase())){elements.push(window.HaxStore.nodeToHaxElement(children[i],null))}}return elements};/**
 * Convert a node to a HAX element. Hax elements ensure
 * a certain level of sanitization by verifying tags and
 * properties / attributes that have values.
 */window.HaxStore.nodeToHaxElement=function(node){var eventName=1<arguments.length&&arguments[1]!==void 0?arguments[1]:"insert-element";if(!node){return null}// build out the properties to send along
var props={};// support basic styles
if(babelHelpers.typeof(node.style)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){props.style=node.getAttribute("style")}// don't set a null style
if(null===props.style||"null"===props.style){delete props.style}// test if a class exists, not everything scopes
if(babelHelpers.typeof(node.attributes.class)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){props.class=node.attributes.class.nodeValue.replace("hax-active","")}// test if a id exists as its a special case in attributes... of course
if(babelHelpers.typeof(node.attributes.id)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){props.id=node.getAttribute("id")}var tmpProps;// relatively cross library
if(customElements.get(node.tagName.toLowerCase())){tmpProps=customElements.get(node.tagName.toLowerCase()).properties}// weak fallback
if(babelHelpers.typeof(tmpProps)===("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){tmpProps=node.__data}// complex elements need complex support
if(babelHelpers.typeof(tmpProps)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){// run through attributes, though non-reflected props won't be here
// run through props, we always defer to property values
for(var property in tmpProps){// make sure we only set things that have a value
if("class"!=property&&"style"!=property&&tmpProps.hasOwnProperty(property)&&babelHelpers.typeof(node[property])!==void 0&&null!=node[property]&&""!=node[property]){props[property]=node[property]}// special support for false boolean
else if(!1===node[property]){props[property]=node[property]}else{}}for(var attribute in node.attributes){// make sure we only set things that have a value
if(babelHelpers.typeof(node.attributes[attribute].name)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))&&"class"!=node.attributes[attribute].name&&"style"!=node.attributes[attribute].name&&"id"!=node.attributes[attribute].name&&node.attributes.hasOwnProperty(attribute)&&babelHelpers.typeof(node.attributes[attribute].value)!==void 0&&null!=node.attributes[attribute].value&&""!=node.attributes[attribute].value&&!tmpProps.hasOwnProperty(window.HaxStore.dashToCamel(node.attributes[attribute].name))){props[window.HaxStore.dashToCamel(node.attributes[attribute].name)]=node.attributes[attribute].value}else{// note: debug here if experiencing attributes that won't bind
}}}else{// much easier case, usually just in primatives
for(var attribute in node.attributes){// make sure we only set things that have a value
if(babelHelpers.typeof(node.attributes[attribute].name)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))&&"class"!=node.attributes[attribute].name&&"style"!=node.attributes[attribute].name&&"id"!=node.attributes[attribute].name&&node.attributes.hasOwnProperty(attribute)&&babelHelpers.typeof(node.attributes[attribute].value)!==void 0&&null!=node.attributes[attribute].value&&""!=node.attributes[attribute].value){props[window.HaxStore.dashToCamel(node.attributes[attribute].name)]=node.attributes[attribute].value}}}// support sandboxed environments which
// will hate iframe tags but love webview
var tag=node.tagName.toLowerCase();if(window.HaxStore.instance._isSandboxed&&"iframe"===tag){tag="webview"}var slotContent=window.HaxStore.getHAXSlot(node);// support fallback on inner text if there were no nodes
if(""==slotContent){slotContent=node.innerText}// special edge case for slot binding in primatives
if("a"===tag){props.innerText=slotContent}else if("p"===tag||"table"===tag||"ol"===tag||"ul"===tag||"div"===tag){props.innerHTML=slotContent}var element={tag:tag,properties:props,content:slotContent};if(null!==eventName){element.eventName=eventName}return element};/**
 * Convert a haxElement to a DOM node.
 */window.HaxStore.haxElementToNode=function(tag,content,properties){// support sandboxed environments which
// will hate iframe tags but love webview
if(window.HaxStore.instance._isSandboxed&&"iframe"===tag){tag="webview"}var frag=document.createElement(tag);frag.innerHTML=content;// clone the fragment which will force an escalation to full node
var newNode=frag.cloneNode(!0);// support for properties if they exist
for(var property in properties){var attributeName=window.HaxStore.camelToDash(property);if(properties.hasOwnProperty(property)){// special supporting for boolean because html is weird :p
if(!0===properties[property]){newNode.setAttribute(attributeName,properties[property])}else if(!1===properties[property]){newNode.removeAttribute(attributeName)}else if(null!=properties[property]&&properties[property].constructor===Array){// do nothing if we have additional data to suggest this is actually readOnly
// polymer / typed specific thing
if(frag.properties&&frag.properties[property]&&frag.properties[property].readOnly){}else{if(newNode.set){newNode.set(attributeName,properties[property])}else{newNode[attributeName]=babelHelpers.toConsumableArray(properties[property])}}}else if(null!=properties[property]&&properties[property].constructor===Object){// do nothing if we have additional data to suggest this is actually readOnly
// polymer / typed specific thing
if(frag.properties&&frag.properties[property]&&frag.properties[property].readOnly){}else{if(newNode.set){newNode.set(attributeName,properties[property])}else{newNode[attributeName]=_objectSpread({},properties[property])}}}else{newNode.setAttribute(attributeName,properties[property])}}}return newNode};/**
 * Convert a node to the correct content object for saving.
 * This DOES NOT acccept a HAXElement which is similar
 */window.HaxStore.nodeToContent=function(node){// ensure we have access to all the member functions of the custom element
var prototype=Object.getPrototypeOf(node);// support for deep API call
if(babelHelpers.typeof(prototype.preProcessHaxNodeToContent)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){node=prototype.preProcessHaxNodeToContent(node)}var tag=node.tagName.toLowerCase();// support sandboxed environments which
// will hate iframe tags but love webview
if(window.HaxStore.instance._isSandboxed&&"webview"===tag){tag="iframe"}var content="";// start to rebuild the same tag we got in a generalized way
content+="<"+tag;// account for things that say NOT to save slot values
// grab all of the original's attributes, and pass them to the replacement
for(var props=window.HaxStore.instance.elementList[tag],propvals={},j=0,l=node.attributes.length;j<l;++j){var nodeName=node.attributes.item(j).nodeName,value=node.attributes.item(j).value;// encode objects and arrays because they are special
if("style"!=nodeName&&(babelHelpers.typeof(value)===("undefined"===typeof Object?"undefined":babelHelpers.typeof(Object))||value.constructor===Array)){propvals[nodeName]=JSON.stringify(value).replace(/"/g,"&quot;")}// only write things that aren't empty
else if(null!=value&&"null"!=value){if(!0===value||"true"===value){propvals[nodeName]=!0}else if(!1===value){// do nothing, no reason to record false unless written as text
// in which case below will capture it
}else{// ensure that value doesn't have " in it unencoded
if("string"===typeof value&&""!==value){value=value.replace(/"/g,"&quot;");propvals[nodeName]=value}// special handling for empty string cause it might mean boolean
// or it might be a string
else if(""===value){if(""==value&&""!=node.attributes.item(j).value){value=node.attributes.item(j).value}propvals[nodeName]=value}else{propvals[nodeName]=value}}}}// now look through properties
var tmpProps;// relatively cross library
if(customElements.get(tag)){tmpProps=customElements.get(tag).properties}// weak fallback
if(babelHelpers.typeof(tmpProps)===("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){tmpProps=node.__data}if(babelHelpers.typeof(tmpProps)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){for(var j in tmpProps){var nodeName=window.HaxStore.camelToDash(j),value=null;// prefer local value over properties object if possible
if(babelHelpers.typeof(node[j])!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){value=node[j]}// never allow read only things to recorded as they
// are run-time creation 99% of the time
// this is very polymer specific but it allows readOnly and computed props
// also __ is a popular convention for private values so let's skip them
if(!tmpProps[j].readOnly&&!tmpProps[j].computed&&value!==tmpProps[j].value&&!nodeName.startsWith("__")){// encode objects and arrays because they are special
if(null!=value&&("object"===babelHelpers.typeof(value)||value.constructor===Array)){if(value.constructor===Array&&[]!=value){propvals[nodeName]=JSON.stringify(value).replace(/"/g,"&quot;")}else if("object"===babelHelpers.typeof(value)&&{}!=value){propvals[nodeName]=JSON.stringify(value).replace(/"/g,"&quot;")}}// only write things that aren't empty
else if(null!=value&&"null"!=value){if(!0===value||"true"===value){propvals[nodeName]=!0}else if(!1===value){// do nothing, no reason to record false unless written as text
// in which case below will capture it
}else{// ensure that value doesn't have " in it unencoded
if("string"===typeof value&&""!==value){value=value.replace(/"/g,"&quot;");propvals[nodeName]=value}// special handling for empty string cause it might mean boolean
// or it might be a string
else if(""===value){if(""==value&&""!=tmpProps[j].value){value=tmpProps[j].value}else if(""===value&&""==tmpProps[j].value){// do nothing, the default value is empty
// so lets record less data
}}else{propvals[nodeName]=value}}}}}}// support for tag defining which properties NOT to save
// for simplification, everything is an attribute during this
// operation
if(babelHelpers.typeof(props)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))&&babelHelpers.typeof(props.saveOptions.unsetAttributes)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){for(var i in props.saveOptions.unsetAttributes){delete propvals[props.saveOptions.unsetAttributes[i]]}}// specialized clean up for some that can leak through from above
// and are edge case things because #hashtag gotta love HTML attributes
// and the webview tag. facepalm.
var delProps=["inner-text","inner-html","tabindex","guestinstance"];for(var delProp in delProps){if(babelHelpers.typeof(propvals[delProps[delProp]])!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){delete propvals[delProps[delProp]]}}// remove id attribute if it's empty, somehow misses above
if(babelHelpers.typeof(propvals.id)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))&&""===propvals.id){delete propvals.id}// run through the properties
for(var i in propvals){if(!0===propvals[i]){content+=" "+i}else{content+=" "+i+"=\""+propvals[i]+"\""}}// set the opening tag, support self-closing void tags
var voidTags=["area","base","br","col","embed","hr","img","input","keygen","link","meta","param","source","track","wbr"];if(voidTags.includes(tag)){content+="/>"}else{content+=">"}// try and work against anything NOT a P tag
if(babelHelpers.typeof(props)===("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))||!props.saveOptions.wipeSlot){// get content that is in the slots
var slotnodes=node.childNodes;// ensure there's something inside of this
if(0<slotnodes.length){// loop through everything found in the slotted area and put it back in
for(var j=0,len2=slotnodes.length;j<len2;j++){if(babelHelpers.typeof(slotnodes[j].tagName)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){// if we're a custom element, keep digging, otherwise a simple
// self append is fine unless template tag cause it's a special
// case for the web in general as it'll register as not a primative
// even though it is...
if(!window.HaxStore.HTMLPrimativeTest(slotnodes[j].tagName)&&"TEMPLATE"!==slotnodes[j].tagName){content+=window.HaxStore.nodeToContent(slotnodes[j])}else{slotnodes[j].setAttribute("data-editable",!1);slotnodes[j].removeAttribute("data-hax-ray");slotnodes[j].contentEditable=!1;content+=slotnodes[j].outerHTML}}// keep comments with a special case since they need wrapped
else if(8===slotnodes[j].nodeType){content+="<!-- "+slotnodes[j].textContent+" -->"}// keep everything NOT an element at this point, this helps
// preserve whitespace because we're crazy about accuracy
else if(1!==slotnodes[j].nodeType&&babelHelpers.typeof(slotnodes[j].textContent)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))&&"undefined"!==slotnodes[j].textContent){content+=slotnodes[j].textContent}}}}// optional support for intentional progressive enhancement
if("function"===typeof node.haxProgressiveEnhancement){content+=node.haxProgressiveEnhancement()}// don't put return for span since it's an inline tag
if("span"===tag){content+="</"+tag+">"}else if("hr"===tag||"br"===tag||"img"===tag){}// do nothing for self-closing tags they'll resolve themselves
// close the tag, placing a return in output for block elements
else{content+="</"+tag+">"+"\n"}// spacing niceness for output readability
content=content.replace(/&nbsp;/gm," ");// target and remove hax specific things from output if they slipped through
content=content.replace(/ data-editable="(\s|.)*?"/gim,"");content=content.replace(/ data-hax-ray="(\s|.)*?"/gim,"");content=content.replace(/ class=""/gim,"");content=content.replace(/ class="hax-active"/gim,"");content=content.replace(/ contenteditable="(\s|.)*?"/gim,"");// wipe pure style spans which can pop up on copy paste if we didn't catch it
// also ensure that we then remove purely visual chars laying around
// this also helps clean up when we did a normal contenteditable paste
// as opposed to our multi-element sanitizing option that we support
content=content.replace(/<span style="(.*?)">/gim,"<span>");content=content.replace(/<span>\s*?<\/span>/g," ");content=content.replace(/<span><br\/><\/span>/gm,"");// account for things taht on normal paste would pick up too many css vars
content=content.replace(/<strong style="(.*?)">/gim,"<strong>");content=content.replace(/<b style="(.*?)">/gim,"<b>");content=content.replace(/<strike style="(.*?)">/gim,"<strike>");content=content.replace(/<em style="(.*?)">/gim,"<em>");content=content.replace(/<i style="(.*?)">/gim,"<i>");// empty with lots of space
content=content.replace(/<p>(\s*)<\/p>/gm,"<p></p>");// empty p / more or less empty
content=content.replace(/<p>&nbsp;<\/p>/gm,"<p></p>");// br somehow getting through here
content=content.replace(/<p><br\/><\/p>/gm,"<p></p>");content=content.replace(/<p><br><\/p>/gm,"<p></p>");// whitespace in reverse of the top case now that we've cleaned it up
content=content.replace(/<\/p>(\s*)<p>/gm,"</p><p>");content=content.split("\n\r").join("\n").split("\r").join("\n").split("\n\n").join("\n").split("\n\n").join("\n").split("\n\n").join("\n");// support postProcess text rewriting for the node that's been
// converted to a string for storage
if("function"===node.postProcesshaxNodeToContent){content=node.postProcesshaxNodeToContent(content)}return content};/**
 * Basic HTML Primitives test
 */window.HaxStore.HTMLPrimativeTest=function(node){if(babelHelpers.typeof(node.tagName)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))&&-1==node.tagName.indexOf("-")){return!0}return!1};/**
 * Slot content w/ support for custom elements in slot.
 */window.HaxStore.getHAXSlot=function(node){// we can skip all of this if we have a text element / HTML prim!
if(window.HaxStore.instance.isTextElement(node)){return node.innerHTML}var content="",slotnodes=node.childNodes;// ensure there's something inside of this
if(0<slotnodes.length){// loop through everything found in the slotted area and put it back in
for(var j=0,len2=slotnodes.length;j<len2;j++){if(babelHelpers.typeof(slotnodes[j].tagName)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){// if we're a custom element, keep digging, otherwise a simple
// self append is fine.
if(0<slotnodes[j].tagName.indexOf("-")){content+="  "+window.HaxStore.nodeToContent(slotnodes[j])+"\n"}else{content+="  "+slotnodes[j].outerHTML+"\n"}}// keep comments with a special case since they need wrapped
else if(8===slotnodes[j].nodeType){content+="<!-- "+slotnodes[j].textContent+" -->"}// keep everything NOT an element at this point, this helps
// preserve whitespace because we're crazy about accuracy
else if(1!==slotnodes[j].nodeType&&babelHelpers.typeof(slotnodes[j].textContent)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))&&"undefined"!==slotnodes[j].textContent){content+=slotnodes[j].textContent}}}return content};/**
 * Shortcut to standardize the write / read process.
 */window.HaxStore.write=function(prop,value,obj){if(obj){obj.dispatchEvent(new CustomEvent("hax-store-write",{composed:!0,bubbles:!0,cancelable:!1,detail:{property:prop,value:value,owner:obj}}))}};/**
 * Guess the type of Gizmo when given some information about what we have.
 */window.HaxStore.guessGizmoType=function(guess){if(babelHelpers.typeof(guess.source)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){var source=guess.source.toLowerCase();if(-1!=source.indexOf(".mp3")){return"audio"}else if(-1!=source.indexOf(".png")||-1!=source.indexOf(".jpg")||-1!=source.indexOf(".jpeg")||-1!=source.indexOf(".gif")){return"image"}else if(-1!=source.indexOf(".pdf")){return"pdf"}else if(-1!=source.indexOf(".svg")){return"svg"}else if(-1!=source.indexOf(".csv")){return"csv"}else if(-1!=source.indexOf(".md")){return"markdown"}else if(-1!=source.indexOf(".html")||-1!=source.indexOf(".htm")){return"html"}else if(-1!=source.indexOf(".txt")||-1!=source.indexOf(".doc")||-1!=source.indexOf(".docx")||-1!=source.indexOf(".xls")||-1!=source.indexOf(".xlsx")||-1!=source.indexOf(".ppt")){return"document"}else if(-1!=source.indexOf(".zip")||-1!=source.indexOf(".tar.gz")||-1!=source.indexOf(".tar")){return"archive"}// if it's external we can't assume what it actually is
else if("external"!=window.MediaBehaviors.Video.getVideoType(source)){return"video"}else{// we don't know how to handle this so let's just
// try ANYTHING that matches
return"*"}}};/**
 * Try and guess the Gizmo based on what we were just handed
 */window.HaxStore.guessGizmo=function(guess,values){var skipPropMatch=2<arguments.length&&arguments[2]!==void 0?arguments[2]:!1,preferExclusive=3<arguments.length&&arguments[3]!==void 0?arguments[3]:!1,matches=[];if(babelHelpers.typeof(guess)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){var store=window.HaxStore.instance;// verify type
if(store.validGizmoTypes.includes(guess)){// now we can look through them
// look for a match
for(var gizmoposition in store.gizmoList){var gizmo=store.gizmoList[gizmoposition],props={},match=!1;// ensure this gizmo can handle things
if(gizmo.handles){for(var i=0;i<gizmo.handles.length;i++){// WHAT!??!?!?!?!
if(guess===gizmo.handles[i].type||"*"===guess&&!match){for(var property in gizmo.handles[i]){// ignore type.. but again.. WHAT?!?!?!
if("type"!==property){// check the values that came across to see if there's a match
// of any kind, we only need one but can then bind to multiple
if(babelHelpers.typeof(values[property])!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){// but ensure there's either no meta data OR
// the meta data needs to NOT say anythinig about hiding
if("inline"===guess||!gizmo.meta||gizmo.meta&&!gizmo.meta.inlineOnly&&!gizmo.meta.hidden){match=!0;props[gizmo.handles[i][property]]=values[property]}}}}// omg... we just found a match on a property from who knows where!
if(match||skipPropMatch){if(preferExclusive&&gizmo.handles[i].type_exclusive){return[window.HaxStore.haxElementPrototype(gizmo,props,"")]}else{matches.push(window.HaxStore.haxElementPrototype(gizmo,props,""))}}}}}}}}return matches};/**
 * Filter app store apps to those that accept this file source.
 */window.HaxStore.getHaxAppStoreTargets=function(type){var targets=window.HaxStore.instance.appList.filter(function(app){if(babelHelpers.typeof(app.connection.operations.add)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){var add=app.connection.operations.add;if(babelHelpers.typeof(add.acceptsGizmoTypes)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))&&add.acceptsGizmoTypes.includes(type)){return!0}}return!1});return targets};/**
 * Generate Hax Element prototype.
 */window.HaxStore.haxElementPrototype=function(gizmo,properties){var content=2<arguments.length&&arguments[2]!==void 0?arguments[2]:"";return{tag:gizmo.tag,properties:properties,content:content,gizmo:gizmo}};/**
 * Wipe out the slot of an element.
 */window.HaxStore.wipeSlot=function(element){var slot=1<arguments.length&&arguments[1]!==void 0?arguments[1]:"";(0,_utils.wipeSlot)(element,slot)};/**
 * HTML encapsulation of a string on script and style tags
 */window.HaxStore.encapScript=function(html){return(0,_utils.encapScript)(html)};/**
 * Global toast bridge so we don't have to keep writing custom event
 */window.HaxStore.toast=function(message){var duration=1<arguments.length&&arguments[1]!==void 0?arguments[1]:4e3,classStyle=2<arguments.length&&arguments[2]!==void 0?arguments[2]:"capsule",closeText=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null,eventCallback=4<arguments.length&&arguments[4]!==void 0?arguments[4]:null,evt=new CustomEvent("simple-toast-show",{bubbles:!0,composed:!0,cancelable:!0,detail:{text:message,duration:duration,classStyle:classStyle,closeText:closeText,eventCallback:eventCallback}});window.dispatchEvent(evt)};/**
 * Selection normalizer
 */window.HaxStore.getSelection=function(){// try and obtain the selection from the nearest shadow
// which would give us the selection object when running native ShadowDOM
// with fallback support for the entire window which would imply Shady
if(window.HaxStore.instance.activeHaxBody.parentNode){// native API
if(window.HaxStore.instance.activeHaxBody.parentNode.getSelection){return window.HaxStore.instance.activeHaxBody.parentNode.getSelection()}// ponyfill from google
else if((0,_utils.getRange)(window.HaxStore.instance.activeHaxBody.parentNode)){return(0,_utils.getRange)(window.HaxStore.instance.activeHaxBody.parentNode)}}// missed on both, hope the normal one will work
return window.getSelection()};/**
 * Get a normalized range based on current selection
 */window.HaxStore.getRange=function(){var sel=window.HaxStore.getSelection();if(sel.getRangeAt&&sel.rangeCount){return sel.getRangeAt(0)}else if(sel){return sel}else!1};var UndoerElement=/*#__PURE__*/function(_HTMLElement){babelHelpers.inherits(UndoerElement,_HTMLElement);babelHelpers.createClass(UndoerElement,null,[{key:"observedAttributes",get:function get(){return["state"]}}]);function UndoerElement(){var _this8;babelHelpers.classCallCheck(this,UndoerElement);_this8=babelHelpers.possibleConstructorReturn(this,babelHelpers.getPrototypeOf(UndoerElement).call(this));_this8.openDrawer=!1;_this8._root=_this8.attachShadow({mode:"open"});// hide from the first attributeChangedCallback call
_this8._selfAttributeChange=!0;window.setTimeout(function(){_this8._selfAttributeChange=!1});var callback=function callback(data){var value=data.value,attr=data.attr;_this8._updateAttribute(attr?value:null);// hooray! tell the client
_this8.dispatchEvent(new CustomEvent("state",{detail:value}))},zero=_this8.getAttribute("state"),attr=_this8.hasAttribute("state");// set up initial zero undo state from attr
_this8._undoer=new _undoer.Undoer(callback,{value:zero,attr:attr});return _this8}babelHelpers.createClass(UndoerElement,[{key:"attributeChangedCallback",value:function attributeChangedCallback(name,oldValue,newValue){if("state"===name&&!this._selfAttributeChange){this._internalSet(newValue,!0)}}},{key:"_updateAttribute",value:function _updateAttribute(value){this._selfAttributeChange=!0;try{if(value){this.setAttribute("state",value)}else{this.removeAttribute("state")}}finally{this._selfAttributeChange=!1}}},{key:"_internalSet",value:function _internalSet(value,attr){this._updateAttribute(attr?value:null);this._undoer.push({value:value,attr:attr},this._root)}},{key:"state",set:function set(value){if(!this.isConnected){throw new Error("can't push state while disconnected")}// render if simple "attribute safe" state
var attr="string"===typeof value||"number"===typeof value;this._internalSet(value,attr)},get:function get(){var value=this._undoer.data.value;return value}}]);return UndoerElement}(babelHelpers.wrapNativeSuper(HTMLElement));_exports.UndoerElement=UndoerElement;window.customElements.define("undoer-element",UndoerElement)});