define(["exports","meta","require","../../../@polymer/polymer/polymer-element.js","../../../@polymer/polymer/lib/utils/render-status.js","../../../@polymer/polymer/lib/legacy/polymer.dom.js","../../../@polymer/polymer/lib/utils/resolve-url.js","../../../@polymer/polymer/lib/utils/settings.js","./shadows-safari.js","./haxutils.js","../../../@polymer/iron-ajax/iron-ajax.js","../../simple-toast/simple-toast.js","../../media-behaviors/media-behaviors.js","../../hax-body-behaviors/hax-body-behaviors.js","../../code-sample/code-sample.js"],function(_exports,meta,_require,_polymerElement,_renderStatus,_polymerDom,_resolveUrl,_settings,_shadowsSafari,_haxutils,_ironAjax,_simpleToast,_mediaBehaviors,_haxBodyBehaviors,_codeSample){"use strict";Object.defineProperty(_exports,"__esModule",{value:!0});_exports.HaxStore=void 0;meta=babelHelpers.interopRequireWildcard(meta);_require=babelHelpers.interopRequireWildcard(_require);function _templateObject_9af8cd50a44b11e98c881fc26e93d8f9(){var data=babelHelpers.taggedTemplateLiteral(["\n      <style>\n        :host {\n          display: none;\n        }\n      </style>\n      <slot></slot>\n      <iron-ajax\n        id=\"appstore\"\n        url=\"[[appStore.url]]\"\n        params=\"[[appStore.params]]\"\n        method=\"GET\"\n        content-type=\"application/json\"\n        handle-as=\"json\"\n        last-response=\"{{__appStoreData}}\"\n      ></iron-ajax>\n      <hal-9000 id=\"hal\" debug=\"debug\" commands=\"[[voiceCommands]]\"></hal-9000>\n    "]);_templateObject_9af8cd50a44b11e98c881fc26e93d8f9=function _templateObject_9af8cd50a44b11e98c881fc26e93d8f9(){return data};return data}var HaxStore=/*#__PURE__*/function(_HAXElement){babelHelpers.inherits(HaxStore,_HAXElement);babelHelpers.createClass(HaxStore,[{key:"_storageDataChanged",/**
   * Local storage data changed; callback to store this data in user storage
   */value:function _storageDataChanged(newValue){if(newValue&&window.HaxStore.ready&&this.__storageDataProcessed){if(window.localStorage.getItem("haxConfirm")){window.localStorage.setItem("haxUserData",JSON.stringify(newValue))}else if(window.sessionStorage.getItem("haxConfirm")){window.sessionStorage.setItem("haxUserData",JSON.stringify(newValue))}}}/**
   * If this is a text node or not so we know if the inline context
   * operations are valid.
   */},{key:"isTextElement",value:function isTextElement(node){if(null!=node&&this.validTagList.includes(node.tagName.toLowerCase())){if(["p","ol","ul","li","a","h1","h2","h3","h4","h5","h6","strike","u","b","sub","sup","span","i","bold","em","strong","blockquote","code","figure"].includes(node.tagName.toLowerCase())){return!0}}return!1}/**
   * test for being a valid grid plate, li is here because
   * nested lists make this really complicated
   */},{key:"isGridPlateElement",value:function isGridPlateElement(node){var tag=node.tagName.toLowerCase();if(this.validTagList.includes(tag)){if(["p","ol","ul","li","div","h1","h2","h3","h4","h5","h6","blockquote","code","figure","grid-plate"].includes(tag)){return!0}}return!1}/**
   * Notice _appStore changed.
   */},{key:"_appStoreChanged",value:function _appStoreChanged(newValue,oldValue){var _this2=this;// if we have an endpoint defined, pull it
if(babelHelpers.typeof(newValue)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))&&null!=newValue){// support having the request or remote loading
// depending on the integration type
if(babelHelpers.typeof(newValue.apps)===("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){this.shadowRoot.querySelector("#appstore").generateRequest()}else{// directly injected json object into the DOM, allow some time to propagate data
// otherwise we might not have a haxAutoloader object ready in time for the paint
setTimeout(function(){_this2.__appStoreData=newValue},500)}}}/**
   * Load and attach items from the app store.
   */},{key:"_loadAppStoreData",value:function _loadAppStoreData(ready,appDataResponse,haxAutoloader){if(ready&&babelHelpers.typeof(appDataResponse)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))&&null!=appDataResponse){var items={};// autoload elements
if(babelHelpers.typeof(appDataResponse.autoloader)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){// ensure the list is in the right order so we can async dynamic imports
// regardless of if its an array or object of values in the right format
// force this to be an object
appDataResponse.autoloader=Object.assign({},appDataResponse.autoloader);for(var i in appDataResponse.autoloader){var CEname=i,CEimport=appDataResponse.autoloader[i];// helps support array or object based appstore
// array was originally in the standard so this lets us support both
if(!isNaN(CEname)){CEname=appDataResponse.autoloader[i];CEimport="@lrnwebcomponents/".concat(CEname,"/").concat(CEname,".js")}// force this into the valid tag list so early paints will
// correctly include the tag without filtering it out incorrectly
this.push("validTagList",CEname);items[CEname]=CEimport}}// load apps automatically
if(babelHelpers.typeof(appDataResponse.apps)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){for(var apps=appDataResponse.apps,i=0,app;i<apps.length;i++){app=document.createElement("hax-app");app.data=apps[i];// see if anything coming across claims to be a backend for adding items
// and then enable the upload button
if(apps[i].connection.operations.add){window.HaxStore.write("canSupportUploads",!0,this)}window.HaxStore.instance.appendChild(app)}}// load in stax dynamically
if(babelHelpers.typeof(appDataResponse.stax)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){for(var staxs=appDataResponse.stax,i=0,stax;i<staxs.length;i++){stax=document.createElement("hax-stax");stax.data=staxs[i];window.HaxStore.instance.appendChild(stax)}}// load in blox dynamically
if(babelHelpers.typeof(appDataResponse.blox)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){for(var bloxs=appDataResponse.blox,i=0,blox;i<bloxs.length;i++){blox=document.createElement("hax-blox");blox.data=bloxs[i];window.HaxStore.instance.appendChild(blox)}}this.dispatchEvent(new CustomEvent("hax-store-app-store-loaded",{bubbles:!0,cancelable:!0,composed:!0,detail:!0}));// now process the dynamic imports
this._handleDynamicImports(items,haxAutoloader)}}/**
   * Handle all the dynamic imports of things told to autoload
   * This ensures we get the definitions very quickly as far as
   * what is a safe / valid tag above but then we import in a way
   * that allows us to correctly associate the hax schema to where
   * it came from.
   */},{key:"_handleDynamicImports",value:function(){var _handleDynamicImports2=babelHelpers.asyncToGenerator(/*#__PURE__*/regeneratorRuntime.mark(function _callee(items,haxAutoloader){var _this3=this,basePath,i;return regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:basePath=(0,_resolveUrl.pathFromUrl)(decodeURIComponent(meta.url));_context.t0=regeneratorRuntime.keys(items);case 2:if((_context.t1=_context.t0()).done){_context.next=8;break}i=_context.t1.value;_context.next=6;return new Promise(function(res,rej){return _require.default(["".concat(basePath,"../../../").concat(items[i])],res,rej)}).then(function(response){for(var cVal in response){// get the custom element definition we used to add that file
var CEClass=response[cVal];if("function"===typeof CEClass.getHaxProperties){_this3.setHaxProperties(CEClass.getHaxProperties(),i)}else if("function"===typeof CEClass.HAXWiring){_this3.setHaxProperties(CEClass.HAXWiring.getHaxProperties(),i)}else if(CEClass.haxProperties){_this3.setHaxProperties(CEClass.haxProperties,i)}else{// this is the less optimized / legacy polymer element method to inlcude
// this item. It's a good reason to skip on this though because you'll
// have a faster boot up time with newer ES6 methods then previous ones.
(0,_polymerDom.dom)(haxAutoloader).appendChild(document.createElement(i))}}}).catch(function(error){/* Error handling */console.log(error)});case 6:_context.next=2;break;case 8:case"end":return _context.stop();}}},_callee)}));function _handleDynamicImports(_x,_x2){return _handleDynamicImports2.apply(this,arguments)}return _handleDynamicImports}()},{key:"_editModeChanged",value:function _editModeChanged(newValue){if(newValue&&this.globalPreferences.haxVoiceCommands){this.shadowRoot.querySelector("#hal").auto=!0}else{this.shadowRoot.querySelector("#hal").auto=!1}}},{key:"_globalPreferencesChanged",value:function _globalPreferencesChanged(newValue,oldValue){// regardless of what it is, reflect it globally but only after setup
if(this.__storageDataProcessed&&newValue&&babelHelpers.typeof(newValue.haxVoiceCommands)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))&&window.HaxStore.ready){var storageData=this.storageData;storageData.globalPreferences=newValue;this.set("storageData",{});this.set("storageData",storageData);if(newValue.haxVoiceCommands&&this.editMode){this.shadowRoot.querySelector("#hal").auto=!0}else{this.shadowRoot.querySelector("#hal").auto=!1}}}/**
   * Detached life cycle
   */},{key:"disconnectedCallback",value:function disconnectedCallback(){// notice hax property definitions coming from anywhere
window.removeEventListener("hax-register-properties",this._haxStoreRegisterProperties.bind(this));// app registration can come in automatically from app-stores
// or through direct definition in the DOM
document.body.removeEventListener("hax-register-app",this._haxStoreRegisterApp.bind(this));// register stax which are groupings of haxElements
document.body.removeEventListener("hax-register-stax",this._haxStoreRegisterStax.bind(this));// register blox which are grid plate configurations
// with lots of sane visual defaults
document.body.removeEventListener("hax-register-blox",this._haxStoreRegisterBlox.bind(this));// register the pieces of the body of what we call HAX
// think of this like the core of the system required
// to do anything like have buttons or state management
// write data to the store
document.body.removeEventListener("hax-store-write",this._writeHaxStore.bind(this));// register the manager panel / modal
document.body.removeEventListener("hax-register-manager",this._haxStoreRegisterManager.bind(this));// register the autoloader area for elements
document.body.removeEventListener("hax-register-autoloader",this._haxStoreRegisterAutoloader.bind(this));// register a body, kind of a big deal
document.body.removeEventListener("hax-register-body",this._haxStoreRegisterBody.bind(this));// register the interaction panel / menu
document.body.removeEventListener("hax-register-panel",this._haxStoreRegisterPanel.bind(this));// register the app picker for contextual setting / option
document.body.removeEventListener("hax-register-app-picker",this._haxStoreRegisterAppPicker.bind(this));// stax modal
document.body.removeEventListener("hax-register-stax-picker",this._haxStoreRegisterStaxPicker.bind(this));// blox modal
document.body.removeEventListener("hax-register-blox-picker",this._haxStoreRegisterBloxPicker.bind(this));// preferences modal
document.body.removeEventListener("hax-register-preferences",this._haxStoreRegisterPreferences.bind(this));// export modal
document.body.removeEventListener("hax-register-export",this._haxStoreRegisterExport.bind(this));// notice content insert and help it along to the body
document.body.removeEventListener("hax-insert-content",this._haxStoreInsertContent.bind(this));// grid plate add item event
document.body.removeEventListener("grid-plate-add-item",this.haxInsertAnything.bind(this));document.body.removeEventListener("hax-insert-content-array",this._haxStoreInsertMultiple.bind(this));window.removeEventListener("hax-add-voice-command",this._addVoiceCommand.bind(this));// capture events and intercept them globally
window.removeEventListener("onbeforeunload",this._onBeforeUnload.bind(this));window.removeEventListener("hax-consent-tap",this._haxConsentTap.bind(this));window.removeEventListener("paste",this._onPaste.bind(this));// send that hax store is ready to go so now we can setup the rest
this.dispatchEvent(new CustomEvent("hax-store-ready",{bubbles:!0,cancelable:!1,composed:!0,detail:!1}));window.HaxStore.ready=!1;babelHelpers.get(babelHelpers.getPrototypeOf(HaxStore.prototype),"disconnectedCallback",this).call(this)}/**
   * This only send if they consented to storage of data locally
   */},{key:"_haxConsentTap",value:function _haxConsentTap(e){// store for future local storage usage
window.localStorage.setItem("haxConfirm",!0);// most likely nothing but set it anyway
window.localStorage.setItem("haxUserData",JSON.stringify(this.storageData))}/**
   * ready life cycle
   */},{key:"ready",value:function ready(){babelHelpers.get(babelHelpers.getPrototypeOf(HaxStore.prototype),"ready",this).call(this);(0,_renderStatus.afterNextRender)(this,function(){// see if a global was used to prevent this check
// this is useful when in trusted environments where the statement
// has been consented to in the application this is utilized in
if(this.skipHAXConfirmation){window.sessionStorage.setItem("haxConfirm",!0);window.localStorage.setItem("haxConfirm",!0)}// check for local storage object
// if not, then store it in sessionStorage so that all our checks
// and balances are the same. This could allow for storing these
// settings on a server in theory
var haxConfirm=window.sessionStorage.getItem("haxConfirm")||window.localStorage.getItem("haxConfirm");if(!haxConfirm){// this way it isn't shown EVERY reload, but if they didn't confirm
// it will show up in the future
window.sessionStorage.setItem("haxConfirm",!0);var msg="\n      The HAX content editor keeps preferences in order to improve your experience.\n      This data is stored in your browser and is never sent anywhere.\n      Click to accept.\n      ";window.HaxStore.toast(msg,"-1","fit-bottom","I Accept","hax-consent-tap")}else{if(window.sessionStorage.getItem("haxConfirm")&&!window.localStorage.getItem("haxConfirm")){// verify there is something there
try{var globalData=window.sessionStorage.getItem("haxUserData")?JSON.parse(window.sessionStorage.getItem("haxUserData")):{};this.set("storageData",globalData)}catch(e){}}else{try{var _globalData=window.localStorage.getItem("haxUserData")?JSON.parse(window.localStorage.getItem("haxUserData")):{};this.set("storageData",_globalData)}catch(e){}}}})}/**
   * attached.
   */},{key:"connectedCallback",value:function connectedCallback(){babelHelpers.get(babelHelpers.getPrototypeOf(HaxStore.prototype),"connectedCallback",this).call(this);(0,_renderStatus.afterNextRender)(this,function(){var _this4=this;// capture events and intercept them globally
window.addEventListener("hax-consent-tap",this._haxConsentTap.bind(this));window.addEventListener("onbeforeunload",this._onBeforeUnload.bind(this));window.addEventListener("paste",this._onPaste.bind(this));// import voice command stuff in the background
// @todo only activate if the setting to use it is in place
new Promise(function(res,rej){return _require.default(["../../hal-9000/hal-9000.js"],res,rej)});// set this global flag so we know it's safe to start trusting data
// that is written to global preferences / storage bin
setTimeout(function(){_this4.__storageDataProcessed=!0;if(_this4.storageData.globalPreferences){window.HaxStore.write("globalPreferences",_this4.storageData.globalPreferences,_this4)}},325)})}},{key:"_storePiecesAllHere",value:function _storePiecesAllHere(haxAutoloader,activeHaxBody,haxPanel,haxToast,haxExport,haxPreferences,haxManager,haxStaxPicker,haxAppPicker){if(!this.__ready&&activeHaxBody&&haxAutoloader&&haxPanel&&haxToast&&haxExport&&haxPreferences&&haxManager&&haxStaxPicker&&haxAppPicker){// send that hax store is ready to go so now we can setup the rest
this.dispatchEvent(new CustomEvent("hax-store-ready",{bubbles:!0,cancelable:!1,composed:!0,detail:!0}));window.HaxStore.ready=!0;this.__ready=!0;// register built in primitive definitions
this._buildPrimitiveDefinitions();// initialize voice commands
this.voiceCommands=this._initVoiceCommands()}}/**
   * Build a list of common voice commands
   */},{key:"_initVoiceCommands",value:function _initVoiceCommands(){var _this5=this,commands={};commands["".concat(this.shadowRoot.querySelector("#hal").respondsTo," scroll up")]=function(){window.scrollBy({top:-(.5*window.innerHeight),left:0,behavior:"smooth"})};commands["".concat(this.shadowRoot.querySelector("#hal").respondsTo," scroll (down)")]=function(){window.scrollBy({top:.5*window.innerHeight,left:0,behavior:"smooth"})};commands["hey ".concat(this.shadowRoot.querySelector("#hal").respondsTo)]=function(){_this5.shadowRoot.querySelector("#hal").speak("Yeah what do you want")};commands["".concat(this.shadowRoot.querySelector("#hal").respondsTo," find media")]=function(){window.HaxStore.write("activeHaxElement",{},window.HaxStore.instance);window.HaxStore.instance.haxManager.resetManager(1);window.HaxStore.instance.haxManager.toggleDialog(!1)};return commands}/**
   * allow uniform method of adding voice commands
   */},{key:"addVoiceCommand",value:function addVoiceCommand(command){this.push("voiceCommands",command);this.notifyPath("voiceCommands.*")}/**
   * event driven version
   */},{key:"_addVoiceCommand",value:function _addVoiceCommand(e){this.addVoiceCommand(e.detail)}/**
   * Before the browser closes / changes paths, ask if they are sure they want to leave
   */},{key:"_onBeforeUnload",value:function _onBeforeUnload(e){// ensure we don't leave DURING edit mode
if(!window.HaxStore.instance.skipExitTrap&&window.HaxStore.instance.editMode){return"Are you sure you want to leave? Your work will not be saved!"}}/**
   * Intercept paste event and clean it up before inserting the contents
   */},{key:"_onPaste",value:function _onPaste(e){// only perform this on a text element that is active
if(window.HaxStore.instance.isTextElement(window.HaxStore.instance.activeNode)&&!window.HaxStore.instance.haxManager.opened){e.preventDefault();e.stopPropagation();e.stopImmediatePropagation();var pasteContent="";// intercept paste event
if(e.clipboardData||e.originalEvent.clipboardData){pasteContent=(e.originalEvent||e).clipboardData.getData("text/html");// trap for partial content / pure text based
if(""==pasteContent){pasteContent="<span>"+(e.originalEvent||e).clipboardData.getData("text/plain")+"</span>"}}else if(window.clipboardData){pasteContent=window.clipboardData.getData("Text")}// edges that some things preserve empty white space needlessly
pasteContent=pasteContent.replace(/<span> <\/span>/g," ");pasteContent=pasteContent.replace(/<span><\/span>/g,"");var haxElements=window.HaxStore.htmlToHaxElements((0,_haxutils.stripMSWord)(pasteContent));// stupid but we need to reverse these
haxElements.reverse();var newContent="";for(var i in haxElements){// special traps for word / other styles bleeding through
delete haxElements[i].properties.style;delete haxElements[i].properties.start;delete haxElements[i].properties.align;// this is not the right function.
var node=window.HaxStore.haxElementToNode(haxElements[i].tag,haxElements[i].content.replace(/<span>&nbsp;<\/span>/g," ").trim(),haxElements[i].properties);newContent+=window.HaxStore.nodeToContent(node)}try{// get the range that's active and selection
var range=window.HaxStore.getRange(),sel=window.HaxStore.getSelection(),newNodes=document.createElement("div");newNodes.innerHTML=newContent;if(range&&sel){range.deleteContents();while(newNodes.firstChild){range.insertNode(newNodes.firstChild)}}}catch(e){console.log(e)}}}/**
   * Created life-cycle to ensure a single global store.
   */}],[{key:"template",get:function get(){return(0,_polymerElement.html)(_templateObject_9af8cd50a44b11e98c881fc26e93d8f9())}},{key:"tag",get:function get(){return"hax-store"}/**
   * Complex observer composites used for initial timing since this is a skeleton setup
   */},{key:"observers",get:function get(){return["_loadAppStoreData(__ready, __appStoreData, haxAutoloader)","_storePiecesAllHere(haxAutoloader,activeHaxBody, haxPanel, haxToast, haxExport, haxPreferences, haxManager, haxStaxPicker, haxAppPicker)"]}},{key:"properties",get:function get(){return Object.assign({/**
         * skipHAXConfirmation
         */skipHAXConfirmation:{type:Boolean,value:!1,reflectToAttribute:!0},/**
         * Local storage bridge
         */storageData:{type:Object,value:{},observer:"_storageDataChanged"},/**
         * Hax app picker element.
         */haxAppPicker:{type:Object},/**
         * Hax stax picker element.
         */haxStaxPicker:{type:Object},/**
         * Hax manager element.
         */haxManager:{type:Object},/**
         * Hax autoloader element.
         */haxAutoloader:{type:Object},/**
         * A list of all haxBodies that exist
         */haxBodies:{type:Array,value:[]},/**
         * An active place holder item reference. This is used
         * for inline drag and drop event detection so that we
         * know what element replace in context.
         */activePlaceHolder:{type:Object,value:null},/**
         * The hax-body that is currently active.
         */activeHaxBody:{type:Object},/**
         * Possible appStore endpoint for loading in things dynamically.
         */appStore:{type:Object,observer:"_appStoreChanged"},/**
         * HAX Toast message.
         */haxToast:{type:Object},/**
         * Hax panel element.
         */haxPanel:{type:Object},/**
         * Hax export dialog element.
         */haxExport:{type:Object},/**
         * Hax preferences dialog element.
         */haxPreferences:{type:Object},/**
         * Active HAX Element if we have one we are working on.
         */activeHaxElement:{type:Object},/**
         * Active Node.
         */activeNode:{type:Object},/**
         * Active container Node, 2nd highest parent of activeNode.
         */activeContainerNode:{type:Object},/**
         * Session object bridged in from a session method of some kind
         */sessionObject:{type:Object,value:{}},/**
         * editMode
         */editMode:{type:Boolean,value:!1,observer:"_editModeChanged"},/**
         * Boolean for if this instance has backends that support uploading
         */canSupportUploads:{type:Boolean,value:!1},/**
         * skip the exit trap to prevent losing data
         */skipExitTrap:{type:Boolean,value:!1},/**
         * Default settings that can be overridden as needed
         */defaults:{type:Object,value:{image:{src:"stock.jpg",alt:"A beachfront deep in the heart of Alaska."},iframe:{src:"https://www.wikipedia.org/"}}},/**
         * Available gizmos.
         */gizmoList:{type:Array,value:[]},/**
         * Available elements keyed by tagName and with
         * their haxProperties centrally registered.
         */elementList:{type:Object,value:{}},/**
         * Available apps of things supplying media / content.
         */appList:{type:Array,value:[]},/**
         * Available hax stax which are just re-usable templates
         */staxList:{type:Array,value:[]},/**
         * Available hax blox which are grid plate / layout elements
         */bloxList:{type:Array,value:[]},/**
         * Global preferences that HAX can write to and
         * other elements can use to go off of.
         */globalPreferences:{type:Object,value:{},observer:"_globalPreferencesChanged"},/**
         * Globally active app, used for brokering communications
         */activeApp:{type:Object,value:{}},/**
         * Valid tag list, tag only and including primatives for a baseline.
         */validTagList:{type:Array,value:["p","div","span","table","sup","sub","u","strike","tr","td","ol","ul","li","a","strong","kbd","em","i","b","hr","h1","h2","h3","h4","h5","h6","blockquote","code","figure","img","iframe","video","audio","section","grid-plate","template","webview"]},/**
         * Gizmo types which can be used to bridge apps to gizmos.
         */validGizmoTypes:{type:Array,value:["data","video","audio","text","link","file","pdf","image","csv","doc","content","text","inline","*"]},/**
         * Sandboxed environment test
         */_isSandboxed:{type:Boolean,value:function value(){var test=document.createElement("webview");// if this function exists it means that our deploy target
// is in a sandboxed environment and is not able to run iframe
// content with any real stability. This is beyond edge case but
// as this is an incredibly useful tag we want to make sure it
// can mutate to work in chromium and android environments
// which support such sandboxing
if("function"===typeof test.reload){return!0}return!1}},/**
         * Internal app store data property after request
         */__appStoreData:{type:Object},__ready:{type:Boolean},voiceCommands:{type:Object},/**
         * Support for deploy specific rewriting for things like JWTs
         */connectionRewrites:{type:Object,value:{}}},babelHelpers.get(babelHelpers.getPrototypeOf(HaxStore),"properties",this))}}]);function HaxStore(){var _this;babelHelpers.classCallCheck(this,HaxStore);_this=babelHelpers.possibleConstructorReturn(this,babelHelpers.getPrototypeOf(HaxStore).call(this));(0,_settings.setPassiveTouchGestures)(!0);new Promise(function(res,rej){return _require.default(["./hax-app.js"],res,rej)});new Promise(function(res,rej){return _require.default(["./hax-stax.js"],res,rej)});new Promise(function(res,rej){return _require.default(["./hax-stax-browser.js"],res,rej)});new Promise(function(res,rej){return _require.default(["./hax-blox.js"],res,rej)});new Promise(function(res,rej){return _require.default(["./hax-blox-browser.js"],res,rej)});// claim the instance spot. This way we can easily
// be referenced globally
if(null==window.HaxStore.instance){window.HaxStore.instance=babelHelpers.assertThisInitialized(_this)}_this.haxToast=window.SimpleToast.requestAvailability();// notice hax property definitions coming from anywhere
window.addEventListener("hax-register-properties",_this._haxStoreRegisterProperties.bind(babelHelpers.assertThisInitialized(_this)));// app registration can come in automatically from app-stores
// or through direct definition in the DOM
document.body.addEventListener("hax-register-app",_this._haxStoreRegisterApp.bind(babelHelpers.assertThisInitialized(_this)));// register stax which are groupings of haxElements
document.body.addEventListener("hax-register-stax",_this._haxStoreRegisterStax.bind(babelHelpers.assertThisInitialized(_this)));// register blox which are grid plate configurations
// with lots of sane visual defaults
document.body.addEventListener("hax-register-blox",_this._haxStoreRegisterBlox.bind(babelHelpers.assertThisInitialized(_this)));// register the pieces of the body of what we call HAX
// think of this like the core of the system required
// to do anything like have buttons or state management
// write data to the store
document.body.addEventListener("hax-store-write",_this._writeHaxStore.bind(babelHelpers.assertThisInitialized(_this)));// register the manager panel / modal
document.body.addEventListener("hax-register-manager",_this._haxStoreRegisterManager.bind(babelHelpers.assertThisInitialized(_this)));// register the autoloader area for elements
document.body.addEventListener("hax-register-autoloader",_this._haxStoreRegisterAutoloader.bind(babelHelpers.assertThisInitialized(_this)));// register a body, kind of a big deal
document.body.addEventListener("hax-register-body",_this._haxStoreRegisterBody.bind(babelHelpers.assertThisInitialized(_this)));// register the interaction panel / menu
document.body.addEventListener("hax-register-panel",_this._haxStoreRegisterPanel.bind(babelHelpers.assertThisInitialized(_this)));// register the app picker for contextual setting / option
document.body.addEventListener("hax-register-app-picker",_this._haxStoreRegisterAppPicker.bind(babelHelpers.assertThisInitialized(_this)));// stax modal
document.body.addEventListener("hax-register-stax-picker",_this._haxStoreRegisterStaxPicker.bind(babelHelpers.assertThisInitialized(_this)));// blox modal
document.body.addEventListener("hax-register-blox-picker",_this._haxStoreRegisterBloxPicker.bind(babelHelpers.assertThisInitialized(_this)));// preferences modal
document.body.addEventListener("hax-register-preferences",_this._haxStoreRegisterPreferences.bind(babelHelpers.assertThisInitialized(_this)));// export modal
document.body.addEventListener("hax-register-export",_this._haxStoreRegisterExport.bind(babelHelpers.assertThisInitialized(_this)));// grid plate add item event
document.body.addEventListener("grid-plate-add-item",_this.haxInsertAnything.bind(babelHelpers.assertThisInitialized(_this)));// notice content insert and help it along to the body
document.body.addEventListener("hax-insert-content",_this._haxStoreInsertContent.bind(babelHelpers.assertThisInitialized(_this)));document.body.addEventListener("hax-insert-content-array",_this._haxStoreInsertMultiple.bind(babelHelpers.assertThisInitialized(_this)));window.addEventListener("hax-add-voice-command",_this._addVoiceCommand.bind(babelHelpers.assertThisInitialized(_this)));document.body.style.setProperty("--hax-ui-headings","#d4ff77");return _this}/**
   * Build HAX property definitions for primitives that we support.
   */babelHelpers.createClass(HaxStore,[{key:"_buildPrimitiveDefinitions",value:function _buildPrimitiveDefinitions(){// sandboxes need a webview definition
// we don't want people making them but we need to
// know how to edit them if asked
if(window.HaxStore.instance._isSandboxed){var webview={canScale:!0,canPosition:!0,canEditSource:!1,settings:{quick:[{attribute:"src",title:"Source",description:"The URL for this video.",inputMethod:"textfield",icon:"link",required:!0,validationType:"url"}],configure:[{attribute:"src",title:"Source",description:"The URL for this video.",inputMethod:"textfield",icon:"link",required:!0,validationType:"url"}],advanced:[]}};this.setHaxProperties(webview,"webview")}var iframe={canScale:!0,canPosition:!0,canEditSource:!0,gizmo:{title:"Basic iframe",description:"A basic iframe",icon:"icons:fullscreen",color:"grey",groups:["Content"],handles:[{type:"link",source:"src",height:"height",width:"width"}],meta:{author:"W3C"}},settings:{quick:[{attribute:"src",title:"Source",description:"The URL for this video.",inputMethod:"textfield",icon:"link",required:!0,validationType:"url"}],configure:[{attribute:"src",title:"Source",description:"The URL for this video.",inputMethod:"textfield",icon:"link",required:!0,validationType:"url"}],advanced:[]}};this.setHaxProperties(iframe,"iframe");var img={canScale:!0,canPosition:!0,canEditSource:!1,gizmo:{title:"Image",description:"A basic img tag",icon:"image:image",color:"grey",groups:["Image","Media"],handles:[{type:"link",source:"src"},{type:"image",source:"src",height:"height",width:"width"}],meta:{author:"W3C"}},settings:{quick:[{attribute:"src",title:"Source",description:"The URL for this video.",inputMethod:"textfield",icon:"link",required:!0,validationType:"url"},{attribute:"alt",title:"Alt text",description:"Useful for screen readers and improved SEO.",inputMethod:"alt",icon:"accessibility"},{attribute:"height",title:"Height",description:"height in pixels of the item",inputMethod:"textfield",icon:"icons:swap-vert"},{attribute:"width",title:"Width",description:"width in pixels of the item",inputMethod:"textfield",icon:"icons:swap-horiz"}],configure:[{attribute:"src",title:"Source",description:"The URL for this video.",inputMethod:"haxupload",icon:"link",required:!0,validationType:"url"},{attribute:"alt",title:"Alt text",description:"Useful for screen readers and improved SEO.",inputMethod:"alt",icon:"accessibility"},{attribute:"height",title:"Height",description:"height in pixels of the item",inputMethod:"textfield",icon:"icons:swap-vert"},{attribute:"width",title:"Width",description:"width in pixels of the item",inputMethod:"textfield",icon:"icons:swap-horiz"}],advanced:[]}};this.setHaxProperties(img,"img");var ahref={canScale:!1,canPosition:!1,canEditSource:!0,gizmo:{title:"Basic link",description:"A basic a tag",icon:"icons:link",color:"grey",groups:["Link"],handles:[{type:"link",source:"href",title:"innerText",alt:"title"}],meta:{author:"W3C"}},settings:{quick:[{attribute:"href",title:"Link",description:"The URL for this video.",inputMethod:"textfield",icon:"icons:link",required:!0,validationType:"url"},{attribute:"title",title:"Title text",description:"Useful for screen readers and improved SEO.",inputMethod:"textfield",icon:"icons:accessibility"}],configure:[{attribute:"innerText",title:"Text",description:"Text of the link",inputMethod:"textfield",required:!0},{attribute:"href",title:"Link",description:"The URL for this video.",inputMethod:"haxupload",icon:"icons:link",required:!0,validationType:"url"},{attribute:"title",title:"Title text",description:"Useful for screen readers and improved SEO.",inputMethod:"textfield",icon:"icons:accessibility"},{attribute:"target",title:"Target",description:"Where to place the link.",inputMethod:"select",icon:"icons:launch",options:{"":"Same window",_blank:"New window",_top:"Top window",_parent:"Parent window"}}],advanced:[]}};this.setHaxProperties(ahref,"a");var p={canScale:!1,canPosition:!1,canEditSource:!0,gizmo:{title:"Paragraph",description:"A basic text area",icon:"editor:short-text",color:"grey",groups:["Text"],handles:[{type:"content",content:""}],meta:{author:"W3C"}},settings:{quick:[],configure:[{slot:"",title:"Content",description:"Internal content",inputMethod:"code-editor",icon:"icons:code"}],advanced:[]}};this.setHaxProperties(p,"p");var hr={canScale:!0,canPosition:!0,canEditSource:!1,settings:{quick:[],configure:[],advanced:[]}};this.setHaxProperties(hr,"hr");this.setHaxProperties(_codeSample.CodeSample.haxProperties,_codeSample.CodeSample.tag)}/**
   * Set the haxManager node so we can interface with it.
   * This also allows for using a different manager that supplies
   * the same functions if that would be desired at some point.
   */},{key:"_haxStoreRegisterManager",value:function _haxStoreRegisterManager(e){if(e.detail&&babelHelpers.typeof(this.haxManager)===("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){this.haxManager=e.detail}}/**
   * Register autoloader so we can ship to it from app-store spec
   */},{key:"_haxStoreRegisterAutoloader",value:function _haxStoreRegisterAutoloader(e){if(e.detail&&babelHelpers.typeof(this.haxAutoloader)===("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){this.haxAutoloader=e.detail}}/**
   * Set the appPicker node so we can interface with it.
   * This helps with picking between multiple options when we need the user
   * to decide between a sub-set of options
   */},{key:"_haxStoreRegisterAppPicker",value:function _haxStoreRegisterAppPicker(e){if(e.detail&&babelHelpers.typeof(this.haxAppPicker)===("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){this.haxAppPicker=e.detail}}/**
   * Set the stax picker so that we have an element in charge
   * of the listing of available stax.
   */},{key:"_haxStoreRegisterStaxPicker",value:function _haxStoreRegisterStaxPicker(e){if(e.detail&&babelHelpers.typeof(this.haxStaxPicker)===("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){this.haxStaxPicker=e.detail}}/**
   * Set the blox picker so that we have an element in charge
   * of the listing of available blox.
   */},{key:"_haxStoreRegisterBloxPicker",value:function _haxStoreRegisterBloxPicker(e){if(e.detail&&babelHelpers.typeof(this.haxBloxPicker)===("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){this.haxBloxPicker=e.detail}}/**
   * Close all drawers
   */},{key:"closeAllDrawers",value:function closeAllDrawers(){var active=0<arguments.length&&arguments[0]!==void 0?arguments[0]:!1,drawers=["haxManager","haxBloxPicker","haxStaxPicker","haxPreferences","haxExport"];for(var i in drawers){if(active===this[drawers[i]]){active.open();if("haxManager"===drawers[i]){setTimeout(function(){if(null!=active.querySelector("#activepage .iron-selected paper-input")){active.querySelector("#activepage .iron-selected paper-input").focus()}},325)}else{setTimeout(function(){if(null!=active.querySelector("paper-checkbox,paper-input,textarea,paper-button")){active.querySelector("paper-checkbox,paper-input,textarea,paper-button").focus()}},325)}}else{this[drawers[i]].close()}}}/**
   * Insert content in the body.
   */},{key:"_haxStoreInsertContent",value:function _haxStoreInsertContent(e){var _this6=this;if(e.detail){var details=e.detail;if(window.customElements.get(details.tag)){var prototype=Object.getPrototypeOf(document.createElement(details.tag));// support for deep API call to clean up special elements
if(babelHelpers.typeof(prototype.preProcessHaxInsertContent)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){details=prototype.preProcessHaxInsertContent(details)}}var properties={};// support for properties to be set automatically optionally
if(babelHelpers.typeof(details.properties)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){properties=details.properties}// support / clean up properties / attributes that have innerHTML / innerText
// these are reserved words but required for certain bindings
if(properties.innerHTML){if(""==details.content){details.content=properties.innerHTML}delete properties.innerHTML}if(properties.innerText){if(""==details.content){details.content=properties.innerText}delete properties.innerText}// ensure better UX for text based operations
this.activeHaxBody.__activeHover=null;// invoke insert or replacement on body, same function so it's easier to trace
if(details.replace&&details.replacement){var node=window.HaxStore.haxElementToNode(details.tag,details.content,properties);if(this.activePlaceHolder){this.activeHaxBody.haxReplaceNode(this.activePlaceHolder,node,this.activePlaceHolder.parentNode);this.activePlaceHolder=null}else{this.activeHaxBody.haxReplaceNode(this.activeNode,node,this.activeNode.parentNode)}}else if(babelHelpers.typeof(details.__type)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))&&"inline"===details.__type){var _node=window.HaxStore.haxElementToNode(details.tag,details.content,properties);// replace what WAS the active selection w/ this new node
if(null!==this.activePlaceHolder){this.activePlaceHolder.deleteContents();this.activePlaceHolder.insertNode(_node)}// set it to nothing
this.activePlaceHolder=null}else if(null!=this.activeContainerNode){var _node2=window.HaxStore.haxElementToNode(details.tag,details.content,properties);// allow for inserting things into things but not grid plate
if(this.activeContainerNode&&"GRID-PLATE"===this.activeContainerNode.tagName){// support slot if we have one on the activeNode (most likely)
if(null!=this.activeNode.getAttribute("slot")){_node2.setAttribute("slot",this.activeNode.getAttribute("slot"))}(0,_polymerDom.dom)(this.activeContainerNode).appendChild(_node2);this.activeHaxBody.$.textcontextmenu.highlightOps=!1;this.activeHaxBody.__updateLockFocus=_node2;// wait so that the DOM can have the node to then attach to
setTimeout(function(){_this6.activeHaxBody.breakUpdateLock()},50)}else{this.activeHaxBody.haxInsert(details.tag,details.content,properties)}}else{this.activeHaxBody.haxInsert(details.tag,details.content,properties)}}}/**
   * Present all elements to potentially insert
   */},{key:"haxInsertAnything",value:function haxInsertAnything(e){var haxElements=[];for(var i in window.HaxStore.instance.gizmoList){haxElements.push(window.HaxStore.haxElementPrototype(window.HaxStore.instance.gizmoList[i],e.detail.properties,""))}// hand off to hax-app-picker to deal with the rest of this
window.HaxStore.instance.haxAppPicker.presentOptions(haxElements,"element","Add an element","gizmo")}/**
   * Optional send array, to improve performance and event bubbling better
   */},{key:"_haxStoreInsertMultiple",value:function _haxStoreInsertMultiple(e){var _this7=this;if(e.detail){var properties;for(var i in e.detail){properties={};// support for properties to be set automatically optionally
if(babelHelpers.typeof(e.detail[i].properties)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){properties=e.detail[i].properties}this.activeHaxBody.haxInsert(e.detail[i].tag,e.detail[i].content,properties,!1)}setTimeout(function(){_this7.activeHaxBody.breakUpdateLock()},300)}}/**
   * Set the activeHaxBody and add to the list so we know what to insert into.
   */},{key:"_haxStoreRegisterBody",value:function _haxStoreRegisterBody(e){if(e.detail){this.haxBodies.push(e.detail);// default active the whatever is last here
this.activeHaxBody=e.detail;// needed so that higher order things can respond to us having a body
window.HaxStore.write("activeHaxBody",this.activeHaxBody,this);window.HaxStore.write("editMode",this.editMode,this)}}/**
   * Set the haxPanel so we know what to insert into.
   */},{key:"_haxStoreRegisterPanel",value:function _haxStoreRegisterPanel(e){if(e.detail&&babelHelpers.typeof(this.haxPanel)===("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){this.haxPanel=e.detail}}/**
   * Set the haxExport so we know who to call for exporting
   */},{key:"_haxStoreRegisterExport",value:function _haxStoreRegisterExport(e){if(e.detail&&babelHelpers.typeof(this.haxExport)===("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){this.haxExport=e.detail}}/**
   * Set the haxPreferences so we know what has global preferences
   */},{key:"_haxStoreRegisterPreferences",value:function _haxStoreRegisterPreferences(e){if(e.detail&&babelHelpers.typeof(this.haxPreferences)===("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){this.haxPreferences=e.detail}}/**
   * Feature detect on the bar.
   */},{key:"computePolyfillSafe",value:function computePolyfillSafe(){/**
     * These are our bad actors in polyfill'ed browsers.
     * This means that https://github.com/webcomponents/webcomponentsjs/commit/ce464bb533bf39b544c312906499a6044ee0d30d
     * explains things but basically if shadow-dom is polyfilled
     * then we can't safely execute a DOM manipulating execCommand.
     * This
     */if(document.head.createShadowRoot||document.head.attachShadow){return!0}else{console.log("Shadow DOM missing, certain operations hidden");return!1}}/**
   * Write store event callback.
   */},{key:"_writeHaxStore",value:function _writeHaxStore(e){// ensure we have a valid store write
if(e.detail&&babelHelpers.typeof(e.detail.value)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))&&e.detail.property&&e.detail.owner){if("object"===babelHelpers.typeof(e.detail.value)){this.set(e.detail.property,{})}this.set(e.detail.property,e.detail.value);this.dispatchEvent(new CustomEvent("hax-store-property-updated",{bubbles:!0,composed:!0,cancelable:!1,detail:{property:e.detail.property,value:e.detail.value,owner:e.detail.owner}}))}}/**
   * Notice that an app was set in HAX; register it
   */},{key:"_haxStoreRegisterApp",value:function _haxStoreRegisterApp(e){if(e.detail){e.detail.index=this.appList.length;this.push("appList",e.detail);window.HaxStore.write("appList",this.appList,this);// preconnect apps at registration time
if(e.detail.connection&&e.detail.connection.protocol&&e.detail.connection.url){var preconnectlink=document.createElement("link");preconnectlink.rel="preconnect";preconnectlink.href=e.detail.connection.protocol+"://"+e.detail.connection.url;document.head.appendChild(preconnectlink)}// we don't care about this after it's launched
if(babelHelpers.typeof(e.target.parentElement)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))&&"HAX-STORE"===e.target.parentElement.tagName){(0,_polymerDom.dom)(e.target.parentElement).removeChild(e.target)}}}/**
   * Notice that a stax was set in HAX; register it
   */},{key:"_haxStoreRegisterStax",value:function _haxStoreRegisterStax(e){if(e.detail){e.detail.index=this.staxList.length;this.push("staxList",e.detail);window.HaxStore.write("staxList",this.staxList,this);// we don't care about this after it's launched
if(babelHelpers.typeof(e.target.parentElement)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))&&"HAX-STORE"===e.target.parentElement.tagName){(0,_polymerDom.dom)(e.target.parentElement).removeChild(e.target)}}}/**
   * Notice that a blox was set in HAX; register it
   */},{key:"_haxStoreRegisterBlox",value:function _haxStoreRegisterBlox(e){if(e.detail){e.detail.index=this.bloxList.length;this.push("bloxList",e.detail);window.HaxStore.write("bloxList",this.bloxList,this);// we don't care about this after it's launched
if(babelHelpers.typeof(e.target.parentElement)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))&&"HAX-STORE"===e.target.parentElement.tagName){(0,_polymerDom.dom)(e.target.parentElement).removeChild(e.target)}}}/**
   * Notice that a property off an element was set in HAX some place; register it here
   */},{key:"_haxStoreRegisterProperties",value:function _haxStoreRegisterProperties(e){if(e.detail&&e.detail.properties&&e.detail.tag){// only register tag if we don't know about it already
if(babelHelpers.typeof(this.elementList[e.detail.tag])===("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){// look for a gizmo; it's not required, technically.
var gizmo=e.detail.properties.gizmo;if(gizmo){gizmo.tag=e.detail.tag;var gizmos=this.gizmoList;gizmos.push(gizmo);window.HaxStore.write("gizmoList",gizmos,this)}this.set("elementList."+e.detail.tag,e.detail.properties);// only push new values on if we got something new
if(!this.validTagList.find(function(element){return element===e.detail.tag})){this.push("validTagList",e.detail.tag)}}// delete this tag if it was in the autoloader as it has served it's purpose.
if(babelHelpers.typeof(e.target.parentElement)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))&&"HAX-AUTOLOADER"===e.target.parentElement.tagName){(0,_polymerDom.dom)(this.haxAutoloader).removeChild(e.target)}}}}]);return HaxStore}((0,_haxBodyBehaviors.HAXElement)((0,_mediaBehaviors.MediaBehaviorsVideo)(_polymerElement.PolymerElement)));/**
 * Trick to write the store to the DOM if it wasn't there already.
 * This is not used yet but could be if you wanted to dynamically
 * load the store based on something else calling for it. Like
 * store lazy loading but it isn't tested.
 */_exports.HaxStore=HaxStore;window.HaxStore=window.HaxStore||{};window.HaxStore.instance=null;window.HaxStore.requestAvailability=function(){if(!window.HaxStore.instance){window.HaxStore.instance=document.createElement("hax-store");document.body.appendChild(window.HaxStore.instance)}return window.HaxStore.instance};/**
 * Simple Array smashing function to ensure Object is array.
 */window.HaxStore.toArray=function(obj){return Object.keys(obj).map(function(key){return obj[key]})};/**
 * Helper to convert camel case to dash; important when setting attributes.
 */window.HaxStore.camelToDash=function(str){return str.replace(/\W+/g,"-").replace(/([a-z\d])([A-Z])/g,"$1-$2").toLowerCase()};/**
 * Helper to convert dash to camel; important when reading attributes.
 */window.HaxStore.dashToCamel=function(str){return str.replace(/-([a-z])/g,function(g){return g[1].toUpperCase()})};/**
 * Convert HTML into HAX Elements
 */window.HaxStore.htmlToHaxElements=function(html){var elements=[],validTags=window.HaxStore.instance.validTagList,fragment=document.createElement("div");fragment.innerHTML=html;// loop over the new nodes
for(var children=fragment.childNodes,i=0;i<children.length;i++){// verify this tag is a valid one
if(babelHelpers.typeof(children[i].tagName)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))&&validTags.includes(children[i].tagName.toLowerCase())){elements.push(window.HaxStore.nodeToHaxElement(children[i],null))}}return elements};/**
 * Convert a node to a HAX element. Hax elements ensure
 * a certain level of sanitization by verifying tags and
 * properties / attributes that have values.
 */window.HaxStore.nodeToHaxElement=function(node){var eventName=1<arguments.length&&arguments[1]!==void 0?arguments[1]:"insert-element";if(!node){return null}// build out the properties to send along
var props={};// support basic styles
if(babelHelpers.typeof(node.style)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){props.style=node.getAttribute("style")}// don't set a null style
if(null===props.style||"null"===props.style){delete props.style}// test if a class exists, not everything scopes
if(babelHelpers.typeof(node.attributes.class)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){props.class=node.attributes.class.nodeValue.replace("hax-active","")}// test if a id exists as its a special case in attributes... of course
if(babelHelpers.typeof(node.attributes.id)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){props.id=node.getAttribute("id")}var tmpProps;// relatively cross library
if(customElements.get(node.tagName.toLowerCase())){tmpProps=customElements.get(node.tagName.toLowerCase()).properties}// weak fallback
if(babelHelpers.typeof(tmpProps)===("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){tmpProps=node.__data}// complex elements need complex support
if(babelHelpers.typeof(tmpProps)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){// run through attributes, though non-reflected props won't be here
// run through props, we always defer to property values
for(var property in tmpProps){// make sure we only set things that have a value
if("class"!=property&&"style"!=property&&tmpProps.hasOwnProperty(property)&&babelHelpers.typeof(node[property])!==void 0&&null!=node[property]&&""!=node[property]){props[property]=node[property]}// special support for false boolean
else if(!1===node[property]){props[property]=node[property]}else{}}for(var attribute in node.attributes){// make sure we only set things that have a value
if(babelHelpers.typeof(node.attributes[attribute].name)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))&&"class"!=node.attributes[attribute].name&&"style"!=node.attributes[attribute].name&&"id"!=node.attributes[attribute].name&&node.attributes.hasOwnProperty(attribute)&&babelHelpers.typeof(node.attributes[attribute].value)!==void 0&&null!=node.attributes[attribute].value&&""!=node.attributes[attribute].value&&!tmpProps.hasOwnProperty(window.HaxStore.dashToCamel(node.attributes[attribute].name))){props[window.HaxStore.dashToCamel(node.attributes[attribute].name)]=node.attributes[attribute].value}else{// note: debug here if experiencing attributes that won't bind
}}}else{// much easier case, usually just in primatives
for(var attribute in node.attributes){// make sure we only set things that have a value
if(babelHelpers.typeof(node.attributes[attribute].name)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))&&"class"!=node.attributes[attribute].name&&"style"!=node.attributes[attribute].name&&"id"!=node.attributes[attribute].name&&node.attributes.hasOwnProperty(attribute)&&babelHelpers.typeof(node.attributes[attribute].value)!==void 0&&null!=node.attributes[attribute].value&&""!=node.attributes[attribute].value){props[window.HaxStore.dashToCamel(node.attributes[attribute].name)]=node.attributes[attribute].value}}}// support sandboxed environments which
// will hate iframe tags but love webview
var tag=node.tagName.toLowerCase();if(window.HaxStore.instance._isSandboxed&&"iframe"===tag){tag="webview"}var slotContent=window.HaxStore.getHAXSlot(node);// support fallback on inner text if there were no nodes
if(""==slotContent){slotContent=node.innerText}// special edge case for slot binding in primatives
if("a"===tag){props.innerText=slotContent}else if("p"===tag||"ol"===tag||"ul"===tag||"div"===tag){props.innerHTML=slotContent}var element={tag:tag,properties:props,content:slotContent};if(null!==eventName){element.eventName=eventName}return element};/**
 * Convert a haxElement to a DOM node.
 */window.HaxStore.haxElementToNode=function(tag,content,properties){// support sandboxed environments which
// will hate iframe tags but love webview
if(window.HaxStore.instance._isSandboxed&&"iframe"===tag){tag="webview"}var frag=document.createElement(tag);frag.innerHTML=content;// clone the fragment which will force an escalation to full node
var newNode=frag.cloneNode(!0);// support for properties if they exist
for(var property in properties){var attributeName=window.HaxStore.camelToDash(property);if(properties.hasOwnProperty(property)){// special supporting for boolean because html is weird :p
if(!0===properties[property]){newNode.setAttribute(attributeName,properties[property])}else if(!1===properties[property]){newNode.removeAttribute(attributeName)}else if(null!=properties[property]&&properties[property].constructor===Array){// do nothing if we have additional data to suggest this is actually readOnly
// polymer / typed specific thing
if(frag.properties&&frag.properties[property]&&frag.properties[property].readOnly){}else{newNode.set(attributeName,properties[property])}}else if(null!=properties[property]&&properties[property].constructor===Object){// do nothing if we have additional data to suggest this is actually readOnly
// polymer / typed specific thing
if(frag.properties&&frag.properties[property]&&frag.properties[property].readOnly){}else{newNode.set(attributeName,properties[property])}}else{newNode.setAttribute(attributeName,properties[property])}}}return newNode};/**
 * Convert a node to the correct content object for saving.
 * This DOES NOT acccept a HAXElement which is similar
 */window.HaxStore.nodeToContent=function(node){if(window.HaxStore.instance.activeHaxBody.globalPreferences.haxDeveloperMode){console.log(node)}// ensure we have access to all the member functions of the custom element
var prototype=Object.getPrototypeOf(node);// support for deep API call
if(babelHelpers.typeof(prototype.preProcessHaxNodeToContent)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){var clone=node.cloneNode(!0);node=prototype.preProcessHaxNodeToContent(clone)}var tag=node.tagName.toLowerCase();// support sandboxed environments which
// will hate iframe tags but love webview
if(window.HaxStore.instance._isSandboxed&&"webview"===tag){tag="iframe"}var content="";// start to rebuild the same tag we got in a generalized way
content+="<"+tag;// account for things that say NOT to save slot values
// grab all of the original's attributes, and pass them to the replacement
for(var props=window.HaxStore.instance.elementList[tag],propvals={},j=0,l=node.attributes.length;j<l;++j){var nodeName=node.attributes.item(j).nodeName,value=node.attributes.item(j).value;// encode objects and arrays because they are special
if("style"!=nodeName&&(babelHelpers.typeof(value)===("undefined"===typeof Object?"undefined":babelHelpers.typeof(Object))||value.constructor===Array)){propvals[nodeName]=JSON.stringify(value).replace(/"/g,"&quot;")}// only write things that aren't empty
else if(null!=value&&"null"!=value){if(!0===value||"true"===value){propvals[nodeName]=!0}else if(!1===value){// do nothing, no reason to record false unless written as text
// in which case below will capture it
}else{// ensure that value doesn't have " in it unencoded
if("string"===typeof value&&""!==value){value=value.replace(/"/g,"&quot;");propvals[nodeName]=value}// special handling for empty string cause it might mean boolean
// or it might be a string
else if(""===value){if(""==value&&""!=node.attributes.item(j).value){value=node.attributes.item(j).value}propvals[nodeName]=value}else{propvals[nodeName]=value}}}}// now look through properties
var tmpProps;// relatively cross library
if(customElements.get(tag)){tmpProps=customElements.get(tag).properties}// weak fallback
if(babelHelpers.typeof(tmpProps)===("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){tmpProps=node.__data}if(babelHelpers.typeof(tmpProps)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){for(var j in tmpProps){var nodeName=window.HaxStore.camelToDash(j),value=null;// prefer local value over properties object if possible
if(babelHelpers.typeof(node[j])!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){value=node[j]}// never allow read only things to recorded as they
// are run-time creation 99% of the time
// this is very polymer specific but it allows readOnly and computed props
if(!tmpProps[j].readOnly&&!tmpProps[j].computed&&value!==tmpProps[j].value){// encode objects and arrays because they are special
if(null!=value&&(babelHelpers.typeof(value)===("undefined"===typeof Object?"undefined":babelHelpers.typeof(Object))||value.constructor===Array)){propvals[nodeName]=JSON.stringify(value).replace(/"/g,"&quot;")}// only write things that aren't empty
else if(null!=value&&"null"!=value){if(!0===value||"true"===value){propvals[nodeName]=!0}else if(!1===value){// do nothing, no reason to record false unless written as text
// in which case below will capture it
}else{// ensure that value doesn't have " in it unencoded
if("string"===typeof value&&""!==value){value=value.replace(/"/g,"&quot;");propvals[nodeName]=value}// special handling for empty string cause it might mean boolean
// or it might be a string
else if(""===value){if(""==value&&""!=tmpProps[j].value){value=tmpProps[j].value}else if(""===value&&""==tmpProps[j].value){// do nothing, the default value is empty
// so lets record less data
}}else{propvals[nodeName]=value}}}}}}// support for tag defining which properties NOT to save
// for simplification, everything is an attribute during this
// operation
if(babelHelpers.typeof(props)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))&&babelHelpers.typeof(props.saveOptions.unsetAttributes)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){for(var i in props.saveOptions.unsetAttributes){delete propvals[props.saveOptions.unsetAttributes[i]]}}// specialized clean up for some that can leak through from above
// and are edge case things because #hashtag gotta love HTML attributes
// and the webview tag. facepalm.
var delProps=["inner-text","inner-html","tabindex","guestinstance"];for(var delProp in delProps){if(babelHelpers.typeof(propvals[delProps[delProp]])!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){delete propvals[delProps[delProp]]}}// remove id attribute if it's empty, somehow misses above
if(babelHelpers.typeof(propvals.id)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))&&""===propvals.id){delete propvals.id}// run through the properties
for(var i in propvals){if(!0===propvals[i]){content+=" "+i}else{content+=" "+i+"=\""+propvals[i]+"\""}}// set the opening tag, support self-closing void tags
var voidTags=["area","base","br","col","embed","hr","img","input","keygen","link","meta","param","source","track","wbr"];if(voidTags.includes(tag)){content+="/>"}else{content+=">"}// try and work against anything NOT a P tag
if(babelHelpers.typeof(props)===("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))||!props.saveOptions.wipeSlot){// get content that is in the slots
var slotnodes=(0,_polymerDom.dom)(node).getEffectiveChildNodes();// ensure there's something inside of this
if(0<slotnodes.length){// loop through everything found in the slotted area and put it back in
for(var j=0,len2=slotnodes.length;j<len2;j++){if(babelHelpers.typeof(slotnodes[j].tagName)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){// if we're a custom element, keep digging, otherwise a simple
// self append is fine unless template tag cause it's a special
// case for the web in general as it'll register as not a primative
// even though it is...
if(!window.HaxStore.HTMLPrimativeTest(slotnodes[j].tagName)&&"TEMPLATE"!==slotnodes[j].tagName){content+=window.HaxStore.nodeToContent(slotnodes[j])}else{slotnodes[j].setAttribute("data-editable",!1);slotnodes[j].removeAttribute("data-hax-ray");slotnodes[j].contentEditable=!1;content+=slotnodes[j].outerHTML}}// keep comments with a special case since they need wrapped
else if(8===slotnodes[j].nodeType){content+="<!-- "+slotnodes[j].textContent+" -->"}// keep everything NOT an element at this point, this helps
// preserve whitespace because we're crazy about accuracy
else if(1!==slotnodes[j].nodeType&&babelHelpers.typeof(slotnodes[j].textContent)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))&&"undefined"!==slotnodes[j].textContent){content+=slotnodes[j].textContent}}}}// don't put return for span since it's an inline tag
if("span"===tag){content+="</"+tag+">"}else if("hr"===tag||"br"===tag||"img"===tag){}// do nothing for self-closing tags they'll resolve themselves
// close the tag, placing a return in output for block elements
else{content+="</"+tag+">"+"\n"}if(window.HaxStore.instance.activeHaxBody.globalPreferences.haxDeveloperMode){console.log(content)}// support postProcess text rewriting for the node that's been
// converted to a string for storage
if("function"===node.postProcesshaxNodeToContent){content=node.postProcesshaxNodeToContent(content)}return content};/**
 * Basic HTML Primitives test
 */window.HaxStore.HTMLPrimativeTest=function(node){if(babelHelpers.typeof(node.tagName)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))&&-1==node.tagName.indexOf("-")){return!0}return!1};/**
 * Slot content w/ support for custom elements in slot.
 */window.HaxStore.getHAXSlot=function(node){// we can skip all of this if we have a text element / HTML prim!
if(window.HaxStore.instance.isTextElement(node)){return node.innerHTML}var content="",slotnodes=(0,_polymerDom.dom)(node).children;// ensure there's something inside of this
if(0<slotnodes.length){// loop through everything found in the slotted area and put it back in
for(var j=0,len2=slotnodes.length;j<len2;j++){if(babelHelpers.typeof(slotnodes[j].tagName)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){// if we're a custom element, keep digging, otherwise a simple
// self append is fine.
if(0<slotnodes[j].tagName.indexOf("-")){content+="  "+window.HaxStore.nodeToContent(slotnodes[j])+"\n"}else{content+="  "+slotnodes[j].outerHTML+"\n"}}// keep comments with a special case since they need wrapped
else if(8===slotnodes[j].nodeType){content+="<!-- "+slotnodes[j].textContent+" -->"}// keep everything NOT an element at this point, this helps
// preserve whitespace because we're crazy about accuracy
else if(1!==slotnodes[j].nodeType&&babelHelpers.typeof(slotnodes[j].textContent)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))&&"undefined"!==slotnodes[j].textContent){content+=slotnodes[j].textContent}}}return content};/**
 * Shortcut to standardize the write / read process.
 */window.HaxStore.write=function(prop,value,obj){obj.dispatchEvent(new CustomEvent("hax-store-write",{composed:!0,bubbles:!0,cancelable:!1,detail:{property:prop,value:value,owner:obj}}))};/**
 * Guess the type of Gizmo when given some information about what we have.
 */window.HaxStore.guessGizmoType=function(guess){if(babelHelpers.typeof(guess.source)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){if(-1!=guess.source.indexOf(".mp3")){return"audio"}else if(-1!=guess.source.indexOf(".png")||-1!=guess.source.indexOf(".jpg")||-1!=guess.source.indexOf(".jpeg")||-1!=guess.source.indexOf(".gif")){return"image"}else if(-1!=guess.source.indexOf(".pdf")){return"pdf"}else if(-1!=guess.source.indexOf(".svg")){return"svg"}else if(-1!=guess.source.indexOf(".csv")){return"csv"}// if it's external we can't assume what it actually is
else if("external"!=window.HaxStore.instance.getVideoType(guess.source)){return"video"}else{// we don't know how to handle this so let's just
// try ANYTHING that matches
return"*"}}};/**
 * Try and guess the Gizmo based on what we were just handed
 */window.HaxStore.guessGizmo=function(guess,values){var skipPropMatch=2<arguments.length&&arguments[2]!==void 0?arguments[2]:!1,matches=[];if(babelHelpers.typeof(guess)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){var store=window.HaxStore.instance;// verify type
if(store.validGizmoTypes.includes(guess)){// now we can look through them
// look for a match
for(var gizmoposition in store.gizmoList){var gizmo=store.gizmoList[gizmoposition],props={},match=!1;if(gizmo.handles){for(var i=0;i<gizmo.handles.length;i++){// WHAT!??!?!?!?!
if(guess===gizmo.handles[i].type||"*"===guess&&!match){for(var property in gizmo.handles[i]){// ignore type.. but again.. WHAT?!?!?!
if("type"!==property){// check the values that came across to see if there's a match
// of any kind, we only need one but can then bind to multiple
if(babelHelpers.typeof(values[property])!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){match=!0;props[gizmo.handles[i][property]]=values[property]}}}// omg... we just found a match on a property from who knows where!
if(match||skipPropMatch){matches.push(window.HaxStore.haxElementPrototype(gizmo,props,""))}}}}}}}return matches};/**
 * Filter app store apps to those that accept this file source.
 */window.HaxStore.getHaxAppStoreTargets=function(type){var targets=window.HaxStore.instance.appList.filter(function(app){if(babelHelpers.typeof(app.connection.operations.add)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){var add=app.connection.operations.add;if(babelHelpers.typeof(add.acceptsGizmoTypes)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))&&add.acceptsGizmoTypes.includes(type)){return!0}}return!1});return targets};/**
 * Generate Hax Element prototype.
 */window.HaxStore.haxElementPrototype=function(gizmo,properties){var content=2<arguments.length&&arguments[2]!==void 0?arguments[2]:"";return{tag:gizmo.tag,properties:properties,content:content,gizmo:gizmo}};/**
 * Wipe out the slot of an element.
 */window.HaxStore.wipeSlot=function(element){var slot=1<arguments.length&&arguments[1]!==void 0?arguments[1]:"";(0,_haxutils.wipeSlot)(element,slot)};/**
 * HTML encapsulation of a string on script and style tags
 */window.HaxStore.encapScript=function(html){return(0,_haxutils.encapScript)(html)};/**
 * Global toast bridge so we don't have to keep writing custom event
 */window.HaxStore.toast=function(message){var duration=1<arguments.length&&arguments[1]!==void 0?arguments[1]:4e3,classStyle=2<arguments.length&&arguments[2]!==void 0?arguments[2]:"",closeText=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null,eventCallback=4<arguments.length&&arguments[4]!==void 0?arguments[4]:null,evt=new CustomEvent("simple-toast-show",{bubbles:!0,composed:!0,cancelable:!0,detail:{text:message,duration:duration,classStyle:classStyle,closeText:closeText,eventCallback:eventCallback}});window.dispatchEvent(evt)};/**
 * Selection normalizer
 */window.HaxStore.getSelection=function(){// try and obtain the selection from the nearest shadow
// which would give us the selection object when running native ShadowDOM
// with fallback support for the entire window which would imply Shady
if(window.HaxStore.instance.activeHaxBody.parentNode){// native API
if(window.HaxStore.instance.activeHaxBody.parentNode.getSelection){return window.HaxStore.instance.activeHaxBody.parentNode.getSelection()}// ponyfill from google
else if((0,_shadowsSafari.getRange)(window.HaxStore.instance.activeHaxBody.parentNode)){return(0,_shadowsSafari.getRange)(window.HaxStore.instance.activeHaxBody.parentNode)}}// missed on both, hope the normal one will work
return window.getSelection()};/**
 * Get a normalized range based on current selection
 */window.HaxStore.getRange=function(){var sel=window.HaxStore.getSelection();if(sel.getRangeAt&&sel.rangeCount){return sel.getRangeAt(0)}else if(sel){return sel}else!1};window.customElements.define(HaxStore.tag,HaxStore)});