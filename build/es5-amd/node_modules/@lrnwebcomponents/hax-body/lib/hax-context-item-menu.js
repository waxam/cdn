define(["exports", "require", "../../../@polymer/polymer/polymer-element.js", "../../../@polymer/polymer/lib/legacy/polymer.dom.js", "./hax-shared-styles.js"], function (_exports, _require, _polymerElement, _polymerDom, _haxSharedStyles) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.HaxContextItemMenu = void 0;
  _require = babelHelpers.interopRequireWildcard(_require);

  function _templateObject_7a216d60b54611e9b6ba27231b6f684a() {
    var data = babelHelpers.taggedTemplateLiteral(["\n      <style include=\"hax-shared-styles\">\n        :host {\n          display: inline-flex;\n          height: 36px;\n          box-sizing: border-box;\n        }\n        :host hax-toolbar-menu ::slotted(*):hover {\n          background-color: var(--hax-color-bg-accent);\n        }\n        :host hax-toolbar-menu ::slotted(*) {\n          height: 36px;\n        }\n      </style>\n      <hax-toolbar-menu\n        id=\"menu\"\n        icon=\"[[icon]]\"\n        tooltip=\"[[label]]\"\n        tooltip-direction=\"[[direction]]\"\n        selected=\"{{selectedValue}}\"\n        reset-on-select=\"[[resetOnSelect]]\"\n      >\n        <slot></slot>\n      </hax-toolbar-menu>\n    "]);

    _templateObject_7a216d60b54611e9b6ba27231b6f684a = function _templateObject_7a216d60b54611e9b6ba27231b6f684a() {
      return data;
    };

    return data;
  }

  /**
   * `hax-context-item-menu`
   * `An icon / button that has support for multiple options via drop down.`
   * @microcopy - the mental model for this element
   * - panel - the flyout from left or right side that has elements that can be placed
   * - button - an item that expresses what interaction you will have with the content.
   */
  var HaxContextItemMenu =
  /*#__PURE__*/
  function (_PolymerElement) {
    babelHelpers.inherits(HaxContextItemMenu, _PolymerElement);

    function HaxContextItemMenu() {
      var _this;

      babelHelpers.classCallCheck(this, HaxContextItemMenu);
      _this = babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(HaxContextItemMenu).call(this));
      new Promise(function (res, rej) {
        return _require.default(["./hax-toolbar-menu.js"], res, rej);
      });
      new Promise(function (res, rej) {
        return _require.default(["../../../@polymer/paper-tooltip/paper-tooltip.js"], res, rej);
      });
      new Promise(function (res, rej) {
        return _require.default(["../../../@polymer/paper-item/paper-item.js"], res, rej);
      });
      new Promise(function (res, rej) {
        return _require.default(["../../../@polymer/neon-animation/neon-animation.js"], res, rej);
      });
      return _this;
    }

    babelHelpers.createClass(HaxContextItemMenu, [{
      key: "_selectedUpdated",

      /**
       * Notice the selected value has changed.
       */
      value: function _selectedUpdated(newValue, oldValue) {
        if (babelHelpers.typeof(newValue) !== babelHelpers.typeof(null) && babelHelpers.typeof(oldValue) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && babelHelpers.typeof(oldValue) !== babelHelpers.typeof(null)) {
          var children = (0, _polymerDom.dom)(this).children;
          var item = new Object();
          var j = 0; // check for tag match since we have to filter out text nodes

          for (var i = 0, len = children.length; i < len; i++) {
            if (children[i].tagName === "PAPER-ITEM") {
              if (j === newValue) {
                item = children[i];
                len = i;
                continue;
              }

              j++;
            }
          } // ensure we have a value; if so, this becomes the event to look for
          // also use our flag to ensure machine setting the tag default doesn't
          // equate to firing off a selected event.


          if (!this._blockEvent && babelHelpers.typeof(item.attributes) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && babelHelpers.typeof(item.attributes.value) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && babelHelpers.typeof(item.attributes.value.value) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
            // weird but this makes the menu close when we send up an event
            // that indicates something higher should do something. This
            // avoids an annoying UX error where the menu stays open for
            // no reason.
            this.shadowRoot.querySelector("#menu").hideMenu();
            this.dispatchEvent(new CustomEvent("hax-context-item-selected", {
              bubbles: true,
              cancelable: true,
              composed: true,
              detail: {
                target: item,
                eventName: item.attributes.value.value
              }
            }));
          } // we only block 1 time if it's available


          if (this._blockEvent) {
            this._blockEvent = false;
          }
        }
      }
    }], [{
      key: "template",
      get: function get() {
        return (0, _polymerElement.html)(_templateObject_7a216d60b54611e9b6ba27231b6f684a());
      }
    }, {
      key: "tag",
      get: function get() {
        return "hax-context-item-menu";
      }
    }, {
      key: "properties",
      get: function get() {
        return {
          /**
           * Internal flag to allow blocking the event firing if machine selects tag.
           */
          _blockEvent: {
            type: Boolean,
            value: false
          },

          /**
           * Should we reset the selection after it is made
           */
          resetOnSelect: {
            type: Boolean,
            value: false
          },

          /**
           * Value.
           */
          selectedValue: {
            type: Number,
            reflectToAttribute: true,
            notify: true,
            value: 0,
            observer: "_selectedUpdated"
          },

          /**
           * Direction for the tooltip
           */
          direction: {
            type: String,
            value: "top"
          },

          /**
           * Icon for the button.
           */
          icon: {
            type: String,
            value: "editor:text-fields",
            reflectToAttribute: true
          },

          /**
           * Label for the button.
           */
          label: {
            type: String,
            value: "editor:text-fields",
            reflectToAttribute: true
          },

          /**
           * Name of the event to bubble up as being tapped.
           * This can be used to tell other elements what was
           * clicked so it can take action appropriately.
           */
          eventName: {
            type: String,
            value: "button",
            reflectToAttribute: true
          }
        };
      }
    }]);
    return HaxContextItemMenu;
  }(_polymerElement.PolymerElement);

  _exports.HaxContextItemMenu = HaxContextItemMenu;
  window.customElements.define(HaxContextItemMenu.tag, HaxContextItemMenu);
});