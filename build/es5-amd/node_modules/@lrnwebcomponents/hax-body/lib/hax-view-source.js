define(["exports", "require", "../../../lit/index.js", "../../dl-behavior/dl-behavior.js", "../../utils/utils.js", "./hax-store.js", "./hax-toolbar.js", "./hax-ui-styles.js", "../../../mobx/dist/mobx.esm.js", "../../i18n-manager/lib/I18NMixin.js"], function (_exports, _require, _index, _dlBehavior, _utils, _haxStore, _haxToolbar, _haxUiStyles, _mobxEsm, _I18NMixin2) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.HaxViewSource = void 0;
  _require = _interopRequireWildcard(_require);

  var _templateObject_f377ed60feb911eb8439e3eec9305af7, _templateObject2_f377ed60feb911eb8439e3eec9305af7;

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || babelHelpers.typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  /**
   * `hax-eview-source`
   * @element hax-eview-source
   * `Export dialog with all export options and settings provided.`
   */
  var HaxViewSource = /*#__PURE__*/function (_I18NMixin) {
    babelHelpers.inherits(HaxViewSource, _I18NMixin);

    var _super = _createSuper(HaxViewSource);

    function HaxViewSource() {
      var _this$t;

      var _this;

      babelHelpers.classCallCheck(this, HaxViewSource);
      _this = _super.call(this);
      _this.t = (_this$t = {
        updatePage: "Update",
        updatePageTooltip: "Update Page HTML",
        copyHTML: "Copy",
        copyHTMLTooltip: "Copy HTML",
        downloadHTML: "Download",
        downloadHTMLTooltip: "Download HTML",
        cleanFormatting: "Clean",
        cleanFormattingTooltip: "Clean HTML Formatting"
      }, babelHelpers.defineProperty(_this$t, "cleanFormatting", "Clean"), babelHelpers.defineProperty(_this$t, "schema", "Schema"), babelHelpers.defineProperty(_this$t, "schemaTooltip", "HAX Schema"), _this$t);

      _this.registerLocalization({
        context: babelHelpers.assertThisInitialized(_this),
        namespace: "hax"
      });

      _this.fileTypes = {
        CSV: "text/csv",
        JSON: "text/json",
        PDF: "application/pdf",
        TXT: "text/plain",
        HTML: "text/html"
      };
      (0, _mobxEsm.autorun)(function () {
        _this.globalPreferences = (0, _mobxEsm.toJS)(_haxStore.HAXStore.globalPreferences);
        _this.haxUiTheme = (_this.globalPreferences || {}).haxUiTheme || "hax";
      });
      return _this;
    }

    babelHelpers.createClass(HaxViewSource, [{
      key: "render",
      value: function render() {
        return (0, _index.html)(_templateObject_f377ed60feb911eb8439e3eec9305af7 || (_templateObject_f377ed60feb911eb8439e3eec9305af7 = babelHelpers.taggedTemplateLiteral(["\n      <div id=\"wrapper\">\n        <div id=\"spacer\"></div>\n        <textarea id=\"hiddentextarea\" hidden></textarea>\n        <code-editor\n          id=\"textarea\"\n          theme=\"", "\"\n          language=\"html\"\n          font-size=\"13\"\n          word-wrap\n        ></code-editor>\n      </div>\n      <hax-toolbar always-expanded>\n        <hax-tray-button\n          label=\"", "\"\n          tooltip=\"", "\"\n          icon=\"editor:insert-drive-file\"\n          @click=\"", "\"\n          show-text-label\n          icon-position=\"top\"\n        >\n        </hax-tray-button>\n        <hax-tray-button\n          @click=\"", "\"\n          icon=\"editor:format-clear\"\n          label=\"", "\"\n          tooltip=\"", "\"\n          show-text-label\n          icon-position=\"top\"\n        >\n        </hax-tray-button>\n        <hax-tray-button\n          @click=\"", "\"\n          icon=\"icons:content-copy\"\n          label=\"", "\"\n          tooltip=\"", "\"\n          show-text-label\n          icon-position=\"top\"\n        >\n        </hax-tray-button>\n        <hax-tray-button\n          label=\"", "\"\n          tooltip=\"", "\"\n          icon=\"icons:file-download\"\n          @click=\"", "\"\n          show-text-label\n          icon-position=\"top\"\n        >\n        </hax-tray-button>\n        <hax-tray-button\n          @click=\"", "\"\n          label=\"", "\"\n          tooltip=\"", "\"\n          icon=\"hax:code-json\"\n          show-text-label\n          icon-position=\"top\"\n        >\n        </hax-tray-button>\n      </hax-toolbar>\n    "])), this.haxUiTheme == "hax" ? "vs" : this.haxUiTheme == "haxdark" ? "vs-dark" : "auto", this.t.updatePage, this.t.updatePageTooltip, this.importContent.bind(this), this.scrubContent.bind(this), this.t.cleanFormatting, this.t.cleanFormattingTooltip, this.selectBody.bind(this), this.t.copyHTML, this.t.copyHTMLTooltip, this.t.downloadHTML, this.t.downloadHTMLTooltip, this.download.bind(this), this.htmlToHaxElements.bind(this), this.t.schema, this.t.schemaTooltip);
      }
    }, {
      key: "download",
      value:
      /**
       * Download file.
       */
      function download(e) {
        var data = this.contentToFile(false);
        this.downloadFromData(data, "html", "my-new-code");

        _haxStore.HAXStore.toast("HTML content downloaded"); //this.close();

      }
      /**
       * Download file.
       */

    }, {
      key: "downloadfull",
      value: function downloadfull(e) {
        var data = this.contentToFile(true);
        this.downloadFromData(data, "html", "my-new-webpage");

        _haxStore.HAXStore.toast("Working offline copy downloaded"); //this.close();

      }
      /**
       * Import content into body area.
       */

    }, {
      key: "importContent",
      value: function importContent(e) {
        // import contents of this text area into the activeHaxBody
        var htmlBody = this.shadowRoot.querySelector("#textarea").value;

        _haxStore.HAXStore.activeHaxBody.importContent(htmlBody);

        _haxStore.HAXStore.haxTray.trayDetail = "";
      }
      /**
       * Scrub and then import content as if pasted from Word / GDocs
       */

    }, {
      key: "scrubContent",
      value: function scrubContent(e) {
        // import contents of this text area into the activeHaxBody
        var htmlBody = this.shadowRoot.querySelector("#textarea").value;

        _haxStore.HAXStore.toast("Scrubbed, Content updated");

        _haxStore.HAXStore.activeHaxBody.importContent((0, _utils.stripMSWord)(htmlBody)); //this.close();

      }
      /**
       * update content of the editor area
       */

    }, {
      key: "openSource",
      value: function openSource() {
        // import at this time so we can delay as long as possible
        // from needing to pull in monaco
        new Promise(function (res, rej) {
          return _require.default(["../../code-editor/code-editor.js"], res, rej);
        });
        this.updateEditor();
      }
      /**
       * selectBody
       */

    }, {
      key: "selectBody",
      value: function selectBody(e) {
        var hiddenarea = this.shadowRoot.querySelector("#hiddentextarea");
        hiddenarea.value = this.shadowRoot.querySelector("#textarea").value;
        hiddenarea.removeAttribute("hidden");
        hiddenarea.focus();
        hiddenarea.select();
        document.execCommand("copy");
        hiddenarea.setAttribute("hidden", "hidden");

        _haxStore.HAXStore.toast(this.t.copiedToClipboard); //this.close();

      }
      /**
       * HTML to HAX Elements
       */

    }, {
      key: "htmlToHaxElements",
      value: function () {
        var _htmlToHaxElements = babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(e) {
          var elements, str, val, hiddenarea;
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.next = 2;
                  return _haxStore.HAXStore.htmlToHaxElements(this.shadowRoot.querySelector("#textarea").value);

                case 2:
                  elements = _context.sent;
                  str = JSON.stringify(elements, null, 2);
                  val = this.shadowRoot.querySelector("#textarea").value;
                  hiddenarea = this.shadowRoot.querySelector("#hiddentextarea");
                  hiddenarea.removeAttribute("hidden");
                  hiddenarea.value = str;
                  hiddenarea.focus();
                  hiddenarea.select();
                  document.execCommand("copy");
                  hiddenarea.value = val;
                  hiddenarea.setAttribute("hidden", "hidden");

                  _haxStore.HAXStore.toast(this.t.copiedToClipboard);

                case 14:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));

        function htmlToHaxElements(_x) {
          return _htmlToHaxElements.apply(this, arguments);
        }

        return htmlToHaxElements;
      }()
    }, {
      key: "firstUpdated",
      value: function () {
        var _firstUpdated = babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(changedProperties) {
          return regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  if (babelHelpers.get(babelHelpers.getPrototypeOf(HaxViewSource.prototype), "firstUpdated", this)) {
                    babelHelpers.get(babelHelpers.getPrototypeOf(HaxViewSource.prototype), "firstUpdated", this).call(this, changedProperties); // fire an event that this is a core piece of the system

                    this.dispatchEvent(new CustomEvent("hax-register-core-piece", {
                      bubbles: true,
                      cancelable: true,
                      composed: true,
                      detail: {
                        piece: "haxViewSource",
                        object: this
                      }
                    }));
                  }

                  _context2.next = 3;
                  return this.updateEditor();

                case 3:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, this);
        }));

        function firstUpdated(_x2) {
          return _firstUpdated.apply(this, arguments);
        }

        return firstUpdated;
      }()
    }, {
      key: "updateEditor",
      value: function () {
        var _updateEditor = babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
          return regeneratorRuntime.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  if (!(_haxStore.HAXStore.activeHaxBody && this.shadowRoot && this.shadowRoot.querySelector("#textarea"))) {
                    _context3.next = 6;
                    break;
                  }

                  _context3.t0 = _utils.formatHTML;
                  _context3.next = 4;
                  return _haxStore.HAXStore.activeHaxBody.haxToContent();

                case 4:
                  _context3.t1 = _context3.sent;
                  this.shadowRoot.querySelector("#textarea").editorValue = (0, _context3.t0)(_context3.t1);

                case 6:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3, this);
        }));

        function updateEditor() {
          return _updateEditor.apply(this, arguments);
        }

        return updateEditor;
      }()
      /**
       * Output entire thing as a file.
       */

    }, {
      key: "contentToFile",
      value: function () {
        var _contentToFile = babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(full) {
          var body, content;
          return regeneratorRuntime.wrap(function _callee4$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  _context4.next = 2;
                  return _haxStore.HAXStore.activeHaxBody.haxToContent();

                case 2:
                  body = _context4.sent;
                  content = body; // if you want full HTML headers or not

                  if (full) {
                    content = "\n        <!DOCTYPE html>\n        <html lang=\"en\">\n          <head>\n            <meta charset=\"utf-8\" />\n            <meta\n              name=\"viewport\"\n              content=\"width=device-width, minimum-scale=1, initial-scale=1, user-scalable=yes\"\n            />\n            <title>hax-body demo</title>\n            <script>window.WCGlobalCDNPath=\"https://cdn.webcomponents.psu.edu/cdn/\"; </script> <script src=\"https://cdn.webcomponents.psu.edu/cdn/build.js\"></script> \n            <style>\n              body {\n                padding: 32px;\n              }\n            </style>\n          </head>\n          <body>\n          ".concat(body, "\n          </body>\n        </html>\n      ");
                  }

                  return _context4.abrupt("return", content);

                case 6:
                case "end":
                  return _context4.stop();
              }
            }
          }, _callee4);
        }));

        function contentToFile(_x3) {
          return _contentToFile.apply(this, arguments);
        }

        return contentToFile;
      }()
    }], [{
      key: "styles",
      get: function get() {
        return [].concat(babelHelpers.toConsumableArray(_haxUiStyles.HaxComponentStyles), [(0, _index.css)(_templateObject2_f377ed60feb911eb8439e3eec9305af7 || (_templateObject2_f377ed60feb911eb8439e3eec9305af7 = babelHelpers.taggedTemplateLiteral(["\n        :host,\n        #wrapper {\n          margin: 0;\n          padding: 0;\n          display: flex;\n          flex-direction: column;\n          align-items: stretch;\n          position: relative;\n          flex: 1 1 100%;\n        }\n        #spacer {\n          flex: 1 1 100%;\n          z-index: -1;\n        }\n        #textarea {\n          position: absolute;\n          top: 0;\n          bottom: 0;\n          margin: 0;\n          padding: 0;\n        }\n        hax-toolbar {\n          flex: 0 0 auto;\n          background-color: var(--hax-ui-background-color);\n        }\n        hax-toolbar::part(buttons) {\n          display: flex;\n          justify-content: center;\n          align-items: stretch;\n          margin: 0 auto;\n        }\n        hax-tray-button {\n          flex: 1 1 auto;\n        }\n        /** This is mobile layout for controls */\n        @media screen and (max-width: 800px) {\n          hax-tray-button {\n            flex: 0 1 auto;\n          }\n        }\n      "])))]);
      }
    }, {
      key: "tag",
      get: function get() {
        return "hax-view-source";
      }
    }, {
      key: "properties",
      get: function get() {
        return _objectSpread(_objectSpread({}, babelHelpers.get(babelHelpers.getPrototypeOf(HaxViewSource), "properties", this)), {}, {
          /**
           * Global preferences for HAX overall
           */
          globalPreferences: {
            type: Object
          },
          theme: {
            type: String
          }
        });
      }
    }]);
    return HaxViewSource;
  }((0, _I18NMixin2.I18NMixin)((0, _dlBehavior.MtzFileDownloadBehaviors)(_index.LitElement)));

  _exports.HaxViewSource = HaxViewSource;
  window.customElements.define(HaxViewSource.tag, HaxViewSource);
});