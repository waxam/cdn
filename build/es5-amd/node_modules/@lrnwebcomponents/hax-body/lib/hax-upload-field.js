define(["exports", "require", "../../../@polymer/polymer/polymer-element.js", "../../simple-colors/simple-colors.js", "../../simple-picker/simple-picker.js", "./hax-shared-styles.js"], function (_exports, _require, _polymerElement, _simpleColors, _simplePicker, _haxSharedStyles) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.HaxUploadField = void 0;
  _require = babelHelpers.interopRequireWildcard(_require);

  function _templateObject_565ba8c0b3b911e9b58d79562a23326c() {
    var data = babelHelpers.taggedTemplateLiteral(["\n      <style include=\"hax-shared-styles\">\n        :host {\n          display: block;\n          visibility: visible;\n          transition: 0.3s all ease;\n          box-sizing: border-box;\n          pointer-events: all;\n          overflow: visible;\n          --simple-camera-snap-width: 300px;\n          --simple-camera-snap-height: calc(300px * 9 / 16);\n          --simple-camera-snap-color: var(--eco-json-form-color, #222);\n          --simple-camera-snap-background: var(--eco-json-form-bg, white);\n          --simple-camera-snap-border-radius: 2px;\n          --lumo-font-family: var(\n            --eco-json-form-font-family,\n            var(--paper-font-caption_-_font-family, unset)\n          );\n          --lumo-base-color: var(\n            --eco-json-form-bg,\n            var(--primary-background-color, #fff)\n          );\n          --lumo-primary-contrast-color: var(\n            --eco-json-form-bg,\n            var(--primary-background-color, #fff)\n          );\n          --lumo-primary-color: var(\n            --eco-json-form-active-color,\n            var(--primary-color, #000)\n          );\n          --lumo-primary-text-color: var(\n            --eco-json-form-color,\n            var(--primary-text-color, #222)\n          );\n          --lumo-body-text-color: var(\n            --eco-json-form-color,\n            var(--primary-text-color, #222)\n          );\n          --lumo-header-text-color: var(\n            --eco-json-form-color,\n            var(--primary-text-color, #222)\n          );\n          --lumo-secondary-text-color: var(\n            --eco-json-form-faded-color,\n            var(--secondary-text-color, #888)\n          );\n          --lumo-disabled-text-color: var(\n            --eco-json-form-faded-color,\n            var(--secondary-text-color, #888)\n          );\n          background-color: var(\n            --eco-json-form-bg,\n            var(--primary-background-color, #fff)\n          );\n          --simple-picker-float-label-active-color: var(\n            --eco-json-form-active-color,\n            var(--primary-color, #000)\n          );\n          --simple-picker-float-label-faded-color: var(\n            --eco-json-form-faded-color,\n            var(--secondary-text-color, #888)\n          );\n          --simple-picker-background-color: var(\n            --eco-json-form-bg,\n            var(--primary-background-color, #fff)\n          );\n          --simple-picker-border-color: transparent;\n          --simple-picker-sample-focus: {\n            transition: all 0.5s;\n            border: none;\n          }\n        }\n        :host #legend {\n          transition: all 0.5s;\n          color: var(\n            --eco-json-form-faded-color,\n            var(--secondary-text-color, #888)\n          );\n        }\n        :host(:focus-within) #legend {\n          color: var(--eco-json-form-active-color, var(--primary-color, #000));\n        }\n        :host #fieldset {\n          border-radius: 2px;\n          transition: all 0.5s;\n          border: 1px solid\n            var(--eco-json-form-faded-color, var(--secondary-text-color, #888));\n        }\n        :host #fieldset > div {\n          display: flex;\n          align-items: center;\n          justify-content: space-between;\n        }\n        :host #fieldset > div > *:not(#picker) {\n          flex: 1 1 auto;\n        }\n        #picker {\n          margin-bottom: 0;\n          margin-right: 5px;\n        }\n        vaadin-upload {\n          padding: 0;\n          margin: 0;\n        }\n        simple-camera-snap {\n          position: relative;\n          --simple-camera-snap-button-container: {\n            position: absolute;\n            bottom: 2px;\n            z-index: 5;\n          }\n          --simple-camera-snap-button: {\n            border-radius: 100%;\n            opacity: 0.7;\n          }\n          @apply --hax-upload-camera;\n        }\n      </style>\n      <fieldset id=\"fieldset\">\n        <legend id=\"legend\" hidden$=\"[[!label]]\">[[label]]</legend>\n        <div>\n          <simple-picker\n            id=\"picker\"\n            aria-label=\"Source...\"\n            required\n            value=\"{{option}}\"\n            options=\"[[options]]\"\n          >\n          </simple-picker>\n          <paper-input\n            id=\"url\"\n            hidden$=\"[[_isHidden(option,'url')]]\"\n            value=\"{{value}}\"\n            label=\"URL\"\n            type=\"url\"\n            auto-validate=\"\"\n          ></paper-input>\n          <vaadin-upload\n            capture\n            form-data-name=\"file-upload\"\n            hidden$=\"[[_isHidden(option,'fileupload')]]\"\n            id=\"fileupload\"\n          ></vaadin-upload>\n          <div id=\"camerahole\" hidden$=\"[[_isHidden(option,'selfie')]]\"></div>\n        </div>\n      </fieldset>\n    "]);

    _templateObject_565ba8c0b3b911e9b58d79562a23326c = function _templateObject_565ba8c0b3b911e9b58d79562a23326c() {
      return data;
    };

    return data;
  }

  var HaxUploadField =
  /*#__PURE__*/
  function (_PolymerElement) {
    babelHelpers.inherits(HaxUploadField, _PolymerElement);

    function HaxUploadField() {
      var _this;

      babelHelpers.classCallCheck(this, HaxUploadField);
      _this = babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(HaxUploadField).call(this));
      new Promise(function (res, rej) {
        return _require.default(["../../../@polymer/paper-input/paper-input.js"], res, rej);
      });
      new Promise(function (res, rej) {
        return _require.default(["../../../@polymer/paper-icon-button/paper-icon-button.js"], res, rej);
      });
      new Promise(function (res, rej) {
        return _require.default(["../../../@vaadin/vaadin-upload/vaadin-upload.js"], res, rej);
      });
      return _this;
    }

    babelHelpers.createClass(HaxUploadField, [{
      key: "_isHidden",
      value: function _isHidden(option, ui) {
        return option !== ui;
      }
      /**
       * Respond to uploading a file
       */

    }, {
      key: "_fileAboutToUpload",
      value: function _fileAboutToUpload(e) {
        if (!this.__allowUpload) {
          // cancel the event so we can jump in
          e.preventDefault();
          e.stopPropagation(); // look for a match as to what gizmo types it supports

          var values = {
            source: e.detail.file.name,
            type: e.detail.file.type
          }; // we have no clue what this is.. let's try and guess..

          var type = window.HaxStore.guessGizmoType(values); // find targets that support this type

          var targets = window.HaxStore.getHaxAppStoreTargets(type); // make sure we have targets

          if (targets.length === 1) {
            this._haxAppPickerSelection({
              detail: targets[0]
            });
          } else if (targets.length !== 0) {
            window.HaxStore.instance.haxAppPicker.presentOptions(targets, type, "Where would you like to upload this " + type + "?", "app");
          } else {
            window.HaxStore.toast("Sorry, you don't have a storage location that can handle " + type + " uploads!", 5000);
          }
        } else {
          this.__allowUpload = false;
        }
      }
      /**
       * Respond to successful file upload, now inject url into url field and
       * do a gizmo guess from there!
       */

    }, {
      key: "_fileUploadResponse",
      value: function _fileUploadResponse(e) {
        // convert response to object
        var response = JSON.parse(e.detail.xhr.response); // access the app that did the upload

        var map = this.__appUsed.connection.operations.add.resultMap;
        var data = {};
        var item = {}; // look for the items element to draw our data from at its root

        if (babelHelpers.typeof(this._resolveObjectPath(map.item, response)) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
          data = this._resolveObjectPath(map.item, response);
        }

        item.type = map.defaultGizmoType; // pull in prop matches

        for (var prop in map.gizmo) {
          item[prop] = this._resolveObjectPath(map.gizmo[prop], data);
        } // another sanity check, if we don't have a url but have a source bind that too


        if (babelHelpers.typeof(item.url) === (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && babelHelpers.typeof(item.source) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
          item.url = item.source;
        } // gizmo type is also supported in the mapping element itself
        // Think an asset management backend as opposed to a specific
        // type of asset like video. If the item coming across can
        // effectively check what kind of gizmo is required for it
        // to work then we need to support that asset declaring the
        // gizmo type needed


        if (babelHelpers.typeof(map.gizmo.type) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
          item.type = this._resolveObjectPath(map.gizmo.type, data);
        } // set the value of the url which will update our URL and notify


        this.shadowRoot.querySelector("#url").value = item.url;
      }
      /**
       * Event for an app being selected from a picker
       * This happens when multiple upload targets support the given type
       */

    }, {
      key: "_haxAppPickerSelection",
      value: function _haxAppPickerSelection(e) {
        // details for where to upload the file
        var connection = e.detail.connection;
        this.__appUsed = e.detail;
        this.shadowRoot.querySelector("#fileupload").method = connection.operations.add.method;
        var requestEndPoint = connection.protocol + "://" + connection.url; // ensure we build a url correctly

        if (requestEndPoint.substr(requestEndPoint.length - 1) != "/") {
          requestEndPoint += "/";
        } // support local end point modification


        if (babelHelpers.typeof(connection.operations.add.endPoint) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
          requestEndPoint += connection.operations.add.endPoint;
        } // implementation specific tweaks to talk to things like HAXcms and other CMSs
        // that have per load token based authentication


        if (window.HaxStore.instance.connectionRewrites.appendUploadEndPoint != null) {
          requestEndPoint += "?" + window.HaxStore.instance.connectionRewrites.appendUploadEndPoint;
        }

        if (window.HaxStore.instance.connectionRewrites.appendJwt != null) {
          requestEndPoint += "&" + window.HaxStore.instance.connectionRewrites.appendJwt + "=" + localStorage.getItem(window.HaxStore.instance.connectionRewrites.appendJwt);
        }

        this.shadowRoot.querySelector("#fileupload").headers = connection.headers;
        this.shadowRoot.querySelector("#fileupload").target = requestEndPoint; // invoke file uploading...

        this.__allowUpload = true;
        this.shadowRoot.querySelector("#fileupload").uploadFiles();
      }
    }, {
      key: "connectedCallback",
      value: function connectedCallback() {
        var _this2 = this;

        babelHelpers.get(babelHelpers.getPrototypeOf(HaxUploadField.prototype), "connectedCallback", this).call(this); // hide the button if this environment can't support it anyway

        if (!navigator.mediaDevices) {
          this.options = [[{
            alt: "URL",
            icon: "icons:link",
            value: "url"
          }], [{
            alt: "Upload",
            icon: "icons:file-upload",
            value: "fileupload"
          }]];
          this.shadowRoot.querySelector("#camerahole").style.display = "none";
        } else {
          this.options = [[{
            alt: "URL",
            icon: "icons:link",
            value: "url"
          }], [{
            alt: "Upload",
            icon: "icons:file-upload",
            value: "fileupload"
          }], [{
            alt: "Camera",
            icon: "image:photo-camera",
            value: "selfie"
          }]];
        }

        this.option = "fileupload";
        this.shadowRoot.querySelector("#fileupload").addEventListener("upload-before", this._fileAboutToUpload.bind(this));
        this.shadowRoot.querySelector("#fileupload").addEventListener("upload-response", this._fileUploadResponse.bind(this));
        this.shadowRoot.querySelector("#picker").addEventListener("change", function (e) {
          if (e && e.detail && e.detail.value === "selfie") _this2._takeSelfie(e);
        });
        this.shadowRoot.querySelector("#camerahole").addEventListener("simple-camera-snap-image", this.__newPhotoShowedUp.bind(this));
        document.body.addEventListener("hax-app-picker-selection", this._haxAppPickerSelection.bind(this));
      }
      /**
       * life cycle, ensure body isnt listened to anymore here
       */

    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        document.body.removeEventListener("hax-app-picker-selection", this._haxAppPickerSelection.bind(this));
        babelHelpers.get(babelHelpers.getPrototypeOf(HaxUploadField.prototype), "disconnectedCallback", this).call(this);
      }
      /**
       * We got a new photo
       */

    }, {
      key: "__newPhotoShowedUp",
      value: function __newPhotoShowedUp(e) {
        var file = new File([e.detail.raw], "headshot" + e.timeStamp + ".jpg");

        this.shadowRoot.querySelector("#fileupload")._addFile(file);
      }
      /**
       * Invoke the camera to set itself up
       */

    }, {
      key: "_takeSelfie",
      value: function _takeSelfie(e) {
        if (!this.camera) {
          new Promise(function (res, rej) {
            return _require.default(["../../simple-login/lib/simple-camera-snap.js"], res, rej);
          });
          this.camera = document.createElement("simple-camera-snap");
          this.camera.autoplay = true;
          this.shadowRoot.querySelector("#camerahole").appendChild(this.camera);
        }
      }
      /**
       * Helper to take a multi-dimensional object and convert
       * it's reference into the real value. This allows for variable input defined
       * in a string to actually hit the deeper part of an object structure.
       */

    }, {
      key: "_resolveObjectPath",
      value: function _resolveObjectPath(path, obj) {
        return path.split(".").reduce(function (prev, curr) {
          return prev ? prev[curr] : null;
        }, obj || self);
      }
    }], [{
      key: "template",
      get: function get() {
        return (0, _polymerElement.html)(_templateObject_565ba8c0b3b911e9b58d79562a23326c());
      }
    }, {
      key: "properties",
      get: function get() {
        return {
          label: {
            type: String,
            value: null
          },
          value: {
            type: String,
            notify: true
          },
          option: {
            type: String
          },
          options: {
            type: Array
          }
        };
      }
    }]);
    return HaxUploadField;
  }(_polymerElement.PolymerElement);

  _exports.HaxUploadField = HaxUploadField;
  window.customElements.define("hax-upload-field", HaxUploadField);
});