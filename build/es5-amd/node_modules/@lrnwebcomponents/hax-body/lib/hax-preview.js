define(["exports", "../../../lit-element/lit-element.js", "../../../@polymer/polymer/lib/utils/flattened-nodes-observer.js", "../../utils/utils.js", "../../../@polymer/iron-media-query/iron-media-query.js", "../../../@polymer/polymer/lib/elements/custom-style.js"], function (_exports, _litElement, _flattenedNodesObserver, _utils, _ironMediaQuery, _customStyle) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.HaxPreview = void 0;

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  function _templateObject2_67544e202d8511ea80ccf124101da415() {
    var data = babelHelpers.taggedTemplateLiteral(["\n      <custom-style>\n        <style>\n          #form {\n            --eco-json-schema-object-form: {\n              display: block !important;\n            }\n          }\n          #modetabs {\n            --paper-tabs: {\n              background: transparent;\n            }\n          }\n          #modetabs paper-tab {\n            --paper-tab: {\n              font-size: 16px;\n            }\n          }\n          eco-json-schema-object {\n            --eco-json-schema-object-form : {\n              -ms-flex: unset;\n              -webkit-flex: unset;\n              flex: unset;\n              -webkit-flex-basis: unset;\n              flex-basis: unset;\n            }\n          }\n        </style>\n      </custom-style>\n      <vaadin-split-layout\n        class=\"panel-wrapper\"\n        orientation=\"", "\"\n      >\n        <div\n          id=\"ppanel1\"\n          class=\"vaadin-split-layout-panel vaadin-layout-", "\"\n        >\n          <div class=\"preview-buttons\">\n            <paper-button id=\"insert\" raised @click=\"", "\"\n              >", "</paper-button\n            >\n            <paper-button id=\"cancel\" raised @click=\"", "\"\n              >Cancel</paper-button\n            >\n          </div>\n          <div class=\"preview-text hide-on-mobile\">\n            <iron-icon icon=\"icons:arrow-drop-down\"></iron-icon\n            ><iron-icon icon=\"icons:arrow-drop-down\"></iron-icon\n            ><iron-icon icon=\"icons:arrow-drop-down\"></iron-icon>", "\n            preview<iron-icon icon=\"icons:arrow-drop-down\"></iron-icon\n            ><iron-icon icon=\"icons:arrow-drop-down\"></iron-icon\n            ><iron-icon icon=\"icons:arrow-drop-down\"></iron-icon>\n          </div>\n          <div id=\"preview\"><slot></slot></div>\n          <div class=\"preview-text preview-text-bottom hide-on-mobile\">\n            <iron-icon icon=\"icons:arrow-drop-up\"></iron-icon\n            ><iron-icon icon=\"icons:arrow-drop-up\"></iron-icon\n            ><iron-icon icon=\"icons:arrow-drop-up\"></iron-icon>end\n            preview<iron-icon icon=\"icons:arrow-drop-up\"></iron-icon\n            ><iron-icon icon=\"icons:arrow-drop-up\"></iron-icon\n            ><iron-icon icon=\"icons:arrow-drop-up\"></iron-icon>\n          </div>\n        </div>\n        <div\n          id=\"ppanel2\"\n          class=\"vaadin-split-layout-panel vaadin-layout-", "\"\n        >\n          <paper-tabs\n            .hidden=\"", "\"\n            id=\"modetabs\"\n            selected=\"", "\"\n            @selected-changed=\"", "\"\n            attr-for-selected=\"data-mode\"\n          >\n            <paper-tab id=\"configurebutton\" data-mode=\"configure\"\n              ><paper-button raised=\"\" noink=\"\"\n                >Configure</paper-button\n              ></paper-tab\n            >\n            <paper-tab id=\"advancedbutton\" data-mode=\"advanced\"\n              ><paper-button raised=\"\" noink=\"\"\n                >Advanced</paper-button\n              ></paper-tab\n            >\n          </paper-tabs>\n          <paper-card class=\"form-wrapper\">\n            <eco-json-schema-object\n              id=\"form\"\n              .schema=\"", "\"\n              .value=\"", "\"\n              @value-changed=\"", "\"\n            ></eco-json-schema-object>\n          </paper-card>\n        </div>\n      </vaadin-split-layout>\n      <iron-media-query\n        query=\"", "\"\n        @query-matches-changed=\"", "\"\n      ></iron-media-query>\n    "]);

    _templateObject2_67544e202d8511ea80ccf124101da415 = function _templateObject2_67544e202d8511ea80ccf124101da415() {
      return data;
    };

    return data;
  }

  function _templateObject_67544e202d8511ea80ccf124101da415() {
    var data = babelHelpers.taggedTemplateLiteral(["\n        :host {\n          display: block;\n          background-color: #ffffff;\n          overflow: hidden;\n        }\n        iron-icon:not(:defined),\n        paper-button:not(:defined) {\n          display: none;\n        }\n        paper-card.form-wrapper {\n          margin: 0;\n          padding: 0 16px 80px 16px;\n          width: 100%;\n          min-height: 160px;\n          background-color: transparent;\n          overflow: auto;\n          height: 100%;\n        }\n\n        vaadin-split-layout {\n          display: flex;\n          justify-content: space-around;\n          height: 100%;\n        }\n        eco-json-schema-object {\n          width: 50%;\n          --eco-json-field-margin: var(--hax-field-margin, 0 0 4px);\n          color: var(--hax-text-color);\n        }\n\n        .vaadin-split-layout-panel {\n          flex: 1 1 auto;\n          width: 100%;\n          flex-wrap: nowrap;\n          margin: 0;\n          height: 100%;\n          overflow: hidden;\n        }\n        #preview {\n          padding: 16px;\n          color: #000000;\n          background-color: white;\n          max-height: 63vh;\n          overflow: scroll;\n        }\n        #preview ::slotted(*) {\n          float: unset !important;\n          margin: unset !important;\n          width: unset !important;\n          position: unset !important;\n          top: unset !important;\n          left: unset !important;\n          right: unset !important;\n          bottom: unset !important;\n        }\n        .preview-text {\n          font-size: 14px;\n          color: var(--hax-color-text);\n          font-style: italic;\n          width: 100%;\n          height: 24px;\n          border-bottom: 1px solid var(--hax-color-border-outline);\n          text-align: center;\n          padding: 8px 0;\n          box-sizing: content-box;\n        }\n        .preview-text iron-icon {\n          margin: 0 8px;\n          display: inline-block;\n        }\n        .preview-text-bottom {\n          border-bottom: unset;\n          border-top: 1px solid var(--hax-color-border-outline);\n        }\n        @media screen and (max-width: 550px) {\n          .hide-on-mobile {\n            opacity: 0;\n            visibility: hidden;\n            position: absolute;\n            left: -9999px;\n          }\n        }\n        #modetabs {\n          height: 64px;\n          padding: 0px;\n          margin: 16px 0 0 0;\n          box-sizing: content-box;\n          color: var(--hax-color-text);\n          text-align: center;\n          background-color: transparent;\n          border-bottom: 1px solid var(--hax-color-border-outline);\n          display: block;\n          justify-content: space-evenly;\n          --paper-tabs-selection-bar-color: var(--hax-color-accent1);\n        }\n        #modetabs paper-tab {\n          display: inline-flex;\n          height: 100%;\n          --paper-tab-ink: var(--hax-color-accent1);\n        }\n        #modetabs paper-tab paper-button {\n          min-width: unset;\n          width: 100%;\n          background-color: var(--hax-preview-button-bg, white);\n          color: var(--hax-preview-button-color, black);\n        }\n        .preview-buttons {\n          height: 64px;\n          padding: 0px;\n          color: var(--hax-color-text);\n          border-bottom: 1px solid var(--hax-color-border-outline);\n          background-color: transparent;\n          margin: 16px 0 0 0;\n          text-align: center;\n          box-sizing: content-box;\n        }\n        .preview-buttons paper-button {\n          min-width: unset;\n          width: 40%;\n          color: var(--hax-preview-button-color, black);\n          display: inline-block;\n          background-color: var(--hax-preview-button-bg, white);\n        }\n        #insert {\n          background-color: var(\n            --hax-preview-insert-button-bg,\n            --hax-preview-button-bg\n          );\n        }\n        #cancel {\n          background-color: var(\n            --hax-preview-cancel-button-bg,\n            --hax-preview-button-bg\n          );\n        }\n        .vaadin-layout-width {\n          min-width: 30%;\n          width: 50%;\n          max-width: 70%;\n        }\n        .vaadin-layout-height {\n          min-height: 40%;\n          height: 50%;\n          max-height: 60%;\n        }\n      "]);

    _templateObject_67544e202d8511ea80ccf124101da415 = function _templateObject_67544e202d8511ea80ccf124101da415() {
      return data;
    };

    return data;
  }

  /**
   * `hax-preview`
   * @customElement hax-preview
   * `An element that can generate a form`
   * @microcopy - the mental model for this element
   *  - element - the element to work against. an object that expresses enough information to create an element in the DOM. This is useful for remixing a tag via the json-form
   *  - source - a json object from some place loaded in remotely which will then be in json-schema format. This will then be parsed into a form which can be used to manipulate the element.
   */
  var HaxPreview =
  /*#__PURE__*/
  function (_winEventsElement) {
    babelHelpers.inherits(HaxPreview, _winEventsElement);
    babelHelpers.createClass(HaxPreview, null, [{
      key: "styles",

      /**
       * LitElement render styles
       */
      get: function get() {
        return [(0, _litElement.css)(_templateObject_67544e202d8511ea80ccf124101da415())];
      }
      /**
       * HTMLElement
       */

    }]);

    function HaxPreview() {
      var _this;

      babelHelpers.classCallCheck(this, HaxPreview);
      _this = babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(HaxPreview).call(this));
      _this.__winEvents = {
        "hax-store-property-updated": "_haxStorePropertyUpdated"
      };
      _this.responsiveWidth = "800px";
      _this.orientation = "horizontal";
      _this.orientationDirection = "width";
      _this.previewNode = {};
      _this.value = {};
      _this.modeTab = "configure";
      _this.editTitle = "Update";
      _this.schema = {
        schema: {}
      };
      _this.activeHaxElement = {};
      _this.advancedForm = false;
      return _this;
    }
    /**
     * LitElement render
     */


    babelHelpers.createClass(HaxPreview, [{
      key: "render",
      value: function render() {
        return (0, _litElement.html)(_templateObject2_67544e202d8511ea80ccf124101da415(), this.orientation, this.orientationDirection, this.insert, this.editTitle, this.cancel, this.humanName, this.orientationDirection, !this.haspreviewNode, this.modeTab, this.__modeTabChanged, this.schema, this.value, this.__valueChangedEvent, this._computeMediaQuery(this.responsiveWidth), this._onQueryMatchesChanged);
      }
      /**
       * Notice change in eco and bubble up
       * @todo this needs replaced with simple-fields
       */

    }, {
      key: "__valueChangedEvent",
      value: function __valueChangedEvent(e) {
        this.value = _objectSpread({}, e.detail.value);
      }
      /**
       * Tab change
       */

    }, {
      key: "__modeTabChanged",
      value: function __modeTabChanged(e) {
        this.modeTab = e.detail.value;
      }
    }, {
      key: "updated",

      /**
       * LitElement properties changed
       */
      value: function updated(changedProperties) {
        var _this2 = this;

        changedProperties.forEach(function (oldValue, propName) {
          if (propName === "value") {
            _this2._valueChanged(_this2[propName]); // notify


            _this2.dispatchEvent(new CustomEvent("value-changed", {
              detail: {
                value: _this2[propName]
              }
            }));
          }

          if (propName === "previewNode") {
            _this2._previewNodeChanged(_this2[propName], oldValue); // notify


            _this2.dispatchEvent(new CustomEvent("preview-node-changed", {
              detail: {
                value: _this2[propName]
              }
            }));
          }

          if (propName === "activeHaxElement") {
            _this2._activeHaxElementChanged(_this2[propName], oldValue); // notify


            _this2.dispatchEvent(new CustomEvent("active-hax-element-changed", {
              detail: {
                value: _this2[propName]
              }
            }));
          }

          if (propName === "modeTab") {
            _this2._editorModeChanged(_this2[propName], oldValue);
          }

          if (propName === "formKey") {
            _this2._formKeyChanged(_this2[propName], oldValue);
          }

          if (propName === "advancedForm") {
            _this2.formKey = _this2._computedFormKey(_this2[propName]);
          }

          if (propName === "formKey") {
            _this2.canEditSource = _this2._computedEditSource(_this2[propName]);
          }

          if (propName === "previewNode") {
            _this2.haspreviewNode = _this2._computedHasPreviewNode(_this2[propName]);
          }
        });
      }
      /**
       * LitElement / popular convention
       */

    }, {
      key: "_onQueryMatchesChanged",
      value: function _onQueryMatchesChanged(e) {
        if (e.detail.value) {
          this.orientation = "vertical";
          this.orientationDirection = "height";
        } else {
          this.orientation = "horizontal";
          this.orientationDirection = "width";
        }
      }
    }, {
      key: "_computeMediaQuery",
      value: function _computeMediaQuery(responsiveWidth) {
        return "(max-width: " + responsiveWidth + ")";
      }
      /**
       * Trigger cancel on manager as it is the parent here.
       */

    }, {
      key: "cancel",
      value: function cancel(e) {
        window.HaxStore.write("openDrawer", false, this);
      }
      /**
       * Trigger insert on manager as it is the parent here.
       */

    }, {
      key: "insert",
      value: function insert(e) {
        window.HaxStore.instance.haxManager.insertHaxElement(e);
      }
      /**
       * Make a boolean to match the preview node's existance.
       */

    }, {
      key: "_computedHasPreviewNode",
      value: function _computedHasPreviewNode(previewNode) {
        if (babelHelpers.typeof(previewNode.tagName) === (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
          return false;
        } else {
          return true;
        }
      }
      /**
       * Edit source.
       */

    }, {
      key: "_computedEditSource",
      value: function _computedEditSource(newValue, oldValue) {
        if (babelHelpers.typeof(newValue) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
          if (babelHelpers.typeof(this.previewNode.tagName) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && window.HaxStore.instance.elementList[this.previewNode.tagName.toLowerCase()]) {
            return window.HaxStore.instance.elementList[this.previewNode.tagName.toLowerCase()].canEditSource;
          }
        }

        return true;
      }
      /**
       * Compute form key to use.
       */

    }, {
      key: "_computedFormKey",
      value: function _computedFormKey(advanced) {
        if (advanced) {
          return "advanced";
        } else {
          return "configure";
        }
      }
      /**
       * Form key changed, rebuild schema for the form
       * but don't update the element. Critical difference.
       */

    }, {
      key: "_formKeyChanged",
      value: function _formKeyChanged(newValue, oldValue) {
        // ensure this doesn't run the 1st pass
        if (babelHelpers.typeof(oldValue) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
          var schema = {}; // see if we can get schema off of this.

          if (babelHelpers.typeof(this.previewNode) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && babelHelpers.typeof(this.previewNode.tagName) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && babelHelpers.typeof(window.HaxStore.instance.elementList[this.previewNode.tagName.toLowerCase()]) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
            var props = window.HaxStore.instance.elementList[this.previewNode.tagName.toLowerCase()];

            if (typeof this.previewNode.getHaxJSONSchemaType === "function") {
              schema = window.HaxStore.instance.getHaxJSONSchema(newValue, props, this.previewNode);
            } else {
              schema = window.HaxStore.instance.getHaxJSONSchema(newValue, props);
            }

            for (var property in this.activeHaxElement.properties) {
              if (this.activeHaxElement.properties.hasOwnProperty(property)) {
                if (babelHelpers.typeof(schema.properties[property]) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
                  schema.properties[property].value = this.activeHaxElement.properties[property]; // support custom element input

                  if (babelHelpers.typeof(schema.properties[property].component) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && schema.properties[property].component.properties) {
                    schema.properties[property].component.properties.value = this.activeHaxElement.properties[property];
                  } // attempt to set the property in the preview node


                  if (property != "prefix" && this.activeHaxElement.properties[property] != null && !this.activeHaxElement.properties[property].readOnly) {
                    if (typeof this.previewNode.set === "function") {
                      // attempt to set it, should be no problem but never know
                      try {
                        this.previewNode.set(property, this.activeHaxElement.properties[property]);
                      } catch (e) {
                        console.warn("".concat(property, " is busted some how"));
                        console.warn(e);
                      }
                    } else if (this.previewNode[property]) {
                      this.previewNode[property] = this.activeHaxElement.properties[property];
                    } else {
                      // set attribute, this doesn't have the Polymer convention
                      // this is Vanilla, Lit, etc
                      // set is powerful though for objects and arrays so they will reflect instantly
                      this.previewNode.setAttribute(property, this.activeHaxElement.properties[property]);
                    }
                  } else if (property === "prefix") {
                    this.previewNode.setAttribute("prefix", this.activeHaxElement.properties[property]);
                  } else {
                    console.warn("".concat(property, " is busted some how"));
                  }
                }

                this.value[property] = this.activeHaxElement.properties[property];
              }
            }

            var slotsApplied = false;

            for (var prop in props.settings[newValue]) {
              var previewNode = this.previewNode;

              if (babelHelpers.typeof(props.settings[this.formKey][prop].slot) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && !slotsApplied) {
                slotsApplied = true; // walk through the slots looking for the value of it

                var previewNodeChildren = _flattenedNodesObserver.FlattenedNodesObserver.getFlattenedNodes(previewNode);

                for (var i in previewNodeChildren) {
                  // test for element nodes to be safe
                  if (babelHelpers.typeof(previewNodeChildren[i]) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && previewNodeChildren[i].nodeType === 1 && previewNodeChildren[i].slot === props.settings[this.formKey][prop].slot) {
                    if (babelHelpers.typeof(previewNodeChildren[i].innerHTML) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
                      schema.properties[props.settings[this.formKey][prop].slot].value = previewNodeChildren[i].innerHTML;
                      this.value[props.settings[this.formKey][prop].slot] = previewNodeChildren[i].innerHTML;
                    }
                  }
                }
              }
            }
          }

          this.schema = _objectSpread({}, schema);
        }
      }
      /**
       * Store updated, sync.
       */

    }, {
      key: "_haxStorePropertyUpdated",
      value: function _haxStorePropertyUpdated(e) {
        if (e.detail && babelHelpers.typeof(e.detail.value) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && e.detail.property) {
          if (e.detail.property == "activeHaxElement") {
            this.activeHaxElement = _objectSpread({}, e.detail.value); // ensure we don't get an empty properties object here

            this.activeHaxElement.properties = _objectSpread({}, e.detail.value.properties);
          }
        }
      }
      /**
       * When the preview node is updated, pull schema associated with it
       */

    }, {
      key: "_previewNodeChanged",
      value: function _previewNodeChanged(newValue, oldValue) {
        // ensure this doesn't run the 1st pass
        if (babelHelpers.typeof(oldValue) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && newValue != oldValue) {
          // see if we can get schema off of this.
          if (babelHelpers.typeof(newValue.tagName) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && babelHelpers.typeof(window.HaxStore.instance.elementList[newValue.tagName.toLowerCase()]) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
            var props = window.HaxStore.instance.elementList[newValue.tagName.toLowerCase()];
            var schema = {};

            if (typeof newValue.getHaxJSONSchemaType === "function") {
              schema = window.HaxStore.instance.getHaxJSONSchema(this.formKey, props, newValue);
            } else {
              schema = window.HaxStore.instance.getHaxJSONSchema(this.formKey, props);
            } // generate a human name for this


            if (babelHelpers.typeof(props.gizmo.title) === (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
              this.humanName = newValue.tagName.replace("-", " ").toLowerCase();
            } else {
              this.humanName = props.gizmo.title;
            } // first, allow element properties to dictate defaults


            for (var property in this.activeHaxElement.properties) {
              if (this.activeHaxElement.properties.hasOwnProperty(property)) {
                if (babelHelpers.typeof(schema.properties[property]) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
                  schema.properties[property].value = this.activeHaxElement.properties[property]; // support custom element input

                  if (babelHelpers.typeof(schema.properties[property].component) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && schema.properties[property].component.properties) {
                    schema.properties[property].component.properties.value = this.activeHaxElement.properties[property];
                  }
                } // ensure this isn't read only


                if (this.activeHaxElement.properties[property] != null && !this.activeHaxElement.properties[property].readOnly) {
                  // make sure slot is NEVER set in the preview
                  // or it'll not show up and we'll get inconsistency with it
                  // when in the context of being inserted into hax-body's shadow
                  // slot is also a special attribute
                  if (property === "slot") {
                    // temp prop we use
                    property = "data-hax-slot"; // move it over

                    this.activeHaxElement.properties[property] = this.activeHaxElement.properties["slot"]; // delete the slot

                    delete this.activeHaxElement.properties["slot"];

                    if (this.activeHaxElement.properties[property] != null) {
                      newValue.setAttribute("data-hax-slot", this.activeHaxElement.properties[property]);
                    }
                  } // prefix is a special attribute and must be handled this way
                  else if (property === "prefix") {
                      newValue.setAttribute("prefix", this.activeHaxElement.properties[property]);
                    } // set is a Polymer convention but help w/ data binding there a lot
                    else if (typeof newValue.set === "function") {
                        // just to be safe
                        try {
                          newValue.set(property, this.activeHaxElement.properties[property]);
                        } catch (e) {
                          console.warn(e);
                        }
                      } // vanilla / anything else we should just be able to set the prop
                      else if (newValue[property]) {
                          newValue[property] = this.activeHaxElement.properties[property];
                        } else {
                          // @todo may need to bind differently for vanilla elements
                          try {
                            newValue.setAttribute(property, this.activeHaxElement.properties[property]);
                          } catch (e) {
                            console.warn(e);
                          }
                        }
                }

                this.value[property] = this.activeHaxElement.properties[property];
              }
            } // then, let the node itself dictate defaults if things are not set


            for (var property in newValue) {
              if (newValue.hasOwnProperty(property) && babelHelpers.typeof(schema.properties[property]) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && babelHelpers.typeof(newValue[property].value) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && newValue[property].value !== null) {
                schema.properties[property].value = newValue.properties[property].value; // support custom element input

                if (babelHelpers.typeof(schema.properties[property].component) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && schema.properties[property].component.properties) {
                  schema.properties[property].component.properties.value = newValue.properties[property].value;
                }

                this.value[property] = newValue.properties[property].value;
              }
            } // need to specifically walk through slots if there is anything
            // that says it has to come from a slot


            for (var prop in props.settings[this.formKey]) {
              if (babelHelpers.typeof(props.settings[this.formKey][prop].slot) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
                var newValueChildren = _flattenedNodesObserver.FlattenedNodesObserver.getFlattenedNodes(newValue); // walk through the slots looking for the value of it


                for (var i in newValueChildren) {
                  // test for element nodes to be safe
                  if (babelHelpers.typeof(newValueChildren[i]) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && newValueChildren[i].nodeType === 1 && newValueChildren[i].slot === props.settings[this.formKey][prop].slot) {
                    if (babelHelpers.typeof(newValueChildren[i].innerHTML) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
                      schema.properties[props.settings[this.formKey][prop].slot].value = newValueChildren[i].innerHTML;
                      this.value[props.settings[this.formKey][prop].slot] = newValueChildren[i].innerHTML;
                    }
                  }
                }
              }
            }

            this.schema = _objectSpread({}, schema);
          }
        }
      }
      /**
       * Element changed, update the preview area.
       */

    }, {
      key: "_activeHaxElementChanged",
      value: function _activeHaxElementChanged(newValue, oldValue) {
        if (babelHelpers.typeof(newValue) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
          // wipe the preview area and assocaited node
          (0, _utils.wipeSlot)(this, "*");
          this.previewNode = {};
          this.value = {};
          this.schema = {};
          this.schema = {
            schema: {}
          };
          this.modeTab = "configure"; // if we have something, generate the new element inside it

          if (newValue && newValue != null && newValue.length != 0 && newValue.tag) {
            var frag = document.createElement(newValue.tag);
            frag.innerHTML = newValue.content; // clone the fragment which will force an escalation to full node

            var newNode = frag.cloneNode(true);
            newNode.setAttribute("hax-preview-mode", "hax-preview-mode"); // if there is slot we need to shift it

            if (newNode.getAttribute("slot") != null) {
              newNode.setAttribute("data-hax-slot", newNode.getAttribute("slot"));
              newNode.removeAttribute("slot");
            } // send this into the root, which should filter it back down into the slot


            this.appendChild(newNode); // need to let append propagate, it probably takes like no time

            this.previewNode = newNode;
          }
        } else {
          this.modeTab = "advanced";
          this.previewNode = {};
        }
      }
      /**
       * Value in the form has changed, reflect to the preview
       */

    }, {
      key: "_valueChanged",
      value: function _valueChanged(valueChange) {
        var node = this.previewNode; // sanity check and then get props and mesh with form value response

        if (babelHelpers.typeof(node.tagName) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && babelHelpers.typeof(window.HaxStore.instance.elementList[node.tagName.toLowerCase()]) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
          for (var path in valueChange) {
            // load up the property bindings we care about from the store
            var props = window.HaxStore.instance.elementList[node.tagName.toLowerCase()]; // translate key name to array position

            var propSettings = props.settings[this.formKey].filter(function (n) {
              if (babelHelpers.typeof(n.attribute) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
                return n.attribute === path;
              } else if (babelHelpers.typeof(n.property) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
                return n.property === path;
              } else if (babelHelpers.typeof(n.slot) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
                return n.slot === path;
              }
            }); // ensure we have anything before moving forward (usually we will)

            if (propSettings.length > 0) {
              var propData = propSettings.pop();

              if (propData.attribute) {
                var attributeName = window.HaxStore.camelToDash(propData.attribute); // special supporting for boolean because html is weird :p

                if (valueChange[path] === true) {
                  node.setAttribute(attributeName, attributeName);
                } else if (valueChange[path] === false) {
                  node.removeAttribute(attributeName);
                } else {
                  // special support for innerText which is an html attribute...sorta
                  if (attributeName === "inner-text") {
                    node.innerText = valueChange[path];
                    node.removeAttribute("innertext");
                  } else if (valueChange[path] !== null && valueChange[path] !== "null") {
                    node.setAttribute(attributeName, valueChange[path]);
                  }
                }

                this.activeHaxElement.properties[propData.attribute] = valueChange[path];
              } else if (propData.property) {
                if (valueChange[path] === true || valueChange[path] === false) {
                  node[propData.property] = valueChange[path];
                } else {
                  // account for a splice because... ugh
                  if (valueChange[path] != null && valueChange[path].indexSplices && valueChange[path].indexSplices[0]) {
                    // dirty check, if this is a vanillaJS element w/ array splices
                    // it might get PO'ed but time will tell
                    // @notice polymer specific
                    if (typeof node.set === "function") {
                      node.set(propData.property, valueChange[path].indexSplices[0].object);
                      node.notifyPath(propData.property + ".*");
                    } else {
                      node[propData.property] = valueChange[path].indexSplices[0].object;
                    }
                  } // account for Array based values on initial set
                  else if (valueChange[path] != null && valueChange[path].constructor === Array) {
                      // look for polymer setter to notify paths correctly
                      if (typeof node.set === "function") {
                        node.set(propData.property, window.HaxStore.toArray(valueChange[path]));
                      } else {
                        node[propData.property] = window.HaxStore.toArray(valueChange[path]);
                      }
                    } else {
                      if (typeof node.set === "function") {
                        node.set(propData.property, valueChange[path]);
                      } else {
                        node[propData.property] = valueChange[path];
                      }
                    }
                }

                this.activeHaxElement.properties[propData.property] = valueChange[path];
              } else if (babelHelpers.typeof(propData.slot) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
                var slotTag = "span";

                if (propData.slotWrapper) {
                  slotTag = propData.slotWrapper;
                } else if (node.tagName.toLowerCase() === "code-editor") {
                  slotTag = "template";
                }

                var tmpel = document.createElement(slotTag);

                if (propData.slotAttributes) {
                  for (var attr in propData.slotAttributes) {
                    tmpel.setAttribute(attr, propData.slotAttributes[attr]);
                  }
                } // support unnamed slots


                if (propData.slot !== "") {
                  tmpel.slot = propData.slot;
                }

                tmpel.innerHTML = valueChange[path];
                var cloneIt = tmpel.cloneNode(true); // inject the slotted content but use text nodes if this is a text element

                if (window.HaxStore.instance.isTextElement(node)) {
                  node.innerHTML = tmpel.innerHTML;
                } else {
                  // wipe just the slot in question
                  (0, _utils.wipeSlot)(node, propData.slot);
                  node.appendChild(cloneIt);
                }

                this.activeHaxElement.content = "<template>" + cloneIt.outerHTML + "</template>";
              }
            }
          }
        }
      }
      /**
       * Editor mode changed handler
       */

    }, {
      key: "_editorModeChanged",
      value: function _editorModeChanged(mode) {
        if (mode) {
          // if it's the advanced setting then toggle the advancedForm setting
          if (mode === "advanced") {
            this.advancedForm = true;
          } else {
            this.advancedForm = false;
          }
        }
      }
    }], [{
      key: "tag",
      get: function get() {
        return "hax-preview";
      }
    }, {
      key: "properties",
      get: function get() {
        return {
          responsiveWidth: {
            type: String,
            attribute: "responsive-width"
          },
          orientation: {
            type: String
          },
          orientationDirection: {
            type: String,
            attribute: "orientation-direction"
          },

          /**
           * A reference to the previewNode so we can do data binding correctly.
           */
          previewNode: {
            type: Object
          },

          /**
           * Returned value from the form input.
           */
          value: {
            type: Object
          },

          /**
           * State of mode tabs.
           */
          modeTab: {
            type: String
          },

          /**
           * Edit title since it can change based on the operation
           */
          editTitle: {
            type: String
          },

          /**
           * The element to work against expressing the structure of the DOM element
           * to create in the preview area.
           */
          activeHaxElement: {
            type: Object
          },

          /**
           * Boolean association for a preview node existing.
           */
          haspreviewNode: {
            type: Boolean
          },

          /**
           * JSON Schema.
           */
          schema: {
            type: Object
          },

          /**
           * If this is the advancedForm or not. Default to not but slider allows
           * switching mode for the form to be presented.
           */
          advancedForm: {
            type: Boolean
          },

          /**
           * If we should show source view or not.
           */
          canEditSource: {
            type: Boolean,
            attribute: "can-edit-source"
          },

          /**
           * Form key from hax to target.
           */
          formKey: {
            type: String,
            attribute: "form-key"
          },

          /**
           * Active Name from the properties
           */
          humanName: {
            type: String
          }
        };
      }
    }]);
    return HaxPreview;
  }((0, _utils.winEventsElement)(_litElement.LitElement));

  _exports.HaxPreview = HaxPreview;
  window.customElements.define(HaxPreview.tag, HaxPreview);
});