define(["exports", "require", "../../../@polymer/polymer/polymer-element.js", "../../../@polymer/polymer/lib/legacy/polymer.dom.js", "./haxutils.js", "../../../@polymer/iron-media-query/iron-media-query.js", "../../simple-colors/simple-colors.js", "./hax-shared-styles.js"], function (_exports, _require, _polymerElement, _polymerDom, _haxutils, _ironMediaQuery, _simpleColors, _haxSharedStyles) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.HaxPreview = void 0;
  _require = babelHelpers.interopRequireWildcard(_require);

  function _templateObject_dfa63cd0e53211e9a0cfefb808989d41() {
    var data = babelHelpers.taggedTemplateLiteral(["\n      <style include=\"simple-colors-shared-styles\">\n        hax-shared-styles\">\n                :host {\n                  display: block;\n                  background-color: #ffffff;\n                  overflow: hidden;\n                }\n                iron-icon:not(:defined),\n                paper-button:not(:defined) {\n                  display: none;\n                }\n                paper-card.form-wrapper {\n                  margin: 0;\n                  padding: 0 16px 80px 16px;\n                  width: 100%;\n                  min-height: 160px;\n                  background-color: transparent;\n                  overflow: auto;\n                  height: 100%;\n                }\n\n                vaadin-split-layout {\n                  display: flex;\n                  justify-content: space-around;\n                  height: 100%;\n                }\n                eco-json-schema-object {\n                  width: 50%;\n                }\n\n                .vaadin-split-layout-panel {\n                  flex: 1 1 auto;\n                  width: 100%;\n                  flex-wrap: nowrap;\n                  margin: 0;\n                  height: 100%;\n                  overflow: hidden;\n                }\n                #form {\n                  --eco-json-schema-object-form: {\n                    display: block !important;\n                  }\n                }\n                #preview {\n                  padding: 16px;\n                  color: #000000;\n                  background-color: white;\n                  max-height: 63vh;\n                  overflow: scroll;\n                }\n                #preview ::slotted(*) {\n                  float: unset !important;\n                  margin: unset !important;\n                  width: unset !important;\n                  position: unset !important;\n                  top: unset !important;\n                  left: unset !important;\n                  right: unset !important;\n                  bottom: unset !important;\n                }\n                .preview-text {\n                  font-size: 14px;\n                  color: var(--hax-color-text);\n                  font-style: italic;\n                  width: 100%;\n                  height: 24px;\n                  border-bottom: 1px solid var(--hax-color-border-outline);\n                  text-align: center;\n                  padding: 8px 0;\n                  box-sizing: content-box;\n                }\n                .preview-text iron-icon {\n                  margin: 0 8px;\n                  display: inline-block;\n                }\n                .preview-text-bottom {\n                  border-bottom: unset;\n                  border-top: 1px solid var(--hax-color-border-outline);\n                }\n                @media screen and (max-width: 550px) {\n                  .hide-on-mobile {\n                    opacity: 0;\n                    visibility: hidden;\n                    position: absolute;\n                    left: -9999px;\n                  }\n                }\n\n                #modetabs {\n                  height: 64px;\n                  padding: 0px;\n                  margin: 16px 0 0 0;\n                  box-sizing: content-box;\n                  color: var(--hax-color-text);\n                  text-align: center;\n                  background-color: transparent;\n                  border-bottom: 1px solid var(--hax-color-border-outline);\n                  display: block;\n                  justify-content: space-evenly;\n                  --paper-tabs-selection-bar-color: var(--hax-color-accent1);\n                  --paper-tabs: {\n                    background: transparent;\n                  }\n                }\n\n                #modetabs paper-tab {\n                  display: inline-flex;\n                  height: 100%;\n                  --paper-tab-ink: var(--hax-color-accent1);\n                  --paper-tab: {\n                    font-size: 16px;\n                  }\n                }\n                #modetabs paper-tab paper-button {\n                  min-width: unset;\n                  width: 100%;\n                  background-color: var(--hax-preview-button-bg, white);\n                  color: var(--hax-preview-button-color, black);\n                }\n                .preview-buttons {\n                  height: 64px;\n                  padding: 0px;\n                  color: var(--hax-color-text);\n                  border-bottom: 1px solid var(--hax-color-border-outline);\n                  background-color: transparent;\n                  margin: 16px 0 0 0;\n                  text-align: center;\n                  box-sizing: content-box;\n                }\n                eco-json-schema-object {\n                  --eco-json-field-margin: var(--hax-field-margin, 0 0 4px);\n                  color: var(--hax-text-color);\n                  --eco-json-schema-object-form : {\n                    -ms-flex: unset;\n                    -webkit-flex: unset;\n                    flex: unset;\n                    -webkit-flex-basis: unset;\n                    flex-basis: unset;\n                  }\n                }\n                .preview-buttons paper-button {\n                  min-width: unset;\n                  width: 40%;\n                  color: var(--hax-preview-button-color, black);\n                  display: inline-block;\n                  background-color: var(--hax-preview-button-bg, white);\n                }\n                #insert {\n                  background-color: var(--hax-preview-insert-button-bg, --hax-preview-button-bg);\n                }\n                #cancel {\n                  background-color: var(--hax-preview-cancel-button-bg, --hax-preview-button-bg);\n                }\n                .vaadin-layout-width {\n                  min-width: 30%;\n                  width: 50%;\n                  max-width: 70%;\n                }\n                .vaadin-layout-height {\n                  min-height: 40%;\n                  height: 50%;\n                  max-height: 60%;\n                }\n      </style>\n      <vaadin-split-layout class=\"panel-wrapper\" orientation=\"[[orientation]]\">\n        <div\n          id=\"ppanel1\"\n          class$=\"vaadin-split-layout-panel vaadin-layout-[[orientationDirection]]\"\n        >\n          <div class=\"preview-buttons\">\n            <paper-button id=\"insert\" raised on-click=\"insert\"\n              >[[editTitle]]</paper-button\n            >\n            <paper-button id=\"cancel\" raised on-click=\"cancel\"\n              >Cancel</paper-button\n            >\n          </div>\n          <div class=\"preview-text hide-on-mobile\">\n            <iron-icon icon=\"icons:arrow-drop-down\"></iron-icon\n            ><iron-icon icon=\"icons:arrow-drop-down\"></iron-icon\n            ><iron-icon icon=\"icons:arrow-drop-down\"></iron-icon>[[humanName]]\n            preview<iron-icon icon=\"icons:arrow-drop-down\"></iron-icon\n            ><iron-icon icon=\"icons:arrow-drop-down\"></iron-icon\n            ><iron-icon icon=\"icons:arrow-drop-down\"></iron-icon>\n          </div>\n          <div id=\"preview\"><slot></slot></div>\n          <div class=\"preview-text preview-text-bottom hide-on-mobile\">\n            <iron-icon icon=\"icons:arrow-drop-up\"></iron-icon\n            ><iron-icon icon=\"icons:arrow-drop-up\"></iron-icon\n            ><iron-icon icon=\"icons:arrow-drop-up\"></iron-icon>end\n            preview<iron-icon icon=\"icons:arrow-drop-up\"></iron-icon\n            ><iron-icon icon=\"icons:arrow-drop-up\"></iron-icon\n            ><iron-icon icon=\"icons:arrow-drop-up\"></iron-icon>\n          </div>\n        </div>\n        <div\n          id=\"ppanel2\"\n          class$=\"vaadin-split-layout-panel vaadin-layout-[[orientationDirection]]\"\n        >\n          <paper-tabs\n            hidden$=\"[[!haspreviewNode]]\"\n            id=\"modetabs\"\n            selected=\"{{modeTab}}\"\n            attr-for-selected=\"data-mode\"\n          >\n            <paper-tab id=\"configurebutton\" data-mode=\"configure\"\n              ><paper-button raised=\"\" noink=\"\"\n                >Configure</paper-button\n              ></paper-tab\n            >\n            <paper-tab id=\"advancedbutton\" data-mode=\"advanced\"\n              ><paper-button raised=\"\" noink=\"\"\n                >Advanced</paper-button\n              ></paper-tab\n            >\n          </paper-tabs>\n          <paper-card class=\"form-wrapper\">\n            <eco-json-schema-object\n              id=\"form\"\n              schema=\"[[schema]]\"\n              value=\"{{value}}\"\n            ></eco-json-schema-object>\n          </paper-card>\n        </div>\n      </vaadin-split-layout>\n      <iron-media-query\n        query=\"[[_computeMediaQuery(responsiveWidth)]]\"\n        on-query-matches-changed=\"_onQueryMatchesChanged\"\n      ></iron-media-query>\n    "], ["\n      <style include=\"simple-colors-shared-styles\">\n        hax-shared-styles\">\n                :host {\n                  display: block;\n                  background-color: #ffffff;\n                  overflow: hidden;\n                }\n                iron-icon:not(:defined),\n                paper-button:not(:defined) {\n                  display: none;\n                }\n                paper-card.form-wrapper {\n                  margin: 0;\n                  padding: 0 16px 80px 16px;\n                  width: 100%;\n                  min-height: 160px;\n                  background-color: transparent;\n                  overflow: auto;\n                  height: 100%;\n                }\n\n                vaadin-split-layout {\n                  display: flex;\n                  justify-content: space-around;\n                  height: 100%;\n                }\n                eco-json-schema-object {\n                  width: 50%;\n                }\n\n                .vaadin-split-layout-panel {\n                  flex: 1 1 auto;\n                  width: 100%;\n                  flex-wrap: nowrap;\n                  margin: 0;\n                  height: 100%;\n                  overflow: hidden;\n                }\n                #form {\n                  --eco-json-schema-object-form: {\n                    display: block !important;\n                  }\n                }\n                #preview {\n                  padding: 16px;\n                  color: #000000;\n                  background-color: white;\n                  max-height: 63vh;\n                  overflow: scroll;\n                }\n                #preview ::slotted(*) {\n                  float: unset !important;\n                  margin: unset !important;\n                  width: unset !important;\n                  position: unset !important;\n                  top: unset !important;\n                  left: unset !important;\n                  right: unset !important;\n                  bottom: unset !important;\n                }\n                .preview-text {\n                  font-size: 14px;\n                  color: var(--hax-color-text);\n                  font-style: italic;\n                  width: 100%;\n                  height: 24px;\n                  border-bottom: 1px solid var(--hax-color-border-outline);\n                  text-align: center;\n                  padding: 8px 0;\n                  box-sizing: content-box;\n                }\n                .preview-text iron-icon {\n                  margin: 0 8px;\n                  display: inline-block;\n                }\n                .preview-text-bottom {\n                  border-bottom: unset;\n                  border-top: 1px solid var(--hax-color-border-outline);\n                }\n                @media screen and (max-width: 550px) {\n                  .hide-on-mobile {\n                    opacity: 0;\n                    visibility: hidden;\n                    position: absolute;\n                    left: -9999px;\n                  }\n                }\n\n                #modetabs {\n                  height: 64px;\n                  padding: 0px;\n                  margin: 16px 0 0 0;\n                  box-sizing: content-box;\n                  color: var(--hax-color-text);\n                  text-align: center;\n                  background-color: transparent;\n                  border-bottom: 1px solid var(--hax-color-border-outline);\n                  display: block;\n                  justify-content: space-evenly;\n                  --paper-tabs-selection-bar-color: var(--hax-color-accent1);\n                  --paper-tabs: {\n                    background: transparent;\n                  }\n                }\n\n                #modetabs paper-tab {\n                  display: inline-flex;\n                  height: 100%;\n                  --paper-tab-ink: var(--hax-color-accent1);\n                  --paper-tab: {\n                    font-size: 16px;\n                  }\n                }\n                #modetabs paper-tab paper-button {\n                  min-width: unset;\n                  width: 100%;\n                  background-color: var(--hax-preview-button-bg, white);\n                  color: var(--hax-preview-button-color, black);\n                }\n                .preview-buttons {\n                  height: 64px;\n                  padding: 0px;\n                  color: var(--hax-color-text);\n                  border-bottom: 1px solid var(--hax-color-border-outline);\n                  background-color: transparent;\n                  margin: 16px 0 0 0;\n                  text-align: center;\n                  box-sizing: content-box;\n                }\n                eco-json-schema-object {\n                  --eco-json-field-margin: var(--hax-field-margin, 0 0 4px);\n                  color: var(--hax-text-color);\n                  --eco-json-schema-object-form : {\n                    -ms-flex: unset;\n                    -webkit-flex: unset;\n                    flex: unset;\n                    -webkit-flex-basis: unset;\n                    flex-basis: unset;\n                  }\n                }\n                .preview-buttons paper-button {\n                  min-width: unset;\n                  width: 40%;\n                  color: var(--hax-preview-button-color, black);\n                  display: inline-block;\n                  background-color: var(--hax-preview-button-bg, white);\n                }\n                #insert {\n                  background-color: var(--hax-preview-insert-button-bg, --hax-preview-button-bg);\n                }\n                #cancel {\n                  background-color: var(--hax-preview-cancel-button-bg, --hax-preview-button-bg);\n                }\n                .vaadin-layout-width {\n                  min-width: 30%;\n                  width: 50%;\n                  max-width: 70%;\n                }\n                .vaadin-layout-height {\n                  min-height: 40%;\n                  height: 50%;\n                  max-height: 60%;\n                }\n      </style>\n      <vaadin-split-layout class=\"panel-wrapper\" orientation=\"[[orientation]]\">\n        <div\n          id=\"ppanel1\"\n          class$=\"vaadin-split-layout-panel vaadin-layout-[[orientationDirection]]\"\n        >\n          <div class=\"preview-buttons\">\n            <paper-button id=\"insert\" raised on-click=\"insert\"\n              >[[editTitle]]</paper-button\n            >\n            <paper-button id=\"cancel\" raised on-click=\"cancel\"\n              >Cancel</paper-button\n            >\n          </div>\n          <div class=\"preview-text hide-on-mobile\">\n            <iron-icon icon=\"icons:arrow-drop-down\"></iron-icon\n            ><iron-icon icon=\"icons:arrow-drop-down\"></iron-icon\n            ><iron-icon icon=\"icons:arrow-drop-down\"></iron-icon>[[humanName]]\n            preview<iron-icon icon=\"icons:arrow-drop-down\"></iron-icon\n            ><iron-icon icon=\"icons:arrow-drop-down\"></iron-icon\n            ><iron-icon icon=\"icons:arrow-drop-down\"></iron-icon>\n          </div>\n          <div id=\"preview\"><slot></slot></div>\n          <div class=\"preview-text preview-text-bottom hide-on-mobile\">\n            <iron-icon icon=\"icons:arrow-drop-up\"></iron-icon\n            ><iron-icon icon=\"icons:arrow-drop-up\"></iron-icon\n            ><iron-icon icon=\"icons:arrow-drop-up\"></iron-icon>end\n            preview<iron-icon icon=\"icons:arrow-drop-up\"></iron-icon\n            ><iron-icon icon=\"icons:arrow-drop-up\"></iron-icon\n            ><iron-icon icon=\"icons:arrow-drop-up\"></iron-icon>\n          </div>\n        </div>\n        <div\n          id=\"ppanel2\"\n          class$=\"vaadin-split-layout-panel vaadin-layout-[[orientationDirection]]\"\n        >\n          <paper-tabs\n            hidden\\$=\"[[!haspreviewNode]]\"\n            id=\"modetabs\"\n            selected=\"{{modeTab}}\"\n            attr-for-selected=\"data-mode\"\n          >\n            <paper-tab id=\"configurebutton\" data-mode=\"configure\"\n              ><paper-button raised=\"\" noink=\"\"\n                >Configure</paper-button\n              ></paper-tab\n            >\n            <paper-tab id=\"advancedbutton\" data-mode=\"advanced\"\n              ><paper-button raised=\"\" noink=\"\"\n                >Advanced</paper-button\n              ></paper-tab\n            >\n          </paper-tabs>\n          <paper-card class=\"form-wrapper\">\n            <eco-json-schema-object\n              id=\"form\"\n              schema=\"[[schema]]\"\n              value=\"{{value}}\"\n            ></eco-json-schema-object>\n          </paper-card>\n        </div>\n      </vaadin-split-layout>\n      <iron-media-query\n        query=\"[[_computeMediaQuery(responsiveWidth)]]\"\n        on-query-matches-changed=\"_onQueryMatchesChanged\"\n      ></iron-media-query>\n    "]);

    _templateObject_dfa63cd0e53211e9a0cfefb808989d41 = function _templateObject_dfa63cd0e53211e9a0cfefb808989d41() {
      return data;
    };

    return data;
  }

  /**
   * `hax-preview`
   * `An element that can generate a form`
   * @microcopy - the mental model for this element
   *  - element - the element to work against. an object that expresses enough information to create an element in the DOM. This is useful for remixing a tag via the json-form
   *  - source - a json object from some place loaded in remotely which will then be in json-schema format. This will then be parsed into a form which can be used to manipulate the element.
   */
  var HaxPreview =
  /*#__PURE__*/
  function (_PolymerElement) {
    babelHelpers.inherits(HaxPreview, _PolymerElement);

    function HaxPreview() {
      var _this;

      babelHelpers.classCallCheck(this, HaxPreview);
      _this = babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(HaxPreview).call(this));
      new Promise(function (res, rej) {
        return _require.default(["../../../@polymer/paper-card/paper-card.js"], res, rej);
      });
      new Promise(function (res, rej) {
        return _require.default(["../../../@polymer/paper-tabs/paper-tabs.js"], res, rej);
      });
      new Promise(function (res, rej) {
        return _require.default(["../../../@polymer/paper-tabs/paper-tab.js"], res, rej);
      });
      new Promise(function (res, rej) {
        return _require.default(["../../../@polymer/paper-button/paper-button.js"], res, rej);
      });
      new Promise(function (res, rej) {
        return _require.default(["../../../@polymer/iron-icons/iron-icons.js"], res, rej);
      });
      new Promise(function (res, rej) {
        return _require.default(["../../../@vaadin/vaadin-split-layout/vaadin-split-layout.js"], res, rej);
      });
      new Promise(function (res, rej) {
        return _require.default(["../../eco-json-schema-form/eco-json-schema-form.js"], res, rej);
      });
      new Promise(function (res, rej) {
        return _require.default(["../../code-editor/code-editor.js"], res, rej);
      });
      new Promise(function (res, rej) {
        return _require.default(["../../../@polymer/paper-input/paper-textarea.js"], res, rej);
      });
      new Promise(function (res, rej) {
        return _require.default(["../../../app-datepicker/app-datepicker.js"], res, rej);
      });
      new Promise(function (res, rej) {
        return _require.default(["../../../@polymer/paper-toggle-button/paper-toggle-button.js"], res, rej);
      });
      new Promise(function (res, rej) {
        return _require.default(["./hax-upload-field.js"], res, rej);
      });
      new Promise(function (res, rej) {
        return _require.default(["../../simple-picker/simple-picker.js"], res, rej);
      });
      new Promise(function (res, rej) {
        return _require.default(["../../simple-icon-picker/simple-icon-picker.js"], res, rej);
      });
      new Promise(function (res, rej) {
        return _require.default(["../../paper-input-flagged/paper-input-flagged.js"], res, rej);
      });
      document.body.addEventListener("hax-store-property-updated", _this._haxStorePropertyUpdated.bind(babelHelpers.assertThisInitialized(_this)));
      return _this;
    }

    babelHelpers.createClass(HaxPreview, [{
      key: "_onQueryMatchesChanged",
      value: function _onQueryMatchesChanged(e) {
        if (e.detail.value) {
          this.orientation = "vertical";
          this.orientationDirection = "height";
        } else {
          this.orientation = "horizontal";
          this.orientationDirection = "width";
        }
      }
    }, {
      key: "_computeMediaQuery",
      value: function _computeMediaQuery(responsiveWidth) {
        return "(max-width: " + responsiveWidth + ")";
      }
      /**
       * Trigger cancel on manager as it is the parent here.
       */

    }, {
      key: "cancel",
      value: function cancel(e) {
        window.HaxStore.instance.haxManager.cancel(e);
      }
      /**
       * Trigger insert on manager as it is the parent here.
       */

    }, {
      key: "insert",
      value: function insert(e) {
        window.HaxStore.instance.haxManager.insertHaxElement(e);
      }
      /**
       * Make a boolean to match the preview node's existance.
       */

    }, {
      key: "_computedHasPreviewNode",
      value: function _computedHasPreviewNode(previewNode) {
        if (babelHelpers.typeof(previewNode.tagName) === (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
          return false;
        } else {
          return true;
        }
      }
      /**
       * Edit source.
       */

    }, {
      key: "_computedEditSource",
      value: function _computedEditSource(newValue, oldValue) {
        if (babelHelpers.typeof(newValue) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
          if (babelHelpers.typeof(this.previewNode.tagName) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && window.HaxStore.instance.elementList[this.previewNode.tagName.toLowerCase()]) {
            return window.HaxStore.instance.elementList[this.previewNode.tagName.toLowerCase()].canEditSource;
          }
        }

        return true;
      }
      /**
       * Compute form key to use.
       */

    }, {
      key: "_computedFormKey",
      value: function _computedFormKey(advanced) {
        if (advanced) {
          return "advanced";
        } else {
          return "configure";
        }
      }
      /**
       * Form key changed, rebuild schema for the form
       * but don't update the element. Critical difference.
       */

    }, {
      key: "_formKeyChanged",
      value: function _formKeyChanged(newValue, oldValue) {
        // ensure this doesn't run the 1st pass
        if (babelHelpers.typeof(oldValue) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
          var schema = {}; // see if we can get schema off of this.

          if (babelHelpers.typeof(this.previewNode) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && babelHelpers.typeof(this.previewNode.tagName) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && babelHelpers.typeof(window.HaxStore.instance.elementList[this.previewNode.tagName.toLowerCase()]) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
            var element = this.activeHaxElement;
            var props = window.HaxStore.instance.elementList[this.previewNode.tagName.toLowerCase()];

            if (typeof this.previewNode.getHaxJSONSchemaType === "function") {
              schema = window.HaxStore.instance.getHaxJSONSchema(newValue, props, this.previewNode);
            } else {
              schema = window.HaxStore.instance.getHaxJSONSchema(newValue, props);
            }

            for (var property in element.properties) {
              if (element.properties.hasOwnProperty(property)) {
                if (babelHelpers.typeof(schema.properties[property]) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
                  schema.properties[property].value = element.properties[property]; // support custom element input

                  if (babelHelpers.typeof(schema.properties[property].component) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && schema.properties[property].component.properties) {
                    schema.properties[property].component.properties.value = element.properties[property];
                  } // attempt to set the property in the preview node


                  if (property != "prefix" && element.properties[property] != null && !element.properties[property].readOnly) {
                    if (typeof this.previewNode.set === "function") {
                      // attempt to set it, should be no problem but never know
                      try {
                        this.previewNode.set(property, element.properties[property]);
                      } catch (e) {
                        console.warn("".concat(property, " is busted some how"));
                        console.warn(e);
                      }
                    } else {
                      // set attribute, this doesn't have the Polymer convention
                      // this is Vanilla, Lit, etc
                      // set is powerful though for objects and arrays so they will reflect instantly
                      this.previewNode.setAttribute(property, element.properties[property]);
                    }
                  } else if (property === "prefix") {
                    this.previewNode.setAttribute("prefix", element.properties[property]);
                  } else {
                    console.warn("".concat(property, " is busted some how"));
                  }
                }

                this.set("value." + property, element.properties[property]);
                this.notifyPath("value." + property);
              }
            }

            var slotsApplied = false;

            for (var prop in props.settings[newValue]) {
              var previewNode = this.previewNode;

              if (babelHelpers.typeof(props.settings[this.formKey][prop].slot) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && !slotsApplied) {
                slotsApplied = true; // walk through the slots looking for the value of it

                for (var i in (0, _polymerDom.dom)(previewNode).getEffectiveChildNodes()) {
                  // test for element nodes to be safe
                  if (babelHelpers.typeof((0, _polymerDom.dom)(previewNode).getEffectiveChildNodes()[i]) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && (0, _polymerDom.dom)(previewNode).getEffectiveChildNodes()[i].nodeType === 1 && (0, _polymerDom.dom)(previewNode).getEffectiveChildNodes()[i].slot === props.settings[this.formKey][prop].slot) {
                    if (babelHelpers.typeof((0, _polymerDom.dom)(previewNode).getEffectiveChildNodes()[i].innerHTML) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
                      schema.properties[props.settings[this.formKey][prop].slot].value = (0, _polymerDom.dom)(previewNode).getEffectiveChildNodes()[i].innerHTML;
                      this.set("value." + props.settings[this.formKey][prop].slot, (0, _polymerDom.dom)(previewNode).getEffectiveChildNodes()[i].innerHTML);
                      this.notifyPath("value." + props.settings[this.formKey][prop].slot);
                    }
                  }
                }
              }
            }
          }

          this.set("schema", {});
          this.set("schema", schema);
        }
      }
      /**
       * Store updated, sync.
       */

    }, {
      key: "_haxStorePropertyUpdated",
      value: function _haxStorePropertyUpdated(e) {
        if (e.detail && babelHelpers.typeof(e.detail.value) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && e.detail.property) {
          if (e.detail.property == "activeHaxElement") {
            this.set(e.detail.property, {});
            this.set(e.detail.property, e.detail.value);
          }
        }
      }
      /**
       * When the preview node is updated, pull schema associated with it
       */

    }, {
      key: "_previewNodeChanged",
      value: function _previewNodeChanged(newValue, oldValue) {
        // ensure this doesn't run the 1st pass
        if (babelHelpers.typeof(oldValue) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && newValue != oldValue) {
          // see if we can get schema off of this.
          if (babelHelpers.typeof(newValue.tagName) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && babelHelpers.typeof(window.HaxStore.instance.elementList[newValue.tagName.toLowerCase()]) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
            var element = this.activeHaxElement;
            var props = window.HaxStore.instance.elementList[newValue.tagName.toLowerCase()];
            var schema = {};

            if (typeof newValue.getHaxJSONSchemaType === "function") {
              schema = window.HaxStore.instance.getHaxJSONSchema(this.formKey, props, newValue);
            } else {
              schema = window.HaxStore.instance.getHaxJSONSchema(this.formKey, props);
            } // generate a human name for this


            if (babelHelpers.typeof(props.gizmo.title) === (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
              this.humanName = newValue.tagName.replace("-", " ").toLowerCase();
            } else {
              this.humanName = props.gizmo.title;
            } // first, allow element properties to dictate defaults


            for (var property in element.properties) {
              if (element.properties.hasOwnProperty(property)) {
                if (babelHelpers.typeof(schema.properties[property]) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
                  schema.properties[property].value = element.properties[property]; // support custom element input

                  if (babelHelpers.typeof(schema.properties[property].component) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && schema.properties[property].component.properties) {
                    schema.properties[property].component.properties.value = element.properties[property];
                  }
                } // ensure this isn't read only


                if (element.properties[property] != null && !element.properties[property].readOnly) {
                  // make sure slot is NEVER set in the preview
                  // or it'll not show up and we'll get inconsistency with it
                  // when in the context of being inserted into hax-body's shadow
                  // slot is also a special attribute
                  if (property === "slot") {
                    // temp prop we use
                    property = "data-hax-slot"; // move it over

                    element.properties[property] = element.properties["slot"]; // delete the slot

                    delete element.properties["slot"];

                    if (element.properties[property] != null) {
                      newValue.setAttribute("data-hax-slot", element.properties[property]);
                    }
                  } // prefix is a special attribute and must be handled this way
                  else if (property === "prefix") {
                      newValue.setAttribute("prefix", element.properties[property]);
                    } // set is a Polymer convention but help w/ data binding there a lot
                    else if (typeof newValue.set === "function") {
                        // just to be safe
                        try {
                          newValue.set(property, element.properties[property]);
                        } catch (e) {
                          console.warn(e);
                        }
                      } // vanilla / anything else we should just be able to set the prop
                      else {
                          // @todo may need to bind differently for vanilla elements
                          newValue.setAttribute(property, element.properties[property]);
                        }
                }

                this.set("value." + property, element.properties[property]);
                this.notifyPath("value." + property);
              }
            } // then, let the node itself dictate defaults if things are not set


            for (var property in newValue) {
              if (newValue.hasOwnProperty(property) && babelHelpers.typeof(schema.properties[property]) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && babelHelpers.typeof(newValue[property].value) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && newValue[property].value !== null) {
                schema.properties[property].value = newValue.properties[property].value; // support custom element input

                if (babelHelpers.typeof(schema.properties[property].component) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && schema.properties[property].component.properties) {
                  schema.properties[property].component.properties.value = newValue.properties[property].value;
                }

                this.set("value." + property, newValue.properties[property].value);
                this.notifyPath("value." + property);
              }
            } // need to specifically walk through slots if there is anything
            // that says it has to come from a slot


            for (var prop in props.settings[this.formKey]) {
              if (babelHelpers.typeof(props.settings[this.formKey][prop].slot) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
                // walk through the slots looking for the value of it
                for (var i in (0, _polymerDom.dom)(newValue).getEffectiveChildNodes()) {
                  // test for element nodes to be safe
                  if (babelHelpers.typeof((0, _polymerDom.dom)(newValue).getEffectiveChildNodes()[i]) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && (0, _polymerDom.dom)(newValue).getEffectiveChildNodes()[i].nodeType === 1 && (0, _polymerDom.dom)(newValue).getEffectiveChildNodes()[i].slot === props.settings[this.formKey][prop].slot) {
                    if (babelHelpers.typeof((0, _polymerDom.dom)(newValue).getEffectiveChildNodes()[i].innerHTML) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
                      schema.properties[props.settings[this.formKey][prop].slot].value = (0, _polymerDom.dom)(newValue).getEffectiveChildNodes()[i].innerHTML;
                      this.set("value." + props.settings[this.formKey][prop].slot, (0, _polymerDom.dom)(newValue).getEffectiveChildNodes()[i].innerHTML);
                      this.notifyPath("value." + props.settings[this.formKey][prop].slot);
                    }
                  }
                }
              }
            }

            this.set("schema", {});
            this.set("schema", schema);
          }
        }
      }
      /**
       * Element changed, update the preview area.
       */

    }, {
      key: "_activeHaxElementChanged",
      value: function _activeHaxElementChanged(newValue, oldValue) {
        if (babelHelpers.typeof(newValue) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
          // wipe the preview area and assocaited node
          var preview = (0, _polymerDom.dom)(this);
          (0, _haxutils.wipeSlot)(preview, "*");
          this.set("previewNode", {});
          this.modeTab = "configure"; // if we have something, generate the new element inside it

          if (newValue && newValue != null && newValue.length != 0 && newValue.tag) {
            var frag = document.createElement(newValue.tag);
            frag.innerHTML = newValue.content; // clone the fragment which will force an escalation to full node

            var newNode = frag.cloneNode(true);
            newNode.setAttribute("hax-preview-mode", "hax-preview-mode"); // if there is slot we need to shift it

            if (newNode.getAttribute("slot") != null) {
              newNode.setAttribute("data-hax-slot", newNode.getAttribute("slot"));
              newNode.removeAttribute("slot");
            } // send this into the root, which should filter it back down into the slot


            preview.appendChild(newNode); // need to let append propagate, it probably takes like no time

            this.set("previewNode", newNode);
          }
        } else {
          this.modeTab = "advanced";
          this.set("previewNode", {});
        }
      }
      /**
       * Value in the form has changed, reflect to the preview.
       */

    }, {
      key: "_valueChanged",
      value: function _valueChanged(valueChange) {
        var node = this.previewNode; // sanity check and then get props and mesh with form value response

        if (babelHelpers.typeof(node.tagName) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && babelHelpers.typeof(window.HaxStore.instance.elementList[node.tagName.toLowerCase()]) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
          for (var path in valueChange.base) {
            // load up the property bindings we care about from the store
            var props = window.HaxStore.instance.elementList[node.tagName.toLowerCase()]; // translate key name to array position

            var propSettings = props.settings[this.formKey].filter(function (n) {
              if (babelHelpers.typeof(n.attribute) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
                return n.attribute === path;
              } else if (babelHelpers.typeof(n.property) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
                return n.property === path;
              } else if (babelHelpers.typeof(n.slot) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
                return n.slot === path;
              }
            }); // ensure we have anything before moving forward (usually we will)

            if (propSettings.length > 0) {
              var propData = propSettings.pop();

              if (propData.attribute) {
                var attributeName = window.HaxStore.camelToDash(propData.attribute); // special supporting for boolean because html is weird :p

                if (valueChange.base[path] === true) {
                  node.setAttribute(attributeName, attributeName);
                } else if (valueChange.base[path] === false) {
                  node.removeAttribute(attributeName);
                } else {
                  // special support for innerText which is an html attribute...sorta
                  if (attributeName === "inner-text") {
                    node.innerText = valueChange.base[path];
                    node.removeAttribute("innertext");
                  } else if (valueChange.base[path] !== null && valueChange.base[path] !== "null") {
                    node.setAttribute(attributeName, valueChange.base[path]);
                  }
                }

                this.set("element.properties." + propData.attribute, valueChange.base[path]);
                this.notifyPath("element.properties." + propData.attribute);
              } else if (propData.property) {
                if (valueChange.base[path] === true || valueChange.base[path] === false) {
                  node[propData.property] = valueChange.base[path];
                } else {
                  // account for a splice because... ugh
                  if (valueChange.base[path] != null && valueChange.base[path].indexSplices && valueChange.base[path].indexSplices[0]) {
                    // dirty check, if this is a vanillaJS element w/ array splices
                    // it might get PO'ed but time will tell
                    if (typeof node.set === "function") {
                      node.set(propData.property, valueChange.base[path].indexSplices[0].object);
                      node.notifyPath(propData.property + ".*");
                    } else {
                      node[propData.property] = valueChange.base[path].indexSplices[0].object;
                    }
                  } // account for Array based values on initial set
                  else if (valueChange.base[path] != null && valueChange.base[path].constructor === Array) {
                      // look for polymer setter to notify paths correctly
                      if (typeof node.set === "function") {
                        node.set(propData.property, window.HaxStore.toArray(valueChange.base[path]));
                      } else {
                        node[propData.property] = window.HaxStore.toArray(valueChange.base[path]);
                      }
                    } else {
                      if (typeof node.set === "function") {
                        node.set(propData.property, valueChange.base[path]);
                      } else {
                        node[propData.property] = valueChange.base[path];
                      }
                    }
                }

                this.set("element.properties." + propData.property, valueChange.base[path]);
                this.notifyPath("element.properties." + propData.property);
              } else if (babelHelpers.typeof(propData.slot) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
                var slotTag = "span";

                if (propData.slotWrapper) {
                  slotTag = propData.slotWrapper;
                } else if (node.tagName.toLowerCase() === "code-editor") {
                  slotTag = "template";
                }

                var tmpel = document.createElement(slotTag);

                if (propData.slotAttributes) {
                  for (var attr in propData.slotAttributes) {
                    tmpel.setAttribute(attr, propData.slotAttributes[attr]);
                  }
                } // support unnamed slots


                if (propData.slot !== "") {
                  tmpel.slot = propData.slot;
                }

                tmpel.innerHTML = valueChange.base[path];
                var cloneIt = tmpel.cloneNode(true); // inject the slotted content but use text nodes if this is a text element

                if (window.HaxStore.instance.isTextElement(node)) {
                  node.innerHTML = tmpel.innerHTML;
                } else {
                  // wipe just the slot in question
                  (0, _haxutils.wipeSlot)(node, propData.slot);
                  (0, _polymerDom.dom)(node).appendChild(cloneIt);
                }

                this.set("element.content", "<template>" + cloneIt.outerHTML + "</template>");
                this.notifyPath("element.content");
              }
            }
          }
        }
      }
      /**
       * Editor mode changed handler
       */

    }, {
      key: "_editorModeChanged",
      value: function _editorModeChanged(mode) {
        if (mode) {
          // if it's the advanced setting then toggle the advancedForm setting
          if (mode === "advanced") {
            this.advancedForm = true;
          } else {
            this.advancedForm = false;
          }
        }
      }
    }], [{
      key: "template",
      get: function get() {
        return (0, _polymerElement.html)(_templateObject_dfa63cd0e53211e9a0cfefb808989d41());
      }
    }, {
      key: "tag",
      get: function get() {
        return "hax-preview";
      }
    }, {
      key: "observers",
      get: function get() {
        return ["_valueChanged(value.*)"];
      }
    }, {
      key: "properties",
      get: function get() {
        return {
          responsiveWidth: {
            type: String,
            value: "800px"
          },
          orientation: {
            type: String,
            value: "horizontal"
          },
          orientationDirection: {
            type: String,
            value: "width"
          },

          /**
           * A reference to the previewNode so we can do data binding correctly.
           */
          previewNode: {
            type: Object,
            value: {},
            notify: true,
            observer: "_previewNodeChanged"
          },

          /**
           * Returned value from the form input.
           */
          value: {
            type: Object,
            notify: true,
            value: {}
          },

          /**
           * State of mode tabs.
           */
          modeTab: {
            type: String,
            value: "configure",
            observer: "_editorModeChanged"
          },

          /**
           * Edit title since it can change based on the operation
           */
          editTitle: {
            type: String,
            value: "Update"
          },

          /**
           * The element to work against expressing the structure of the DOM element
           * to create in the preview area.
           */
          activeHaxElement: {
            type: Object,
            notify: true,
            observer: "_activeHaxElementChanged"
          },

          /**
           * Boolean association for a preview node existing.
           */
          haspreviewNode: {
            type: Boolean,
            computed: "_computedHasPreviewNode(previewNode)"
          },

          /**
           * JSON Schema.
           */
          schema: {
            type: Object,
            value: {
              schema: {}
            }
          },

          /**
           * If this is the advancedForm or not. Default to not but slider allows
           * switching mode for the form to be presented.
           */
          advancedForm: {
            type: Boolean,
            value: false
          },

          /**
           * If we should show source view or not.
           */
          canEditSource: {
            type: Boolean,
            computed: "_computedEditSource(formKey)"
          },

          /**
           * Form key from hax to target.
           */
          formKey: {
            type: String,
            computed: "_computedFormKey(advancedForm)",
            observer: "_formKeyChanged"
          },

          /**
           * Active Name from the properties
           */
          humanName: {
            type: String
          }
        };
      }
    }]);
    return HaxPreview;
  }(_polymerElement.PolymerElement);

  _exports.HaxPreview = HaxPreview;
  window.customElements.define(HaxPreview.tag, HaxPreview);
});