define(["exports","require","../../../@polymer/polymer/polymer-element.js","../../simple-colors/simple-colors.js","./hax-shared-styles.js"],function(_exports,_require,_polymerElement,_simpleColors,_haxSharedStyles){"use strict";Object.defineProperty(_exports,"__esModule",{value:!0});_exports.HaxAppSearchResult=void 0;_require=babelHelpers.interopRequireWildcard(_require);function _templateObject_9ba48df0898111e9ba38e33cad2d1624(){var data=babelHelpers.taggedTemplateLiteral(["\n      <style include=\"hax-shared-styles\">\n        :host {\n          display: inline-flex;\n          width: 50%;\n          background-color: var(--hax-color-bg-accent);\n          color: var(--hax-color-text);\n        }\n        paper-button.button {\n          margin: 0;\n          padding: 7px;\n          height: 168px;\n          border-radius: 0;\n          width: 100%;\n          border: 1px solid var(--hax-color-border-outline);\n          justify-content: flex-start;\n          background-image: none;\n          text-align: unset;\n          display: flex;\n        }\n        paper-button:hover,\n        paper-button:focus,\n        paper-button:active {\n          outline: 2px solid var(--hax-color-bg-accent1);\n        }\n        .detail-wrapper {\n          padding: 0 8px;\n          display: inline-block;\n          height: 100%;\n          width: calc(80% - 16px);\n          overflow: hidden;\n          font-family: \"Noto Serif\", serif;\n        }\n        .title {\n          font-size: 16px;\n          font-weight: bold;\n          text-transform: none;\n          padding-bottom: 4px;\n        }\n        .details {\n          height: 100px;\n          overflow: hidden;\n          font-size: 12px;\n          line-height: 16px;\n          padding: 0;\n          margin: 0;\n          text-transform: none;\n        }\n        .image {\n          display: inline-flex;\n          height: 152px;\n          width: 20%;\n          background-color: lightgray;\n        }\n        @media screen and (max-width: 1000px) {\n          :host {\n            width: 100%;\n          }\n          .title {\n            font-size: 12px;\n          }\n          .image {\n            min-width: 160px;\n            width: 160px;\n          }\n          .details {\n            font-size: 10px;\n          }\n        }\n        @media screen and (max-width: 600px) {\n          .details {\n            font-size: 8px;\n          }\n        }\n      </style>\n\n      <paper-button on-click=\"_itemSelected\" class=\"button\">\n        <iron-image\n          alt=\"\"\n          class=\"image\"\n          src=\"[[resultData.image]]\"\n          preload=\"\"\n          fade=\"\"\n          sizing=\"cover\"\n        ></iron-image>\n        <div class=\"detail-wrapper\">\n          <div class=\"title\">[[resultData.title]]</div>\n          <div class=\"details\">[[resultData.details]]</div>\n        </div>\n      </paper-button>\n    "]);_templateObject_9ba48df0898111e9ba38e33cad2d1624=function _templateObject_9ba48df0898111e9ba38e33cad2d1624(){return data};return data}/**
 * `hax-source`
 * `An element that brokers the visual display of a listing of material from an end point. The goal is to normalize data from some location which is media centric. This expects to get at least enough data in order to form a grid of items which are selectable. It's also generically implemented so that anything can be hooked up as a potential source for input (example: youtube API or custom in-house solution). The goal is to return enough info via fired event so that hax-manager can tell hax-body that the user selected a tag, properties, slot combination so that hax-body can turn the selection into a custom element / element injected into the hax-body slot.`
 */var HaxAppSearchResult=/*#__PURE__*/function(_PolymerElement){babelHelpers.inherits(HaxAppSearchResult,_PolymerElement);function HaxAppSearchResult(){var _this;babelHelpers.classCallCheck(this,HaxAppSearchResult);_this=babelHelpers.possibleConstructorReturn(this,babelHelpers.getPrototypeOf(HaxAppSearchResult).call(this));new Promise(function(res,rej){return _require.default(["../../../@polymer/iron-image/iron-image.js"],res,rej)});new Promise(function(res,rej){return _require.default(["../../../@polymer/paper-button/paper-button.js"],res,rej)});new Promise(function(res,rej){return _require.default(["../../../@polymer/paper-styles/paper-styles.js"],res,rej)});return _this}babelHelpers.createClass(HaxAppSearchResult,[{key:"_itemSelected",/**
   * Handle media item selected.
   */value:function _itemSelected(e){var map=this.resultData.map,gizmoType=this.resultData.type;// sanity check as well as guessing based on type if we absolutely have to
if((null===gizmoType||""===gizmoType)&&babelHelpers.typeof(map.source)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){gizmoType=window.HaxStore.guessGizmoType(map.source)}var haxElements=window.HaxStore.guessGizmo(gizmoType,map);// see if we got anything
if(0<haxElements.length){if(1===haxElements.length){if(babelHelpers.typeof(haxElements[0].tag)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){window.HaxStore.write("activeHaxElement",haxElements[0],this)}}else{// hand off to hax-app-picker to deal with the rest of this
window.HaxStore.instance.haxAppPicker.presentOptions(haxElements,gizmoType,"How would you like to display this "+gizmoType+"?","gizmo")}}else{window.HaxStore.toast("Sorry, I don't know how to handle that link yet.")}}}],[{key:"template",get:function get(){return(0,_polymerElement.html)(_templateObject_9ba48df0898111e9ba38e33cad2d1624())}},{key:"tag",get:function get(){return"hax-app-search-result"}},{key:"properties",get:function get(){return{/**
       * Preview object from hax-app originally.
       */resultData:{type:Object}}}}]);return HaxAppSearchResult}(_polymerElement.PolymerElement);_exports.HaxAppSearchResult=HaxAppSearchResult;window.customElements.define(HaxAppSearchResult.tag,HaxAppSearchResult)});