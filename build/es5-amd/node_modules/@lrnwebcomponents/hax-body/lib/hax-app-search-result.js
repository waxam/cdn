define(["exports", "require", "../../../lit-element/lit-element.js"], function (_exports, _require, _litElement) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.HaxAppSearchResult = void 0;
  _require = babelHelpers.interopRequireWildcard(_require);

  function _templateObject2_67d6e2e0d34d11ea880ba1e93364c49c() {
    var data = babelHelpers.taggedTemplateLiteral(["\n        :host {\n          display: inline-flex;\n          width: 49%;\n          height: 220px;\n          background-color: var(--hax-color-bg-accent);\n          color: var(--hax-color-text);\n        }\n        paper-button.button {\n          margin: 0;\n          padding: 7px;\n          display: block;\n          border-radius: 0;\n          border: none;\n          width: 100%;\n          outline: 2px solid black;\n          background-image: none;\n          text-align: unset;\n        }\n        paper-button:hover,\n        paper-button:focus,\n        paper-button:active {\n          background-color: #eeeeee;\n          outline: 2px solid var(--hax-color-bg-accent);\n        }\n        .detail-wrapper {\n          padding: 0 8px;\n          overflow: hidden;\n          font-family: \"Noto Serif\", serif;\n        }\n        .title {\n          font-size: 14px;\n          overflow: hidden;\n          font-weight: bold;\n          text-transform: none;\n          padding-bottom: 4px;\n          text-align: center;\n        }\n        .image {\n          height: 152px;\n          width: 100%;\n          background-color: var(--simple-colors-default-theme-cyan-7, #009dc7);\n        }\n        @media screen and (max-width: 1000px) {\n          :host {\n            width: 100%;\n          }\n          .title {\n            font-size: 12px;\n          }\n        }\n      "]);

    _templateObject2_67d6e2e0d34d11ea880ba1e93364c49c = function _templateObject2_67d6e2e0d34d11ea880ba1e93364c49c() {
      return data;
    };

    return data;
  }

  function _templateObject_67d6e2e0d34d11ea880ba1e93364c49c() {
    var data = babelHelpers.taggedTemplateLiteral(["\n      <paper-button\n        draggable=\"true\"\n        @click=\"", "\"\n        @dragstart=\"", "\"\n        @dragend=\"", "\"\n        class=\"button\"\n        title=\"", "\"\n      >\n        <iron-image\n          alt=\"\"\n          class=\"image\"\n          src=\"", "\"\n          preload=\"\"\n          fade=\"\"\n          sizing=\"cover\"\n        ></iron-image>\n        <div class=\"detail-wrapper\">\n          <div class=\"title\">", "</div>\n        </div>\n      </paper-button>\n    "]);

    _templateObject_67d6e2e0d34d11ea880ba1e93364c49c = function _templateObject_67d6e2e0d34d11ea880ba1e93364c49c() {
      return data;
    };

    return data;
  }

  /**
   * `hax-source`
   * @element hax-source
   * `An element that brokers the visual display of a listing of material from an end point. The goal is to normalize data from some location which is media centric. This expects to get at least enough data in order to form a grid of items which are selectable. It's also generically implemented so that anything can be hooked up as a potential source for input (example: youtube API or custom in-house solution). The goal is to return enough info via fired event so that we can tell hax-body that the user selected a tag, properties, slot combination so that hax-body can turn the selection into a custom element / element injected into the hax-body slot.`
   */
  var HaxAppSearchResult =
  /*#__PURE__*/
  function (_LitElement) {
    babelHelpers.inherits(HaxAppSearchResult, _LitElement);

    function HaxAppSearchResult() {
      var _this;

      babelHelpers.classCallCheck(this, HaxAppSearchResult);
      _this = babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(HaxAppSearchResult).call(this));
      new Promise(function (res, rej) {
        return _require.default(["../../../@polymer/iron-image/iron-image.js"], res, rej);
      });
      new Promise(function (res, rej) {
        return _require.default(["../../../@polymer/paper-button/paper-button.js"], res, rej);
      });
      new Promise(function (res, rej) {
        return _require.default(["../../../@polymer/paper-styles/paper-styles.js"], res, rej);
      });
      return _this;
    }

    babelHelpers.createClass(HaxAppSearchResult, [{
      key: "render",
      value: function render() {
        return (0, _litElement.html)(_templateObject_67d6e2e0d34d11ea880ba1e93364c49c(), this._itemSelected, this._dragStart, this._dragEnd, this.details, this.image, this.title.substr(0, 40));
      }
    }, {
      key: "_dragStart",

      /**
       * Drag start so we know what target to set
       */
      value: function _dragStart(e) {
        // create the tag
        var target = this.cloneNode(true);
        window.HaxStore.instance.__dragTarget = target;

        if (e.dataTransfer) {
          this.crt = target;
          this.crt.style.position = "absolute";
          this.crt.style.top = "-1000px";
          this.crt.style.right = "-1000px";
          this.crt.style.transform = "scale(0.25)";
          this.crt.style.opacity = ".8";
          e.dataTransfer.dropEffect = "move";
          document.body.appendChild(this.crt);
          e.dataTransfer.setDragImage(this.crt, 0, 0);
        }

        e.stopPropagation();
        e.stopImmediatePropagation(); // show where things can be dropped only during the drag

        if (!window.HaxStore.instance.activeHaxBody.openDrawer && window.HaxStore.instance.editMode) {
          var children = window.HaxStore.instance.activeHaxBody.children; // walk the children and apply the draggable state needed

          for (var i in children) {
            if (children[i].classList && target !== children[i]) {
              children[i].classList.add("hax-mover");
            }
          }
        }
      }
      /**
       * When we end dragging ensure we remove the mover class.
       */

    }, {
      key: "_dragEnd",
      value: function _dragEnd(e) {
        var _this2 = this;

        this.crt.remove();
        setTimeout(function () {
          var children = window.HaxStore.instance.activeHaxBody.querySelectorAll(".hax-mover, .hax-hovered, .hax-moving, .grid-plate-active-item"); // walk the children and apply the draggable state needed

          for (var i in children) {
            if (babelHelpers.typeof(children[i].classList) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
              children[i].classList.remove("hax-mover", "hax-hovered", "hax-moving", "grid-plate-active-item");
            }
          }

          setTimeout(function () {
            _this2._itemSelected(e);
          }, 100);
        }, 0);
      }
      /**
       * Handle media item selected.
       */

    }, {
      key: "_itemSelected",
      value: function _itemSelected(e) {
        var map = this.map;
        var gizmoType = this.type; // sanity check as well as guessing based on type if we absolutely have to

        if ((!gizmoType || gizmoType == null || gizmoType == "" || gizmoType == "undefined") && map.source) {
          gizmoType = window.HaxStore.guessGizmoType(map);
        }

        var haxElements = window.HaxStore.guessGizmo(gizmoType, map, false, true); // see if we got anything

        if (haxElements.length > 0) {
          if (haxElements.length === 1) {
            if (babelHelpers.typeof(haxElements[0].tag) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
              this.dispatchEvent(new CustomEvent("hax-insert-content", {
                bubbles: true,
                cancelable: true,
                composed: true,
                detail: haxElements[0]
              }));
            }
          } else {
            // hand off to hax-app-picker to deal with the rest of this
            window.HaxStore.instance.haxAppPicker.presentOptions(haxElements, gizmoType, "How would you like to display this " + gizmoType + "?", "gizmo");
          }
        } else {
          window.HaxStore.toast("Sorry, HAX can't handle that link yet.");
        }
      }
    }], [{
      key: "styles",
      get: function get() {
        return [(0, _litElement.css)(_templateObject2_67d6e2e0d34d11ea880ba1e93364c49c())];
      }
    }, {
      key: "tag",
      get: function get() {
        return "hax-app-search-result";
      }
    }, {
      key: "properties",
      get: function get() {
        return {
          image: {
            type: String
          },
          title: {
            type: String
          },
          details: {
            type: String
          },
          map: {
            type: Object
          },
          type: {
            type: String
          }
        };
      }
    }]);
    return HaxAppSearchResult;
  }(_litElement.LitElement);

  _exports.HaxAppSearchResult = HaxAppSearchResult;
  window.customElements.define(HaxAppSearchResult.tag, HaxAppSearchResult);
});