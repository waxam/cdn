define(["exports", "../../../lit-element/lit-element.js", "../../simple-fields/simple-fields.js", "../../hax-body-behaviors/lib/HAXFields.js"], function (_exports, _litElement, _simpleFields, _HAXFields) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.HaxAppSearchInputs = void 0;

  function _templateObject2_8ddafb40552d11ebb4022f4768b4777e() {
    var data = babelHelpers.taggedTemplateLiteral(["\n      <div class=\"search-label\">Search ", "</div>\n      <simple-fields\n        id=\"form\"\n        .schema=\"", "\"\n        .schematizer=\"", "\"\n        .elementizer=\"", "\"\n        @value-changed=\"", "\"\n      ></simple-fields>\n    "]);

    _templateObject2_8ddafb40552d11ebb4022f4768b4777e = function _templateObject2_8ddafb40552d11ebb4022f4768b4777e() {
      return data;
    };

    return data;
  }

  function _templateObject_8ddafb40552d11ebb4022f4768b4777e() {
    var data = babelHelpers.taggedTemplateLiteral(["\n        :host {\n          display: block;\n        }\n        simple-fields {\n          color: var(--hax-color-text, #000000);\n        }\n        .search-label {\n          font-size: 24px;\n          color: var(--hax-color-text, #000000);\n          font-weight: bold;\n          margin: 0;\n          padding: 0;\n        }\n      "]);

    _templateObject_8ddafb40552d11ebb4022f4768b4777e = function _templateObject_8ddafb40552d11ebb4022f4768b4777e() {
      return data;
    };

    return data;
  }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  /**
  `hax-app-search-inputs`
   An element that brokers the visual display of a listing of material from an end point. The goal is to normalize data from some location which is media centric. This expects to get at least enough data in order to form a grid of items which are selectable. It's also generically implemented so that anything can be hooked up as a potential source for input (example: youtube API or custom in-house solution). The goal is to return enough info via fired event so that we can tell hax-body that the user selected a tag, properties, slot combination so that hax-body can turn the selection into a custom element / element injected into the hax-body slot.
  
  * @demo demo/index.html
  
  @microcopy - the mental model for this element
   - hax-app - a source of input we're querying for media / content
   - hax-app-search - element controlling the experience of searching an app
   - hax-body - the text are ultimately we are trying to insert this item into
  */
  var HaxAppSearchInputs = /*#__PURE__*/function (_LitElement) {
    babelHelpers.inherits(HaxAppSearchInputs, _LitElement);

    var _super = _createSuper(HaxAppSearchInputs);

    babelHelpers.createClass(HaxAppSearchInputs, [{
      key: "updated",
      value: function updated(changedProperties) {
        var _this2 = this;

        if (babelHelpers.get(babelHelpers.getPrototypeOf(HaxAppSearchInputs.prototype), "updated", this).call(this)) {
          babelHelpers.get(babelHelpers.getPrototypeOf(HaxAppSearchInputs.prototype), "updated", this).call(this, changedProperties);
        }

        changedProperties.forEach(function (oldValue, propName) {
          if (propName == "label") {
            // hack, rebuild values bute force
            _this2.shadowRoot.querySelector("#form").value = {};
          }
        });
      }
    }], [{
      key: "styles",

      /**
       * LitElement constructable styles enhancement
       */
      get: function get() {
        return [(0, _litElement.css)(_templateObject_8ddafb40552d11ebb4022f4768b4777e())];
      }
    }]);

    function HaxAppSearchInputs() {
      var _this;

      babelHelpers.classCallCheck(this, HaxAppSearchInputs);
      _this = _super.call(this);
      _this.label = "app";
      return _this;
    }

    babelHelpers.createClass(HaxAppSearchInputs, [{
      key: "render",
      value: function render() {
        return (0, _litElement.html)(_templateObject2_8ddafb40552d11ebb4022f4768b4777e(), this.label, this.schema, _HAXFields.HaxSchematizer, _HAXFields.HaxElementizer, this.searchValuesChanged);
      }
    }, {
      key: "searchValuesChanged",
      value: function searchValuesChanged(e) {
        if (typeof e.detail.value !== "string") {
          // dispatch the event directly so that we can data bind to input
          this.dispatchEvent(new CustomEvent("search-values-changed", {
            detail: e.detail.value
          }));
        }
      }
    }], [{
      key: "tag",
      get: function get() {
        return "hax-app-search-inputs";
      }
    }, {
      key: "properties",
      get: function get() {
        return {
          /**
           * Title.
           */
          label: {
            type: String
          },

          /**
           * Schema used to generate the input types.
           */
          schema: {
            type: Object
          }
        };
      }
    }]);
    return HaxAppSearchInputs;
  }(_litElement.LitElement);

  _exports.HaxAppSearchInputs = HaxAppSearchInputs;
  window.customElements.define(HaxAppSearchInputs.tag, HaxAppSearchInputs);
});