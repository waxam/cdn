define(["exports","meta","require","../../../@polymer/polymer/polymer-element.js","../../../@polymer/polymer/lib/utils/async.js","../../../@polymer/polymer/lib/utils/flattened-nodes-observer.js","../../../@polymer/polymer/lib/utils/resolve-url.js","../../hax-body-behaviors/hax-body-behaviors.js"],function(_exports,meta,_require,_polymerElement,async,_flattenedNodesObserver,_resolveUrl,_haxBodyBehaviors){"use strict";Object.defineProperty(_exports,"__esModule",{value:!0});_exports.HaxAutoloader=void 0;meta=babelHelpers.interopRequireWildcard(meta);_require=babelHelpers.interopRequireWildcard(_require);async=babelHelpers.interopRequireWildcard(async);function _templateObject_a4ab84307c0711e98a2471d74bf08c91(){var data=babelHelpers.taggedTemplateLiteral(["\n      <style>\n        :host {\n          display: none;\n        }\n      </style>\n      <slot></slot>\n    "]);_templateObject_a4ab84307c0711e98a2471d74bf08c91=function _templateObject_a4ab84307c0711e98a2471d74bf08c91(){return data};return data}/**
 * `hax-autoloader`
 * `Automatically load elements based on the most logical location with future fallback support for CDNs.`
 * @microcopy - the mental model for this element
 * - hax-autoloader - autoloading of custom element imports which can then emmit events as needed
 */var HaxAutoloader=/*#__PURE__*/function(_HAXElement){babelHelpers.inherits(HaxAutoloader,_HAXElement);function HaxAutoloader(){babelHelpers.classCallCheck(this,HaxAutoloader);return babelHelpers.possibleConstructorReturn(this,babelHelpers.getPrototypeOf(HaxAutoloader).apply(this,arguments))}babelHelpers.createClass(HaxAutoloader,[{key:"connectedCallback",/**
   * Attached to the DOM, now fire that we exist.
   */value:function connectedCallback(){var _this=this;babelHelpers.get(babelHelpers.getPrototypeOf(HaxAutoloader.prototype),"connectedCallback",this).call(this);// fire an event that this is the manager
this.dispatchEvent(new CustomEvent("hax-register-autoloader",{bubbles:!0,cancelable:!0,composed:!0,detail:this}));// notice elements when they update
this._observer=new _flattenedNodesObserver.FlattenedNodesObserver(this,function(info){// if we've got new nodes, we have to react to that
if(0<info.addedNodes.length){async.microTask.run(function(){_this.processNewElements(info.addedNodes)})}})}/**
   * Process new elements
   */},{key:"processNewElements",value:function processNewElements(e){for(var _this2=this,effectiveChildren=_flattenedNodesObserver.FlattenedNodesObserver.getFlattenedNodes(this).filter(function(n){return n.nodeType===Node.ELEMENT_NODE}),i=0;i<effectiveChildren.length;i++){// strip invalid tags / textnodes
if(babelHelpers.typeof(effectiveChildren[i].tagName)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))&&babelHelpers.typeof(this.processedList[effectiveChildren[i].tagName])===("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){// attempt a dynamic import with graceful failure / fallback
try{(function(){var name=effectiveChildren[i].tagName.toLowerCase();// see if we already have this definition
if("function"===typeof effectiveChildren[i].getHaxProperties){var evt=new CustomEvent("hax-register-properties",{bubbles:!0,composed:!0,cancelable:!0,detail:{tag:name,properties:effectiveChildren[i].getHaxProperties(),polymer:!0}});context.dispatchEvent(evt)}else if("function"===typeof effectiveChildren[i].HAXWiring){var _evt=new CustomEvent("hax-register-properties",{bubbles:!0,cancelable:!0,composed:!0,detail:{tag:name,properties:effectiveChildren[i].HAXWiring.getHaxProperties(),polymer:!1}});context.dispatchEvent(_evt)}else{// @todo support CDN failover or a flag of some kind to ensure
// this delivers locally or from remote
// @todo need to support name spacing of packages so that we
// don't assume they are all relative to lrnwebcomponents
var basePath=(0,_resolveUrl.pathFromUrl)(decodeURIComponent(meta.url));new Promise(function(res,rej){return _require.default(["".concat(basePath,"../../").concat(name,"/").concat(name,".js")],res,rej)}).then(function(response){// get the custom element definition we used to add that file
var CEClass=window.customElements.get(name);if("function"===typeof CEClass.getHaxProperties){_this2.setHaxProperties(CEClass.getHaxProperties(),name)}else if("function"===typeof CEClass.HAXWiring){_this2.setHaxProperties(CEClass.HAXWiring.getHaxProperties(),name)}else if(CEClass.haxProperties){_this2.setHaxProperties(CEClass.haxProperties,name)}else{console.log("".concat(name," didn't have hax wiring in the end"))}}).catch(function(error){/* Error handling */console.log(error)})}_this2.processedList[name]=name})()}catch(err){// error in the event this is a double registration
}}}}}],[{key:"template",get:function get(){return(0,_polymerElement.html)(_templateObject_a4ab84307c0711e98a2471d74bf08c91())}},{key:"tag",get:function get(){return"hax-autoloader"}},{key:"properties",get:function get(){return{/**
       * List of elements processed so we don't double process
       */processedList:{type:Object,value:{}}}}}]);return HaxAutoloader}((0,_haxBodyBehaviors.HAXElement)(_polymerElement.PolymerElement));_exports.HaxAutoloader=HaxAutoloader;window.customElements.define(HaxAutoloader.tag,HaxAutoloader)});