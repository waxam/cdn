define(["exports"], function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.FutureTerminalTextLiteSuper = void 0;

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var FutureTerminalTextLiteSuper = function FutureTerminalTextLiteSuper(SuperClass) {
    return /*#__PURE__*/function (_SuperClass) {
      babelHelpers.inherits(_class, _SuperClass);

      var _super = _createSuper(_class);

      /**
       * HTMLElement
       */
      function _class() {
        var _this;

        babelHelpers.classCallCheck(this, _class);
        _this = _super.call(this);
        _this.red = false;
        _this.fadein = false;
        _this.glitch = false;
        _this.glitchMax = 5;
        _this.glitchDuration = 50;
        return _this;
      }

      babelHelpers.createClass(_class, [{
        key: "_doGlitch",
        value: function () {
          var _doGlitch2 = babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
            var text, scrambleCount, scrambleIterationCount, j, newText, i;
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    text = this.innerHTML;
                    scrambleCount = Math.floor(Math.floor(Math.random() * text.length / 10) + text.length / 20) + 1;
                    scrambleIterationCount = Math.floor(Math.random() * this.glitchMax) + 10;
                    j = 0;

                  case 4:
                    if (!(j < scrambleIterationCount)) {
                      _context.next = 13;
                      break;
                    }

                    newText = text;

                    for (i = 0; i < scrambleCount; i++) {
                      newText = this._scramble(newText);
                    }

                    this.innerHTML = newText;
                    _context.next = 10;
                    return this._wait(this.glitchDuration);

                  case 10:
                    j++;
                    _context.next = 4;
                    break;

                  case 13:
                    this.innerHTML = text;

                  case 14:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));

          function _doGlitch() {
            return _doGlitch2.apply(this, arguments);
          }

          return _doGlitch;
        }()
      }, {
        key: "_scramble",
        value: function _scramble(text) {
          var index = Math.floor(Math.random() * Math.floor(text.length - 1));
          var random = Math.floor(Math.random() * 100);
          return text.substring(0, index) + String.fromCharCode(random) + text.substring(index + 1);
        }
      }, {
        key: "_wait",
        value: function _wait(ms) {
          return new Promise(function (resolve) {
            return setTimeout(resolve, ms);
          });
        }
      }], [{
        key: "styles",
        get: //styles function
        function get() {
          return;
          ":host {\n            font-weight: bold;\n            display: inline-flex;\n            --flicker-easing: cubic-bezier(0.32, 0.32, 0, 0.92);\n            --flicker-duration: 300ms;\n            --fade-in-duration: 500ms;\n          }\n          span {\n              color: #5fa4a5;\n              text-shadow: 0 0 4px #5fa4a5;\n              animation: flicker var(--flicker-duration) var(--flicker-easing);\n          }\n          :host([red]) span {\n              color: #b35b5a;\n              text-shadow: 0 0 4px #b35b5a;\n          }\n          :host([fadein]) span {\n              animation: fade-in var(--fade-in-duration), flicker 300ms var(--flicker-easing) calc(var(--fade-in-duration) * 0.8);\n              transform: translate(0,0);\n              opacity: 1;\n          }\n          @keyframes flicker {\n              0% { opacity: 0.75; }\n              50% { opacity: 0.45; }\n              100% { opacity: 1; }\n          }\n          @keyframes fade-in {\n              from {\n                  transform: translate(-30px, 0px);\n                  opacity: 0;\n              }\n          }\n        ";
        }
      }]);
      return _class;
    }(SuperClass);
  };

  _exports.FutureTerminalTextLiteSuper = FutureTerminalTextLiteSuper;
});