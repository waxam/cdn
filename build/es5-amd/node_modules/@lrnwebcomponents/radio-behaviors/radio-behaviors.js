define(["exports"], function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.RadioBehaviors = void 0;

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  /**
   * Copyright 2018 The Pennsylvania State University
   * @license Apache-2.0, see License.md for full text.
   */
  var RadioBehaviors = function RadioBehaviors(SuperClass) {
    return /*#__PURE__*/function (_SuperClass) {
      babelHelpers.inherits(_class, _SuperClass);

      var _super = _createSuper(_class);

      function _class() {
        var _this;

        babelHelpers.classCallCheck(this, _class);
        _this = _super.call(this);

        _this.addEventListener(_this.__selectEvent, _this._handleSelectItem);

        return _this;
      }

      babelHelpers.createClass(_class, [{
        key: "render",
        value: function render() {
          return "";
        } // properties available to the custom element for data binding

      }, {
        key: "connectedCallback",
        value: function connectedCallback() {
          babelHelpers.get(babelHelpers.getPrototypeOf(_class.prototype), "connectedCallback", this).call(this);

          this.__observer.observe(this, {
            attributes: true,
            childList: true,
            subtree: true
          });
        }
        /**
         * life cycle, element is removed from the DOM
         */

      }, {
        key: "disconnectedCallback",
        value: function disconnectedCallback() {
          if (this.__observer && this.__observer.disconnect) this.__observer.disconnect();
          this.removeEventListener(this.__selectEvent, this._handleSelectItem);
          babelHelpers.get(babelHelpers.getPrototypeOf(_class.prototype), "disconnectedCallback", this).call(this);
        }
        /**
         * listen for change event
         */

      }, {
        key: "firstUpdated",
        value: function firstUpdated(changedProperties) {
          if (babelHelpers.get(babelHelpers.getPrototypeOf(_class.prototype), "firstUpdated", this)) babelHelpers.get(babelHelpers.getPrototypeOf(_class.prototype), "firstUpdated", this).call(this, changedProperties);
          this.selectItem(this.selection);
        }
        /**
         * listen for change event
         */

      }, {
        key: "updated",
        value: function updated(changedProperties) {
          var _this2 = this;

          if (babelHelpers.get(babelHelpers.getPrototypeOf(_class.prototype), "updated", this)) babelHelpers.get(babelHelpers.getPrototypeOf(_class.prototype), "updated", this).call(this, changedProperties);
          changedProperties.forEach(function (oldValue, propName) {
            if (propName === "selection" && _this2.selection !== oldValue) _this2.selectItem(_this2.selection);
          });
        }
        /**
         * index of selected item
         * @readonly
         */

      }, {
        key: "selectedIndex",
        get: function get() {
          var _this3 = this;

          var item = this.itemData.filter(function (i) {
            return i.id === _this3.selection;
          });
          return item && item[0] ? item[0].index : 0;
        }
        /**
         * mutation observer for tabs
         * @readonly
         * @returns {object}
         */

      }, {
        key: "__observer",
        get: function get() {
          var _this4 = this;

          var callback = function callback(mutationsList, observer) {
            return _this4._handleItemChange(mutationsList, observer);
          };

          return new MutationObserver(callback);
        }
        /**
         * allows no item to be selected
         * @readonly
         */

      }, {
        key: "__allowNull",
        get: function get() {
          return false;
        }
        /**
         * query selector for slotted children, can be overridden
         * @readonly
         */

      }, {
        key: "__query",
        get: function get() {
          return "> item";
        }
        /**
         * attribute to apply to selected item, can be overridden
         * @readonly
         */

      }, {
        key: "__selected",
        get: function get() {
          return "selected";
        }
        /**
         * name of event that selects item, can be overridden
         * @readonly
         */

      }, {
        key: "__selectEvent",
        get: function get() {
          return "select-item";
        }
        /**
         * selects an item
         * @param {string|object} item id or node
         */

      }, {
        key: "selectItem",
        value: function selectItem(item) {
          //make sure item is an object
          item = typeof item === "string" && item.trim().length > 0 ? this._getItemById(item) : typeof item === "integer" ? this._getItemByIndex(item) : item; //make sure an item is selected if null is unallowed

          if (!this.__allowNull && (!item || item.disabled)) {
            item = this.selection && this._getItemByQuery("#".concat(this.selection)) ? this._getItemByQuery("#".concat(this.selection)) : this.__selected && this._getItemByQuery("[".concat(this.__selected, "]")) ? this._getItemByQuery("[".concat(this.__selected, "]")) : this._getItemByQuery();
          } //only update if item isn't already selected


          if (item && !this._isItemSelected(item)) {
            item.id = item.id || this._generateUUID();
            this.selection = item.id;

            this._handleSelectionChange();
          } else if (!item && this.__allowNull && this.selection) {
            this.selection = undefined;

            this._handleSelectionChange();
          } //make sure itemData is up-to-date


          this._updateItemData();
        }
        /**
         * updates array of items
         * @returns
         */

      }, {
        key: "_getDataFromItems",
        value: function _getDataFromItems() {
          var _this5 = this;

          var slotted = this.querySelectorAll("".concat(this.__query));
          return Object.keys(slotted || {}).map(function (key) {
            return _this5._getDataFromItem(slotted[key], key, _this5.__selected);
          });
        }
        /**
         * updates iitem for item array
         * @returns
         */

      }, {
        key: "_getDataFromItem",
        value: function _getDataFromItem(item, index, selected) {
          if (!item.id || item.id.trim().length < 1) item.id = this._generateUUID();
          var data = {
            id: item.id,
            index: parseInt(index),
            node: item,
            innerHTML: item.innerHTML,
            selected: item.getAttribute(selected)
          };
          return data;
        }
        /**
         * generates a unique id
         * @returns {string } unique id
         */

      }, {
        key: "_generateUUID",
        value: function _generateUUID() {
          return "item-ss-s-s-s-sss".replace(/s/g, Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1));
        }
        /**
         * gets first non-disabled item that matches a given id
         *
         * @param {string} id
         * @returns object
         */

      }, {
        key: "_getItemById",
        value: function _getItemById(id) {
          return this._getItemByQuery("#".concat(id));
        }
        /**
         * gets non-disabled item at a given index
         *
         * @param {integer} index
         * @returns object
         */

      }, {
        key: "_getItemByIndex",
        value: function _getItemByIndex(index) {
          var items = this.querySelectorAll(this.__query);
          return items && items[index] && !items[index].disabled ? items[index] : undefined;
        }
        /**
         * gets first non-disabled item that matches query
         *
         * @param {string} query
         * @returns object
         */

      }, {
        key: "_getItemByQuery",
        value: function _getItemByQuery() {
          var query = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
          var item = this.querySelector("".concat(this.__query).concat(query));
          return item && !item.disabled ? item : undefined;
        }
        /**
         * updates when slotted item changes
         * @param {*} mutationsList
         * @param {*} observer
         */

      }, {
        key: "_handleItemChange",
        value: function _handleItemChange(mutationsList, observer) {
          var _this6 = this;

          var changed = false; //see if any mutations are relevant enough

          mutationsList.forEach(function (m) {
            var added = m.type === "childList" ? m.addedNodes.length > 0 : false,
                removed = m.type === "childList" && m.removedNodes.length > 0 ? Object.keys(m.removedNodes || {}).filter(function (n) {
              return m.removedNodes[n].id === _this6.selection;
            }).length > 0 : false,
                id = m.type === "attributes" && m.attributeName === "id";
            changed = changed || added || removed || id;
          });

          if (changed) {
            this.querySelectorAll("".concat(this.__query)).forEach(function (i) {
              if (!i.id) i.id = _this6._generateUUID();
            });
            this.selectItem(this.selection);
          }

          this._updateItemData();
        }
        /**
         * handles item selection event
         * @param {event} e
         */

      }, {
        key: "_handleSelectItem",
        value: function _handleSelectItem(e) {
          if (e.stopPropagation) e.stopPropagation();
          this.selectItem(e.detail.controls);
        }
        /**
         * shows or hides items based on selection
         */

      }, {
        key: "_handleSelectionChange",
        value: function _handleSelectionChange() {
          var _this7 = this;

          this.querySelectorAll("".concat(this.__query)).forEach(function (i) {
            return _this7._setItemSelected(i);
          });
          /**
           * Fires when selection update, so that parent radio group can listen for it.
           * @event selection-changed
           */

          this.dispatchEvent(new CustomEvent("selection-changed", {
            bubbles: false,
            cancelable: true,
            composed: true,
            detail: this
          }));
        }
        /**
         * checks to see if item is the selected item
         *
         * @param {*} item
         * @returns
         */

      }, {
        key: "_isItemSelected",
        value: function _isItemSelected(item) {
          return item && (item.id && item.id === this.selection || item.hasAttribute(this.__selected));
        }
        /**
         * sets item __selected attribute
         *
         * @param {*} item
         */

      }, {
        key: "_setItemSelected",
        value: function _setItemSelected(item) {
          item.id !== this.selection ? item.removeAttribute(this.__selected) : item.setAttribute(this.__selected, true);
        }
        /**
         * updates items list and rerenders as needed;
         */

      }, {
        key: "_updateItemData",
        value: function _updateItemData() {
          this.itemData = this._getDataFromItems();
          if (this.render) this.render();
        }
      }], [{
        key: "properties",
        get: function get() {
          return _objectSpread(_objectSpread({}, babelHelpers.get(babelHelpers.getPrototypeOf(_class), "properties", this)), {}, {
            itemData: {
              type: Array
            },
            selection: {
              type: String,
              attribute: "selection"
            }
          });
        }
      }]);
      return _class;
    }(SuperClass);
  };
  /**
   * RadioBehaviors
   * Provides state management when only one child can be selected at a time.
   */


  _exports.RadioBehaviors = RadioBehaviors;
});