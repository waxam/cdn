define(["exports", "require", "../../../../../@polymer/polymer/polymer-element.js", "../../../../beaker-broker/beaker-broker.js", "../haxcms-site-store.js"], function (_exports, _require, _polymerElement, _beakerBroker, _haxcmsSiteStore) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.HAXCMSBackendBeaker = void 0;
  _require = babelHelpers.interopRequireWildcard(_require);

  function _templateObject_3c6a2eb0aa5311e9b999174ecd579fc6() {
    var data = babelHelpers.taggedTemplateLiteral(["\n      <beaker-broker id=\"beaker\"></beaker-broker>\n    "]);

    _templateObject_3c6a2eb0aa5311e9b999174ecd579fc6 = function _templateObject_3c6a2eb0aa5311e9b999174ecd579fc6() {
      return data;
    };

    return data;
  }

  /**
   * `haxcms-backend-beaker`
   * `a simple element to check for and fetch JWTs`
   *
   * @microcopy - the mental model for this element
   * - jwt - a json web token which is an encrypted security token to talk
   */
  var HAXCMSBackendBeaker =
  /*#__PURE__*/
  function (_PolymerElement) {
    babelHelpers.inherits(HAXCMSBackendBeaker, _PolymerElement);
    babelHelpers.createClass(HAXCMSBackendBeaker, null, [{
      key: "tag",

      /**
       * Store the tag name to make it easier to obtain directly.
       * @notice function name must be here for tooling to operate correctly
       */
      get: function get() {
        return "haxcms-backend-beaker";
      } // render function

    }, {
      key: "template",
      get: function get() {
        return (0, _polymerElement.html)(_templateObject_3c6a2eb0aa5311e9b999174ecd579fc6());
      }
    }, {
      key: "properties",
      get: function get() {
        return {
          /**
           * JSON Web token, it'll come from a global call if it's available
           */
          jwt: {
            type: String
          },

          /**
           * Store manifest that makes up the site.
           */
          manifest: {
            type: Object
          },

          /**
           * Track activeItem
           */
          activeItem: {
            type: Object
          }
        };
      }
      /**
       * Attached life cycle
       */

    }]);

    function HAXCMSBackendBeaker() {
      var _this;

      babelHelpers.classCallCheck(this, HAXCMSBackendBeaker);
      _this = babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(HAXCMSBackendBeaker).call(this));
      afterNextRender(babelHelpers.assertThisInitialized(_this), function () {
        document.body.addEventListener("jwt-token", this._jwtTokenFired.bind(this)); // HAX CMS events to intercept

        document.body.addEventListener("haxcms-save-site-data", this.saveManifest.bind(this));
        document.body.addEventListener("haxcms-save-outline", this.saveOutline.bind(this));
        document.body.addEventListener("haxcms-save-node", this.saveNode.bind(this));
        document.body.addEventListener("haxcms-delete-node", this.deleteNode.bind(this));
        document.body.addEventListener("haxcms-create-node", this.createNode.bind(this)); // listen for app being selected

        document.body.addEventListener("hax-app-picker-selection", this._appPicked.bind(this));
      });
      return _this;
    }
    /**
     * detached life cycle
     */


    babelHelpers.createClass(HAXCMSBackendBeaker, [{
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        document.body.removeEventListener("jwt-token", this._jwtTokenFired.bind(this)); // HAX CMS events to intercept

        document.body.removeEventListener("haxcms-save-site-data", this.saveManifest.bind(this));
        document.body.removeEventListener("haxcms-save-outline", this.saveOutline.bind(this));
        document.body.removeEventListener("haxcms-save-node", this.saveNode.bind(this));
        document.body.removeEventListener("haxcms-delete-node", this.deleteNode.bind(this));
        document.body.removeEventListener("haxcms-create-node", this.createNode.bind(this)); // listen for app being selected

        document.body.removeEventListener("hax-app-picker-selection", this._appPicked.bind(this));
        babelHelpers.get(babelHelpers.getPrototypeOf(HAXCMSBackendBeaker.prototype), "disconnectedCallback", this).call(this);
      }
    }, {
      key: "_appPicked",
      value: function _appPicked(e) {
        var _this2 = this;

        if (e.detail.connection.protocol === "dat") {
          e.preventDefault();
          e.stopPropagation();
          var reader = new FileReader();

          reader.onload = function (event) {
            var fileLocation = "files/" + window.HaxStore.instance.haxManager.$.fileupload.files[0].name;

            _this2.$.beaker.write(fileLocation, event.target.result);

            window.HaxStore.instance.haxManager.$.url.value = fileLocation;
            window.HaxStore.instance.haxManager.newAssetConfigure();
          };

          reader.readAsArrayBuffer(window.HaxStore.instance.haxManager.$.fileupload.files[0]);
        }
      }
      /**
       * Save page data
       */

    }, {
      key: "saveNode",
      value: function () {
        var _saveNode = babelHelpers.asyncToGenerator(
        /*#__PURE__*/
        regeneratorRuntime.mark(function _callee(e) {
          var evt;
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  this.activeItem = e.detail; // make sure this location exists

                  _context.next = 3;
                  return this.$.beaker.write(this.activeItem.location, window.HaxStore.instance.activeHaxBody.haxToContent());

                case 3:
                  _haxcmsSiteStore.store.cmsSiteEditor.instance.haxCmsSiteEditorElement.$.toast.show("Page updated!");

                  evt = new CustomEvent("haxcms-trigger-update-node", {
                    bubbles: true,
                    composed: true,
                    cancelable: false,
                    detail: true
                  });

                  _haxcmsSiteStore.store.cmsSiteEditor.instance.haxCmsSiteEditorElement.dispatchEvent(evt);

                case 6:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));

        function saveNode(_x) {
          return _saveNode.apply(this, arguments);
        }

        return saveNode;
      }()
      /**
       * Outline save event.
       */

    }, {
      key: "saveOutline",
      value: function () {
        var _saveOutline = babelHelpers.asyncToGenerator(
        /*#__PURE__*/
        regeneratorRuntime.mark(function _callee2(e) {
          var _this3 = this;

          return regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  // snag global to be sure we have it set first
                  this.manifest = _haxcmsSiteStore.store.cmsSiteEditor.instance.haxCmsSiteEditorElement.manifest; // set items specifically since it's just an outline update

                  this.manifest.items = e.detail; // loop through and match the data our backend generates

                  this.manifest.items.forEach(function (element, index) {
                    // test for things that are not set and build the whole thing out
                    if (babelHelpers.typeof(element.location) === (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
                      var id = _this3.generateResourceID("item-");

                      element.id = id;
                      element.location = "pages/" + id + "/index.html";
                      element.order = index;
                      element.description = "";
                      element.metadata = {
                        created: Math.floor(Date.now() / 1000),
                        updated: Math.floor(Date.now() / 1000)
                      }; // make a directory

                      _this3.$.beaker.archive.mkdir("pages/" + id); // make the page


                      _this3.$.beaker.write("pages/" + id + "/index.html", "<p>Ex uno Plures</p>");

                      _this3.manifest.items[index] = element;
                    }
                  });
                  this.$.beaker.write("site.json", JSON.stringify(this.manifest, null, 2)); // simulate save events since they wont fire

                  _haxcmsSiteStore.store.cmsSiteEditor.instance.haxCmsSiteEditorElement.$.toast.show("Outline saved!");

                  _haxcmsSiteStore.store.cmsSiteEditor.instance.haxCmsSiteEditorElement.dispatchEvent(new CustomEvent("haxcms-trigger-update", {
                    bubbles: true,
                    composed: true,
                    cancelable: false,
                    detail: true
                  }));

                  _haxcmsSiteStore.store.cmsSiteEditor.instance.haxCmsSiteEditorElement.dispatchEvent(new CustomEvent("json-outline-schema-changed", {
                    bubbles: true,
                    composed: true,
                    cancelable: false,
                    detail: this.manifest
                  }));

                case 7:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, this);
        }));

        function saveOutline(_x2) {
          return _saveOutline.apply(this, arguments);
        }

        return saveOutline;
      }()
      /**
       * Outline save event.
       */

    }, {
      key: "deleteNode",
      value: function () {
        var _deleteNode = babelHelpers.asyncToGenerator(
        /*#__PURE__*/
        regeneratorRuntime.mark(function _callee3(e) {
          var _this4 = this;

          var page;
          return regeneratorRuntime.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  page = e.detail.item; // snag global to be sure we have it set first

                  this.manifest = _haxcmsSiteStore.store.cmsSiteEditor.instance.haxCmsSiteEditorElement.manifest; // set items specifically since it's just an outline update

                  this.manifest.items = e.detail; // loop through and match the data our backend generates

                  this.manifest.items.forEach(function (element, index) {
                    if (element.id === page.id) {
                      _this4.splice("manifest.items", index, 1);
                    }
                  });
                  this.$.beaker.write("site.json", JSON.stringify(this.manifest, null, 2)); // simulate save events since they wont fire

                  _haxcmsSiteStore.store.cmsSiteEditor.instance.haxCmsSiteEditorElement.$.toast.show("".concat(page.title, " deleted"));

                  _haxcmsSiteStore.store.cmsSiteEditor.instance.haxCmsSiteEditorElement.dispatchEvent(new CustomEvent("haxcms-trigger-update", {
                    bubbles: true,
                    composed: true,
                    cancelable: false,
                    detail: true
                  }));

                  _haxcmsSiteStore.store.cmsSiteEditor.instance.haxCmsSiteEditorElement.dispatchEvent(new CustomEvent("json-outline-schema-changed", {
                    bubbles: true,
                    composed: true,
                    cancelable: false,
                    detail: this.manifest
                  }));

                case 8:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3, this);
        }));

        function deleteNode(_x3) {
          return _deleteNode.apply(this, arguments);
        }

        return deleteNode;
      }()
      /**
       * createNode
       */

    }, {
      key: "createNode",
      value: function () {
        var _createNode = babelHelpers.asyncToGenerator(
        /*#__PURE__*/
        regeneratorRuntime.mark(function _callee4(e) {
          var _this5 = this;

          var page;
          return regeneratorRuntime.wrap(function _callee4$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  page = e.detail.values; // snag global to be sure we have it set first

                  this.manifest = _haxcmsSiteStore.store.cmsSiteEditor.instance.haxCmsSiteEditorElement.manifest; // set items specifically since it's just an outline update

                  this.manifest.items = e.detail; // loop through and match the data our backend generates

                  this.manifest.items.forEach(function (element, index) {
                    // test for things that are not set and build the whole thing out
                    if (babelHelpers.typeof(element.location) === (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
                      if (!page.id) {
                        page.id = _this5.generateResourceID("item-");
                      }

                      if (!page.location) {
                        page.location = "pages/" + page.id + "/index.html";
                      }

                      var directory = page.location.replace("/index.html", "");
                      element.id = page.id;
                      element.location = page.location;
                      element.order = page.order;
                      element.indent = page.indent;
                      element.parent = page.parent;
                      element.description = page.description;
                      element.metadata.created = Math.floor(Date.now() / 1000);
                      element.metadata.updated = Math.floor(Date.now() / 1000); // make a directory

                      _this5.$.beaker.archive.mkdir(directory); // make the page


                      _this5.$.beaker.write(page.location, "<p>My great new content!</p>");

                      _this5.set("manifest.items.".concat(index), element);
                    }
                  });
                  this.$.beaker.write("site.json", JSON.stringify(this.manifest, null, 2)); // simulate save events since they wont fire

                  _haxcmsSiteStore.store.cmsSiteEditor.instance.haxCmsSiteEditorElement.$.toast.show("".concat(page.title, " created!"));

                  _haxcmsSiteStore.store.cmsSiteEditor.instance.haxCmsSiteEditorElement.dispatchEvent(new CustomEvent("haxcms-trigger-update", {
                    bubbles: true,
                    composed: true,
                    cancelable: false,
                    detail: true
                  }));

                  _haxcmsSiteStore.store.cmsSiteEditor.instance.haxCmsSiteEditorElement.dispatchEvent(new CustomEvent("json-outline-schema-changed", {
                    bubbles: true,
                    composed: true,
                    cancelable: false,
                    detail: this.manifest
                  }));

                case 8:
                case "end":
                  return _context4.stop();
              }
            }
          }, _callee4, this);
        }));

        function createNode(_x4) {
          return _createNode.apply(this, arguments);
        }

        return createNode;
      }()
      /**
       * Manifest save event.
       */

    }, {
      key: "saveManifest",
      value: function () {
        var _saveManifest = babelHelpers.asyncToGenerator(
        /*#__PURE__*/
        regeneratorRuntime.mark(function _callee5(e) {
          var themeData;
          return regeneratorRuntime.wrap(function _callee5$(_context5) {
            while (1) {
              switch (_context5.prev = _context5.next) {
                case 0:
                  this.manifest = e.detail; // limits options but makes it possible to switch core themes

                  if (typeof this.manifest.metadata.theme === "string") {
                    themeData = {
                      "haxcms-dev-theme": {
                        element: "haxcms-dev-theme",
                        path: "@lrnwebcomponents/haxcms-elements/lib/haxcms-dev-theme.js",
                        name: "Developer theme"
                      },
                      "outline-player": {
                        element: "outline-player",
                        path: "@lrnwebcomponents/outline-player/outline-player.js",
                        name: "Outline player"
                      },
                      "simple-blog": {
                        element: "simple-blog",
                        path: "@lrnwebcomponents/simple-blog/simple-blog.js",
                        name: "Simple blog"
                      }
                    }; // if it's not a core theme we can't really do it

                    if (themeData[this.manifest.metadata.theme]) {
                      this.manifest.metadata.theme = themeData[this.manifest.metadata.theme];
                    }
                  }

                  _context5.next = 4;
                  return this.$.beaker.write("site.json", JSON.stringify(this.manifest, null, 2));

                case 4:
                  // simulate save events since they wont fire
                  _haxcmsSiteStore.store.cmsSiteEditor.instance.haxCmsSiteEditorElement.$.toast.show("Site details saved!");

                  _haxcmsSiteStore.store.cmsSiteEditor.instance.haxCmsSiteEditorElement.dispatchEvent(new CustomEvent("haxcms-trigger-update", {
                    bubbles: true,
                    composed: true,
                    cancelable: false,
                    detail: true
                  }));

                  _haxcmsSiteStore.store.cmsSiteEditor.instance.haxCmsSiteEditorElement.dispatchEvent(new CustomEvent("json-outline-schema-changed", {
                    bubbles: true,
                    composed: true,
                    cancelable: false,
                    detail: this.manifest
                  }));

                case 7:
                case "end":
                  return _context5.stop();
              }
            }
          }, _callee5, this);
        }));

        function saveManifest(_x5) {
          return _saveManifest.apply(this, arguments);
        }

        return saveManifest;
      }()
      /**
       * JWT token fired, let's capture it
       */

    }, {
      key: "_jwtTokenFired",
      value: function _jwtTokenFired(e) {
        this.jwt = e.detail;
      }
      /**
       * Generate a uinque ID
       */

    }, {
      key: "generateResourceID",
      value: function generateResourceID() {
        var base = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";

        function idPart() {
          return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
        }

        return base + idPart() + idPart() + "-" + idPart() + "-" + idPart() + "-" + idPart() + "-" + idPart() + idPart() + idPart();
      }
      /**
       * Attached life cycle
       */

    }, {
      key: "connectedCallback",
      value: function () {
        var _connectedCallback = babelHelpers.asyncToGenerator(
        /*#__PURE__*/
        regeneratorRuntime.mark(function _callee6() {
          var _this6 = this;

          var beaker, info, appstore;
          return regeneratorRuntime.wrap(function _callee6$(_context6) {
            while (1) {
              switch (_context6.prev = _context6.next) {
                case 0:
                  babelHelpers.get(babelHelpers.getPrototypeOf(HAXCMSBackendBeaker.prototype), "connectedCallback", this).call(this);
                  beaker = this.$.beaker;
                  this.jwt = beaker.archive.url;
                  _context6.next = 5;
                  return beaker.archive.getInfo();

                case 5:
                  info = _context6.sent;

                  if (!(this.jwt != null && typeof this.jwt == "string" && info.isOwner)) {
                    _context6.next = 13;
                    break;
                  }

                  _context6.t0 = JSON;
                  _context6.next = 10;
                  return beaker.read("appstore.json");

                case 10:
                  _context6.t1 = _context6.sent;
                  appstore = _context6.t0.parse.call(_context6.t0, _context6.t1);

                  // attempt to dynamically import the hax cms site editor
                  // which will appear to be injecting into the page
                  // but because of this approach it should be non-blocking
                  try {
                    new Promise(function (res, rej) {
                      return _require.default(["../haxcms-site-editor.js"], res, rej);
                    }).then(function (e) {
                      var haxCmsSiteEditorElement = document.createElement("haxcms-site-editor");
                      haxCmsSiteEditorElement.jwt = _this6.jwt;
                      haxCmsSiteEditorElement.appStore = appstore;
                      _haxcmsSiteStore.store.cmsSiteEditor.instance.haxCmsSiteEditorElement = haxCmsSiteEditorElement;

                      _haxcmsSiteStore.store.cmsSiteEditor.instance.appendTarget.appendChild(haxCmsSiteEditorElement);
                    }, function (e) {//import failed
                    });
                  } catch (err) {// error in the event this is a double registration
                  }

                case 13:
                case "end":
                  return _context6.stop();
              }
            }
          }, _callee6, this);
        }));

        function connectedCallback() {
          return _connectedCallback.apply(this, arguments);
        }

        return connectedCallback;
      }()
    }]);
    return HAXCMSBackendBeaker;
  }(_polymerElement.PolymerElement);

  _exports.HAXCMSBackendBeaker = HAXCMSBackendBeaker;
  window.customElements.define(HAXCMSBackendBeaker.tag, HAXCMSBackendBeaker);
});