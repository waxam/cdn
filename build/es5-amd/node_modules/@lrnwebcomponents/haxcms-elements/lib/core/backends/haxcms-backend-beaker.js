define(["exports", "require", "../../../../../lit-element/lit-element.js", "../haxcms-site-store.js", "../../../../../mobx/lib/mobx.module.js", "../../../../utils/utils.js", "../../../../beaker-broker/beaker-broker.js"], function (_exports, _require, _litElement, _haxcmsSiteStore, _mobxModule, _utils, _beakerBroker) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.HAXCMSBackendBeaker = void 0;
  _require = babelHelpers.interopRequireWildcard(_require);

  function _templateObject_73a72da0d34d11ea880ba1e93364c49c() {
    var data = babelHelpers.taggedTemplateLiteral(["\n      <beaker-broker id=\"beaker\"></beaker-broker>\n    "]);

    _templateObject_73a72da0d34d11ea880ba1e93364c49c = function _templateObject_73a72da0d34d11ea880ba1e93364c49c() {
      return data;
    };

    return data;
  }

  /**
   * `haxcms-backend-beaker`
   * `a simple element to check for and fetch JWTs`
   *
   * @microcopy - the mental model for this element
   * - jwt - a json web token which is an encrypted security token to talk
   */
  var HAXCMSBackendBeaker =
  /*#__PURE__*/
  function (_LitElement) {
    babelHelpers.inherits(HAXCMSBackendBeaker, _LitElement);
    babelHelpers.createClass(HAXCMSBackendBeaker, [{
      key: "render",
      // render function
      value: function render() {
        return (0, _litElement.html)(_templateObject_73a72da0d34d11ea880ba1e93364c49c());
      }
    }], [{
      key: "tag",

      /**
       * Store the tag name to make it easier to obtain directly.
       */
      get: function get() {
        return "haxcms-backend-beaker";
      }
    }, {
      key: "properties",
      get: function get() {
        return {
          /**
           * JSON Web token, it'll come from a global call if it's available
           */
          jwt: {
            type: String
          },

          /**
           * Store manifest that makes up the site.
           */
          manifest: {
            type: Object
          },

          /**
           * Track activeItem
           */
          activeItem: {
            type: Object
          }
        };
      }
      /**
       * Attached life cycle
       */

    }]);

    function HAXCMSBackendBeaker() {
      var _this;

      babelHelpers.classCallCheck(this, HAXCMSBackendBeaker);
      _this = babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(HAXCMSBackendBeaker).call(this));
      _this.__disposer = []; // see up a tag to place RIGHT next to the site-builder itself

      (0, _mobxModule.autorun)(function (reaction) {
        _this.jwt = (0, _mobxModule.toJS)(_haxcmsSiteStore.store.jwt);

        _this.__disposer.push(reaction);
      });
      document.body.addEventListener("jwt-token", _this._jwtTokenFired.bind(babelHelpers.assertThisInitialized(_this))); // HAX CMS events to intercept

      document.body.addEventListener("haxcms-save-site-data", _this.saveManifest.bind(babelHelpers.assertThisInitialized(_this)));
      document.body.addEventListener("haxcms-save-outline", _this.saveOutline.bind(babelHelpers.assertThisInitialized(_this)));
      document.body.addEventListener("haxcms-save-node", _this.saveNode.bind(babelHelpers.assertThisInitialized(_this)));
      document.body.addEventListener("haxcms-delete-node", _this.deleteNode.bind(babelHelpers.assertThisInitialized(_this)));
      document.body.addEventListener("haxcms-create-node", _this.createNode.bind(babelHelpers.assertThisInitialized(_this))); // listen for app being selected

      document.body.addEventListener("hax-app-picker-selection", _this._appPicked.bind(babelHelpers.assertThisInitialized(_this)));
      return _this;
    }
    /**
     * detached life cycle
     */


    babelHelpers.createClass(HAXCMSBackendBeaker, [{
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        document.body.removeEventListener("jwt-token", this._jwtTokenFired.bind(this)); // HAX CMS events to intercept

        document.body.removeEventListener("haxcms-save-site-data", this.saveManifest.bind(this));
        document.body.removeEventListener("haxcms-save-outline", this.saveOutline.bind(this));
        document.body.removeEventListener("haxcms-save-node", this.saveNode.bind(this));
        document.body.removeEventListener("haxcms-delete-node", this.deleteNode.bind(this));
        document.body.removeEventListener("haxcms-create-node", this.createNode.bind(this)); // listen for app being selected

        document.body.removeEventListener("hax-app-picker-selection", this._appPicked.bind(this));
        babelHelpers.get(babelHelpers.getPrototypeOf(HAXCMSBackendBeaker.prototype), "disconnectedCallback", this).call(this);
      }
    }, {
      key: "_appPicked",
      value: function _appPicked(e) {
        var _this2 = this;

        if (e.detail.connection.protocol === "dat") {
          e.preventDefault();
          e.stopPropagation();
          var reader = new FileReader();

          reader.onload = function (event) {
            var fileLocation = "files/" + window.HaxStore.instance.haxTray.shadowRoot.querySelector("#fileupload").files[0].name;

            _this2.shadowRoot.querySelector("#beaker").write(fileLocation, event.target.result);

            window.HaxStore.instance.haxTray.shadowRoot.querySelector("#url").value = fileLocation;
            window.HaxStore.instance.haxTray.shadowRoot.querySelector("hax-tray-upload").newAssetConfigure();
          };

          reader.readAsArrayBuffer(window.HaxStore.instance.haxTray.shadowRoot.querySelector("#fileupload").files[0]);
        }
      }
      /**
       * Save page data
       */

    }, {
      key: "saveNode",
      value: function () {
        var _saveNode = babelHelpers.asyncToGenerator(
        /*#__PURE__*/
        regeneratorRuntime.mark(function _callee(e) {
          var evt;
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  this.activeItem = e.detail; // make sure this location exists

                  _context.next = 3;
                  return this.shadowRoot.querySelector("#beaker").write(this.activeItem.location, window.HaxStore.instance.activeHaxBody.haxToContent());

                case 3:
                  _haxcmsSiteStore.store.cmsSiteEditor.instance.shadowRoot.querySelector("#toast").show("Page updated!");

                  evt = new CustomEvent("haxcms-trigger-update-node", {
                    bubbles: true,
                    composed: true,
                    cancelable: false,
                    detail: true
                  });

                  _haxcmsSiteStore.store.cmsSiteEditor.instance.dispatchEvent(evt);

                case 6:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));

        function saveNode(_x) {
          return _saveNode.apply(this, arguments);
        }

        return saveNode;
      }()
      /**
       * Outline save event.
       */

    }, {
      key: "saveOutline",
      value: function () {
        var _saveOutline = babelHelpers.asyncToGenerator(
        /*#__PURE__*/
        regeneratorRuntime.mark(function _callee2(e) {
          var _this3 = this;

          return regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  // snag global to be sure we have it set first
                  this.manifest = _haxcmsSiteStore.store.cmsSiteEditor.instance.manifest; // set items specifically since it's just an outline update

                  this.manifest.items = e.detail; // loop through and match the data our backend generates

                  this.manifest.items.forEach(function (element, index) {
                    // test for things that are not set and build the whole thing out
                    if (babelHelpers.typeof(element.location) === (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
                      var id = (0, _utils.generateResourceID)("item-");
                      element.id = id;
                      element.location = "pages/" + id + "/index.html";
                      element.order = index;
                      element.description = "";
                      element.metadata = {
                        created: Math.floor(Date.now() / 1000),
                        updated: Math.floor(Date.now() / 1000)
                      }; // make a directory

                      _this3.shadowRoot.querySelector("#beaker").archive.mkdir("pages/" + id); // make the page


                      _this3.shadowRoot.querySelector("#beaker").write("pages/" + id + "/index.html", "<p>Ex uno Plures</p>");

                      _this3.manifest.items[index] = element;
                    }
                  });
                  this.shadowRoot.querySelector("#beaker").write("site.json", JSON.stringify(this.manifest, null, 2)); // simulate save events since they wont fire

                  _haxcmsSiteStore.store.cmsSiteEditor.instance.shadowRoot.querySelector("#toast").show("Outline saved!");

                  _haxcmsSiteStore.store.cmsSiteEditor.instance.dispatchEvent(new CustomEvent("haxcms-trigger-update", {
                    bubbles: true,
                    composed: true,
                    cancelable: false,
                    detail: true
                  }));

                  _haxcmsSiteStore.store.cmsSiteEditor.instance.dispatchEvent(new CustomEvent("json-outline-schema-changed", {
                    bubbles: true,
                    composed: true,
                    cancelable: false,
                    detail: this.manifest
                  }));

                case 7:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, this);
        }));

        function saveOutline(_x2) {
          return _saveOutline.apply(this, arguments);
        }

        return saveOutline;
      }()
      /**
       * Outline save event.
       */

    }, {
      key: "deleteNode",
      value: function () {
        var _deleteNode = babelHelpers.asyncToGenerator(
        /*#__PURE__*/
        regeneratorRuntime.mark(function _callee3(e) {
          var _this4 = this;

          var page;
          return regeneratorRuntime.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  page = e.detail.item; // snag global to be sure we have it set first

                  this.manifest = _haxcmsSiteStore.store.cmsSiteEditor.instance.manifest; // set items specifically since it's just an outline update

                  this.manifest.items = e.detail; // loop through and match the data our backend generates

                  this.manifest.items.forEach(function (element, index) {
                    if (element.id === page.id) {
                      _this4.splice("manifest.items", index, 1);
                    }
                  });
                  this.shadowRoot.querySelector("#beaker").write("site.json", JSON.stringify(this.manifest, null, 2)); // simulate save events since they wont fire

                  _haxcmsSiteStore.store.cmsSiteEditor.instance.shadowRoot.querySelector("#toast").show("".concat(page.title, " deleted"));

                  _haxcmsSiteStore.store.cmsSiteEditor.instance.dispatchEvent(new CustomEvent("haxcms-trigger-update", {
                    bubbles: true,
                    composed: true,
                    cancelable: false,
                    detail: true
                  }));

                  _haxcmsSiteStore.store.cmsSiteEditor.instance.dispatchEvent(new CustomEvent("json-outline-schema-changed", {
                    bubbles: true,
                    composed: true,
                    cancelable: false,
                    detail: this.manifest
                  }));

                case 8:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3, this);
        }));

        function deleteNode(_x3) {
          return _deleteNode.apply(this, arguments);
        }

        return deleteNode;
      }()
      /**
       * createNode
       */

    }, {
      key: "createNode",
      value: function () {
        var _createNode = babelHelpers.asyncToGenerator(
        /*#__PURE__*/
        regeneratorRuntime.mark(function _callee4(e) {
          var _this5 = this;

          var page;
          return regeneratorRuntime.wrap(function _callee4$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  page = e.detail.values; // snag global to be sure we have it set first

                  this.manifest = _haxcmsSiteStore.store.cmsSiteEditor.instance.manifest; // set items specifically since it's just an outline update

                  this.manifest.items = e.detail; // loop through and match the data our backend generates

                  this.manifest.items.forEach(function (element, index) {
                    // test for things that are not set and build the whole thing out
                    if (babelHelpers.typeof(element.location) === (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
                      if (!page.id) {
                        page.id = (0, _utils.generateResourceID)("item-");
                      }

                      if (!page.location) {
                        page.location = "pages/" + page.id + "/index.html";
                      }

                      var directory = page.location.replace("/index.html", "");
                      element.id = page.id;
                      element.location = page.location;
                      element.slug = page.title;
                      element.order = page.order;
                      element.indent = page.indent;
                      element.parent = page.parent;
                      element.description = page.description;
                      element.metadata.created = Math.floor(Date.now() / 1000);
                      element.metadata.updated = Math.floor(Date.now() / 1000); // make a directory

                      _this5.shadowRoot.querySelector("#beaker").archive.mkdir(directory); // make the page


                      _this5.shadowRoot.querySelector("#beaker").write(page.slug, "<p>My great new content!</p>");

                      _this5.manifest.items[index] = element;
                    }
                  });
                  this.shadowRoot.querySelector("#beaker").write("site.json", JSON.stringify(this.manifest, null, 2)); // simulate save events since they wont fire

                  _haxcmsSiteStore.store.cmsSiteEditor.instance.shadowRoot.querySelector("#toast").show("".concat(page.title, " created!"));

                  _haxcmsSiteStore.store.cmsSiteEditor.instance.dispatchEvent(new CustomEvent("haxcms-trigger-update", {
                    bubbles: true,
                    composed: true,
                    cancelable: false,
                    detail: true
                  }));

                  _haxcmsSiteStore.store.cmsSiteEditor.instance.dispatchEvent(new CustomEvent("json-outline-schema-changed", {
                    bubbles: true,
                    composed: true,
                    cancelable: false,
                    detail: this.manifest
                  }));

                case 8:
                case "end":
                  return _context4.stop();
              }
            }
          }, _callee4, this);
        }));

        function createNode(_x4) {
          return _createNode.apply(this, arguments);
        }

        return createNode;
      }()
      /**
       * Manifest save event.
       */

    }, {
      key: "saveManifest",
      value: function () {
        var _saveManifest = babelHelpers.asyncToGenerator(
        /*#__PURE__*/
        regeneratorRuntime.mark(function _callee5(e) {
          var themeData;
          return regeneratorRuntime.wrap(function _callee5$(_context5) {
            while (1) {
              switch (_context5.prev = _context5.next) {
                case 0:
                  this.manifest = e.detail; // limits options but makes it possible to switch core themes

                  if (typeof this.manifest.metadata.theme === "string") {
                    themeData = {
                      "haxcms-dev-theme": {
                        element: "haxcms-dev-theme",
                        path: "@lrnwebcomponents/haxcms-elements/lib/haxcms-dev-theme.js",
                        name: "Developer theme"
                      },
                      "outline-player": {
                        element: "outline-player",
                        path: "@lrnwebcomponents/outline-player/outline-player.js",
                        name: "Outline player"
                      },
                      "simple-blog": {
                        element: "simple-blog",
                        path: "@lrnwebcomponents/simple-blog/simple-blog.js",
                        name: "Simple blog"
                      }
                    }; // if it's not a core theme we can't really do it

                    if (themeData[this.manifest.metadata.theme]) {
                      this.manifest.metadata.theme = themeData[this.manifest.metadata.theme];
                    }
                  }

                  _context5.next = 4;
                  return this.shadowRoot.querySelector("#beaker").write("site.json", JSON.stringify(this.manifest, null, 2));

                case 4:
                  // simulate save events since they wont fire
                  _haxcmsSiteStore.store.cmsSiteEditor.instance.shadowRoot.querySelector("#toast").show("Site details saved!");

                  _haxcmsSiteStore.store.cmsSiteEditor.instance.dispatchEvent(new CustomEvent("haxcms-trigger-update", {
                    bubbles: true,
                    composed: true,
                    cancelable: false,
                    detail: true
                  }));

                  _haxcmsSiteStore.store.cmsSiteEditor.instance.dispatchEvent(new CustomEvent("json-outline-schema-changed", {
                    bubbles: true,
                    composed: true,
                    cancelable: false,
                    detail: this.manifest
                  }));

                case 7:
                case "end":
                  return _context5.stop();
              }
            }
          }, _callee5, this);
        }));

        function saveManifest(_x5) {
          return _saveManifest.apply(this, arguments);
        }

        return saveManifest;
      }()
      /**
       * JWT token fired, let's capture it
       */

    }, {
      key: "_jwtTokenFired",
      value: function _jwtTokenFired(e) {
        this.jwt = e.detail;
        _haxcmsSiteStore.store.jwt = this.jwt;

        if (_haxcmsSiteStore.store.cmsSiteEditor && _haxcmsSiteStore.store.cmsSiteEditor.instance) {
          _haxcmsSiteStore.store.cmsSiteEditor.instance.jwt = this.jwt;
        }
      }
      /**
       * Detatched life cycle
       */

    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        for (var i in this.__disposer) {
          this.__disposer[i].dispose();
        }

        babelHelpers.get(babelHelpers.getPrototypeOf(HAXCMSBackendBeaker.prototype), "disconnectedCallback", this).call(this);
      }
      /**
       * Attached life cycle
       */

    }, {
      key: "connectedCallback",
      value: function () {
        var _connectedCallback = babelHelpers.asyncToGenerator(
        /*#__PURE__*/
        regeneratorRuntime.mark(function _callee6() {
          var _this6 = this;

          var beaker, info, appstore;
          return regeneratorRuntime.wrap(function _callee6$(_context6) {
            while (1) {
              switch (_context6.prev = _context6.next) {
                case 0:
                  babelHelpers.get(babelHelpers.getPrototypeOf(HAXCMSBackendBeaker.prototype), "connectedCallback", this).call(this);
                  beaker = this.shadowRoot.querySelector("#beaker");
                  this.jwt = beaker.archive.url;
                  _context6.next = 5;
                  return beaker.archive.getInfo();

                case 5:
                  info = _context6.sent;

                  if (!(this.jwt != null && typeof this.jwt == "string" && info.isOwner)) {
                    _context6.next = 15;
                    break;
                  }

                  _context6.t0 = JSON;
                  _context6.next = 10;
                  return beaker.read("appstore.json");

                case 10:
                  _context6.t1 = _context6.sent;
                  appstore = _context6.t0.parse.call(_context6.t0, _context6.t1);

                  // attempt to dynamically import the hax cms site editor
                  // which will appear to be injecting into the page
                  // but because of this approach it should be non-blocking
                  try {
                    new Promise(function (res, rej) {
                      return _require.default(["../haxcms-site-editor.js"], res, rej);
                    }).then(function (e) {
                      _haxcmsSiteStore.store.cmsSiteEditorAvailability();

                      _haxcmsSiteStore.store.cmsSiteEditor.instance.jwt = _this6.jwt;
                      _haxcmsSiteStore.store.cmsSiteEditor.instance.appStore = appstore;
                    }, function (e) {//import failed
                    });
                  } catch (err) {// error in the event this is a double registration
                  }

                  _context6.next = 16;
                  break;

                case 15:
                  // other things will have to sort out the fact that while we
                  // DO have a dynamic backend, we didn't get a hit on the JWT
                  // meaning that we are in a dynamic environment but logged out
                  // at the moment (or viewing a site we don't have authorization to)
                  window.dispatchEvent(new CustomEvent("haxcms-not-logged-in", {
                    bubbles: true,
                    composed: true,
                    cancelable: false,
                    detail: this
                  }));

                case 16:
                case "end":
                  return _context6.stop();
              }
            }
          }, _callee6, this);
        }));

        function connectedCallback() {
          return _connectedCallback.apply(this, arguments);
        }

        return connectedCallback;
      }()
    }]);
    return HAXCMSBackendBeaker;
  }(_litElement.LitElement);

  _exports.HAXCMSBackendBeaker = HAXCMSBackendBeaker;
  window.customElements.define(HAXCMSBackendBeaker.tag, HAXCMSBackendBeaker);
});