define(["exports", "../../../../i18n-manager/lib/I18NMixin.js"], function (_exports, _I18NMixin2) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.HAXCMSI18NMixin = void 0;

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  /**
   * registration normalization so that we can ensure the entire HAXcms
   * base layer implements a uniform series of localizations
   */
  var HAXCMSI18NMixin = function HAXCMSI18NMixin(SuperClass) {
    return /*#__PURE__*/function (_I18NMixin) {
      babelHelpers.inherits(_class, _I18NMixin);

      var _super = _createSuper(_class);

      function _class() {
        var _this;

        babelHelpers.classCallCheck(this, _class);
        _this = _super.call(this); // register a centralized namespace so that everything in HAXcms
        // can leverage the same localization bucket

        _this.registerLocalization({
          context: babelHelpers.assertThisInitialized(_this),
          namespace: "haxcms"
        });

        return _this;
      }

      return _class;
    }((0, _I18NMixin2.I18NMixin)(SuperClass));
  };

  _exports.HAXCMSI18NMixin = HAXCMSI18NMixin;
});