define(["exports", "meta", "require", "../../../../../@polymer/polymer/polymer-element.js", "../../../../../@vaadin/router/dist/vaadin-router.js", "../../../../../@polymer/polymer/lib/utils/async.js", "../../../../../@polymer/polymer/lib/utils/render-status.js", "../../../../utils/utils.js", "../../../../../@polymer/app-layout/app-header/app-header.js", "../../../../../@polymer/app-layout/app-toolbar/app-toolbar.js", "../../../../../@polymer/app-layout/app-drawer/app-drawer.js", "../../../../../@polymer/app-layout/app-drawer-layout/app-drawer-layout.js", "../../../../../@polymer/app-layout/app-header-layout/app-header-layout.js", "../../../../../@polymer/iron-ajax/iron-ajax.js", "../../../../simple-colors/lib/simple-colors-polymer.js", "../../../../map-menu/map-menu.js"], function (_exports, meta, _require, _polymerElement, _vaadinRouter, _async, _renderStatus, _utils, _appHeader, _appToolbar, _appDrawer, _appDrawerLayout, _appHeaderLayout, _ironAjax, _simpleColorsPolymer, _mapMenu) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.HAXCMSLegacyPlayer = void 0;
  meta = babelHelpers.interopRequireWildcard(meta);
  _require = babelHelpers.interopRequireWildcard(_require);

  function _templateObject_00ee0340954211eaba7de7fca9c9f5e8() {
    var data = babelHelpers.taggedTemplateLiteral(["\n      <style include=\"simple-colors-shared-styles-polymer\">\n        :host {\n          display: block;\n          font-family: libre baskerville;\n          position: relative;\n          overflow: hidden;\n          --outline-player-min-height: 100vh;\n          --app-drawer-width: 300px;\n          --outline-player-dark: #222222;\n          --outline-player-light: #f8f8f8;\n          background-color: var(--outline-player-light);\n        }\n\n        :host([closed]) {\n          --app-drawer-width: 0px;\n        }\n\n        h1 {\n          font-size: 48px;\n          line-height: 16px;\n        }\n\n        h2 {\n          font-size: 32px;\n        }\n\n        h3 {\n          font-size: 28px;\n        }\n\n        p {\n          line-height: 26px;\n          min-height: 26px;\n        }\n\n        a,\n        a:visited,\n        a:active {\n          color: #000;\n        }\n\n        a:hover {\n          color: #2196f3;\n        }\n\n        ul li {\n          padding-bottom: 24px;\n          line-height: 1.5;\n          color: #424242;\n          max-width: 448px;\n        }\n\n        ul li:last-child {\n          padding-bottom: 16px;\n        }\n\n        app-drawer-layout {\n          min-height: 100vh;\n          min-height: -moz-available; /* WebKit-based browsers will ignore this. */\n          min-height: -webkit-fill-available; /* Mozilla-based browsers will ignore this. */\n          min-height: fill-available;\n          /* if the user has set a specific value then override the defaults */\n          min-height: var(--outline-player-min-height);\n        }\n\n        .outline-title {\n          font-size: 24px;\n          font-weight: normal;\n          line-height: 32px;\n          vertical-align: middle;\n          padding: 16px;\n          height: 32px;\n          margin: 0;\n          text-align: center;\n          text-overflow: ellipsis;\n          overflow: hidden;\n          word-break: break-word;\n          border-bottom: 1px solid #eeeeee;\n          position: sticky;\n        }\n\n        site-menu {\n          padding: 8px;\n        }\n\n        outline-player-navigation {\n          --outline-player-dark: var(--outline-player-dark);\n        }\n\n        div[main-title] {\n          margin-left: 16px;\n          font-size: 20px;\n          line-height: 20px;\n          overflow-wrap: break-word;\n          text-overflow: ellipsis;\n          display: inline-block;\n          word-break: break-word;\n        }\n\n        paper-progress {\n          display: block;\n          width: 100%;\n          --paper-progress-active-color: rgba(255, 255, 255, 0.5);\n          --paper-progress-container-color: transparent;\n        }\n\n        app-header {\n          color: var(--outline-player-dark);\n          /* Enable outline to be placed anywhere in the dom */\n          /* This will override the app-header-layout forcing fixed mode */\n          /*position: absolute !important;\n        left: 0 !important;*/\n          --app-header-background-rear-layer: {\n            /* app-header-layout will force fixed */\n            background-color: var(--outline-player-light);\n          }\n        }\n\n        app-toolbar {\n          border-bottom: none;\n          background-color: #ffffff;\n          box-shadow: 0 0 6px -3px var(--outline-player-dark);\n        }\n        app-drawer {\n          box-shadow: 0 0 6px -3px var(--outline-player-dark);\n          overflow: hidden;\n          --app-drawer-scrim-background: rgba(80, 80, 80, 0.8);\n          --app-drawer-content-container: {\n            overflow: hidden;\n            background-color: var(--outline-player-light);\n          }\n        }\n        app-drawer-layout[narrow] app-toolbar {\n          position: fixed !important;\n          left: 0;\n          right: 0;\n        }\n        app-drawer-layout[narrow] #contentcontainer {\n          padding-top: 64px;\n        }\n        #content {\n          justify-content: center;\n          padding: 8px 8px 8px 8px;\n        }\n\n        #content > * {\n          display: flex;\n          flex-direction: column;\n          align-items: center;\n        }\n\n        /* Required for HAX */\n        :host([edit-mode]) #slot {\n          display: none !important;\n        }\n        :host([edit-mode]) #content {\n          padding: 32px 8px 8px 8px;\n        }\n        #contentcontainer {\n          max-width: 840px;\n          margin: 0 auto;\n          padding: 0 16px 16px 16px;\n          flex: 1 1 auto;\n          order: 1;\n          display: flex;\n        }\n        #contentcontainer > * {\n          flex: 1 1 auto;\n          display: flex;\n          flex-direction: column;\n          width: 100%;\n        }\n        #contentcontainer h-a-x {\n          margin: 0;\n        }\n        site-menu {\n          height: calc(100vh - 64px);\n          color: #000000;\n          padding: 0;\n          background-color: #ffffff;\n          --site-menu-active-color: rgba(0, 0, 0, 0.1);\n          --site-menu-scrolltrack-bg-color: rgba(0, 0, 0, 0.3);\n          --site-menu-bg-shadow: rgba(0, 0, 0, 0.3);\n          --site-menu-bg-color: #fafafa;\n          --site-menu: {\n            padding: 0;\n            background-color: #ffffff;\n            color: #000000;\n          }\n          --site-menu-container: {\n            padding: 0;\n            background-color: #ffffff;\n            color: #000000;\n          }\n          --site-menu-item-active-item-color: #000000;\n        }\n        site-menu-button {\n          --site-menu-button-button: {\n            border-radius: 50%;\n            background-color: rgba(0, 0, 0, 0.1);\n            height: 40px;\n            width: 40px;\n          }\n          --site-menu-button-button-hover: {\n            background-color: rgba(0, 0, 0, 0.2);\n          }\n        }\n      </style>\n      <iron-ajax\n        id=\"manifest\"\n        url=\"[[outlineLocation]][[file]]\"\n        handle-as=\"json\"\n        debounce-duration=\"250\"\n        last-response=\"{{manifest}}\"\n      ></iron-ajax>\n      <iron-ajax\n        id=\"activecontent\"\n        url=\"[[outlineLocation]][[activeItemLocation]]\"\n        handle-as=\"text\"\n        loading=\"{{loading}}\"\n        debounce-duration=\"250\"\n        last-response=\"{{activeItemContent}}\"\n      ></iron-ajax>\n      <!-- Begin Layout -->\n      <app-drawer-layout narrow=\"{{narrow}}\">\n        <app-drawer id=\"drawer\" swipe-open slot=\"drawer\" opened=\"{{opened}}\">\n          <h2 class=\"outline-title\">[[manifest.title]]</h2>\n          <map-menu\n            id=\"menu\"\n            selected=\"[[activeItem.id]]\"\n            manifest=\"[[routerManifest]]\"\n            active-indicator\n            auto-scroll\n          ></map-menu>\n        </app-drawer>\n        <app-header-layout>\n          <app-header slot=\"header\" reveals>\n            <app-toolbar>\n              <div main-title>\n                [[activeItem.title]]\n                <div id=\"slotTitle\"><slot name=\"title\"></slot></div>\n              </div>\n              <site-menu-button\n                type=\"prev\"\n                position=\"bottom\"\n                label=\"Prev\"\n                raised\n              ></site-menu-button>\n              <site-menu-button\n                type=\"next\"\n                position=\"bottom\"\n                label=\"Next\"\n                raised\n              ></site-menu-button>\n              <site-print-button></site-print-button>\n            </app-toolbar>\n          </app-header>\n          <div id=\"content\">\n            <div id=\"contentcontainer\">\n              <div id=\"slot\"><slot></slot></div>\n            </div>\n          </div>\n        </app-header-layout>\n      </app-drawer-layout>\n    "]);

    _templateObject_00ee0340954211eaba7de7fca9c9f5e8 = function _templateObject_00ee0340954211eaba7de7fca9c9f5e8() {
      return data;
    };

    return data;
  }

  /**
   * `haxcms-legacy-player`
   * `A simple slide playing theme`
   *
  
   * @polymer
   * @demo demo/index.html
   */
  var HAXCMSLegacyPlayer =
  /*#__PURE__*/
  function (_PolymerElement) {
    babelHelpers.inherits(HAXCMSLegacyPlayer, _PolymerElement);
    babelHelpers.createClass(HAXCMSLegacyPlayer, [{
      key: "_activeItemLocationChanged",
      value: function _activeItemLocationChanged(newValue) {
        if (newValue) {
          this.shadowRoot.querySelector("#activecontent").generateRequest();
        }
      }
      /**
       * File changed so let's pull from the location
       */

    }, {
      key: "_fileChanged",
      value: function _fileChanged(newValue, oldValue) {
        if (babelHelpers.typeof(newValue) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
          this.shadowRoot.querySelector("#manifest").generateRequest();
        }
      } // render function

    }], [{
      key: "tag",

      /**
       * Store the tag name to make it easier to obtain directly.
       */
      get: function get() {
        return "haxcms-legacy-player";
      }
    }, {
      key: "properties",
      get: function get() {
        return {
          /**
           * Location of the site.json file
           */
          file: {
            type: String,
            observer: "_fileChanged"
          },

          /**
           * Active item content
           */
          activeItemContent: {
            type: String,
            notify: true,
            observer: "_activeItemContentChanged"
          },
          activeItemLocation: {
            type: String,
            computed: "computeActiveItemLocation(activeItem, __ready)",
            observer: "_activeItemLocationChanged"
          },
          activeItem: {
            type: Object
          },
          manifest: {
            type: Object
          },
          __ready: {
            type: Boolean,
            value: false
          },
          routerManifest: {
            type: Object,
            computed: "computeRouterManifest(manifest)",
            observer: "_updateRouter"
          }
        };
      }
    }, {
      key: "template",
      get: function get() {
        return (0, _polymerElement.html)(_templateObject_00ee0340954211eaba7de7fca9c9f5e8());
      }
    }]);

    function HAXCMSLegacyPlayer() {
      var _this;

      babelHelpers.classCallCheck(this, HAXCMSLegacyPlayer);
      _this = babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(HAXCMSLegacyPlayer).call(this)); // create router

      var options = {};

      if (_this.baseURI) {
        options.baseUrl = _this.baseURI;
      }

      _this.router = new _vaadinRouter.Router(babelHelpers.assertThisInitialized(_this), options);
      window.addEventListener("vaadin-router-location-changed", _this._routerLocationChanged.bind(babelHelpers.assertThisInitialized(_this)));
      return _this;
    } // simple path from a url modifier


    babelHelpers.createClass(HAXCMSLegacyPlayer, [{
      key: "pathFromUrl",
      value: function pathFromUrl(url) {
        return url.substring(0, url.lastIndexOf("/") + 1);
      }
      /**
       * React to content being loaded from a page.
       */

    }, {
      key: "_activeItemContentChanged",
      value: function _activeItemContentChanged(newValue, oldValue) {
        var _this2 = this;

        if (newValue) {
          var html = newValue; // only append if not empty

          if (html !== null) {
            (0, _utils.wipeSlot)(this, "*");
            html = (0, _utils.encapScript)(newValue); // insert the content as quickly as possible, then work on the dynamic imports

            _async.microTask.run(function () {
              setTimeout(function () {
                var frag = document.createRange().createContextualFragment(html);

                _this2.appendChild(frag);

                var evt = new CustomEvent("json-outline-schema-active-body-changed", {
                  bubbles: true,
                  composed: true,
                  cancelable: false,
                  detail: {
                    html: html
                  }
                });
              }, 5);
            }); // if there are, dynamically import them


            if (!window.WCAutoload && (0, _utils.varExists)(this.manifest, "metadata.node.dynamicElementLoader")) {
              var i;

              (function () {
                var tagsFound = (0, _utils.findTagsInHTML)(html);

                var basePath = _this2.pathFromUrl(decodeURIComponent(meta.url));

                var _loop = function _loop() {
                  var tagName = tagsFound[i];

                  if (_this2.manifest.metadata.node.dynamicElementLoader[tagName] && !window.customElements.get(tagName)) {
                    new Promise(function (res, rej) {
                      return _require.default(["".concat(basePath, "../../../../../").concat(_this2.manifest.metadata.node.dynamicElementLoader[tagName])], res, rej);
                    }).then(function (response) {//console.log(tagName + ' dynamic import');
                    }).catch(function (error) {
                      /* Error handling */
                      console.log(error);
                    });
                  }
                };

                for (i in tagsFound) {
                  _loop();
                }
              })();
            }
          }
        }
      }
    }, {
      key: "ready",
      value: function ready() {
        babelHelpers.get(babelHelpers.getPrototypeOf(HAXCMSLegacyPlayer.prototype), "ready", this).call(this); // tidy up the dom if this is there

        if (document.getElementById("haxcmsoutdatedfallbacksuperold")) {
          document.getElementById("haxcmsoutdatedfallback").removeChild(document.getElementById("haxcmsoutdatedfallbacksuperold"));
        }
      }
    }, {
      key: "connectedCallback",
      value: function connectedCallback() {
        babelHelpers.get(babelHelpers.getPrototypeOf(HAXCMSLegacyPlayer.prototype), "connectedCallback", this).call(this);
        (0, _renderStatus.afterNextRender)(this, function () {
          // forces the other stuff to wair
          this.__ready = true;
        });
      }
    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        window.removeEventListener("vaadin-router-location-changed", this._routerLocationChanged.bind(this));
        babelHelpers.get(babelHelpers.getPrototypeOf(HAXCMSLegacyPlayer.prototype), "disconnectedCallback", this).call(this);
      }
    }, {
      key: "computeActiveItemLocation",
      value: function computeActiveItemLocation(activeItem, __ready) {
        if (activeItem && activeItem.location) {
          return "pages/" + activeItem.location + "/index.html";
        }
      }
      /**
       * The manifest but with routing mixed in
       */

    }, {
      key: "computeRouterManifest",
      value: function computeRouterManifest(manifest) {
        document.body.dispatchEvent(new CustomEvent("json-outline-schema-changed", {
          bubbles: true,
          detail: manifest
        }));

        if (manifest && typeof manifest.items !== "undefined") {
          var manifestItems = manifest.items.map(function (i) {
            // get local storage and look for data from this to mesh up
            var location = i.location.replace("pages/", "").replace("/index.html", "");
            return Object.assign({}, i, {
              location: location
            });
          });
          return Object.assign({}, manifest, {
            items: manifestItems
          });
        }
      }
      /**
       * Update the router based on a manifest.
       * This should not be called directly. Use the
       * 'haxcms-router-manifest-changed' event
       *
       * @param {object} manifest
       */

    }, {
      key: "_updateRouter",
      value: function _updateRouter(routerManifest) {
        if (!routerManifest || typeof routerManifest.items === "undefined") return;
        var routerItems = routerManifest.items.map(function (i) {
          return {
            path: i.location,
            name: i.id,
            component: "fake-".concat(i.id, "-e")
          };
        });
        this.router.setRoutes([].concat(babelHelpers.toConsumableArray(routerItems), [{
          path: "/",
          component: "fake-home-e",
          name: "home"
        }, {
          path: "/(.*)",
          component: "fake-404-e",
          name: "404"
        }]));
      }
      /**
       * React to page changes in the vaadin router and convert it
       * to a change in the mobx store.
       * @param {event} e
       */

    }, {
      key: "_routerLocationChanged",
      value: function _routerLocationChanged(e) {
        var _this3 = this;

        // micro delay for map menu to open
        setTimeout(function () {
          if (_this3.routerManifest.items.find) {
            var tmpItem = _this3.routerManifest.items.find(function (i) {
              return i.location == e.detail.location.route.path;
            });

            if (tmpItem) {
              _this3.set("activeItem", tmpItem);
            }
          }
        }, 100);
      }
    }]);
    return HAXCMSLegacyPlayer;
  }(_polymerElement.PolymerElement);

  _exports.HAXCMSLegacyPlayer = HAXCMSLegacyPlayer;
  window.customElements.define(HAXCMSLegacyPlayer.tag, HAXCMSLegacyPlayer);
});