define(["exports", "meta", "../../../../mobx/dist/mobx.esm.js", "../../../utils/utils.js", "../../../json-outline-schema/json-outline-schema.js", "../../../replace-tag/lib/PerformanceDetect.js"], function (_exports, meta, _mobxEsm, _utils, _jsonOutlineSchema, _PerformanceDetect) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.store = _exports.HAXcmsStore = _exports.HAXCMSSiteStore = void 0;
  meta = _interopRequireWildcard(meta);

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || babelHelpers.typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

  (0, _mobxEsm.configure)({
    enforceActions: false,
    useProxies: "ifavailable"
  }); // strict mode off

  var Store = /*#__PURE__*/function () {
    function Store() {
      babelHelpers.classCallCheck(this, Store);
      this.badDevice = false;
      this.evaluatebadDevice();
      this.location = null;
      this.jwt = null;
      this.soundStatus = (0, _utils.localStorageGet)('app-hax-soundStatus', true);
      this.darkMode = !(0, _utils.localStorageGet)('app-hax-darkMode') ? false : (0, _utils.localStorageGet)('app-hax-darkMode');
      this.setupSlots = {
        "haxcms-site-editor-ui-prefix-avatar": [],
        "haxcms-site-editor-ui-prefix-buttons": [],
        "haxcms-site-editor-ui-suffix-buttons": [],
        "haxcms-site-editor-ui-main-menu": [],
        "haxcms-site-editor-ui-topbar-character-button": []
      };
      this.appReady = false;
      this.editMode = false;
      this.manifest = null;
      this.activeItemContent = "";
      this.themeElement = null;
      this.themeStyleElement = document.createElement("style");
      this.themeStyleElement.id = "haxcms-theme-global-style-element";
      this.t = {
        close: "Close"
      };
      this.activeId = null;
      this.userData = {};
      this.cmsSiteEditor = {
        instance: null
      };
      this.cmsSiteEditorBackend = {
        instance: null
      };
      this.dashboardOpened = false;
      (0, _mobxEsm.makeObservable)(this, {
        location: _mobxEsm.observable.ref,
        // router location in url
        editMode: _mobxEsm.observable,
        // global editing state
        jwt: _mobxEsm.observable,
        // json web token
        dashboardOpened: _mobxEsm.observable,
        // if haxcms backend settings are open
        userData: _mobxEsm.observable,
        // user data object for logged in users
        manifest: _mobxEsm.observable,
        // JOS / manifest
        activeItemContent: _mobxEsm.observable,
        // active site content, cleaned up
        themeElement: _mobxEsm.observable,
        // theme element
        routerManifest: _mobxEsm.computed,
        // router mixed in manifest w/ routes / paths
        siteTitle: _mobxEsm.computed,
        isLoggedIn: _mobxEsm.computed,
        // simple boolean for state so we can style based on logged in
        themeData: _mobxEsm.computed,
        // get the active theme from manifest + activeId
        homeLink: _mobxEsm.computed,
        activeId: _mobxEsm.observable,
        // this affects all state changes associated to activeItem
        activeItem: _mobxEsm.computed,
        // active item object
        activeItemFields: _mobxEsm.computed,
        // active item field values
        activeManifestIndex: _mobxEsm.computed,
        // active array index, used for pagination
        activeManifestIndexCounter: _mobxEsm.computed,
        // active array index counter, used for pagination
        activeTitle: _mobxEsm.computed,
        // active page title
        parentTitle: _mobxEsm.computed,
        // active page parent title
        ancestorTitle: _mobxEsm.computed,
        // active page ancestor title
        darkMode: _mobxEsm.observable,
        // dark mode pref
        soundStatus: _mobxEsm.observable,
        // toggle sounds on and off
        appReady: _mobxEsm.observable,
        // system is ready via firstUpdated of haxcms-site-builder
        badDevice: _mobxEsm.observable // if we have a low performance device

      });
    }
    /**
     * Get a unique slug name / path based on existing slug, page data and if we are to automatically generate
     * @param {*} slug
     * @param {*} page
     * @param {*} pathAuto
     * @returns
     */


    babelHelpers.createClass(Store, [{
      key: "getUniqueSlugName",
      value: function getUniqueSlugName(slug) {
        var page = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        var pathAuto = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var rSlug = slug; // check for pathauto setting and this having a parent

        if (page != null && page.parent != null && page.parent != "" && pathAuto) {
          var item = page;
          var pieces = [slug];

          while (item = this.findItem(item.parent)) {
            var tmp = item.slug.split("/");
            pieces.unshift(tmp.pop());
          }

          slug = pieces.join("/");
          rSlug = slug;
        }

        var loop = 0;
        var ready = false; // while not ready, keep checking

        while (!ready) {
          ready = true; // loop through items

          for (var key in this.manifest.items) {
            var _item = this.manifest.items[key]; // if our slug matches an existing

            if (rSlug == _item.slug) {
              // if we have a page, and it matches that, bail out cause we have it already
              if (page != null && _item.id == page.id) {
                return rSlug;
              } else {
                // increment the number
                loop++; // append to the new slug

                rSlug = slug + "-" + loop; // force a new test

                ready = false;
              }
            }
          }
        }

        return rSlug.toLowerCase().split(" ").join("-").replace(/[^0-9\-\/a-z]/gi, "");
      } // see if this device is poor

    }, {
      key: "evaluatebadDevice",
      value: function () {
        var _evaluatebadDevice = babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.next = 2;
                  return _PerformanceDetect.DeviceDetails.badDevice();

                case 2:
                  this.badDevice = _context.sent;

                  if (this.badDevice) {
                    this.soundStatus = false;
                  }

                case 4:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));

        function evaluatebadDevice() {
          return _evaluatebadDevice.apply(this, arguments);
        }

        return evaluatebadDevice;
      }() // eslint-disable-next-line class-methods-use-this

    }, {
      key: "playSound",
      value: function playSound(sound) {
        if (this.soundStatus && this.appReady) {
          try {
            switch (sound) {
              case 'click':
              case 'click2':
              case 'coin':
              case 'coin2':
              case 'hit':
              case 'success':
                this.audio = new Audio(new URL("../../../app-hax/lib/assets/sounds/".concat(sound, ".mp3"), meta.url).href);
                this.audio.play();
                break;

              default:
                this.audio = new Audio(new URL("../../../app-hax/lib/assets/sounds/hit.mp3", meta.url).href);
                this.audio.play();
                console.warn("".concat(sound, " is not a valid sound file yet"));
                break;
            }
          } catch (e) {
            console.warn(e);
          }
        }
      }
      /**
       * Global toast bridge so we don't have to keep writing custom event
       */

    }, {
      key: "toast",
      value: function toast(message) {
        var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2000;
        var extras = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var classStyle = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "capsule";
        var closeText = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : this.t.close;
        var eventCallback = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
        var slot = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;

        if (this.appReady) {
          // gets it all the way to the top immediately
          window.dispatchEvent(new CustomEvent("haxcms-toast-show", {
            bubbles: true,
            composed: true,
            cancelable: true,
            detail: _objectSpread({
              text: message,
              duration: duration,
              classStyle: classStyle,
              closeText: closeText,
              eventCallback: eventCallback,
              slot: slot
            }, extras)
          }));
        }
      }
      /**
       * Load a manifest / site.json / JSON outline schema
       * and prep it for usage in HAXcms
       */

    }, {
      key: "loadManifest",
      value: function () {
        var _loadManifest = babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(manifest) {
          var target,
              git,
              site,
              nodes,
              correctOrder,
              newItems,
              key,
              _args2 = arguments;
          return regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  target = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : null;

                  // support a custom target or ensure event fires off window
                  if (target == null && window) {
                    target = window;
                  } // @todo replace this with a schema version mapper
                  // once we have versions


                  if ((0, _utils.varExists)(manifest, "metadata.siteName")) {
                    git = (0, _utils.varGet)(manifest, "publishing.git", {});
                    manifest.metadata.site = {
                      name: manifest.metadata.siteName,
                      git: git,
                      created: manifest.metadata.created,
                      updated: manifest.metadata.updated
                    };
                    manifest.metadata.theme.variables = {
                      image: manifest.metadata.image,
                      icon: manifest.metadata.icon,
                      hexCode: manifest.metadata.hexCode,
                      cssVariable: manifest.metadata.cssVariable
                    };
                    manifest.metadata.node = {
                      dynamicElementLoader: manifest.metadata.dynamicElementLoader,
                      fields: manifest.metadata.fields
                    };
                    delete manifest.metadata.publishing;
                    delete manifest.metadata.created;
                    delete manifest.metadata.updated;
                    delete manifest.metadata.siteName;
                    delete manifest.metadata.image;
                    delete manifest.metadata.icon;
                    delete manifest.metadata.hexCode;
                    delete manifest.metadata.cssVariable;
                    delete manifest.metadata.dynamicElementLoader;
                    delete manifest.metadata.fields;
                  } // repair slug not being in earlier builds of json schema


                  _context2.next = 5;
                  return manifest.items.forEach(function (item, index, array) {
                    // if we did not have a slug, generate one off location
                    if (!item.slug) {
                      array[index].slug = item.location.replace("pages/", "").replace("/index.html", "");
                    } // we default published to true if not set
                    // this avoids constantly checking downstream


                    // we default published to true if not set
                    // this avoids constantly checking downstream
                    if (!item.metadata.hasOwnProperty("published")) {
                      array[index].metadata.published = true;
                    } // fix order typing


                    // fix order typing
                    array[index].order = Number(array[index].order); // we default locked to false if not set

                    // we default locked to false if not set
                    if (!item.metadata.hasOwnProperty("locked")) {
                      array[index].metadata.locked = false;
                    } // we default locked to false if not set


                    // we default locked to false if not set
                    if (!item.metadata.hasOwnProperty("status")) {
                      array[index].metadata.status = "";
                    }
                  });

                case 5:
                  site = new _jsonOutlineSchema.JsonOutlineSchema(); // we already have our items, pass them in

                  nodes = site.itemsToNodes(manifest.items); // smash outline into flat to get the correct order

                  correctOrder = site.nodesToItems(nodes);
                  newItems = []; // build a new array in the correct order by pushing the old items around

                  for (key in correctOrder) {
                    newItems.push(manifest.items.find(function (element) {
                      return element.id === correctOrder[key].id;
                    }));
                  } // support for language being defined in the manifest of the site


                  if (document.documentElement && manifest.metadata.site.lang) {
                    document.documentElement.lang = manifest.metadata.site.lang;
                    window.dispatchEvent(new CustomEvent("languagechange", {
                      detail: manifest.metadata.site.lang
                    }));
                  }

                  manifest.items = newItems;
                  this.manifest = manifest;
                  target.dispatchEvent(new CustomEvent("json-outline-schema-changed", {
                    bubbles: true,
                    composed: true,
                    cancelable: false,
                    detail: manifest
                  }));
                  window.dispatchEvent(new CustomEvent("haxcms-item-rebuild", {
                    bubbles: true,
                    composed: true,
                    cancelable: false,
                    detail: true
                  }));

                case 15:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, this);
        }));

        function loadManifest(_x) {
          return _loadManifest.apply(this, arguments);
        }

        return loadManifest;
      }()
      /**
       * Ensure there's a copy of the site-editor globally available
       */

    }, {
      key: "cmsSiteEditorAvailability",
      value: function cmsSiteEditorAvailability() {
        if (!this.cmsSiteEditor.instance) {
          this.cmsSiteEditor.instance = document.createElement("haxcms-site-editor");
        }

        return this.cmsSiteEditor.instance;
      }
    }, {
      key: "processedItems",
      get: function get() {}
      /**
       * Compute items leveraging the site query engine
       */

    }, {
      key: "_computeItems",
      value: function _computeItems(start, end, parent, dynamicMethodology, _routerManifest) {
        var _this = this;

        if (_routerManifest) {
          var _ret = function () {
            var items = [];
            var data = [];
            var tmpItem;

            _routerManifest.items.forEach(function (element) {
              // find top level parents
              if (!element.parent) {
                items.push(element);
              }
            });

            switch (dynamicMethodology) {
              case "parent":
                tmpItem = _routerManifest.items.find(function (d) {
                  return parent === d.id;
                }); // shift up 1 if we found something

                if (tmpItem) {
                  parent = tmpItem.parent;
                }

                break;

              case "ancestor":
                tmpItem = _routerManifest.items.find(function (d) {
                  return parent === d.id;
                }); // walk back up to the root

                while (tmpItem && tmpItem.parent != null) {
                  // take the parent object of this current item
                  tmpItem = _routerManifest.items.find(function (i) {
                    return i.id == tmpItem.parent;
                  });
                }

                if (tmpItem) {
                  parent = tmpItem.id;
                }

                break;
            }

            items.forEach(function (item, i) {
              _this._spiderChildren(item, data, start, end, parent, false);
            });
            return {
              v: data
            };
          }();

          if (babelHelpers.typeof(_ret) === "object") return _ret.v;
        }
      }
      /**
       * Recursively search through a data to find children
       * of a specified item.
       */

    }, {
      key: "_setChildren",
      value: function _setChildren(item, data) {
        var _this2 = this;

        // find all children
        var children = data.filter(function (d) {
          return item.id === d.parent;
        });
        item.children = children;

        if (item.children.length > 0) {
          item.children.forEach(function (child) {
            // recursively call itself
            _this2._setChildren(child, data);
          });
        }
      }
      /**
       * The manifest but with routing mixed in
       */

    }, {
      key: "routerManifest",
      get: function get() {
        var _this3 = this;

        var manifest = this.manifest;
        document.body.dispatchEvent(new CustomEvent("json-outline-schema-changed", {
          bubbles: true,
          composed: true,
          cancelable: false,
          detail: manifest
        }));

        if (manifest && typeof manifest.items !== "undefined") {
          var manifestItems = manifest.items.map(function (i) {
            var parentLocation = null;
            var parentSlug = null;
            var parent = manifest.items.find(function (d) {
              return i.parent === d.id;
            });

            if (parent) {
              parentLocation = parent.location;
              parentSlug = parent.slug;
            }

            var metadata = i.metadata;
            var location = i.location;
            var slug = i.slug;
            return Object.assign({}, i, {
              parentLocation: parentLocation,
              parentSlug: parentSlug,
              location: location,
              slug: slug,
              metadata: metadata
            });
          }); // build the children into a hierarchy too

          manifestItems.forEach(function (item, i) {
            _this3._setChildren(item, manifestItems);
          });
          /**
           * Publish Pages Option
           *
           * This option enables the notion of published and unpublished pages.
           * To enable this option set manifest.metadata.site.settings.publishPagesOn = true
           *
           * By default all pages will be published unless "metadata.published" is set to "true" on the
           * item.
           */

          if ((0, _utils.varGet)(manifest, "metadata.site.settings.publishPagesOn", true) === true) {
            var filterHiddenParentsRecursive = function filterHiddenParentsRecursive(item) {
              // if the item is unpublished then remove it.
              if (item.metadata.published === false) {
                return false;
              } // if the item has parents, recursively see if any parent is not published


              var parent = manifestItems.find(function (i) {
                return i.id === item.parent;
              });

              if (parent) {
                return filterHiddenParentsRecursive(parent);
              } // if it got this far then it should be good.


              return true;
            }; // If the user is not logged in then we need to hide unpublished nodes items


            if (!this.isLoggedIn) {
              manifestItems = manifestItems.filter(function (i) {
                return filterHiddenParentsRecursive(i);
              });
            }
          }

          return Object.assign({}, manifest, {
            items: manifestItems
          });
        }
      }
      /**
       * Return the site title
       */

    }, {
      key: "siteTitle",
      get: function get() {
        if (this.manifest && this.manifest.title) {
          return this.manifest.title;
        }

        return "";
      }
      /**
       * Figure out the home page, lazily the 1st thing in the manifest
       */

    }, {
      key: "homeLink",
      get: function get() {
        // if we are on the homepage then load the first item in the manifest and set it active
        if (this.manifest) {
          var firstItem = this.manifest.items.find(function (i) {
            return typeof i.id !== "undefined";
          });

          if (firstItem) {
            return firstItem.slug;
          }
        }

        return "/";
      }
      /**
       * Get the active Item based on activeId
       */

    }, {
      key: "activeItem",
      get: function get() {
        var item = this.findItem(this.activeId); // ensure we found something, return null for consistency in data

        if (item) {
          return item;
        }

        return null;
      }
      /**
       * Get the fields from the node
       */

    }, {
      key: "activeItemFields",
      get: function get() {
        // need to have metadata to be valid so..
        if (this.activeItem && this.activeItem.metadata) {
          // core "fields" we'd expect
          var fields = {
            title: this.activeItem.title,
            description: this.activeItem.description,
            location: this.activeItem.location,
            slug: this.activeItem.slug,
            created: this.activeItem.metadata.created,
            updated: this.activeItem.metadata.created
          }; // mix in any custom field definitions

          if (this.activeItem.metadata.fields) {
            return Object.assign({}, fields, this.activeItem.metadata.fields);
          }
        }
      }
      /**
       * get theme data from manifest + activeId combo
       */

    }, {
      key: "themeData",
      get: function get() {
        if (this.manifest) {
          var themeData = {}; // this is required so better be...

          if ((0, _utils.varExists)(this.manifest, "metadata.theme")) {
            themeData = this.manifest.metadata.theme;
          } else {
            // fallback juuuuust to be safe...
            themeData = {
              "haxcms-basic-theme": {
                element: "haxcms-basic-theme",
                path: "@lrnwebcomponents/haxcms-elements/lib/core/themes/haxcms-basic-theme.js",
                name: "Basic theme",
                variables: {
                  image: "assets/banner.jpg",
                  icon: "icons:record-voice-over",
                  hexCode: "#da004e",
                  cssVariable: "pink"
                }
              }
            };
          } // ooo you sneaky devil you...


          if (this.activeItem && (0, _utils.varExists)(this.activeItem, "metadata.theme")) {
            return this.activeItem.metadata.theme;
          }

          return themeData;
        }
      }
      /**
       * Get the active manifest index array position
       * -1 if not found
       */

    }, {
      key: "activeManifestIndex",
      get: function get() {
        if (this.manifest && this.manifest.items && this.activeId) {
          for (var index in this.manifest.items) {
            if (this.manifest.items[index].id === this.activeId) {
              return parseInt(index);
            }
          }
        }

        return -1;
      }
    }, {
      key: "activeRouterManifestIndex",
      get: function get() {
        if (this.routerManifest && this.routerManifest.items && this.activeId) {
          for (var index in this.routerManifest.items) {
            if (this.routerManifest.items[index].id === this.activeId) {
              return parseInt(index);
            }
          }
        }

        return -1;
      }
      /**
       * Better for visualizing the counter
       */

    }, {
      key: "activeManifestIndexCounter",
      get: function get() {
        if (this.activeManifestIndex !== null) {
          return 1 + this.activeManifestIndex;
        }

        return 0;
      }
      /**
       * shortcut for active page title
       */

    }, {
      key: "activeTitle",
      get: function get() {
        if (this.activeItem) {
          return this.activeItem.title;
        }

        return "";
      }
      /**
       * shortcut for active page parent title
       */

    }, {
      key: "parentTitle",
      get: function get() {
        var _this4 = this;

        if (this.manifest && this.activeItem) {
          var tmpItem = this.manifest.items.find(function (d) {
            return _this4.activeItem.parent === d.id;
          }); // shift up 1 if we found something

          if (tmpItem) {
            return tmpItem.title;
          }
        }

        return "";
      }
    }, {
      key: "isLoggedIn",
      get: function get() {
        // account for keypair storage issue since its a string bin
        if (this.jwt && this.jwt != "null") {
          return true;
        }

        return false;
      }
      /**
       * shortcut for active page ancestor title
       */

    }, {
      key: "ancestorTitle",
      get: function get() {
        var _this5 = this;

        if (this.manifest && this.activeItem) {
          var _ret2 = function () {
            var tmpItem = _this5.manifest.items.find(function (d) {
              return _this5.activeItem.parent === d.id;
            }); // walk back up to the root


            while (tmpItem && tmpItem.parent != null) {
              // take the parent object of this current item
              tmpItem = _this5.manifest.items.find(function (i) {
                return i.id == tmpItem.parent;
              });
            }

            if (tmpItem) {
              return {
                v: tmpItem.title
              };
            }
          }();

          if (babelHelpers.typeof(_ret2) === "object") return _ret2.v;
        }

        return "";
      }
      /**
       * shortcut to find an item in the manifest based on id
       */

    }, {
      key: "findItem",
      value: function findItem(id) {
        if (this.manifest && id) {
          return this.manifest.items.find(function (item) {
            if (item.id !== id) {
              return false;
            }

            return true;
          });
        }

        return null;
      }
      /**
       * shortcut to find an item in the manifest based on id
       */

    }, {
      key: "findItemAsObject",
      value: function () {
        var _findItemAsObject = babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(id) {
          var attrLookup,
              scope,
              useToJS,
              tmpItem,
              _args3 = arguments;
          return regeneratorRuntime.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  attrLookup = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : "id";
                  scope = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : "item";
                  useToJS = _args3.length > 3 && _args3[3] !== undefined ? _args3[3] : true;

                  if (!(this.manifest && id)) {
                    _context3.next = 18;
                    break;
                  }

                  _context3.next = 6;
                  return this.manifest.items.find(function (item) {
                    if (item[attrLookup] !== id) {
                      return false;
                    }

                    return true;
                  });

                case 6:
                  tmpItem = _context3.sent;

                  if (useToJS) {
                    tmpItem = (0, _mobxEsm.toJS)(tmpItem);
                  }

                  if (!(scope == "item")) {
                    _context3.next = 12;
                    break;
                  }

                  return _context3.abrupt("return", tmpItem);

                case 12:
                  if (!(scope == "parent" && tmpItem.parent)) {
                    _context3.next = 18;
                    break;
                  }

                  _context3.t0 = _mobxEsm.toJS;
                  _context3.next = 16;
                  return this.manifest.items.find(function (d) {
                    return tmpItem.parent === d.id;
                  });

                case 16:
                  _context3.t1 = _context3.sent;
                  return _context3.abrupt("return", (0, _context3.t0)(_context3.t1));

                case 18:
                  return _context3.abrupt("return", null);

                case 19:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3, this);
        }));

        function findItemAsObject(_x2) {
          return _findItemAsObject.apply(this, arguments);
        }

        return findItemAsObject;
      }()
      /**
       * return a fallback item because we just got a miss.
       * usually to avoid redirect loops
       */

    }, {
      key: "fallbackItemSlug",
      value: function fallbackItemSlug() {
        if (this.manifest && this.activeItem) {
          if (this.activeManifestIndex > 0 && this.manifest.items[this.activeManifestIndex - 1]) {
            return this.manifest.items[this.activeManifestIndex - 1].slug;
          } else if (this.activeManifestIndex < this.manifest.items.length - 1 && this.manifest.items[this.activeManifestIndex + 1]) {
            return this.manifest.items[this.activeManifestIndex + 1].slug;
          }
        }

        return null;
      }
      /**
       * Return a clone of the manifest items list
       */

    }, {
      key: "getManifestItems",
      value: function getManifestItems() {
        var cloneIt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

        if (cloneIt) {
          return (0, _mobxEsm.toJS)(this.manifest.items);
        }

        return this.manifest.items;
      }
      /**
       * Add an item
       */

    }, {
      key: "addItem",
      value: function () {
        var _addItem = babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(item) {
          var schema, newItem, safeItem, nodes, correctOrder, newItems, key;
          return regeneratorRuntime.wrap(function _callee4$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  schema = new _jsonOutlineSchema.JsonOutlineSchema();
                  newItem = schema.newItem();

                  if (item.id) {
                    newItem.id = item.id;
                  }

                  if (item.indent) {
                    newItem.indent = item.indent;
                  }

                  newItem.location = item.location;
                  newItem.slug = item.slug;
                  newItem.order = item.order;
                  newItem.parent = item.parent;
                  newItem.title = item.title; // metadata can be anything so whatever

                  newItem.metadata = item.metadata; // all items rebuilt

                  schema.items = (0, _mobxEsm.toJS)(this.manifest.items);
                  safeItem = _objectSpread({}, schema.validateItem(newItem));
                  schema.items.push(safeItem); // we already have our items, pass them in

                  nodes = schema.itemsToNodes(schema.items); // smash outline into flat to get the correct order

                  correctOrder = schema.nodesToItems(nodes);
                  newItems = []; // build a new array in the correct order by pushing the old items around

                  for (key in correctOrder) {
                    newItems.push(schema.items.find(function (element) {
                      return element.id === correctOrder[key].id;
                    }));
                  }

                  this.manifest.items.replace(newItems);
                  window.dispatchEvent(new CustomEvent("json-outline-schema-changed", {
                    bubbles: true,
                    composed: true,
                    cancelable: false,
                    detail: this.manifest
                  }));
                  window.dispatchEvent(new CustomEvent("haxcms-item-rebuild", {
                    bubbles: true,
                    composed: true,
                    cancelable: false,
                    detail: true
                  }));
                  return _context4.abrupt("return", this.findItem(newItem.id));

                case 21:
                case "end":
                  return _context4.stop();
              }
            }
          }, _callee4, this);
        }));

        function addItem(_x3) {
          return _addItem.apply(this, arguments);
        }

        return addItem;
      }()
      /**
       * Remove an item
       */

    }, {
      key: "removeItem",
      value: function removeItem(id) {
        var item = this.findItem(id); // "new" items have not yet been added

        if (item) {
          if (item.metadata.status === "new") {
            var index = this.manifest.items.indexOf(item);

            if (index > -1) {
              this.manifest.items.splice(index, 1);
            }
          } else {
            // implies it's going to get deleted on next run
            item.metadata.status = "delete";
          }
        }
      }
      /**
       * Spider children based on criteria and return what we found
       */

    }, {
      key: "spiderChildren",
      value: function spiderChildren(item, data, start, end, parent, parentFound, noDynamicLevel) {
        var _this6 = this;

        // see if we have the parent... or keep going
        if (item.id === parent || parentFound) {
          // set parent to current so it's gaurenteed to match on next one
          if (!parentFound) {
            parentFound = true; // support sliding scales, meaning that start / end is relative to active

            if (!noDynamicLevel && item.indent >= start) {
              start += item.indent;
              end += item.indent;
            }
          } // only add on what we're between


          if (item.indent >= start && item.indent <= end) {
            data.push(item);
          } // we've found it. Now everyone below here should match


          if (item.children.length > 0) {
            item.children.forEach(function (child) {
              // recursively call itself
              _this6.spiderChildren(child, data, start, end, parent, parentFound, noDynamicLevel);
            });
          }
        } else {
          if (item.children.length > 0) {
            item.children.forEach(function (child) {
              // recursively call itself
              _this6.spiderChildren(child, data, start, end, parent, parentFound, noDynamicLevel);
            });
          }
        }
      }
      /**
       * Compute items leveraging the site query engine
       */

    }, {
      key: "computeItems",
      value: function computeItems(start, end, parent, dynamicMethodology, _routerManifest, noDynamicLevel) {
        if (_routerManifest) {
          var _ret3 = function () {
            var items = [];
            var data = [];
            var tmpItem;

            _routerManifest.items.forEach(function (element) {
              // find top level parents
              if (!element.parent) {
                items.push(element);
              }
            });

            switch (dynamicMethodology) {
              case "parent":
                tmpItem = _routerManifest.items.find(function (d) {
                  return parent === d.id;
                }); // shift up 1 if we found something

                if (tmpItem) {
                  parent = tmpItem.parent;
                }

                break;

              case "ancestor":
                tmpItem = _routerManifest.items.find(function (d) {
                  return parent === d.id;
                }); // walk back up to the root

                while (tmpItem && tmpItem.parent != null) {
                  // take the parent object of this current item
                  tmpItem = _routerManifest.items.find(function (i) {
                    return i.id == tmpItem.parent;
                  });
                }

                if (tmpItem) {
                  parent = tmpItem.id;
                }

                break;
            }

            _routerManifest.items.forEach(function (item, i) {
              store.spiderChildren(item, data, start, end, parent, false, noDynamicLevel);
            });

            return {
              v: data
            };
          }();

          if (babelHelpers.typeof(_ret3) === "object") return _ret3.v;
        }
      }
    }]);
    return Store;
  }();
  /**
   * Central store
   */


  var store = new Store(); // register globally so we can make sure there is only one

  _exports.store = store;
  window.HAXCMS = window.HAXCMS || {}; // request if this exists. This helps invoke the element existing in the dom
  // as well as that there is only one of them. That way we can ensure everything
  // is rendered through the same modal

  window.HAXCMS.requestAvailability = function () {
    if (!window.HAXCMS.instance) {
      window.HAXCMS.instance = document.createElement("haxcms-site-store");
      document.body.appendChild(window.HAXCMS.instance);
    }

    return window.HAXCMS.instance;
  }; // weird, but self appending


  var HAXcmsStore = window.HAXCMS.requestAvailability();
  /**
   * HTMLElement
   */

  _exports.HAXcmsStore = HAXcmsStore;

  var HAXCMSSiteStore = /*#__PURE__*/function (_HTMLElement) {
    babelHelpers.inherits(HAXCMSSiteStore, _HTMLElement);

    var _super = _createSuper(HAXCMSSiteStore);

    function HAXCMSSiteStore() {
      var _this7;

      babelHelpers.classCallCheck(this, HAXCMSSiteStore);
      _this7 = _super.call(this); // keep track of the HTML element pieces dedicated to different
      // critical pieces of functionality like theme and editor builders.

      _this7.storePieces = {}; // full on store that does the heavy lifting

      _this7.store = store; // source for reading in the store if different than default site.json

      _this7.source = "";
      /**
       * When location changes update activeItem
       */

      (0, _mobxEsm.autorun)(function () {
        if (store.location && store.location.route && store.location.route.component) {
          // get the id from the router
          var id = store.location.route.name; // make sure that we aren't in edit mode

          var found = store.manifest.items.filter(function (item) {
            if (item.id !== id) {
              return false;
            }

            return true;
          });

          if (found) {
            store.activeId = id;
          }
        }
      });
      /**
       * When Active Item Changes notify json-outline-schema to have the backend
       * change the page.
       */

      (0, _mobxEsm.autorun)(function () {
        var foundItem = (0, _mobxEsm.toJS)(store.findItem(store.activeId));

        if (foundItem) {
          document.body.dispatchEvent(new CustomEvent("json-outline-schema-active-item-changed", {
            bubbles: true,
            composed: true,
            cancelable: false,
            detail: foundItem
          })); //change site title when page changes

          document.title = store.activeTitle;
        }
      });
      /**
       * When editMode changes notify HAXeditor.
       */

      (0, _mobxEsm.autorun)(function () {
        var editMode = (0, _mobxEsm.toJS)(store.editMode); // trap for early setup

        if (window.HaxStore && window.HaxStore.requestAvailability() && window.HaxStore.requestAvailability().write) {
          window.dispatchEvent(new CustomEvent("haxcms-edit-mode-changed", {
            bubbles: true,
            composed: true,
            cancelable: false,
            detail: editMode
          }));
          window.HaxStore.requestAvailability().editMode = editMode;
          window.HaxStore.requestAvailability().toastShowEventName = "haxcms-toast-show"; // @todo hack to keep voice controls active if enabled

          if (window.HaxStore.requestAvailability().globalPreferences.haxVoiceCommands && window.HaxStore.requestAvailability().__hal) {
            setTimeout(function () {
              window.HaxStore.requestAvailability().__hal.auto = true;
            }, 10);
          }
        }
      });
      return _this7;
    }

    babelHelpers.createClass(HAXCMSSiteStore, [{
      key: "connectedCallback",
      value: function connectedCallback() {
        document.body.appendChild(this.store.themeStyleElement);
      }
    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        this.store.themeStyleElement.remove();
        this.store.themeStyleElement = document.createElement("style");
      }
      /**
       * Try to get context of what backend is powering this
       */

    }, {
      key: "getApplicationContext",
      value: function getApplicationContext() {
        var context = ""; // @todo review if we even need this because newer contexts don't care
        // figure out the context we need to apply for where the editing creds
        // and API might come from
        // beaker is a unique scenario

        if ((typeof DatArchive === "undefined" ? "undefined" : babelHelpers.typeof(DatArchive)) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
          context = "beaker"; // implies usage of BeakerBrowser, an experimental browser for decentralization
        } else {
          switch (window.HAXCMSContext) {
            case "published": // implies this is to behave as if it is completely static

            case "nodejs": // implies nodejs based backend, tho no diff from

            case "php": // implies php backend

            case "11ty": // implies 11ty static site generator

            case "demo": // demo / local development

            case "desktop": // implies electron

            case "local":
              // implies ability to use local file system
              context = window.HAXCMSContext;
              break;

            default:
              // we don't have one so assume it's php for now
              // @notice change this in the future
              context = "php";
              break;
          }
        }

        return context;
      }
    }, {
      key: "source",
      get: function get() {
        return this.getAttribute("source");
      },
      set: function set(value) {
        this[name] = value;

        if (value) {
          this.setAttribute("source", value);
        }
      }
    }, {
      key: "attributeChangedCallback",
      value: function attributeChangedCallback(name, oldVal, newVal) {
        var _this8 = this;

        if (name == "source" && newVal != "") {
          fetch(this[name]).then(function (response) {
            return response.json();
          }).then(function (data) {
            _this8.store.loadManifest(data);
          }).catch(function (err) {
            console.warn(err);
          });
        }
      }
    }], [{
      key: "tag",
      get: function get() {
        return "haxcms-site-store";
      }
    }, {
      key: "observedAttributes",
      get: function get() {
        return ["source"];
      }
    }]);
    return HAXCMSSiteStore;
  }( /*#__PURE__*/babelHelpers.wrapNativeSuper(HTMLElement));

  _exports.HAXCMSSiteStore = HAXCMSSiteStore;
  window.customElements.define(HAXCMSSiteStore.tag, HAXCMSSiteStore);
});