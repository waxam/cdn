define(["exports", "../../../../mobx/lib/mobx.module.js", "../../../utils/utils.js", "../../../json-outline-schema/json-outline-schema.js"], function (_exports, _mobxModule, _utils, _jsonOutlineSchema) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.HAXCMSSiteStore = _exports.store = void 0;

  var Store =
  /*#__PURE__*/
  function () {
    function Store() {
      babelHelpers.classCallCheck(this, Store);
      this.location = null;
      this.jwt = null;
      this.editMode = false;
      this.manifest = null;
      this.activeItemContent = "";
      this.themeElement = null;
      this.activeId = null;
      this.userData = {};
      this.cmsSiteEditor = {
        instance: null
      };
      this.cmsSiteEditorBackend = {
        instance: null
      };
      this.dashboardOpened = false;
    }
    /**
     * Load a manifest / site.json / JSON outline schema
     * and prep it for usage in HAXcms
     */


    babelHelpers.createClass(Store, [{
      key: "loadManifest",
      value: function loadManifest(manifest) {
        var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

        // support a custom target or ensure event fires off window
        if (target == null && window) {
          target = window;
        } // @todo replace this with a schema version mapper
        // once we have versions


        if ((0, _utils.varExists)(manifest, "metadata.siteName")) {
          var git = (0, _utils.varGet)(manifest, "publishing.git", {});
          manifest.metadata.site = {
            name: manifest.metadata.siteName,
            git: git,
            created: manifest.metadata.created,
            updated: manifest.metadata.updated
          };
          manifest.metadata.theme.variables = {
            image: manifest.metadata.image,
            icon: manifest.metadata.icon,
            hexCode: manifest.metadata.hexCode,
            cssVariable: manifest.metadata.cssVariable
          };
          manifest.metadata.node = {
            dynamicElementLoader: manifest.metadata.dynamicElementLoader,
            fields: manifest.metadata.fields
          };
          delete manifest.metadata.publishing;
          delete manifest.metadata.created;
          delete manifest.metadata.updated;
          delete manifest.metadata.siteName;
          delete manifest.metadata.image;
          delete manifest.metadata.icon;
          delete manifest.metadata.hexCode;
          delete manifest.metadata.cssVariable;
          delete manifest.metadata.dynamicElementLoader;
          delete manifest.metadata.fields;
        } // repair slug not being in earlier builds of json schema


        manifest.items.forEach(function (item, index, array) {
          if (!item.slug) {
            array[index].slug = item.location.replace("pages/", "").replace("/index.html", "");
          }
        });
        var site = new _jsonOutlineSchema.JsonOutlineSchema(); // we already have our items, pass them in

        var nodes = site.itemsToNodes(manifest.items); // smash outline into flat to get the correct order

        var correctOrder = site.nodesToItems(nodes);
        var newItems = []; // build a new array in the correct order by pushing the old items around

        for (var key in correctOrder) {
          newItems.push(manifest.items.find(function (element) {
            return element.id === correctOrder[key].id;
          }));
        }

        manifest.items = newItems;
        this.manifest = manifest;
        target.dispatchEvent(new CustomEvent("json-outline-schema-changed", {
          bubbles: true,
          composed: true,
          cancelable: false,
          detail: manifest
        }));
      }
      /**
       * Ensure there's a copy of the site-editor globally available
       */

    }, {
      key: "cmsSiteEditorAvailability",
      value: function cmsSiteEditorAvailability() {
        if (!this.cmsSiteEditor.instance) {
          this.cmsSiteEditor.instance = document.createElement("haxcms-site-editor");
        }

        return this.cmsSiteEditor.instance;
      }
    }, {
      key: "_computeItems",

      /**
       * Compute items leveraging the site query engine
       */
      value: function _computeItems(start, end, parent, dynamicMethodology, _routerManifest) {
        var _this = this;

        if (_routerManifest) {
          var _ret = function () {
            var items = [];
            var data = [];
            var tmpItem;

            _routerManifest.items.forEach(function (element) {
              // find top level parents
              if (!element.parent) {
                items.push(element);
              }
            });

            switch (dynamicMethodology) {
              case "parent":
                tmpItem = _routerManifest.items.find(function (d) {
                  return parent === d.id;
                }); // shift up 1 if we found something

                if (tmpItem) {
                  parent = tmpItem.parent;
                }

                break;

              case "ancestor":
                tmpItem = _routerManifest.items.find(function (d) {
                  return parent === d.id;
                }); // walk back up to the root

                while (tmpItem && tmpItem.parent != null) {
                  // take the parent object of this current item
                  tmpItem = _routerManifest.items.find(function (i) {
                    return i.id == tmpItem.parent;
                  });
                }

                if (tmpItem) {
                  parent = tmpItem.id;
                }

                break;
            }

            items.forEach(function (item, i) {
              _this._spiderChildren(item, data, start, end, parent, false);
            });
            return {
              v: data
            };
          }();

          if (babelHelpers.typeof(_ret) === "object") return _ret.v;
        }
      }
      /**
       * Recursively search through a data to find children
       * of a specified item.
       */

    }, {
      key: "_setChildren",
      value: function _setChildren(item, data) {
        var _this2 = this;

        // find all children
        var children = data.filter(function (d) {
          return item.id === d.parent;
        });
        item.children = children;

        if (item.children.length > 0) {
          item.children.forEach(function (child) {
            // recursively call itself
            _this2._setChildren(child, data);
          });
        }
      }
      /**
       * The manifest but with routing mixed in
       */

    }, {
      key: "findItem",

      /**
       * shortcut to find an item in the manifest based on id
       */
      value: function findItem(id) {
        if (this.manifest && id) {
          return this.manifest.items.find(function (item) {
            if (item.id !== id) {
              return false;
            }

            return true;
          });
        } else {
          return null;
        }
      }
      /**
       * Spider children based on criteria and return what we found
       */

    }, {
      key: "spiderChildren",
      value: function spiderChildren(item, data, start, end, parent, parentFound, noDynamicLevel) {
        var _this3 = this;

        // see if we have the parent... or keep going
        if (item.id === parent || parentFound) {
          // set parent to current so it's gaurenteed to match on next one
          if (!parentFound) {
            parentFound = true; // support sliding scales, meaning that start / end is relative to active

            if (!noDynamicLevel && item.indent >= start) {
              start += item.indent;
              end += item.indent;
            }
          } // only add on what we're between


          if (item.indent >= start && item.indent <= end) {
            data.push(item);
          } // we've found it. Now everyone below here should match


          if (item.children.length > 0) {
            item.children.forEach(function (child) {
              // recursively call itself
              _this3.spiderChildren(child, data, start, end, parent, parentFound, noDynamicLevel);
            });
          }
        } else {
          if (item.children.length > 0) {
            item.children.forEach(function (child) {
              // recursively call itself
              _this3.spiderChildren(child, data, start, end, parent, parentFound, noDynamicLevel);
            });
          }
        }
      }
      /**
       * Compute items leveraging the site query engine
       */

    }, {
      key: "computeItems",
      value: function computeItems(start, end, parent, dynamicMethodology, _routerManifest, noDynamicLevel) {
        if (_routerManifest) {
          var _ret2 = function () {
            var items = [];
            var data = [];
            var tmpItem;

            _routerManifest.items.forEach(function (element) {
              // find top level parents
              if (!element.parent) {
                items.push(element);
              }
            });

            switch (dynamicMethodology) {
              case "parent":
                tmpItem = _routerManifest.items.find(function (d) {
                  return parent === d.id;
                }); // shift up 1 if we found something

                if (tmpItem) {
                  parent = tmpItem.parent;
                }

                break;

              case "ancestor":
                tmpItem = _routerManifest.items.find(function (d) {
                  return parent === d.id;
                }); // walk back up to the root

                while (tmpItem && tmpItem.parent != null) {
                  // take the parent object of this current item
                  tmpItem = _routerManifest.items.find(function (i) {
                    return i.id == tmpItem.parent;
                  });
                }

                if (tmpItem) {
                  parent = tmpItem.id;
                }

                break;
            }

            _routerManifest.items.forEach(function (item, i) {
              store.spiderChildren(item, data, start, end, parent, false, noDynamicLevel);
            });

            return {
              v: data
            };
          }();

          if (babelHelpers.typeof(_ret2) === "object") return _ret2.v;
        }
      }
    }, {
      key: "processedItems",
      get: function get() {}
    }, {
      key: "routerManifest",
      get: function get() {
        var _this4 = this;

        var manifest = this.manifest;
        document.body.dispatchEvent(new CustomEvent("json-outline-schema-changed", {
          bubbles: true,
          composed: true,
          cancelable: false,
          detail: manifest
        }));

        if (manifest && typeof manifest.items !== "undefined") {
          var userData = JSON.parse(window.localStorage.getItem("HAXCMSSystemData"));
          var accessData = {}; // establish on first pass if needed

          if (userData == null) {
            userData = {
              manifests: {}
            };
            userData.manifests[manifest.id] = {
              accessData: {}
            };
            window.localStorage.setItem("HAXCMSSystemData", JSON.stringify(userData));
          }

          if (userData && babelHelpers.typeof(userData.manifests) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && babelHelpers.typeof(userData.manifests[manifest.id]) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && userData.manifests[manifest.id].accessData !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
            accessData = userData.manifests[manifest.id].accessData;
          }

          var manifestItems = manifest.items.map(function (i) {
            var parentLocation = null;
            var parentSlug = null;
            var parent = manifest.items.find(function (d) {
              return i.parent === d.id;
            });

            if (parent) {
              parentLocation = parent.location;
              parentSlug = parent.slug;
            } // get local storage and look for data from this to mesh up


            var metadata = i.metadata;

            if (babelHelpers.typeof(accessData[i.id]) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
              metadata.accessData = accessData[i.id];
            }

            var location = i.location;
            var slug = i.slug;
            return Object.assign({}, i, {
              parentLocation: parentLocation,
              parentSlug: parentSlug,
              location: location,
              slug: slug,
              metadata: metadata
            });
          }); // build the children into a hierarchy too

          manifestItems.forEach(function (item, i) {
            _this4._setChildren(item, manifestItems);
          });
          /**
           * Publish Pages Option
           *
           * This option enables the notion of published and unpublished pages.
           * To enable this option set manifest.metadata.site.settings.publishPagesOn = true
           *
           * By default all pages will be published unless "metadata.published" is set to "true" on the
           * item.
           */

          if ((0, _utils.varGet)(manifest, "metadata.site.settings.publishPagesOn", false) === true) {
            var filterHiddenParentsRecursive = function filterHiddenParentsRecursive(item) {
              // if the item is unpublished then remove it.
              if (item.metadata.published === false) {
                return false;
              } // if the item has parents, recursively see if any parent is not published


              var parent = manifestItems.find(function (i) {
                return i.id === item.parent;
              });

              if (parent) {
                return filterHiddenParentsRecursive(parent);
              } // if it got this far then it should be good.


              return true;
            };

            manifestItems = manifestItems.filter(function (i) {
              return filterHiddenParentsRecursive(i);
            });
          }

          return Object.assign({}, manifest, {
            items: manifestItems,
            accessData: accessData
          });
        }
      }
      /**
       * Return the site title
       */

    }, {
      key: "siteTitle",
      get: function get() {
        var manifest = this.manifest;

        if (manifest && manifest.title) {
          return manifest.title;
        }

        return "";
      }
      /**
       * Figure out the home page, lazily the 1st thing in the manifest
       */

    }, {
      key: "homeLink",
      get: function get() {
        // if we are on the homepage then load the first item in the manifest and set it active
        if (this.manifest) {
          var firstItem = this.manifest.items.find(function (i) {
            return typeof i.id !== "undefined";
          });

          if (firstItem) {
            return firstItem.slug;
          }
        }

        return "/";
      }
      /**
       * Get the active Item based on activeId
       */

    }, {
      key: "activeItem",
      get: function get() {
        var item = this.findItem(this.activeId); // ensure we found something, return null for consistency in data

        if (item) {
          return item;
        }

        return null;
      }
      /**
       * Get the fields from the node
       */

    }, {
      key: "activeItemFields",
      get: function get() {
        // need to have metadata to be valid so..
        if (this.activeItem && this.activeItem.metadata) {
          // core "fields" we'd expect
          var fields = {
            title: this.activeItem.title,
            description: this.activeItem.description,
            location: this.activeItem.location,
            slug: this.activeItem.slug,
            created: this.activeItem.metadata.created,
            updated: this.activeItem.metadata.created
          }; // mix in any custom field definitions

          if (this.activeItem.metadata.fields) {
            return Object.assign({}, fields, this.activeItem.metadata.fields);
          }
        }
      }
      /**
       * get theme data from manifest + activeId combo
       */

    }, {
      key: "themeData",
      get: function get() {
        if (this.manifest) {
          var themeData = {}; // this is required so better be...

          if ((0, _utils.varExists)(this.manifest, "metadata.theme")) {
            themeData = this.manifest.metadata.theme;
          } else {
            // fallback juuuuust to be safe...
            themeData = {
              "haxcms-basic-theme": {
                element: "haxcms-basic-theme",
                path: "@lrnwebcomponents/haxcms-elements/lib/core/themes/haxcms-basic-theme.js",
                name: "Basic theme",
                variables: {
                  image: "assets/banner.jpg",
                  icon: "icons:record-voice-over",
                  hexCode: "#da004e",
                  cssVariable: "pink"
                }
              }
            };
          } // ooo you sneaky devil you...


          if (this.activeItem && (0, _utils.varExists)(this.activeItem, "metadata.theme")) {
            return this.activeItem.metadata.theme;
          }

          return themeData;
        }
      }
      /**
       * Get the active manifest index array position
       * -1 if not found
       */

    }, {
      key: "activeManifestIndex",
      get: function get() {
        if (this.manifest && this.manifest.items && this.activeId) {
          for (var index in this.manifest.items) {
            if (this.manifest.items[index].id === this.activeId) {
              return parseInt(index);
            }
          }
        }

        return -1;
      }
    }, {
      key: "activeRouterManifestIndex",
      get: function get() {
        if (this.routerManifest && this.routerManifest.items && this.activeId) {
          for (var index in this.routerManifest.items) {
            if (this.routerManifest.items[index].id === this.activeId) {
              return parseInt(index);
            }
          }
        }

        return -1;
      }
      /**
       * Better for visualizing the counter
       */

    }, {
      key: "activeManifestIndexCounter",
      get: function get() {
        if (this.activeManifestIndex !== null) {
          return 1 + this.activeManifestIndex;
        }

        return 0;
      }
      /**
       * shortcut for active page title
       */

    }, {
      key: "activeTitle",
      get: function get() {
        if (this.activeItem) {
          return this.activeItem.title;
        }

        return "";
      }
      /**
       * shortcut for active page parent title
       */

    }, {
      key: "parentTitle",
      get: function get() {
        var _this5 = this;

        if (this.manifest && this.activeItem) {
          var tmpItem = this.manifest.items.find(function (d) {
            return _this5.activeItem.parent === d.id;
          }); // shift up 1 if we found something

          if (tmpItem) {
            return tmpItem.title;
          }
        }

        return "";
      }
    }, {
      key: "isLoggedIn",
      get: function get() {
        // account for keypair storage issue since its a string bin
        if (this.jwt && this.jwt != "null") {
          return true;
        }

        return false;
      }
      /**
       * shortcut for active page ancestor title
       */

    }, {
      key: "ancestorTitle",
      get: function get() {
        var _this6 = this;

        if (this.manifest && this.activeItem) {
          var _ret3 = function () {
            var tmpItem = _this6.manifest.items.find(function (d) {
              return _this6.activeItem.parent === d.id;
            }); // walk back up to the root


            while (tmpItem && tmpItem.parent != null) {
              // take the parent object of this current item
              tmpItem = _this6.manifest.items.find(function (i) {
                return i.id == tmpItem.parent;
              });
            }

            if (tmpItem) {
              return {
                v: tmpItem.title
              };
            }
          }();

          if (babelHelpers.typeof(_ret3) === "object") return _ret3.v;
        }

        return "";
      }
    }]);
    return Store;
  }();

  (0, _mobxModule.decorate)(Store, {
    location: _mobxModule.observable.ref,
    // router location in url
    editMode: _mobxModule.observable,
    // global editing state
    jwt: _mobxModule.observable,
    // json web token
    dashboardOpened: _mobxModule.observable,
    // if haxcms backend settings are open
    userData: _mobxModule.observable,
    // user data object for logged in users
    manifest: _mobxModule.observable,
    // JOS / manifest
    activeItemContent: _mobxModule.observable,
    // active site content, cleaned up
    themeElement: _mobxModule.observable,
    // theme element
    routerManifest: _mobxModule.computed,
    // router mixed in manifest w/ routes / paths
    siteTitle: _mobxModule.computed,
    isLoggedIn: _mobxModule.computed,
    // simple boolean for state so we can style based on logged in
    themeData: _mobxModule.computed,
    // get the active theme from manifest + activeId
    homeLink: _mobxModule.computed,
    activeId: _mobxModule.observable,
    // this affects all state changes associated to activeItem
    activeItem: _mobxModule.computed,
    // active item object
    activeItemFields: _mobxModule.computed,
    // active item field values
    activeManifestIndex: _mobxModule.computed,
    // active array index, used for pagination
    activeManifestIndexCounter: _mobxModule.computed,
    // active array index counter, used for pagination
    activeTitle: _mobxModule.computed,
    // active page title
    parentTitle: _mobxModule.computed,
    // active page parent title
    ancestorTitle: _mobxModule.computed,
    // active page ancestor title
    changeActiveItem: _mobxModule.action.bound
  });
  /**
   * Central store
   */

  var store = new Store(); // register globally so we can make sure there is only one

  _exports.store = store;
  window.HAXCMS = window.HAXCMS || {}; // request if this exists. This helps invoke the element existing in the dom
  // as well as that there is only one of them. That way we can ensure everything
  // is rendered through the same modal

  window.HAXCMS.requestAvailability = function () {
    if (!window.HAXCMS.instance) {
      window.HAXCMS.instance = document.createElement("haxcms-site-store");
      document.body.appendChild(window.HAXCMS.instance);
    }

    return window.HAXCMS.instance;
  }; // weird, but self appending


  window.HAXCMS.requestAvailability();
  /**
   * HTMLElement
   */

  var HAXCMSSiteStore =
  /*#__PURE__*/
  function (_HTMLElement) {
    babelHelpers.inherits(HAXCMSSiteStore, _HTMLElement);

    function HAXCMSSiteStore() {
      var _this7;

      babelHelpers.classCallCheck(this, HAXCMSSiteStore);
      _this7 = babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(HAXCMSSiteStore).call(this)); // keep track of the HTML element pieces dedicated to different
      // critical pieces of functionality like theme and editor builders.

      _this7.storePieces = {}; // full on store that does the heavy lifting

      _this7.store = store; // source for reading in the store if different than default site.json

      _this7.source = "";
      /**
       * When location changes update activeItem
       */

      (0, _mobxModule.autorun)(function () {
        if (store.location && store.location.route && store.location.route.component) {
          // get the id from the router
          var id = store.location.route.name; // make sure that we aren't in edit mode

          var found = store.manifest.items.filter(function (item) {
            if (item.id !== id) {
              return false;
            }

            return true;
          });

          if (found) {
            store.activeId = id;
          }
        }
      });
      /**
       * When Active Item Changes notify json-outline-schema to have the backend
       * change the page.
       */

      (0, _mobxModule.autorun)(function () {
        var foundItem = (0, _mobxModule.toJS)(store.findItem(store.activeId));

        if (foundItem) {
          document.body.dispatchEvent(new CustomEvent("json-outline-schema-active-item-changed", {
            bubbles: true,
            composed: true,
            cancelable: false,
            detail: foundItem
          }));
        }
      });
      /**
       * When editMode changes notify HAXeditor.
       */

      (0, _mobxModule.autorun)(function () {
        var editMode = (0, _mobxModule.toJS)(store.editMode); // trap for early setup

        if (window.HaxStore && window.HaxStore.write) {
          window.dispatchEvent(new CustomEvent("haxcms-edit-mode-changed", {
            bubbles: true,
            composed: true,
            cancelable: false,
            detail: editMode
          }));
          window.HaxStore.write("editMode", editMode, window.HaxStore.instance); // @todo hack to keep voice controls active if enabled

          if (window.HaxStore.instance && window.HaxStore.instance.globalPreferences.haxVoiceCommands) {
            setTimeout(function () {
              window.HaxStore.instance.__hal.auto = true;
            }, 10);
          }
        }
      });
      return _this7;
    }
    /**
     * Try to get context of what backend is powering this
     */


    babelHelpers.createClass(HAXCMSSiteStore, [{
      key: "getApplicationContext",
      value: function getApplicationContext() {
        var context = ""; // @todo review if we even need this because newer contexts don't care
        // figure out the context we need to apply for where the editing creds
        // and API might come from
        // beaker is a unique scenario

        if ((typeof DatArchive === "undefined" ? "undefined" : babelHelpers.typeof(DatArchive)) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
          context = "beaker";
        } else {
          switch (window.HAXCMSContext) {
            case "published":
            case "nodejs":
            case "php":
            case "11ty":
            case "demo":
            case "desktop":
              context = window.HAXCMSContext;
              break;

            default:
              // we don't have one so assume it's php for now
              // @notice change this in the future
              context = "php";
              break;
          }
        }

        return context;
      }
    }, {
      key: "attributeChangedCallback",
      value: function attributeChangedCallback(name, oldVal, newVal) {
        var _this8 = this;

        if (name == "source" && newVal != "") {
          fetch(this[name]).then(function (response) {
            return response.json();
          }).then(function (data) {
            _this8.store.loadManifest(data);
          }).catch(function (err) {
            console.warn(err);
          });
        }
      }
    }, {
      key: "source",
      set: function set(value) {
        this[name] = value;

        if (value) {
          this.setAttribute("source", value);
        }
      },
      get: function get() {
        return this.getAttribute("source");
      }
    }], [{
      key: "tag",
      get: function get() {
        return "haxcms-site-store";
      }
    }, {
      key: "observedAttributes",
      get: function get() {
        return ["source"];
      }
    }]);
    return HAXCMSSiteStore;
  }(babelHelpers.wrapNativeSuper(HTMLElement));

  _exports.HAXCMSSiteStore = HAXCMSSiteStore;
  window.customElements.define(HAXCMSSiteStore.tag, HAXCMSSiteStore);
});