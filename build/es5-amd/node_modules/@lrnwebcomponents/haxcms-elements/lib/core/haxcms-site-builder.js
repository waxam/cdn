define(["exports", "meta", "require", "../../../../@polymer/polymer/polymer-element.js", "../../../../@polymer/polymer/lib/utils/settings.js", "../../../../@polymer/polymer/lib/mixins/element-mixin.js", "../../../../@polymer/polymer/lib/utils/render-status.js", "../../../../@polymer/polymer/lib/legacy/polymer.dom.js", "../../../../@polymer/polymer/lib/utils/resolve-url.js", "../../../json-outline-schema/json-outline-schema.js", "../../../hax-body/lib/haxutils.js", "../../../../mobx/lib/mobx.module.js", "./haxcms-site-store.js", "./haxcms-site-router.js", "../../../../@polymer/iron-ajax/iron-ajax.js"], function (_exports, meta, _require, _polymerElement, _settings, _elementMixin, _renderStatus, _polymerDom, _resolveUrl, _jsonOutlineSchema, _haxutils, _mobxModule, _haxcmsSiteStore, _haxcmsSiteRouter, _ironAjax) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.HAXCMSSiteBuilder = void 0;
  meta = babelHelpers.interopRequireWildcard(meta);
  _require = babelHelpers.interopRequireWildcard(_require);

  function _templateObject_63e0b0d0e14a11e9bce923988a998e3c() {
    var data = babelHelpers.taggedTemplateLiteral(["\n      <style>\n        :host {\n          display: block;\n        }\n        :host #slot {\n          transition: all 0.2s ease-in-out;\n          background-color: var(--haxcms-color, white);\n          opacity: 0.2;\n          visibility: hidden;\n        }\n        :host([dashboard-opened]) {\n          display: inline-block !important;\n          margin-left: 50vw;\n          height: 100vh;\n          transition: 1s linear margin;\n          pointer-events: none;\n          opacity: 0.5;\n          width: 100vw;\n        }\n        :host([theme-loaded]) #slot {\n          opacity: 1;\n          visibility: visible;\n        }\n        paper-progress {\n          display: block;\n          width: 100%;\n          position: fixed;\n          top: 0;\n          left: 0;\n          right: 0;\n          background-color: transparent;\n          z-index: 1000;\n          --paper-progress-active-color: var(\n            --haxcms-color,\n            rgba(255, 255, 255, 0.5)\n          );\n          --paper-progress-container-color: transparent;\n        }\n      </style>\n      <haxcms-site-router base-uri=\"[[baseURI]]\"></haxcms-site-router>\n      <paper-progress hidden$=\"[[!loading]]\" indeterminate></paper-progress>\n      <iron-ajax\n        id=\"manifest\"\n        url=\"[[outlineLocation]][[file]][[_timeStamp]]\"\n        handle-as=\"json\"\n        last-response=\"{{manifest}}\"\n        last-error=\"{{lastError}}\"\n      ></iron-ajax>\n      <iron-ajax\n        id=\"activecontent\"\n        url=\"[[outlineLocation]][[activeItem.location]][[_timeStamp]]\"\n        handle-as=\"text\"\n        loading=\"{{loading}}\"\n        last-response=\"{{activeItemContent}}\"\n        last-error=\"{{lastError}}\"\n      ></iron-ajax>\n      <div id=\"slot\"><slot></slot></div>\n      <simple-colors></simple-colors>\n    "], ["\n      <style>\n        :host {\n          display: block;\n        }\n        :host #slot {\n          transition: all 0.2s ease-in-out;\n          background-color: var(--haxcms-color, white);\n          opacity: 0.2;\n          visibility: hidden;\n        }\n        :host([dashboard-opened]) {\n          display: inline-block !important;\n          margin-left: 50vw;\n          height: 100vh;\n          transition: 1s linear margin;\n          pointer-events: none;\n          opacity: 0.5;\n          width: 100vw;\n        }\n        :host([theme-loaded]) #slot {\n          opacity: 1;\n          visibility: visible;\n        }\n        paper-progress {\n          display: block;\n          width: 100%;\n          position: fixed;\n          top: 0;\n          left: 0;\n          right: 0;\n          background-color: transparent;\n          z-index: 1000;\n          --paper-progress-active-color: var(\n            --haxcms-color,\n            rgba(255, 255, 255, 0.5)\n          );\n          --paper-progress-container-color: transparent;\n        }\n      </style>\n      <haxcms-site-router base-uri=\"[[baseURI]]\"></haxcms-site-router>\n      <paper-progress hidden\\$=\"[[!loading]]\" indeterminate></paper-progress>\n      <iron-ajax\n        id=\"manifest\"\n        url=\"[[outlineLocation]][[file]][[_timeStamp]]\"\n        handle-as=\"json\"\n        last-response=\"{{manifest}}\"\n        last-error=\"{{lastError}}\"\n      ></iron-ajax>\n      <iron-ajax\n        id=\"activecontent\"\n        url=\"[[outlineLocation]][[activeItem.location]][[_timeStamp]]\"\n        handle-as=\"text\"\n        loading=\"{{loading}}\"\n        last-response=\"{{activeItemContent}}\"\n        last-error=\"{{lastError}}\"\n      ></iron-ajax>\n      <div id=\"slot\"><slot></slot></div>\n      <simple-colors></simple-colors>\n    "]);

    _templateObject_63e0b0d0e14a11e9bce923988a998e3c = function _templateObject_63e0b0d0e14a11e9bce923988a998e3c() {
      return data;
    };

    return data;
  }

  /**
   * `haxcms-site-builder`
   * `build the site and everything off of this`
   * @microcopy - the mental model for this element
   * - This is a factory element, it doesn't do much on its own visually
   * - it loads a site.json file and then utilizes this data in order to construct
   *   what theme it should load (element) in order to get everything off and running
   */
  var HAXCMSSiteBuilder =
  /*#__PURE__*/
  function (_PolymerElement) {
    babelHelpers.inherits(HAXCMSSiteBuilder, _PolymerElement);
    babelHelpers.createClass(HAXCMSSiteBuilder, [{
      key: "_themeNameChanged",
      value: function _themeNameChanged(newValue) {
        if (newValue) {
          _haxcmsSiteStore.store.themeElement = document.createElement(newValue);
          (0, _haxutils.wipeSlot)(this, "*");
          (0, _polymerDom.dom)(this).appendChild(_haxcmsSiteStore.store.themeElement);
        } else if (newValue && oldValue) {
          // theme changed
          _haxcmsSiteStore.store.themeElement.remove(); // wipe out what we got


          (0, _haxutils.wipeSlot)(this, "*");
          _haxcmsSiteStore.store.themeElement = document.createElement(newValue);
          (0, _polymerDom.dom)(this).appendChild(_haxcmsSiteStore.store.themeElement);
        }
      }
    }, {
      key: "_lastErrorChanged",
      value: function _lastErrorChanged(newValue) {
        if (newValue) {
          console.error(newValue);
          var evt = new CustomEvent("simple-toast-show", {
            bubbles: true,
            composed: true,
            cancelable: true,
            detail: {
              text: newValue.statusText
            }
          });
          window.dispatchEvent(evt);
        }
      }
      /**
       * ready life cycle
       */

    }], [{
      key: "tag",

      /**
       * Store the tag name to make it easier to obtain directly.
       * @notice function name must be here for tooling to operate correctly
       */
      get: function get() {
        return "haxcms-site-builder";
      } // render function

    }, {
      key: "template",
      get: function get() {
        return (0, _polymerElement.html)(_templateObject_63e0b0d0e14a11e9bce923988a998e3c());
      }
    }, {
      key: "properties",
      get: function get() {
        return {
          /**
           * Singular error reporter / visual based on requests erroring
           */
          lastError: {
            type: Object,
            observer: "_lastErrorChanged"
          },
          _timeStamp: {
            type: String
          },
          dashboardOpened: {
            type: Boolean,
            observer: "_dashboardOpenedChanged",
            reflectToAttribute: true
          },

          /**
           * queryParams
           */
          queryParams: {
            type: Object
          },

          /**
           * Loading status of the page to render.
           */
          loading: {
            type: Boolean,
            value: false,
            reflectToAttribute: true
          },

          /**
           * support for alternate locations.
           */
          outlineLocation: {
            type: String,
            notify: true,
            reflectToAttribute: true
          },

          /**
           * Manifest from file
           */
          manifest: {
            type: Object,
            notify: true,
            observer: "_manifestChanged"
          },

          /**
           * Theme, used to boot a design element
           */
          themeData: {
            type: Object,
            observer: "_themeChanged"
          },

          /**
           * Theme name, which we then use to setup the theme
           */
          themeName: {
            type: String,
            observer: "_themeNameChanged"
          },

          /**
           * Imported items so we can allow theme flipping dynamically
           */
          __imported: {
            type: Object,
            value: {}
          },

          /**
           * theme loaded to indicate to the theme we have a theme ready to go
           */
          themeLoaded: {
            type: Boolean,
            reflectToAttribute: true,
            value: false
          },

          /**
           * Active item which is in JSON Outline Schema
           */
          activeItem: {
            type: Object,
            notify: true,
            observer: "_activeItemChanged"
          },

          /**
           * Active item content
           */
          activeItemContent: {
            type: String,
            notify: true,
            observer: "_activeItemContentChanged"
          },

          /**
           * Location of the site.json file
           */
          file: {
            type: String,
            observer: "_fileChanged"
          },

          /**
           * Injected by HAXcms
           */
          baseURI: {
            type: String
          }
        };
      }
    }]);

    function HAXCMSSiteBuilder() {
      var _this;

      babelHelpers.classCallCheck(this, HAXCMSSiteBuilder);
      _this = babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(HAXCMSSiteBuilder).call(this));
      window.addEventListener("hax-store-ready", _this.storeReady.bind(babelHelpers.assertThisInitialized(_this))); // attempt to set polymer passive gestures globally
      // this decreases logging and improves performance on scrolling

      (0, _settings.setPassiveTouchGestures)(true); // hide the outdated fallback

      if (document.getElementById("haxcmsoutdatedfallback")) {
        document.getElementById("haxcmsoutdatedfallback").style.display = "none";
      }

      _this.__disposer = [];
      (0, _mobxModule.autorun)(function (reaction) {
        _this.dashboardOpened = (0, _mobxModule.toJS)(_haxcmsSiteStore.store.dashboardOpened);

        _this.__disposer.push(reaction);
      });
      (0, _mobxModule.autorun)(function (reaction) {
        _this.themeData = (0, _mobxModule.toJS)(_haxcmsSiteStore.store.themeData);

        if (_this.themeData && _this.themeData.element !== _this.themeName) {
          _this.themeName = _this.themeData.element;
        }

        _this.__disposer.push(reaction);
      });
      (0, _mobxModule.autorun)(function (reaction) {
        _this.activeItem = (0, _mobxModule.toJS)(_haxcmsSiteStore.store.activeItem);

        _this.__disposer.push(reaction);
      });
      _this._timeStamp = "";
      return _this;
    }

    babelHelpers.createClass(HAXCMSSiteBuilder, [{
      key: "_dashboardOpenedChanged",
      value: function _dashboardOpenedChanged(newValue, oldValue) {
        if (newValue) {
          this.setAttribute("aria-hidden", "aria-hidden");
          this.setAttribute("tabindex", "-1");
        } else if (!newValue && oldValue) {
          this.removeAttribute("aria-hidden");
          this.removeAttribute("tabindex");
        }
      }
    }, {
      key: "connectedCallback",
      value: function connectedCallback() {
        babelHelpers.get(babelHelpers.getPrototypeOf(HAXCMSSiteBuilder.prototype), "connectedCallback", this).call(this);
        new Promise(function (res, rej) {
          return _require.default(["../../../../@polymer/paper-progress/paper-progress.js"], res, rej);
        });
        (0, _renderStatus.afterNextRender)(this, function () {
          var _this2 = this;

          new Promise(function (res, rej) {
            return _require.default(["../../../simple-toast/simple-toast.js"], res, rej);
          });
          new Promise(function (res, rej) {
            return _require.default(["../../../simple-colors/simple-colors.js"], res, rej);
          });
          this.dispatchEvent(new CustomEvent("haxcms-ready", {
            bubbles: true,
            composed: true,
            cancelable: false,
            detail: this
          }));

          if (document.getElementById("haxcmsoutdatedfallback")) {
            document.body.removeChild(document.getElementById("haxcmsoutdatedfallback"));
          }

          window.addEventListener("haxcms-trigger-update", this._triggerUpdatedData.bind(this));
          window.addEventListener("haxcms-trigger-update-node", this._triggerUpdatedNode.bind(this)); // dyanmcially import the editor builder which figures out if we should have one

          new Promise(function (res, rej) {
            return _require.default(["./haxcms-editor-builder.js"], res, rej);
          }).then(function (response) {
            _this2.editorBuilder = document.createElement("haxcms-editor-builder"); // attach editor builder after we've appended to the screen

            document.body.appendChild(_this2.editorBuilder); // get fresh data if not published / demo which is a form of published

            if (_this2.editorBuilder.getContext() !== "published" && _this2.editorBuilder.getContext() !== "demo") {
              _this2._timeStamp = "?" + Math.floor(Date.now() / 1000);
            }
          }).catch(function (error) {
            /* Error handling */
            console.log(error);
          });
          var evt = document.createEvent("UIEvents");
          evt.initUIEvent("resize", true, false, window, 0);
          window.dispatchEvent(evt);
        });
      }
      /**
       * Detached life cycle
       */

    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        window.removeEventListener("haxcms-trigger-update", this._triggerUpdatedData.bind(this));
        window.removeEventListener("haxcms-trigger-update-node", this._triggerUpdatedNode.bind(this));

        for (var i in this.__disposer) {
          this.__disposer[i].dispose();
        }

        window.removeEventListener("hax-store-ready", this.storeReady.bind(this));
        babelHelpers.get(babelHelpers.getPrototypeOf(HAXCMSSiteBuilder.prototype), "disconnectedCallback", this).call(this);
      }
    }, {
      key: "storeReady",
      value: function storeReady(e) {
        // append UI element to body to avoid stack order issues
        if (_haxcmsSiteStore.store.cmsSiteEditor && _haxcmsSiteStore.store.cmsSiteEditor.instance && window.HaxStore.instance.activeHaxBody && _haxcmsSiteStore.store.activeItemContent) {
          window.HaxStore.instance.activeHaxBody.importContent(_haxcmsSiteStore.store.activeItemContent);
        }
      }
      /**
       * React to content being loaded from a page.
       */

    }, {
      key: "_activeItemContentChanged",
      value: function _activeItemContentChanged(newValue, oldValue) {
        var _this3 = this;

        if (newValue) {
          var html = newValue; // only append if not empty

          if (html !== null) {
            (0, _haxutils.wipeSlot)(_haxcmsSiteStore.store.themeElement, "*");
            html = (0, _haxutils.encapScript)(newValue); // set in the store

            _haxcmsSiteStore.store.activeItemContent = html; // insert the content as quickly as possible, then work on the dynamic imports
            // @todo this might be why we get a double render some times

            setTimeout(function () {
              if ((0, _polymerDom.dom)(_haxcmsSiteStore.store.themeElement).getEffectiveChildNodes().length === 0) {
                var frag = document.createRange().createContextualFragment(html);
                (0, _polymerDom.dom)(_haxcmsSiteStore.store.themeElement).appendChild(frag);

                _this3.dispatchEvent(new CustomEvent("json-outline-schema-active-body-changed", {
                  bubbles: true,
                  composed: true,
                  cancelable: false,
                  detail: html
                }));
              }
            }, 5); // if there are, dynamically import them

            if ((0, _haxutils.varExists)(this.manifest, "metadata.node.dynamicElementLoader")) {
              var i;

              (function () {
                var tagsFound = (0, _haxutils.findTagsInHTML)(html);
                var basePath = (0, _resolveUrl.pathFromUrl)(decodeURIComponent(meta.url));

                var _loop = function _loop() {
                  var tagName = tagsFound[i];

                  if (_this3.manifest.metadata.node.dynamicElementLoader[tagName] && !window.customElements.get(tagName)) {
                    new Promise(function (res, rej) {
                      return _require.default(["".concat(basePath, "../../../../").concat(_this3.manifest.metadata.node.dynamicElementLoader[tagName])], res, rej);
                    }).then(function (response) {// useful to debug if dynamic references are coming in
                      //console.log(tagName + ' dynamic import');
                    }).catch(function (error) {
                      /* Error handling */
                      console.log(error);
                      console.log(tagName);
                    });
                  }
                };

                for (i in tagsFound) {
                  _loop();
                }
              })();
            }
          }
        }
      }
      /**
       * Active item updated, let's request the content from it
       */

    }, {
      key: "_activeItemChanged",
      value: function _activeItemChanged(newValue, oldValue) {
        if (newValue && babelHelpers.typeof(newValue.id) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
          this.set("queryParams.nodeId", newValue.id);
          this.notifyPath("queryParams.nodeId"); // if published, keep it static on request
          // @todo might revisit this in the future

          if (this.editorBuilder && this.editorBuilder.getContext() === "published") {
            this._timeStamp = "";
          } else {
            this._timeStamp = "?" + Math.floor(Date.now() / 1000);
          }

          this.$.activecontent.generateRequest();
        } // we had something, now we don't. wipe out the content area of the theme
        else if (oldValue && !newValue) {
            // fire event w/ nothing, this is because there is no content
            this.dispatchEvent(new CustomEvent("json-outline-schema-active-body-changed", {
              bubbles: true,
              composed: true,
              cancelable: false,
              detail: null
            }));
          }
      }
      /**
       * got a message that we need to update our json manifest data
       */

    }, {
      key: "_triggerUpdatedData",
      value: function _triggerUpdatedData(e) {
        // get fresh data if not published
        if (this.editorBuilder && this.editorBuilder.getContext() !== "published") {
          this._timeStamp = "?" + Math.floor(Date.now() / 1000);
        }

        this.$.manifest.generateRequest();
      }
      /**
       * got a message that we need to update our page content
       */

    }, {
      key: "_triggerUpdatedNode",
      value: function _triggerUpdatedNode(e) {
        // get fresh data if not published
        if (this.editorBuilder && this.editorBuilder.getContext() !== "published" && this.editorBuilder.getContext() !== "demo") {
          this._timeStamp = "?" + Math.floor(Date.now() / 1000);
        } // ensure we don't get a miss on initial load


        if (this.activeItem.location) {
          this.$.activecontent.generateRequest();
        }
      }
      /**
       * File changed so let's pull from the location
       */

    }, {
      key: "_fileChanged",
      value: function _fileChanged(newValue, oldValue) {
        if (babelHelpers.typeof(newValue) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
          this.$.manifest.generateRequest();
        }
      }
      /**
       * notice manifest changes and ensure slot is rebuilt.
       */

    }, {
      key: "_manifestChanged",
      value: function _manifestChanged(newValue, oldValue) {
        if (newValue && newValue.metadata && newValue.items) {
          // @todo replace this with a schema version mapper
          // once we have versions
          if ((0, _haxutils.varExists)(newValue, "metadata.siteName")) {
            var git = (0, _haxutils.varGet)(newValue, "publishing.git", {});
            newValue.metadata.site = {
              name: newValue.metadata.siteName,
              git: git,
              created: newValue.metadata.created,
              updated: newValue.metadata.updated
            };
            newValue.metadata.theme.variables = {
              image: newValue.metadata.image,
              icon: newValue.metadata.icon,
              hexCode: newValue.metadata.hexCode,
              cssVariable: newValue.metadata.cssVariable
            };
            newValue.metadata.node = {
              dynamicElementLoader: newValue.metadata.dynamicElementLoader,
              fields: newValue.metadata.fields
            };
            delete newValue.metadata.publishing;
            delete newValue.metadata.created;
            delete newValue.metadata.updated;
            delete newValue.metadata.siteName;
            delete newValue.metadata.image;
            delete newValue.metadata.icon;
            delete newValue.metadata.hexCode;
            delete newValue.metadata.cssVariable;
            delete newValue.metadata.dynamicElementLoader;
            delete newValue.metadata.fields;
          }

          var site = new _jsonOutlineSchema.JsonOutlineSchema(); // we already have our items, pass them in

          var nodes = site.itemsToNodes(newValue.items); // smash outline into flat to get the correct order

          var correctOrder = site.nodesToItems(nodes);
          var newItems = []; // build a new array in the correct order by pushing the old items around

          for (var key in correctOrder) {
            newItems.push(newValue.items.find(function (element) {
              return element.id === correctOrder[key].id;
            }));
          }

          newValue.items = newItems;
          _haxcmsSiteStore.store.manifest = newValue;
          this.dispatchEvent(new CustomEvent("json-outline-schema-changed", {
            bubbles: true,
            composed: true,
            cancelable: false,
            detail: newValue
          }));
        }
      }
      /**
       * notice theme changes and ensure slot is rebuilt.
       */

    }, {
      key: "_themeChanged",
      value: function _themeChanged(newValue, oldValue) {
        var _this4 = this;

        if (newValue) {
          this.themeLoaded = false;
          var theme = newValue; // create the 'theme' as a new element
          // weird but definition already here so we should be able
          // to just use this without an import, it's possible..

          if (babelHelpers.typeof(this.__imported[theme.element]) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
            this.themeLoaded = true;
          } else {
            // import the reference to the item dynamically, if we can
            try {
              new Promise(function (res, rej) {
                return _require.default([(0, _resolveUrl.pathFromUrl)(decodeURIComponent(meta.url)) + "../../../../" + newValue.path], res, rej);
              }).then(function (e) {
                // add it into ourselves so it unpacks and we kick this off!
                _this4.__imported[theme.element] = theme.element;
                _this4.themeLoaded = true;
              });
            } catch (err) {
              // error in the event this is a double registration
              // also strange to be able to reach this but technically possible
              this.themeLoaded = true;
            }
          } // delay for theme switching to reapply the css variable associations


          setTimeout(function () {
            (0, _elementMixin.updateStyles)();
          }, 500);
        }
      }
    }]);
    return HAXCMSSiteBuilder;
  }(_polymerElement.PolymerElement);

  _exports.HAXCMSSiteBuilder = HAXCMSSiteBuilder;
  window.customElements.define(HAXCMSSiteBuilder.tag, HAXCMSSiteBuilder); // this global allows a backdoor into activating the HAXcms editor UI
  // this is only going to be visually enabled but it won't actually
  // be able to talk to the backend correctly bc the JWT won't exist
  // the endpoints are also fictional. also useful for testing purposes

  window.HAXme = function () {
    var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

    if (context == null) {
      // fake a demo
      context = "demo"; // fake endpoints

      window.appSettings = {
        login: "dist/dev/login.json",
        logout: "dist/dev/logout.json",
        saveNodePath: "dist/dev/saveNode.json",
        saveManifestPath: "dist/dev/saveManifestPath.json",
        createNodePath: "dist/dev/saveNode.json",
        deleteNodePath: "dist/dev/saveNode.json",
        saveOutlinePath: "dist/dev/saveNode.json",
        publishSitePath: "dist/dev/saveNode.json",
        syncSitePath: "dist/dev/saveNode.json",
        getNodeFieldsPath: "dist/dev/getNodeFieldsPath.json",
        getSiteFieldsPath: "dist/dev/getSiteFieldsPath.json",
        revertSitePath: "dist/dev/saveNode.json",
        getFormToken: "adskjadshjudfu823u823u8fu8fij",
        appStore: {
          url: "dist/dev/appstore.json"
        },
        // add your custom theme here if testing locally and wanting to emulate the theme selector
        // this isn't really nessecary though
        themes: {
          "haxcms-dev-theme": {
            element: "haxcms-dev-theme",
            path: "@lrnwebcomponents/haxcms-elements/lib/haxcms-dev-theme.js",
            name: "Developer theme"
          }
        }
      };
    }

    if (context == "demo") {
      window.__haxCMSContextDemo = true;
    } // apply context


    document.body.querySelector("haxcms-editor-builder").applyContext(context);
  };
});