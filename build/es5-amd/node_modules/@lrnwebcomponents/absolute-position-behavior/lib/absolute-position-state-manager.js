define(["exports", "../../../lit-element/lit-element.js", "../../../@polymer/iron-resizable-behavior/iron-resizable-behavior.js"], function (_exports, _litElement, _ironResizableBehavior) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.AbsolutePositionStateManager = void 0;

  /**
   * Copyright 2018 The Pennsylvania State University
   * @license Apache-2.0, see License.md for full text.
   */
  // register globally so we can make sure there is only one
  window.AbsolutePositionStateManager = window.AbsolutePositionStateManager || {}; // request if this exists. This helps invoke element existing in dom
  // as well as that there is only one of them. That way we can ensure everything
  // is rendered through same modal

  window.AbsolutePositionStateManager.requestAvailability = function () {
    if (!window.AbsolutePositionStateManager.instance) {
      window.AbsolutePositionStateManager.instance = document.createElement("absolute-position-state-manager");
      var instance = window.AbsolutePositionStateManager.instance;
      document.body.appendChild(instance);
    }

    return window.AbsolutePositionStateManager.instance;
  };
  /**
   * `absolute-position-state-manager`
   * @customElement absolute-position-state-manager
   * manages state of multiple absolute-positioned elements on a page
   *
  
   * @polymer
   */


  var AbsolutePositionStateManager =
  /*#__PURE__*/
  function (_LitElement) {
    babelHelpers.inherits(AbsolutePositionStateManager, _LitElement);
    babelHelpers.createClass(AbsolutePositionStateManager, null, [{
      key: "tag",

      /* REQUIRED FOR TOOLING DO NOT TOUCH */

      /**
       * Store tag name to make it easier to obtain directly.
       */
      get: function get() {
        return "absolute-position-state-manager";
      } // properties available to custom element for data binding

    }, {
      key: "properties",
      get: function get() {
        return {
          /**
           * Stores an array of all elements using manager.
           */
          elements: {
            type: Array
          },

          /**
           * mutation observer
           */
          __observer: {
            type: Object
          },

          /**
           * resize timeout
           */
          __timeout: {
            type: Object
          }
        };
      }
      /**
       * Makes sure there is a utility ready and listening for elements.
       */

    }]);

    function AbsolutePositionStateManager() {
      var _this;

      babelHelpers.classCallCheck(this, AbsolutePositionStateManager);
      _this = babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(AbsolutePositionStateManager).call(this));
      _this.elements = [];
      _this.__timeout = false;
      _this.__observer = new MutationObserver(function (mutations) {
        return _this.checkMutations(mutations);
      });
      return _this;
    }
    /**
     * Loads element into array
     * @param {object} element to be added
     */


    babelHelpers.createClass(AbsolutePositionStateManager, [{
      key: "loadElement",
      value: function loadElement(el) {
        //only have event listeners when there are elements using manager
        if (this.elements.length < 1) {
          this.__observer.observe(document, {
            attributes: true,
            childList: true,
            subtree: true,
            characterData: true
          });

          this.updateElements();
          document.addEventListener("load", this.updateElements);
          window.addEventListener("resize", this._handleResize);
        }

        this.elements.push(el);
        this.positionElement(el);
      }
      /**
       * Unloads element from array
       * @param {object} element to be removed
       */

    }, {
      key: "unloadElement",
      value: function unloadElement(el) {
        this.elements.filter(function (element) {
          return element === el;
        });
        if (this.elements.length < 1) this.removeEventListeners();
      }
      /**
       * handles resize event
       */

    }, {
      key: "_handleResize",
      value: function _handleResize() {
        if (this.__timeout) clearTimeout(this.__timeout);
        this.__timeout = setTimeout(window.AbsolutePositionStateManager.instance.updateElements(), 250);
      }
      /**
       * Checks if there are any chances other than to
       * element's position and updates accordioning.
       * This is needed so that positioning elements
       * doesn't trigger an infinite loop of updates.
       *
       * @param {array} mutation records
       * @return {void}
       */

    }, {
      key: "checkMutations",
      value: function checkMutations(mutations) {
        var _this2 = this;

        var update = false;
        mutations.forEach(function (mutation) {
          if (update) return;
          update = update || !(mutation.type === "attributes" && mutation.attributeName === "style" && _this2.elements.includes(mutation.target));
        });
        if (update) this.updateElements();
      }
      /**
       * Returns target element that this element is anchored to. It is
       * either element given by `for` attribute, or immediate parent
       * of element.
       *
       * Uses `target` object if specified.
       * If not, queries document for elements with id specified in `for` attribute.
       * If there is more than one element that matches, gets closest matching element.
       *
       * @param {object} element using absolute-position behavior
       * @return {object} target element for positioning
       */

    }, {
      key: "findTarget",
      value: function findTarget(el) {
        var selector = "#" + el.for,
            docQuery = document.querySelectorAll(selector).length === 1 ? document.querySelector(selector) : null,
            target = el.target || docQuery,
            ancestor = el;

        while (el.for !== undefined && target === null && ancestor !== null && ancestor !== document) {
          ancestor = ancestor.parentNode;
          if (ancestor.nodeType === 11) ancestor = ancestor.host;
          target = ancestor ? ancestor.querySelector(selector) : null;
        }

        return target;
      }
      /**
       * Removes event listeners
       * @return {void}
       */

    }, {
      key: "removeEventListeners",
      value: function removeEventListeners() {
        if (this.__observer && this.__observer.disconnect) this.__observer.disconnect();
        document.removeEventListener("load", this.updateElements);
        window.removeEventListener("resize", this._handleResize);
      }
      /**
       * Updates position for all elements on page.
       * @return {void}
       */

    }, {
      key: "updateElements",
      value: function updateElements() {
        var _this3 = this;

        this.elements.forEach(function (element) {
          return _this3.positionElement(element);
        });
      }
      /**
       * Gets an updated position based on target.
       * @param {object} element using absolute-position behavior
       * @return {void}
       */

    }, {
      key: "positionElement",
      value: function positionElement(el) {
        var target = this.findTarget(el);
        if (!target || !el.offsetParent) return;

        var offset = el.offset,
            parentRect = el.offsetParent.getBoundingClientRect(),
            targetRect = target.getBoundingClientRect(),
            elRect = el.getBoundingClientRect(),
            vertical = function vertical(position) {
          //place element before vertically?
          return position !== "left" && position !== "right";
        },
            before = function before(position) {
          //place element before target?
          return position === "left" || position === "top";
        },

        /**
         * ;
         *
         */
        fitToBounds = function fitToBounds() {
          //fits element within parent's boundaries
          var pos1 = vertical(el.position) ? "left" : "top",
              pos2 = vertical(el.position) ? "right" : "bottom",
              getRect = function getRect(rect) {
            return vertical(el.position) ? rect.width : rect.height;
          },
              coord = targetRect[pos1] - getRect(elRect) / 2 + getRect(targetRect) / 2,
              min = parentRect[pos1],
              max = parentRect[pos2] - getRect(elRect);

          return el.fitToVisibleBounds ? Math.max(min, Math.min(max, coord)) + "px" : coord + "px"; //if element size > parent, align where parent begins
        },
            getCoord = function getCoord() {
          //adds or subtracts offset from target based on position
          return el.position === "top" ? targetRect.top - elRect.height - offset + "px" : el.position === "left" ? targetRect.left - elRect.width - offset + "px" : targetRect[el.position] + offset + "px";
        },
            isFit = function isFit(position) {
          //determines if room for element between parent and target
          var size = vertical(position) ? elRect.height + offset : elRect.width + offset;
          return before(position) ? targetRect[position] - parentRect[position] > size : parentRect[position] - targetRect[position] > size; //if no room, return original position
        };

        var flip = el.fitToVisibleBounds !== false && !isFit(el.position),
            flipData = {
          top: ["bottom", "left", "right"],
          left: ["right", "top", "bottom"],
          bottom: ["top", "right", "left"],
          right: ["left", "bottom", "top"]
        };
        /*
         * fits element according to specified postion,
         * or finds an alternative position that fits
         */

        if (flip && isFit(flipData[el.position][0])) {
          el.position = flipData[el.position][0];
        } else if (flip && isFit(flipData[el.position][1])) {
          el.position = flipData[el.position][1];
        } else if (flip && isFit(flipData[el.position][2])) {
          el.position = flipData[el.position][2];
        } else {
          el.style.position = "absolute";
          el.style.top = vertical(el.position) ? getCoord() : fitToBounds();
          el.style.left = vertical(el.position) ? fitToBounds() : getCoord(); //provide positions for element and target (in case furthor positioning adjustments are needed)

          el.__positions = {
            self: elRect,
            parent: parentRect,
            target: targetRect
          };
        }
      }
      /**
       * life cycle, element is removed from DOM
       */

    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        this.removeEventListeners();
        babelHelpers.get(babelHelpers.getPrototypeOf(AbsolutePositionStateManager.prototype), "disconnectedCallback", this).call(this);
      }
    }]);
    return AbsolutePositionStateManager;
  }(_litElement.LitElement);

  _exports.AbsolutePositionStateManager = AbsolutePositionStateManager;
  window.customElements.define(AbsolutePositionStateManager.tag, AbsolutePositionStateManager);
});