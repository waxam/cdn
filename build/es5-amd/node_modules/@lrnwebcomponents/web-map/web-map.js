define(["exports", "../../@polymer/polymer/polymer-element.js", "../../@polymer/polymer/lib/legacy/polymer.dom.js", "../../@polymer/polymer/lib/utils/async.js", "./lib/map-layer.js", "./lib/map-area.js", "./lib/map-styles.js"], function (_exports, _polymerElement, _polymerDom, async, _mapLayer, _mapArea, _mapStyles) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.WebMap = void 0;
  async = babelHelpers.interopRequireWildcard(async);

  function _templateObject_2f28e3d0b49011e9ae0d876050e9d419() {
    var data = babelHelpers.taggedTemplateLiteral(["\n      <!-- use the leaflet-styles style module -->\n      <style include=\"map-styles\">\n        /* make sure the map element doesn't get selected and styled by document styles */\n        :host {\n          display: inline-block !important;\n          position: relative !important;\n        }\n        /* try to constrain the map and the leaflet div#map to the size of the container */\n        :host,\n        :host #map {\n          max-width: 100%;\n          min-width: 100%;\n        }\n        /* this is a hack for shady DOM, as max-width messes with Leaflet tiles */\n        :host img {\n          max-width: none !important;\n        }\n        #map:focus {\n          outline: 2px double lightskyblue;\n        }\n      </style>\n      <!-- giving the map div a tabindex allows the map to display its focus. -->\n      <!-- see the #map:focus selector in styles, above. -->\n      <div id=\"map\" tabindex=\"0\"></div>\n      <slot></slot>\n    "]);

    _templateObject_2f28e3d0b49011e9ae0d876050e9d419 = function _templateObject_2f28e3d0b49011e9ae0d876050e9d419() {
      return data;
    };

    return data;
  }

  /* styles scoped to inside a custom element must be in a style module */

  /* web-map is an HTML &lt;map&gt; customized built-in element */
  var WebMap =
  /*#__PURE__*/
  function (_PolymerElement) {
    babelHelpers.inherits(WebMap, _PolymerElement);

    function WebMap() {
      babelHelpers.classCallCheck(this, WebMap);
      return babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(WebMap).apply(this, arguments));
    }

    babelHelpers.createClass(WebMap, [{
      key: "factoryImpl",
      value: function factoryImpl(width, height, lat, lon, zoom, projection, controls) {
        this.width = width;
        this.height = height;
        this.lat = lat || this.lat;
        this.lon = lon || this.lon;
        this.zoom = zoom || this.zoom;
        this.projection = projection || "OSMTILE";
        this.controls = controls || this.controls;
      }
    }, {
      key: "_toggleControls",
      value: function _toggleControls(controls) {
        if (this._map) {
          if (controls) {
            this._zoomControl = L.control.zoom().addTo(this._map);
            this._layerControl = M.mapMlLayerControl(null, {
              collapsed: true
            }).addTo(this._map);

            for (var i = 0; i < this.layers.length; i++) {
              if (!this.layers[i].hidden) {
                this._layerControl.addOverlay(this.layers[i]._layer, this.layers[i].label);

                this._map.on("moveend", this.layers[i]._validateDisabled, this.layers[i]);

                this.layers[i]._layerControl = this._layerControl;
              }
            }
          } else {
            this._map.removeControl(this._layerControl);

            this._map.removeControl(this._zoomControl);
          }
        }
      }
    }, {
      key: "_widthChanged",
      value: function _widthChanged(width) {
        this.style.width = width + "px";
        this.$.map.style.width = width + "px";

        if (this._map) {
          this._map.invalidateSize(false);
        }
      }
    }, {
      key: "_heightChanged",
      value: function _heightChanged(height) {
        this.style.height = height + "px";
        this.$.map.style.height = height + "px";

        if (this._map) {
          this._map.invalidateSize(false);
        }
      }
    }, {
      key: "zoomTo",
      value: function zoomTo(lat, lon, zoom) {
        zoom = zoom || this.zoom;
        var location = new L.LatLng(lat, lon);

        this._map.setView(location, zoom);

        this.zoom = zoom;
        this.lat = location.lat;
        this.lon = location.lng;
      }
    }, {
      key: "_updateMapCenter",
      value: function _updateMapCenter() {
        // remember to tell Leaflet event handler that 'this' in here refers to
        //  something other than the map in this case the custom polymer element
        this.lat = this._map.getCenter().lat;
        this.lon = this._map.getCenter().lng;
        this.zoom = this._map.getZoom();
      }
    }, {
      key: "ready",
      value: function ready() {
        babelHelpers.get(babelHelpers.getPrototypeOf(WebMap.prototype), "ready", this).call(this); // when used in a custom element, the leaflet script element is hidden inside
        // the import's shadow dom.

        L.Icon.Default.imagePath = function () {
          var imp = document.querySelector('link[rel="import"][href*="web-map.html"]'),
              doc = imp ? imp.import : document,
              scripts = doc.getElementsByTagName("script"),
              leafletRe = /[\/^]leaflet[\-\._]?([\w\-\._]*)\.js\??/;
          var i, len, src, path;

          for (i = 0, len = scripts.length; i < len; i++) {
            src = scripts[i].src;

            if (src.match(leafletRe)) {
              path = src.split(leafletRe)[0];
              return (path ? path + "/" : "") + "images";
            }
          }
        }();

        if (this.hasAttribute("name")) {
          var name = this.getAttribute("name");

          if (name) {
            this.poster = document.querySelector("img[usemap=" + '"#' + name + '"]'); // firefox has an issue where the attribution control's use of
            // _container.innerHTML does not work properly if the engine is throwing
            // exceptions because there are no area element children of the image map
            // for firefox only, a workaround is to actually remove the image...

            if (this.poster) {
              if (L.Browser.gecko) {
                this.poster.removeAttribute("usemap");
              }

              (0, _polymerDom.dom)(this.$.map).appendChild(this.poster);
            }
          }
        }
      }
    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        this._removeEvents();

        babelHelpers.get(babelHelpers.getPrototypeOf(WebMap.prototype), "disconnectedCallback", this).call(this);
      }
    }, {
      key: "connectedCallback",
      value: function connectedCallback() {
        var _this = this;

        babelHelpers.get(babelHelpers.getPrototypeOf(WebMap.prototype), "connectedCallback", this).call(this);
        async.microTask.run(function () {
          // the dimension attributes win, if they're there. A map does not
          // have an intrinsic size, unlike an image or video, and so must
          // have a defined width and height.
          var s = window.getComputedStyle(_this),
              wpx = s.width,
              hpx = s.height,
              w = parseInt(wpx.replace("px", "")),
              h = parseInt(hpx.replace("px", ""));

          if (wpx === "" || hpx === "") {
            return;
          }

          if (!_this.width || _this.width !== w) {
            _this.$.map.style.width = wpx;
            _this.width = w;
          } else {
            _this.$.map.style.width = _this.width + "px";
          }

          if (!_this.height || _this.height !== h) {
            _this.$.map.style.height = h;
            _this.height = h;
          } else {
            _this.$.map.style.height = _this.height + "px";
          } // create the Leaflet map if this is the first time attached is called


          if (!_this._map) {
            _this._map = L.map(_this.$.map, {
              center: new L.LatLng(_this.lat, _this.lon),
              projection: _this.projection,
              crs: M[_this.projection],
              zoom: _this.zoom,
              zoomControl: false,
              // because the M.MapMLLayer invokes _tileLayer._onMoveEnd when
              // the mapml response is received the screen tends to flash.  I'm sure
              // there is a better configuration than that, but at this moment
              // I'm not sure how to approach that issue.
              // See https://github.com/Maps4HTML/MapML-Leaflet-Client/issues/24
              fadeAnimation: true
            }); // optionally add controls to the map

            if (_this.controls) {
              _this._layerControl = M.mapMlLayerControl(null, {
                collapsed: true
              }).addTo(_this._map);
              _this._zoomControl = L.control.zoom().addTo(_this._map);
            } // the attribution control is not optional


            _this._attributionControl = _this._map.attributionControl.setPrefix('<a href="https://www.w3.org/community/maps4html/" title="W3C Maps4HTML Community Group">Maps4HTML</a> | <a href="http://leafletjs.com" title="A JS library for interactive maps">Leaflet</a>'); // make sure the layer knows about the map it belongs to.

            for (var i = 0; i < _this.layers.length; i++) {
              _this.layers[i]._attachedToMap();
            } // the area elements need the map to convert their coordinates to LatLng


            for (var i = 0; i < _this.areas.length; i++) {
              _this.areas[i]._attachedToMap();
            } // undisplay the image if *the first* layer works.  This is not perfect, as it
            // relies on the server to have responded by now.


            if (_this.layers[0] && typeof _this.layers[0]._layer.error === "undefined" && _this.layers[0]._layer._extent) {
              if (_this.poster) {
                _this.poster.style.display = "none";
              }
            }

            _this._setUpEvents();

            _this.dispatchEvent(new CustomEvent("load", {
              bubbles: true,
              cancelable: true,
              composed: true,
              detail: {
                target: _this
              }
            }));
          }
        }, 10);
      }
    }, {
      key: "_removeEvents",
      value: function _removeEvents() {
        if (this._map) {
          this._map.off("preclick click dblclick mousemove mouseover mouseout mousedown mouseup contextmenu", false, this);

          this._map.off("load movestart move moveend zoomstart zoom zoomend", false, this);
        }
      }
    }, {
      key: "_setUpEvents",
      value: function _setUpEvents() {
        this._map.on("load", function () {
          this.dispatchEvent(new CustomEvent("load", {
            bubbles: true,
            cancelable: true,
            composed: true,
            detail: {
              target: this
            }
          }));
        }, this);

        this._map.on("preclick", function (e) {
          this.dispatchEvent(new CustomEvent("preclick", {
            bubbles: true,
            cancelable: true,
            composed: true,
            detail: {
              lat: e.latlng.lat,
              lon: e.latlng.lng,
              x: e.containerPoint.x,
              y: e.containerPoint.y
            }
          }));
        }, this);

        this._map.on("click", function (e) {
          this.dispatchEvent(new CustomEvent("click", {
            bubbles: true,
            cancelable: true,
            composed: true,
            detail: {
              lat: e.latlng.lat,
              lon: e.latlng.lng,
              x: e.containerPoint.x,
              y: e.containerPoint.y
            }
          }));
        }, this);

        this._map.on("dblclick", function (e) {
          this.dispatchEvent(new CustomEvent("dblclick", {
            bubbles: true,
            cancelable: true,
            composed: true,
            detail: {
              lat: e.latlng.lat,
              lon: e.latlng.lng,
              x: e.containerPoint.x,
              y: e.containerPoint.y
            }
          }));
        }, this);

        this._map.on("mousemove", function (e) {
          this.dispatchEvent(new CustomEvent("mousemove", {
            bubbles: true,
            cancelable: true,
            composed: true,
            detail: {
              lat: e.latlng.lat,
              lon: e.latlng.lng,
              x: e.containerPoint.x,
              y: e.containerPoint.y
            }
          }));
        }, this);

        this._map.on("mouseover", function (e) {
          this.dispatchEvent(new CustomEvent("mouseover", {
            bubbles: true,
            cancelable: true,
            composed: true,
            detail: {
              lat: e.latlng.lat,
              lon: e.latlng.lng,
              x: e.containerPoint.x,
              y: e.containerPoint.y
            }
          }));
        }, this);

        this._map.on("mouseout", function (e) {
          this.dispatchEvent(new CustomEvent("mouseout", {
            bubbles: true,
            cancelable: true,
            composed: true,
            detail: {
              lat: e.latlng.lat,
              lon: e.latlng.lng,
              x: e.containerPoint.x,
              y: e.containerPoint.y
            }
          }));
        }, this);

        this._map.on("mousedown", function (e) {
          this.dispatchEvent(new CustomEvent("mousedown", {
            bubbles: true,
            cancelable: true,
            composed: true,
            detail: {
              lat: e.latlng.lat,
              lon: e.latlng.lng,
              x: e.containerPoint.x,
              y: e.containerPoint.y
            }
          }));
        }, this);

        this._map.on("mouseup", function (e) {
          this.dispatchEvent(new CustomEvent("mouseup", {
            bubbles: true,
            cancelable: true,
            composed: true,
            detail: {
              lat: e.latlng.lat,
              lon: e.latlng.lng,
              x: e.containerPoint.x,
              y: e.containerPoint.y
            }
          }));
        }, this);

        this._map.on("contextmenu", function (e) {
          this.dispatchEvent(new CustomEvent("contextmenu", {
            bubbles: true,
            cancelable: true,
            composed: true,
            detail: {
              lat: e.latlng.lat,
              lon: e.latlng.lng,
              x: e.containerPoint.x,
              y: e.containerPoint.y
            }
          }));
        }, this);

        this._map.on("movestart", function () {
          this._updateMapCenter();

          this.dispatchEvent(new CustomEvent("movestart", {
            bubbles: true,
            cancelable: true,
            composed: true,
            detail: {
              target: this
            }
          }));
        }, this);

        this._map.on("move", function () {
          this._updateMapCenter();

          this.dispatchEvent(new CustomEvent("move", {
            bubbles: true,
            cancelable: true,
            composed: true,
            detail: {
              target: this
            }
          }));
        }, this);

        this._map.on("moveend", function () {
          this._updateMapCenter();

          this.dispatchEvent(new CustomEvent("moveend", {
            bubbles: true,
            cancelable: true,
            composed: true,
            detail: {
              target: this
            }
          }));
        }, this);

        this._map.on("zoomstart", function () {
          this._updateMapCenter();

          this.dispatchEvent(new CustomEvent("zoomstart", {
            bubbles: true,
            cancelable: true,
            composed: true,
            detail: {
              target: this
            }
          }));
        }, this);

        this._map.on("zoom", function () {
          this._updateMapCenter();

          this.dispatchEvent(new CustomEvent("zoom", {
            bubbles: true,
            cancelable: true,
            composed: true,
            detail: {
              target: this
            }
          }));
        }, this);

        this._map.on("zoomend", function () {
          this._updateMapCenter();

          this.dispatchEvent(new CustomEvent("zoomend", {
            bubbles: true,
            cancelable: true,
            composed: true,
            detail: {
              target: this
            }
          }));
        }, this);
      }
    }], [{
      key: "template",
      get: function get() {
        return (0, _polymerElement.html)(_templateObject_2f28e3d0b49011e9ae0d876050e9d419());
      }
    }, {
      key: "tag",
      get: function get() {
        return "web-map";
      }
    }, {
      key: "properties",
      get: function get() {
        return {
          lat: {
            type: Number,
            value: 0,
            reflectToAttribute: true
          },
          lon: {
            type: Number,
            value: 0,
            reflectToAttribute: true
          },
          zoom: {
            type: Number,
            value: 0,
            reflectToAttribute: true
          },
          projection: {
            type: String,
            value: "OSMTILE",
            reflectToAttribute: false
          },
          width: {
            type: Number,
            value: null,
            reflectToAttribute: true
          },
          height: {
            type: Number,
            value: null,
            reflectToAttribute: true
          },
          layers: {
            type: Object,
            value: function value() {
              return this.getElementsByTagName("layer-");
            }
          },
          areas: {
            type: Object,
            value: function value() {
              return this.getElementsByTagName("area");
            }
          },
          controls: {
            type: Boolean,
            reflectToAttribute: true
          }
        };
      }
    }, {
      key: "observers",
      get: function get() {
        return ["_widthChanged(width)", "_heightChanged(height)", "_toggleControls(controls)"];
      }
    }]);
    return WebMap;
  }(_polymerElement.PolymerElement);

  _exports.WebMap = WebMap;
  window.customElements.define(WebMap.tag, WebMap);
});