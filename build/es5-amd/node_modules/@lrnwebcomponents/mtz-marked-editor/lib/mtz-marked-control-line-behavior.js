define(["exports"], function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.mtzMarkedControlLineBehaviorImpl = void 0;

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var mtzMarkedControlLineBehaviorImpl = function mtzMarkedControlLineBehaviorImpl(SuperClass) {
    return /*#__PURE__*/function (_SuperClass) {
      babelHelpers.inherits(_class, _SuperClass);

      var _super = _createSuper(_class);

      function _class() {
        babelHelpers.classCallCheck(this, _class);
        return _super.apply(this, arguments);
      }

      babelHelpers.createClass(_class, [{
        key: "_handleCommand",
        value:
        /**
         * Toggles a syntax prefix at the start of selected lines
         * @param {MouseEvent|KeyboardEvent} event
         * @protected
         */
        function _handleCommand(event) {
          var _this = this;

          event.preventDefault();
          event.stopPropagation();
          var editor = this.__editor;
          var selection = editor.getSelection();
          var lines = editor.getLines(); // Grab the newline char

          var newlineChar = lines.length > 1 ? lines[1].match(/(\n|\r\n)/)[0] : ""; // Grab lines within the selection

          var selectedLines = [];
          var accumulator = 0;
          lines.every(function (line) {
            // Accumulate line
            accumulator += line.length; // Check if selection start is not within the line, skip to next line

            if (accumulator + 1 < selection.start) {
              return true;
            } // Line is part of selection or contains selection start, so let's grab it


            selectedLines.push({
              start: accumulator - line.length,
              end: accumulator,
              length: line.length,
              text: line.trimLeft()
            }); // Stop grabbing lines if we reach the end of the selection

            return accumulator < selection.end;
          }); // Check the first line for syntax

          var firstLine = selectedLines[0];
          var removeSyntax = firstLine.text.startsWith(this.syntaxPrefix);
          var offset = 0; // Toggle syntax on each line

          selectedLines.forEach(function (line) {
            // if the syntax exists remove it from any lines containing it
            if (removeSyntax && line.text.startsWith(_this.syntaxPrefix)) {
              line.text = line.text.slice(_this.syntaxPrefix.length, line.end);
            } else if (!removeSyntax) {
              line.text = "".concat(_this.syntaxPrefix).concat(line.text);
            } // Accumulate number of characters modified in the textarea


            offset += _this.syntaxPrefix.length;
          }); // Selected all the lines affected

          var lastLine = selectedLines[selectedLines.length - 1];
          editor.setSelection(firstLine.start, lastLine.end); // If single line, add newline

          if (selectedLines.length === 1 && selectedLines[0].start > 0) {
            firstLine.text = "".concat(newlineChar).concat(firstLine.text);
            firstLine.start += newlineChar.length;
          } // Replace all selected lines with modified content


          editor.replaceSelection(selectedLines.map(function (line) {
            return line.text;
          }).join(newlineChar)); // Re-select the new content on the lines

          editor.setSelection(firstLine.start, lastLine.end + (!removeSyntax ? 1 : -1) * offset);
          editor.getTextarea().focus();
        }
      }], [{
        key: "properties",
        get: function get() {
          return _objectSpread(_objectSpread({}, babelHelpers.get(babelHelpers.getPrototypeOf(_class), "properties", this)), {}, {
            syntaxPrefix: String // Must implement

          });
        }
      }]);
      return _class;
    }(SuperClass);
  };

  _exports.mtzMarkedControlLineBehaviorImpl = mtzMarkedControlLineBehaviorImpl;
});