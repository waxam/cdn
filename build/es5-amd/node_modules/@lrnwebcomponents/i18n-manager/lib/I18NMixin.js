define(["exports", "../i18n-manager.js"], function (_exports, _i18nManager) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  Object.defineProperty(_exports, "I18NManagerStore", {
    enumerable: true,
    get: function get() {
      return _i18nManager.I18NManagerStore;
    }
  });
  _exports.I18NMixin = void 0;

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  // SuperClass to simplify wiring up and noticing changes to t values
  // this is not required as you can simply use the event system
  // to keep to 0 dependencies but this helps simplify and standardize
  // integration with lots of downstream i18n files
  var I18NMixin = function I18NMixin(SuperClass) {
    return /*#__PURE__*/function (_SuperClass) {
      babelHelpers.inherits(_class, _SuperClass);

      var _super = _createSuper(_class);

      /**
       * Life cycle
       */
      function _class() {
        var _this;

        babelHelpers.classCallCheck(this, _class);
        _this = _super.call(this);
        _this.t = _this.t || {};
        return _this;
      }
      /**
       * Enhanced data reactivity for LitElement if available
       */


      babelHelpers.createClass(_class, [{
        key: "registerLocalization",
        value: // pass through to the manager, automatically adding some namespace values
        function registerLocalization(detail) {
          // ensure we have a namespace for later use
          if (!detail.namespace) {
            detail.namespace = detail.context.tagName.toLowerCase();
          } // support fallback calls for requestUpdate; you can always supply one


          if (!detail.updateCallback) {
            if (detail.context.requestUpdate) {
              detail.updateCallback = "requestUpdate"; // automatically set for common VanillaJS convention
            } else if (detail.context.render) {
              detail.updateCallback = "render";
            }
          } // auto-detect localePath if we have a basePath
          // this is another short hand that allows for enforcing the location
          // of the locales bucket of files. You can define where these are
          // per request but this helps simplify the original implementation


          if (!detail.localesPath && detail.basePath) {
            // clean up path and force adding locales. part security thing as well
            detail.localesPath = "".concat(decodeURIComponent(detail.basePath), "/../locales");
          } // register the localization directly, skipping event
          // this also ensures that things leveraging the Mixin will never miss
          // the singleton being registered


          _i18nManager.I18NManagerStore.registerLocalization(detail);
        }
      }], [{
        key: "properties",
        get: function get() {
          return _objectSpread(_objectSpread({}, babelHelpers.get(babelHelpers.getPrototypeOf(_class), "properties", this)), {}, {
            t: {
              type: Object
            }
          });
        }
      }]);
      return _class;
    }(SuperClass);
  };

  _exports.I18NMixin = I18NMixin;
});