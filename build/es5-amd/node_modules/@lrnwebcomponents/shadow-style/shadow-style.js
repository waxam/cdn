define(["exports"], function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.ShadowStyle = void 0;

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  /**
   * Copyright 2021 The Pennsylvania State University
   * @license Apache-2.0, see License.md for full text.
   */

  /**
   * `shadow-style`
   * `write css that is for piercing shadow roots and applying CSS automatically`
   *
   * @demo demo/index.html
   * @element shadow-style
   */
  var ShadowStyle = /*#__PURE__*/function (_HTMLElement) {
    babelHelpers.inherits(ShadowStyle, _HTMLElement);

    var _super = _createSuper(ShadowStyle);

    function ShadowStyle() {
      var _this;

      babelHelpers.classCallCheck(this, ShadowStyle);
      _this = _super.call(this); // support evil

      if (_this.getAttribute("evil") != null) {
        // this will forcibly hijack all shadowRoot definitions to ensure that they
        // can work with our call structure: reference: https://twitter.com/btopro/status/1356798076812484614
        Element.prototype._attachShadow = Element.prototype.attachShadow;

        Element.prototype.attachShadow = function () {
          return this._attachShadow({
            mode: "open"
          });
        };

        console.error("Leave us..");
        console.warn("No, stay here. I'm in charge");
        console.error("[laying a hand on the web component] Do you feel in charge?");
        console.warn("..I've paid your APIs a small fortune.");
        console.error("And this gives you... power over me?");
        console.warn("What is this..");
        console.error("You APIs and web platform have been important, till now");
        console.warn("What are you..");
        console.error("I'm web standards' reckoning, here to end the ball of twine you've all been coding on.");
        console.warn("You .. you're evil.");
        console.error("I am nessecary evil");
      } // this will build the map for all styles


      _this.cssMap = {}; // force this to not be shown visually

      _this.style.display = "none"; // run through the injector based on innerText

      _this.processShadowText(_this.innerText);

      return _this;
    }

    babelHelpers.createClass(ShadowStyle, [{
      key: "processShadowText",
      value: // async to ensure we await the Promises all resolving
      function () {
        var _processShadowText = babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(text) {
          var _this2 = this;

          var regex, result, promises, selector, tmp, ceTagName, shadowSelector;
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  // selector to help match our css
                  regex = new RegExp("(.*?)([^{])s*{s*([^}]*?)}", "gim");
                  // storage for all promises so that we can wait till they all resolve
                  promises = []; // run through each selector we found

                  while (result = regex.exec(text)) {
                    // clean up while space and work on the high level selector for the tag to inject into
                    selector = result[1].trim().replace(/\s\s+/g, " "); // target our made up shadow selector

                    tmp = selector.split("::shadow"); // this is the tag to be injecting into

                    ceTagName = tmp[0]; // clean up the () around it

                    shadowSelector = tmp[1].replace("(", "").replace(")", ""); // ensure we have this defined / there can be multiple selectors on same thing applied

                    if (!this.cssMap[ceTagName]) {
                      this.cssMap[ceTagName] = {};
                    } // append the text of the css selector (aka attributes / css props) to a single string
                    // accounting for multiple selections of the same shadow selector


                    if (!this.cssMap[ceTagName][shadowSelector]) {
                      this.cssMap[ceTagName][shadowSelector] = result[3].trim().replace(/\s\s+/g, " ");
                    } else {
                      this.cssMap[ceTagName][shadowSelector] += result[3].trim().replace(/\s\s+/g, " ");
                    } // we now have to wait till this definition is populated in the registry
                    // so wait for this so that the definition comes in when it feels like it


                    promises.push(customElements.whenDefined(ceTagName));
                  } // below here won't run until all those elements we care about can be injected into successfully


                  _context.next = 5;
                  return Promise.all(promises);

                case 5:
                  // delay a microtask just to be safe
                  setTimeout(function () {
                    // run through the map built ahead of time
                    for (var tagName in _this2.cssMap) {
                      // walk the tag name and query anything in the root document above our implementation
                      // this SHOULD then work within shadows of shadows :)
                      _this2.getRootNode().querySelectorAll(tagName).forEach(function (el) {
                        // sanity check for shadow or just append into the tag itself
                        // which is of limited use but at least do... something
                        var appendTo = el;

                        if (el.shadowRoot) {
                          appendTo = el.shadowRoot;
                        } // make a style tag that is empty


                        var style = document.createElement("style");
                        style.innerHTML = ""; // apply any / all selectors found to this element

                        for (var _shadowSelector in _this2.cssMap[tagName]) {
                          // append the selector
                          style.innerHTML += "".concat(_shadowSelector, " {").concat(_this2.cssMap[tagName][_shadowSelector], "}");
                        } // append it to the shadowRoot of the node in question


                        appendTo.appendChild(style);
                      });
                    }
                  }, 0);

                case 6:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));

        function processShadowText(_x) {
          return _processShadowText.apply(this, arguments);
        }

        return processShadowText;
      }()
    }], [{
      key: "tag",
      get: function get() {
        return "shadow-style";
      }
    }]);
    return ShadowStyle;
  }( /*#__PURE__*/babelHelpers.wrapNativeSuper(HTMLElement));

  _exports.ShadowStyle = ShadowStyle;
  customElements.define(ShadowStyle.tag, ShadowStyle);
});