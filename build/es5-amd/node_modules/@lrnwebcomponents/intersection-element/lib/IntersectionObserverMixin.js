define(["exports"],function(_exports){"use strict";Object.defineProperty(_exports,"__esModule",{value:!0});_exports.IntersectionObserverMixin=void 0;/**
 * Copyright 2020 The Pennsylvania State University
 * @license Apache-2.0, see License.md for full text.
 */ /**
 * `IntersectionObserverMixin`
 * `Wiring to provide basic IntersectionObserver support to any web component`
 */var IntersectionObserverMixin=function IntersectionObserverMixin(SuperClass){// SuperClass so we can write any web component library / base class
return(/*#__PURE__*/function(_SuperClass){babelHelpers.inherits(_class,_SuperClass);/**
     * Constructor
     */function _class(){var _this;babelHelpers.classCallCheck(this,_class);_this=babelHelpers.possibleConstructorReturn(this,babelHelpers.getPrototypeOf(_class).call(this));// listen for this to be true in your element
_this.elementVisible=!1;// threasholds to check for, every 25%
_this.IOThresholds=[0,.25,.5,.75,1];// margin from root element
_this.IORootMargin="0px";// wait till at least 50% of the item is visible to claim visible
_this.IOVisibleLimit=.5;// drop the observer once we are visible
_this.IORemoveOnVisible=!0;// delay in observing, performance reasons for minimum at 100
_this.IODelay=100;return _this}/**
     * HTMLElement specification
     */babelHelpers.createClass(_class,[{key:"connectedCallback",value:function connectedCallback(){if(babelHelpers.get(babelHelpers.getPrototypeOf(_class.prototype),"connectedCallback",this)){babelHelpers.get(babelHelpers.getPrototypeOf(_class.prototype),"connectedCallback",this).call(this)}// setup the intersection observer, only if we are not visible
if(!this.elementVisible){this.intersectionObserver=new IntersectionObserver(this.handleIntersectionCallback.bind(this),{root:document.rootElement,rootMargin:this.IORootMargin,threshold:this.IOThresholds,delay:this.IODelay});this.intersectionObserver.observe(this)}}/**
     * HTMLElement specification
     */},{key:"disconnectedCallback",value:function disconnectedCallback(){// if we have an intersection observer, disconnect it
if(this.intersectionObserver){this.intersectionObserver.disconnect()}if(babelHelpers.get(babelHelpers.getPrototypeOf(_class.prototype),"disconnectedCallback",this)){babelHelpers.get(babelHelpers.getPrototypeOf(_class.prototype),"disconnectedCallback",this).call(this)}}/**
     * Very basic IntersectionObserver callback which will set elementVisible to true
     */},{key:"handleIntersectionCallback",value:function handleIntersectionCallback(entries){var _iteratorNormalCompletion=!0,_didIteratorError=!1,_iteratorError=void 0;try{for(var _iterator=entries[Symbol.iterator](),_step;!(_iteratorNormalCompletion=(_step=_iterator.next()).done);_iteratorNormalCompletion=!0){var entry=_step.value,ratio=(+entry.intersectionRatio).toFixed(2);// ensure ratio is higher than our limit before trigger visibility
if(ratio>=this.IOVisibleLimit){this.elementVisible=!0;// remove the observer if we've reached our target of being visible
if(this.IORemoveOnVisible){this.intersectionObserver.disconnect()}}}}catch(err){_didIteratorError=!0;_iteratorError=err}finally{try{if(!_iteratorNormalCompletion&&null!=_iterator.return){_iterator.return()}}finally{if(_didIteratorError){throw _iteratorError}}}}}]);return _class}(SuperClass))};_exports.IntersectionObserverMixin=IntersectionObserverMixin});