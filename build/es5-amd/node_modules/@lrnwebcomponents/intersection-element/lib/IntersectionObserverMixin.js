define(["exports"], function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.IntersectionObserverMixin = void 0;

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  /**
   * Copyright 2020 The Pennsylvania State University
   * @license Apache-2.0, see License.md for full text.
   */

  /**
   * `IntersectionObserverMixin`
   * `Wiring to provide basic IntersectionObserver support to any web component`
   */
  var IntersectionObserverMixin = function IntersectionObserverMixin(SuperClass) {
    // SuperClass so we can write any web component library / base class
    return (
      /*#__PURE__*/
      function (_SuperClass) {
        babelHelpers.inherits(_class, _SuperClass);

        /**
         * Constructor
         */
        function _class() {
          var _this;

          babelHelpers.classCallCheck(this, _class);
          _this = babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(_class).call(this)); // listen for this to be true in your element

          _this.elementVisible = false; // threasholds to check for, every 25%

          _this.IOThresholds = [0.0, 0.25, 0.5, 0.75, 1.0]; // margin from root element

          _this.IORootMargin = "0px"; // wait till at least 50% of the item is visible to claim visible

          _this.IOVisibleLimit = 0.5; // drop the observer once we are visible

          _this.IORemoveOnVisible = true; // delay in observing, performance reasons for minimum at 100

          _this.IODelay = 100;
          return _this;
        }
        /**
         * Properties, LitElement format
         */


        babelHelpers.createClass(_class, [{
          key: "connectedCallback",

          /**
           * HTMLElement specification
           */
          value: function connectedCallback() {
            if (babelHelpers.get(babelHelpers.getPrototypeOf(_class.prototype), "connectedCallback", this)) {
              babelHelpers.get(babelHelpers.getPrototypeOf(_class.prototype), "connectedCallback", this).call(this);
            } // setup the intersection observer, only if we are not visible


            if (!this.elementVisible) {
              this.intersectionObserver = new IntersectionObserver(this.handleIntersectionCallback.bind(this), {
                root: document.rootElement,
                rootMargin: this.IORootMargin,
                threshold: this.IOThresholds,
                delay: this.IODelay
              });
              this.intersectionObserver.observe(this);
            }
          }
          /**
           * HTMLElement specification
           */

        }, {
          key: "disconnectedCallback",
          value: function disconnectedCallback() {
            // if we have an intersection observer, disconnect it
            if (this.intersectionObserver) {
              this.intersectionObserver.disconnect();
            }

            if (babelHelpers.get(babelHelpers.getPrototypeOf(_class.prototype), "disconnectedCallback", this)) {
              babelHelpers.get(babelHelpers.getPrototypeOf(_class.prototype), "disconnectedCallback", this).call(this);
            }
          }
          /**
           * Very basic IntersectionObserver callback which will set elementVisible to true
           */

        }, {
          key: "handleIntersectionCallback",
          value: function handleIntersectionCallback(entries) {
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
              for (var _iterator = entries[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var entry = _step.value;
                var ratio = Number(entry.intersectionRatio).toFixed(2); // ensure ratio is higher than our limit before trigger visibility

                if (ratio >= this.IOVisibleLimit) {
                  this.elementVisible = true; // remove the observer if we've reached our target of being visible

                  if (this.IORemoveOnVisible) {
                    this.intersectionObserver.disconnect();
                  }
                }
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                  _iterator.return();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }
          }
        }], [{
          key: "properties",
          get: function get() {
            var props = {};

            if (babelHelpers.get(babelHelpers.getPrototypeOf(_class), "properties", this)) {
              props = babelHelpers.get(babelHelpers.getPrototypeOf(_class), "properties", this);
            }

            return _objectSpread({}, props, {
              elementVisible: {
                type: Boolean,
                attribute: "element-visible",
                reflect: true
              }
            });
          }
        }]);
        return _class;
      }(SuperClass)
    );
  };

  _exports.IntersectionObserverMixin = IntersectionObserverMixin;
});