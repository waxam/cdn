define(["exports", "../dynamic-import-registry/dynamic-import-registry.js"], function (_exports, _dynamicImportRegistry) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.WcAutoload = void 0;

  /**
   * Copyright 2020 The Pennsylvania State University
   * @license Apache-2.0, see License.md for full text.
   */
  // register globally so we can make sure there is only one
  window.WCAutoload = window.WCAutoload || {}; // request if this exists. This helps invoke the element existing in the dom
  // as well as that there is only one of them. That way we can ensure everything
  // is rendered through the same modal

  window.WCAutoload.requestAvailability = function () {
    if (!window.WCAutoload.instance) {
      window.WCAutoload.instance = document.createElement("wc-autoload");
      document.body.appendChild(window.WCAutoload.instance);
    }

    return window.WCAutoload.instance;
  };
  /**
   * process the loading event in case we need to ensure timing is
   * better handled downstream.
   */


  window.WCAutoload.process = function (e) {
    // find the loader
    var loader = window.WCAutoload.requestAvailability();
    loader.loaded = true;
    var list = {}; // microtask timing to ensure window settings are accepted

    if (window.WCAutoloadRegistryFileProcessed) {
      // mutation observer will pick up changes after initial load
      // but this gets us at load time with fallback support for legacy
      var target = document;

      if (loader.target) {
        target = loader.target;
        loader.processNewElement(target);
      } // hack to convert children into array


      target.querySelectorAll("*").forEach(function (el) {
        if (el.tagName && !list[el.tagName]) {
          loader.processNewElement(el);
          list[el.tagName] = el.tagName;
        }
      });
    } else {
      setTimeout(
      /*#__PURE__*/
      babelHelpers.asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee() {
        var i, target;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                // set the basePath if it exists
                if (window.WCAutoloadBasePath) {
                  loader.registry.basePath = window.WCAutoloadBasePath;
                }

                if (!(window.WCAutoloadRegistryFile && !window.WCAutoloadRegistryFileProcessed)) {
                  _context.next = 4;
                  break;
                }

                _context.next = 4;
                return fetch(window.WCAutoloadRegistryFile).then(function (response) {
                  return response.json();
                }).then(function (data) {
                  window.WCAutoloadRegistryFileProcessed = true;
                  window.WCAutoloadRegistry = data;
                });

              case 4:
                // build out the registry via events translated from object
                if (window.WCAutoloadRegistry) {
                  for (i in window.WCAutoloadRegistry) {
                    loader.registry.register({
                      tag: i,
                      path: window.WCAutoloadRegistry[i]
                    });
                  }
                }

                target = document;

                if (loader.target) {
                  target = loader.target;
                  loader.processNewElement(target);
                } // mutation observer will pick up changes after initial load
                // but this gets us at load time with fallback support for legacy


                target.querySelectorAll("*").forEach(function (el) {
                  if (el.tagName && !list[el.tagName]) {
                    loader.processNewElement(el);
                    list[el.tagName] = el.tagName;
                  }
                });

              case 8:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      })), 0);
    }
  }; // forces self appending which kicks all this off but AFTER dom is loaded
  // function based allows for fallbacks due to timing on legacy browsers


  window.addEventListener("load", window.WCAutoload.process); // edge case; definition to load comes in AFTER we have loaded the page
  // and MutationObserver doesn't pick up the tag being there
  // this could be the result of a slow page load for example
  // in these cases; see the event of the item being in the registry

  window.WCAutoload.postLoaded = function (e) {
    setTimeout(function () {
      var loader = window.WCAutoload.requestAvailability();

      if (loader.loaded && document.querySelectorAll(e.detail.tag).length > 0) {
        loader.registry.loadDefinition(e.detail.tag);
      }
    }, 0);
  }; // listen for new tags being registered


  window.addEventListener("dynamic-import-registry--new-registration", window.WCAutoload.postLoaded);
  /**
   * `wc-registry`
   * `optionally build the registry from the innerHTML of an element`
   * @demo demo/index.html
   * @element wc-registry
   */

  var WcRegistry =
  /*#__PURE__*/
  function (_HTMLElement) {
    babelHelpers.inherits(WcRegistry, _HTMLElement);
    babelHelpers.createClass(WcRegistry, null, [{
      key: "tag",

      /**
       * This is a convention, not the standard
       */
      get: function get() {
        return "wc-registry";
      }
    }]);

    function WcRegistry() {
      var _this;

      babelHelpers.classCallCheck(this, WcRegistry);
      _this = babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(WcRegistry).call(this));
      _this.loader = window.WCAutoload.requestAvailability();
      return _this;
    }

    babelHelpers.createClass(WcRegistry, [{
      key: "connectedCallback",
      value: function connectedCallback() {
        var _this2 = this;

        setTimeout(function () {
          if (_this2.children.length > 0 && _this2.children[0].tagName == "TEMPLATE") {
            // we don't trust no JS blobs :p
            try {
              var jsonList = JSON.parse(_this2.children[0].content.textContent); // register these items on the fly

              for (var i in jsonList) {
                _this2.loader.registry.register({
                  tag: i,
                  path: jsonList[i]
                });
              }
            } catch (e) {
              console.warn(e);
            }
          }
        }, 0);
      }
    }]);
    return WcRegistry;
  }(babelHelpers.wrapNativeSuper(HTMLElement));

  customElements.define(WcRegistry.tag, WcRegistry);
  /**
   * `wc-autoload`
   * `automatically load new tags in the dom`
   * @demo demo/index.html
   * @element wc-autoload
   */

  var WcAutoload =
  /*#__PURE__*/
  function (_HTMLElement2) {
    babelHelpers.inherits(WcAutoload, _HTMLElement2);
    babelHelpers.createClass(WcAutoload, null, [{
      key: "tag",

      /**
       * This is a convention, not the standard
       */
      get: function get() {
        return "wc-autoload";
      }
    }]);

    function WcAutoload() {
      var _this3;

      babelHelpers.classCallCheck(this, WcAutoload);
      _this3 = babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(WcAutoload).call(this));
      _this3.loaded = false;
      _this3.registry = window.DynamicImportRegistry.requestAvailability();
      _this3.options = {
        childList: true,
        subtree: true
      };
      return _this3;
    }

    babelHelpers.createClass(WcAutoload, [{
      key: "connectedCallback",
      value: function connectedCallback() {
        var _this4 = this;

        // listen for changes and then process any new node that has a tag name
        this._mutationObserver = new MutationObserver(function (mutations) {
          mutations.forEach(function (mutation) {
            mutation.addedNodes.forEach(function (node) {
              _this4.processNewElement(node);
            });
          });
        }); // support window target

        if (window.WCAutoloadOptions) {
          this.options = window.WCAutoloadOptions;
        }

        setTimeout(function () {
          // support window target
          if (window.WCAutoloadTarget) {
            _this4.target = window.WCAutoloadTarget;
          } else {
            _this4.target = document.body;
          } // listen on the body and deep children as well


          _this4._mutationObserver.observe(_this4.target, _this4.options);
        }, 0);
      }
    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        this._mutationObserver.disconnect();
      }
      /**
       * Process new elements
       */

    }, {
      key: "processNewElement",
      value: function processNewElement(node) {
        // skip checks for self
        if (node.tagName && node.tagName.includes("-") && node.tagName != "DYNAMIC-IMPORT-REGISTRY" && node.tagName != "WC-AUTOLOAD") {
          this.registry.loadDefinition(node.tagName);
        }
      }
    }]);
    return WcAutoload;
  }(babelHelpers.wrapNativeSuper(HTMLElement));

  _exports.WcAutoload = WcAutoload;
  window.customElements.define(WcAutoload.tag, WcAutoload);
});