define(["exports","../dynamic-import-registry/dynamic-import-registry.js"],function(_exports,_dynamicImportRegistry){"use strict";Object.defineProperty(_exports,"__esModule",{value:!0});_exports.WcAutoload=void 0;/**
 * Copyright 2020 The Pennsylvania State University
 * @license Apache-2.0, see License.md for full text.
 */ // register globally so we can make sure there is only one
window.WCAutoload=window.WCAutoload||{};// request if this exists. This helps invoke the element existing in the dom
// as well as that there is only one of them. That way we can ensure everything
// is rendered through the same modal
window.WCAutoload.requestAvailability=function(){if(!window.WCAutoload.instance){window.WCAutoload.instance=document.createElement("wc-autoload");document.body.appendChild(window.WCAutoload.instance)}return window.WCAutoload.instance};/**
 * process the loading event in case we need to ensure timing is
 * better handled downstream.
 */window.WCAutoload.process=function(e){// find the loader
var loader=window.WCAutoload.requestAvailability();loader.loaded=!0;// set the basePath if it exists
if(window.WCAutoloadBasePath){loader.registry.basePath=window.WCAutoloadBasePath}// build out the registry via events translated from object
if(window.WCAutoloadRegistry){for(var i in window.WCAutoloadRegistry){loader.registry.register({tag:i,path:window.WCAutoloadRegistry[i]})}}// mutation observer will pick up changes after initial load
// but this gets us at load time with fallback support for legacy
try{document.querySelectorAll(":not(:defined)").forEach(function(el,index){// process every tag NOT defined when the page loads
loader.processNewElement(el)})}catch(e){// hack to convert children into array
[].slice.call(document.body.children).forEach(function(el,index){// process every tag NOT defined when the page loads
loader.processNewElement(el)})}};// forces self appending which kicks all this off but AFTER dom is loaded
// function based allows for fallbacks due to timing on legacy browsers
window.addEventListener("load",window.WCAutoload.process);// edge case; definition to load comes in AFTER we have loaded the page
// and MutationObserver doesn't pick up the tag being there
// this could be the result of a slow page load for example
// in these cases; see the event of the item being in the registry
window.WCAutoload.postLoaded=function(e){setTimeout(function(){var loader=window.WCAutoload.requestAvailability();if(loader.loaded&&0<document.querySelectorAll(e.detail.tag).length){loader.registry.loadDefinition(e.detail.tag)}},0)};// listen for new tags being registered
window.addEventListener("dynamic-import-registry--new-registration",window.WCAutoload.postLoaded);/**
 * `wc-autoload`
 * `automatically load new tags in the dom`
 * @demo demo/index.html
 * @element wc-autoload
 */var WcAutoload=/*#__PURE__*/function(_HTMLElement){babelHelpers.inherits(WcAutoload,_HTMLElement);babelHelpers.createClass(WcAutoload,null,[{key:"tag",/**
   * This is a convention, not the standard
   */get:function get(){return"wc-autoload"}}]);function WcAutoload(){var _this;babelHelpers.classCallCheck(this,WcAutoload);_this=babelHelpers.possibleConstructorReturn(this,babelHelpers.getPrototypeOf(WcAutoload).call(this));_this.loaded=!1;_this.registry=window.DynamicImportRegistry.requestAvailability();return _this}babelHelpers.createClass(WcAutoload,[{key:"connectedCallback",value:function connectedCallback(){var _this2=this;// listen for changes and then process any new node that has a tag name
this._mutationObserver=new MutationObserver(function(mutations){mutations.forEach(function(mutation){mutation.addedNodes.forEach(function(node){if(node.tagName){_this2.processNewElement(node)}})})});// listen on the body and deep children as well
this._mutationObserver.observe(document.body,{childList:!0,subtree:!0})}},{key:"disconnectedCallback",value:function disconnectedCallback(){this._mutationObserver.disconnect()}/**
   * Process new elements
   */},{key:"processNewElement",value:function processNewElement(node){this.registry.loadDefinition(node.tagName)}}]);return WcAutoload}(babelHelpers.wrapNativeSuper(HTMLElement));_exports.WcAutoload=WcAutoload;window.customElements.define(WcAutoload.tag,WcAutoload)});