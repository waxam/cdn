define(["exports","../dynamic-import-registry/dynamic-import-registry.js"],function(_exports,_dynamicImportRegistry){"use strict";Object.defineProperty(_exports,"__esModule",{value:!0});_exports.WcAutoload=void 0;/**
 * Copyright 2020 The Pennsylvania State University
 * @license Apache-2.0, see License.md for full text.
 */ // register globally so we can make sure there is only one
window.WCAutoload=window.WCAutoload||{};// request if this exists. This helps invoke the element existing in the dom
// as well as that there is only one of them. That way we can ensure everything
// is rendered through the same modal
window.WCAutoload.requestAvailability=function(){if(!window.WCAutoload.instance){window.WCAutoload.instance=document.createElement("wc-autoload");document.body.appendChild(window.WCAutoload.instance)}return window.WCAutoload.instance};/**
 * process the loading event in case we need to ensure timing is
 * better handled downstream.
 */window.WCAutoload.process=function(e){// find the loader
var loader=window.WCAutoload.requestAvailability();loader.loaded=!0;var list={};// microtask timing to ensure window settings are accepted
if(window.WCAutoloadRegistryFileProcessed){// mutation observer will pick up changes after initial load
// but this gets us at load time with fallback support for legacy
var target=document;if(loader.target){target=loader.target;loader.processNewElement(target)}// hack to convert children into array
target.querySelectorAll("*").forEach(function(el){if(el.tagName&&!list[el.tagName]){loader.processNewElement(el);list[el.tagName]=el.tagName}})}else{setTimeout(/*#__PURE__*/babelHelpers.asyncToGenerator(/*#__PURE__*/regeneratorRuntime.mark(function _callee(){var i,target;return regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:// set the basePath if it exists
if(window.WCAutoloadBasePath){loader.registry.basePath=window.WCAutoloadBasePath}if(!(window.WCAutoloadRegistryFile&&!window.WCAutoloadRegistryFileProcessed)){_context.next=4;break}_context.next=4;return fetch(window.WCAutoloadRegistryFile).then(function(response){return response.json()}).then(function(data){window.WCAutoloadRegistryFileProcessed=!0;window.WCAutoloadRegistry=data});case 4:// build out the registry via events translated from object
if(window.WCAutoloadRegistry){for(i in window.WCAutoloadRegistry){loader.registry.register({tag:i,path:window.WCAutoloadRegistry[i]})}}target=document;if(loader.target){target=loader.target;loader.processNewElement(target)}// mutation observer will pick up changes after initial load
// but this gets us at load time with fallback support for legacy
target.querySelectorAll("*").forEach(function(el){if(el.tagName&&!list[el.tagName]){loader.processNewElement(el);list[el.tagName]=el.tagName}});case 8:case"end":return _context.stop();}}},_callee)})),0)}};// forces self appending which kicks all this off but AFTER dom is loaded
// function based allows for fallbacks due to timing on legacy browsers
window.addEventListener("load",window.WCAutoload.process);// edge case; definition to load comes in AFTER we have loaded the page
// and MutationObserver doesn't pick up the tag being there
// this could be the result of a slow page load for example
// in these cases; see the event of the item being in the registry
window.WCAutoload.postLoaded=function(e){setTimeout(function(){var loader=window.WCAutoload.requestAvailability();if(loader.loaded&&0<document.querySelectorAll(e.detail.tag).length){loader.registry.loadDefinition(e.detail.tag)}},0)};// listen for new tags being registered
window.addEventListener("dynamic-import-registry--new-registration",window.WCAutoload.postLoaded);/**
 * `wc-autoload`
 * `automatically load new tags in the dom`
 * @demo demo/index.html
 * @element wc-autoload
 */var WcAutoload=/*#__PURE__*/function(_HTMLElement){babelHelpers.inherits(WcAutoload,_HTMLElement);babelHelpers.createClass(WcAutoload,null,[{key:"tag",/**
   * This is a convention, not the standard
   */get:function get(){return"wc-autoload"}}]);function WcAutoload(){var _this;babelHelpers.classCallCheck(this,WcAutoload);_this=babelHelpers.possibleConstructorReturn(this,babelHelpers.getPrototypeOf(WcAutoload).call(this));_this.loaded=!1;_this.registry=window.DynamicImportRegistry.requestAvailability();_this.options={childList:!0,subtree:!0};return _this}babelHelpers.createClass(WcAutoload,[{key:"connectedCallback",value:function connectedCallback(){var _this2=this;// listen for changes and then process any new node that has a tag name
this._mutationObserver=new MutationObserver(function(mutations){mutations.forEach(function(mutation){mutation.addedNodes.forEach(function(node){_this2.processNewElement(node)})})});// support window target
if(window.WCAutoloadOptions){this.options=window.WCAutoloadOptions}setTimeout(function(){// support window target
if(window.WCAutoloadTarget){_this2.target=window.WCAutoloadTarget}else{_this2.target=document.body}// listen on the body and deep children as well
_this2._mutationObserver.observe(_this2.target,_this2.options)},0)}},{key:"disconnectedCallback",value:function disconnectedCallback(){this._mutationObserver.disconnect()}/**
   * Process new elements
   */},{key:"processNewElement",value:function processNewElement(node){// skip checks for self
if(node.tagName&&node.tagName.includes("-")&&"DYNAMIC-IMPORT-REGISTRY"!=node.tagName&&"WC-AUTOLOAD"!=node.tagName){this.registry.loadDefinition(node.tagName)}}}]);return WcAutoload}(babelHelpers.wrapNativeSuper(HTMLElement));_exports.WcAutoload=WcAutoload;window.customElements.define(WcAutoload.tag,WcAutoload)});