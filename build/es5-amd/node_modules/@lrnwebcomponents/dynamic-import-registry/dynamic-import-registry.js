define(["exports","meta","require"],function(_exports,meta,_require){"use strict";Object.defineProperty(_exports,"__esModule",{value:!0});_exports.DynamicImportRegistry=void 0;meta=babelHelpers.interopRequireWildcard(meta);_require=babelHelpers.interopRequireWildcard(_require);/**
 * Copyright 2020 The Pennsylvania State University
 * @license Apache-2.0, see License.md for full text.
 */ // register globally so we can make sure there is only one
window.DynamicImportRegistry=window.DynamicImportRegistry||{};// request if this exists. This helps invoke the element existing in the dom
// as well as that there is only one of them. That way we can ensure everything
// is rendered through the same modal
window.DynamicImportRegistry.requestAvailability=function(){if(!window.DynamicImportRegistry.instance){window.DynamicImportRegistry.instance=document.createElement("dynamic-import-registry");document.body.appendChild(window.DynamicImportRegistry.instance)}return window.DynamicImportRegistry.instance};/**
 * `dynamic-import-registry`
 * `maintain manage the registration and usage of dynamic imports`
 * @demo demo/index.html
 * @element dynamic-import-registry
 */var DynamicImportRegistry=/*#__PURE__*/function(_HTMLElement){babelHelpers.inherits(DynamicImportRegistry,_HTMLElement);babelHelpers.createClass(DynamicImportRegistry,null,[{key:"tag",get:function get(){return"dynamic-import-registry"}}]);function DynamicImportRegistry(){var _this,delayRender=0<arguments.length&&arguments[0]!==void 0?arguments[0]:!1;babelHelpers.classCallCheck(this,DynamicImportRegistry);_this=babelHelpers.possibleConstructorReturn(this,babelHelpers.getPrototypeOf(DynamicImportRegistry).call(this));// object for tracking what the registry is
_this.list={};_this.__loaded={};_this.basePath=_this.pathFromUrl(decodeURIComponent(meta.url))+"../../";return _this}babelHelpers.createClass(DynamicImportRegistry,[{key:"connectedCallback",value:function connectedCallback(){window.addEventListener("dynamic-import-registry--register",this.registerDefinitionEvent.bind(this))}},{key:"disconnectedCallback",value:function disconnectedCallback(){window.removeEventListener("dynamic-import-registry--register",this.registerDefinitionEvent.bind(this))}},{key:"register",value:function register(item){// validate with basic test
if(item.tag&&item.path){if(!this.list[item.tag]){this.list[item.tag]=item.path}}else{console.warn("DynamicImportRegistry: registration requires tag and path be set")}}/**
   * This doesn't actually do the import, it just holds the definition
   */},{key:"registerDefinitionEvent",value:function registerDefinitionEvent(e){// validate with basic test
if(e.detail.tag&&e.detail.path){this.register(e.detail)}}/**
   * This implements the definition with checks to ensure it need not run
   */},{key:"loadDefinition",value:function loadDefinition(tag){var _this2=this;// must be lowercase
tag=tag.toLowerCase();// only import if we already had it
if(!window.customElements.get(tag)&&this.list[tag]&&!this.__loaded[tag]){// let's assume it's there cause we got here
// this can help things on polyfill environments
this.__loaded[tag]=!0;try{new Promise(function(res,rej){return _require.default(["".concat(_this2.basePath).concat(_this2.list[tag])],res,rej)}).then(function(module){// dispatch custom event in case anyone cares
_this2.dispatchEvent(new CustomEvent("dynamic-import-registry-loaded",{detail:{tag:tag,path:_this2.list[tag],module:module}}))})}catch(e){console.warn(e);// fire on error too
this.dispatchEvent(new CustomEvent("dynamic-import-registry-failure",{detail:{tag:tag,path:this.list[tag],module:null}}))}}}// simple path from a url modifier
},{key:"pathFromUrl",value:function pathFromUrl(url){return url.substring(0,url.lastIndexOf("/")+1)}}]);return DynamicImportRegistry}(babelHelpers.wrapNativeSuper(HTMLElement));_exports.DynamicImportRegistry=DynamicImportRegistry;window.customElements.define(DynamicImportRegistry.tag,DynamicImportRegistry)});