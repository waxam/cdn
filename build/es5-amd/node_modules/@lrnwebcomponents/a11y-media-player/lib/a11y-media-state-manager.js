define(["exports", "../../../lit-element/lit-element.js", "../../../@polymer/iron-resizable-behavior/iron-resizable-behavior.js"], function (_exports, _litElement, _ironResizableBehavior) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.A11yMediaStateManager = void 0;

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  // register globally so we can make sure there is only one
  window.A11yMediaStateManager = window.A11yMediaStateManager || {}; // request if this exists. This helps invoke the element existing in the dom
  // as well as that there is only one of them. That way we can ensure everything
  // is rendered through the same modal

  window.A11yMediaStateManager.requestAvailability = function () {
    if (!window.A11yMediaStateManager.instance) {
      window.A11yMediaStateManager.instance = document.createElement("a11y-media-state-manager");
      document.body.appendChild(window.A11yMediaStateManager.instance);
    }

    return window.A11yMediaStateManager.instance;
  };
  /**
   * `a11y-media-state-manager`
   * A utility that manages the state of multiple a11y-media-players on a single page.
   * 
   * @customElement
   */


  var A11yMediaStateManager =
  /*#__PURE__*/
  function (_LitElement) {
    babelHelpers.inherits(A11yMediaStateManager, _LitElement);
    babelHelpers.createClass(A11yMediaStateManager, null, [{
      key: "tag",

      /**
       * Store the tag name to make it easier to obtain directly.
       */
      get: function get() {
        return "a11y-media-state-manager";
      } // properties available to the custom element for data binding

    }, {
      key: "properties",
      get: function get() {
        return _objectSpread({}, babelHelpers.get(babelHelpers.getPrototypeOf(A11yMediaStateManager), "properties", this), {
          /**
           * Stores an array of all the players on the page.
           */
          players: {
            type: Array
          },

          /**
           * Is the screenfull library loaded and screenfull constant set.
           */
          screenfullLoaded: {
            type: Boolean
          },

          /**
           * Manages which player is sticky.
           */
          stickyPlayer: {
            type: Object
          }
        });
      }
      /**
       * Makes sure there is a utility ready and listening for elements.
       */

    }]);

    function A11yMediaStateManager() {
      var _this;

      babelHelpers.classCallCheck(this, A11yMediaStateManager);
      _this = babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(A11yMediaStateManager).call(this));
      _this.players = [];
      _this.screenfullLoaded = false;
      _this.stickyPlayer = null;
      var root = babelHelpers.assertThisInitialized(_this);

      _this.__stickyManager = function (e) {
        return root.setStickyPlayer(e.detail);
      };

      _this.__scrollChecker = function (e) {
        return root._checkScroll(e);
      };

      _this.__playerLoader = function (e) {
        return root.players.push(e.detail);
      }; // sets the instance to the current instance


      if (!window.A11yMediaStateManager.instance) {
        window.A11yMediaStateManager.instance = babelHelpers.assertThisInitialized(_this); // listen for a player that starts playing,
        // make it the player that can be sticky,
        // and check for concurrent players

        window.addEventListener("a11y-player-playing", root.__stickyManager); // listen for scrolling and find out if a player is off-screen

        window.addEventListener("scroll", root.__scrollChecker); // listen for a players added to the page

        window.addEventListener("a11y-player", root.__playerLoader);
      }

      return _this;
    }
    /**
     * if a player disallows concurrent players, pauses other players
     */


    babelHelpers.createClass(A11yMediaStateManager, [{
      key: "checkConcurrentPlayers",
      value: function checkConcurrentPlayers() {
        var root = this,
            player = root.stickyPlayer;

        for (var i = 0; i < root.players.length; i++) {
          var playeri = root.players[i];

          if (playeri !== player && (!player.allowConcurrent || !playeri.allowConcurrent)) {
            playeri.pause();
          }
        }
      }
      /**
       * stops all other players on the page
       *
       * @param {object} the player to set stickiness
       */

    }, {
      key: "setStickyPlayer",
      value: function setStickyPlayer(player) {
        var root = this,
            parent = root._getParentNode(player);

        root.__playerTop = parent.offsetTop;
        root.__playerUpperMiddle = root.__playerTop + parent.offsetHeight * 0.9;
        root.__playerLowerMiddle = root.__playerTop + parent.offsetHeight * 0.1;

        if (player !== root.stickyPlayer && root.stickyPlayer !== undefined && root.stickyPlayer !== null) {
          root.stickyPlayer.toggleSticky(false);
          root.__parent.style.height = "unset";
        }

        parent.style.height = parent.offsetHeight + "px";
        root.__parent = parent;
        root.stickyPlayer = player;
        if (!player.allowConcurrent) root.checkConcurrentPlayers();

        root._checkScroll();
      }
      /**
       * checks the wondow's scroll position and compares it to active player to set sticky attribute
       */

    }, {
      key: "_checkScroll",
      value: function _checkScroll() {
        var root = this,
            wintop = window.pageYOffset,
            winbottom = wintop + window.innerHeight;

        if (root.stickyPlayer !== undefined && root.stickyPlayer !== null) {
          if (root.stickyPlayer.__playing && (root.__playerLowerMiddle > winbottom || root.__playerUpperMiddle < wintop)) {
            root.stickyPlayer.toggleSticky(true);
          } else {
            root.stickyPlayer.toggleSticky(false);
          }
        }
      }
      /**
       * gets parent node in light DOM
       *
       * @param {object} the node
       * @returns {object} the parent node
       */

    }, {
      key: "_getParentNode",
      value: function _getParentNode(node) {
        var parent = node.parentNode;

        if (parent !== undefined && parent !== null && parent.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
          parent = parent.host;
        }

        return parent;
      }
      /**
       * life cycle, element is removed from the DOM
       */

    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        babelHelpers.get(babelHelpers.getPrototypeOf(A11yMediaStateManager.prototype), "disconnectedCallback", this).call(this);
        var root = this;
        window.removeEventListener("a11y-player", root.__playerLoader);
        window.removeEventListener("a11y-player-playing", root.__stickyManager);
        window.removeEventListener("scroll", root.__scrollChecker);
      }
    }]);
    return A11yMediaStateManager;
  }(_litElement.LitElement);

  _exports.A11yMediaStateManager = A11yMediaStateManager;
  window.customElements.define(A11yMediaStateManager.tag, A11yMediaStateManager);
});