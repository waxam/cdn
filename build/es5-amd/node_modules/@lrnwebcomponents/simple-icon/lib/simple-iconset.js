define(["exports"], function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.SimpleIconsetStore = _exports.SimpleIconset = void 0;

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  /**
   * Singleton to manage iconsets
   * @demo demo/index.html
   */
  // polyfill for replaceAll, I hate you Safari / really old stuff
  if (!String.prototype.replaceAll) {
    String.prototype.replaceAll = function (find, replace) {
      return this.split(find).join(replace);
    };
  }
  /**
   *
   * @class SimpleIconset
   * @extends HTMLElement
   */


  var SimpleIconset = /*#__PURE__*/function (_HTMLElement) {
    babelHelpers.inherits(SimpleIconset, _HTMLElement);

    var _super = _createSuper(SimpleIconset);

    function SimpleIconset() {
      var _this;

      babelHelpers.classCallCheck(this, SimpleIconset);
      _this = _super.call(this);
      _this.iconsets = {};
      _this.iconlist = [];
      _this.manifest = {};
      _this.needsHydrated = [];
      return _this;
    }
    /**
     * Manifest.js files can register themselves to create an icon list.
     * These files export an array of iconsets
     * as [{name: iconsetName, icons: [ iconName,iconName2 ]}]
     *
     * @param {array} manifest array of iconsets
     * @memberof SimpleIconset
     */


    babelHelpers.createClass(SimpleIconset, [{
      key: "registerManifest",
      value: function registerManifest(manifest) {
        var _this2 = this;

        (manifest || []).forEach(function (iconset) {
          if (!_this2.manifest[iconset.name]) {
            _this2.manifest[iconset.name] = iconset.icons || [];

            _this2.manifest[iconset.name].forEach(function (icon) {
              _this2.iconlist.push("".concat(iconset.name, ":").concat(icon));
            });
          }
        });
      }
      /**
       * Iconsets are to register a namespace in either manner:
       * object notation: key name of the icon with a specific path to the file
       * {
       *   icon: iconLocation,
       *   icon2: iconLocation2
       * }
       * string notation: assumes icon name can be found at ${iconLocationBasePath}${iconname}.svg
       * iconLocationBasePath
       */

    }, {
      key: "registerIconset",
      value: function registerIconset(name) {
        var _this3 = this;

        var icons = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (babelHelpers.typeof(icons) === "object") {
          this.iconsets[name] = _objectSpread({}, icons);
        } else if (typeof icons === "string") {
          this.iconsets[name] = icons;
        } // try processing anything that might have missed previously


        if (this.needsHydrated.length > 0) {
          var list = [];
          this.needsHydrated.forEach(function (item, index) {
            // set the src from interns of the icon, returns if it matched
            // which will then push it into the list to be removed from processing
            if (typeof item.setSrcByIcon === "function" && item.setSrcByIcon(_this3)) {
              list.push(index);
            }
          }); // process in reverse order to avoid key splicing issues

          list.reverse().forEach(function (val) {
            _this3.needsHydrated.splice(val, 1);
          });
        }
      }
      /**
       * return the icon location on splitting the string on : for position in the object
       * if the icon doesn't exist, it sets a value for future updates in the event
       * that the library for the icon registers AFTER the request to visualize is made
       */

    }, {
      key: "getIcon",
      value: function getIcon(val, context) {
        var ary = val.replaceAll("/", "-").split(":"); // legacy API used to fill in icons: for lazy devs so let's mirror

        if (ary.length === 1) {
          ary = ["icons", val];
        }

        if (ary.length == 2 && this.iconsets[ary[0]]) {
          if (typeof this.iconsets[ary[0]] !== "string" && this.iconsets[ary[0]][ary[1]] && typeof this.iconsets[ary[0]][ary[1]] !== "function") {
            return this.iconsets[ary[0]][ary[1]];
          } else if (ary[1]) {
            return "".concat(this.iconsets[ary[0]]).concat(ary[1], ".svg");
          }
        } // if we get here we just missed on the icon hydrating which means
        // either it's an invalid icon OR the library to register the icons
        // location will import AFTER (possible microtiming early on)
        // also weird looking by context is either the element asking about
        // itself OR the the iconset state manager checking for hydration


        if (context !== this && context) {
          this.needsHydrated.push(context);
        }

        return null;
      }
    }], [{
      key: "tag",
      get: function get() {
        return "simple-iconset";
      }
    }]);
    return SimpleIconset;
  }( /*#__PURE__*/babelHelpers.wrapNativeSuper(HTMLElement));

  _exports.SimpleIconset = SimpleIconset;
  customElements.define(SimpleIconset.tag, SimpleIconset);
  window.SimpleIconset = window.SimpleIconset || {};
  /**
   * Checks to see if there is an instance available, and if not appends one
   */

  window.SimpleIconset.requestAvailability = function () {
    if (window.SimpleIconset.instance == null) {
      window.SimpleIconset.instance = document.createElement("simple-iconset");
    }

    document.body.appendChild(window.SimpleIconset.instance);
    return window.SimpleIconset.instance;
  }; // self request so that when this file is referenced it exists in the dom


  var SimpleIconsetStore = window.SimpleIconset.requestAvailability();
  _exports.SimpleIconsetStore = SimpleIconsetStore;
});