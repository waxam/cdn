define(["exports"], function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.pathResolver = pathResolver;
  _exports.pathFromUrl = pathFromUrl;
  _exports.SimpleIconsetStore = _exports.SimpleIconset = void 0;

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  /**
   * Singleton to manage iconsets
   * @demo demo/index.html
   */
  // polyfill for replaceAll, I hate you Safari / really old stuff
  if (!String.prototype.replaceAll) {
    String.prototype.replaceAll = function (find, replace) {
      return this.split(find).join(replace);
    };
  }

  var SimpleIconset = /*#__PURE__*/function (_HTMLElement) {
    babelHelpers.inherits(SimpleIconset, _HTMLElement);

    var _super = _createSuper(SimpleIconset);

    babelHelpers.createClass(SimpleIconset, null, [{
      key: "tag",
      get: function get() {
        return "simple-iconset";
      }
    }]);

    function SimpleIconset() {
      var _this;

      babelHelpers.classCallCheck(this, SimpleIconset);
      _this = _super.call(this);
      _this.iconsets = {};
      _this.needsHydrated = [];
      return _this;
    }
    /**
     * Iconsets are to register a namespace in either manner:
     * object notation: key name of the icon with a specific path to the file
     * {
     *   icon: iconLocation,
     *   icon2: iconLocation2
     * }
     * string notation: assumes icon name can be found at ${iconLocationBasePath}${iconname}.svg
     * iconLocationBasePath
     */


    babelHelpers.createClass(SimpleIconset, [{
      key: "registerIconset",
      value: function registerIconset(name) {
        var _this2 = this;

        var icons = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        if (babelHelpers.typeof(icons) === "object") {
          this.iconsets[name] = _objectSpread({}, icons);
        } else if (typeof icons === "string") {
          this.iconsets[name] = icons;
        } // try processing anything that might have missed previously


        if (this.needsHydrated.length > 0) {
          var list = [];
          this.needsHydrated.forEach(function (item, index) {
            // set the src from interns of the icon, returns if it matched
            // which will then push it into the list to be removed from processing
            if (item.setSrcByIcon(_this2)) {
              list.push(index);
            }
          }); // process in reverse order to avoid key splicing issues

          list.reverse().forEach(function (val) {
            _this2.needsHydrated.splice(val, 1);
          });
        }
      }
      /**
       * return the icon location on splitting the string on : for position in the object
       * if the icon doesn't exist, it sets a value for future updates in the event
       * that the library for the icon registers AFTER the request to visualize is made
       */

    }, {
      key: "getIcon",
      value: function getIcon(val, context) {
        var ary = val.replaceAll("/", "-").split(":"); // legacy API used to fill in icons: for lazy devs so let's mirror

        if (ary.length === 1) {
          ary = ["icons", val];
        }

        if (ary.length == 2 && this.iconsets[ary[0]]) {
          if (typeof this.iconsets[ary[0]] !== "string" && this.iconsets[ary[0]][ary[1]] && typeof this.iconsets[ary[0]][ary[1]] !== "function") {
            return this.iconsets[ary[0]][ary[1]];
          } else if (ary[1]) {
            return "".concat(this.iconsets[ary[0]]).concat(ary[1], ".svg");
          }
        } // if we get here we just missed on the icon hydrating which means
        // either it's an invalid icon OR the library to register the icons
        // location will import AFTER (possible microtiming early on)
        // also weird looking by context is either the element asking about
        // itself OR the the iconset state manager checking for hydration


        if (context != this) {
          this.needsHydrated.push(context);
        }

        return null;
      }
    }]);
    return SimpleIconset;
  }( /*#__PURE__*/babelHelpers.wrapNativeSuper(HTMLElement));
  /**
   * helper function for iconset developers to resolve relative paths
   */


  _exports.SimpleIconset = SimpleIconset;

  function pathResolver(base) {
    var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
    return pathFromUrl(decodeURIComponent(base)) + path;
  } // simple path from url


  function pathFromUrl(url) {
    return url.substring(0, url.lastIndexOf("/") + 1);
  }

  customElements.define(SimpleIconset.tag, SimpleIconset);
  window.SimpleIconset = window.SimpleIconset || {};
  /**
   * Checks to see if there is an instance available, and if not appends one
   */

  window.SimpleIconset.requestAvailability = function () {
    if (window.SimpleIconset.instance == null) {
      window.SimpleIconset.instance = document.createElement("simple-iconset");
    }

    document.body.appendChild(window.SimpleIconset.instance);
    return window.SimpleIconset.instance;
  }; // self request so that when this file is referenced it exists in the dom


  var SimpleIconsetStore = window.SimpleIconset.requestAvailability();
  _exports.SimpleIconsetStore = SimpleIconsetStore;
});