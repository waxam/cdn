define(["exports"], function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.SchemaBehaviors = void 0;

  /**
   * Copyright 2018 The Pennsylvania State University
   * @license Apache-2.0, see License.md for full text.
   */
  var SchemaBehaviors = function SchemaBehaviors(SuperClass) {
    return (
      /*#__PURE__*/
      function (_SuperClass) {
        babelHelpers.inherits(_class, _SuperClass);

        /**
         * HTMLElement
         */
        function _class() {
          var _this;

          babelHelpers.classCallCheck(this, _class);
          _this = babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(_class).call(this));
          _this.schemaResourceID = "";
          _this.schemaMap = {
            prefix: {
              oer: "http://oerschema.org/",
              schema: "http://schema.org/",
              dc: "http://purl.org/dc/terms/",
              foaf: "http://xmlns.com/foaf/0.1/",
              cc: "http://creativecommons.org/ns#",
              bib: "http://bib.schema.org"
            }
          };
          return _this;
        }
        /**
         * Popular convention across libraries
         */


        babelHelpers.createClass(_class, [{
          key: "updated",

          /**
           * LitElement support
           */
          value: function updated(changedProperties) {
            var _this2 = this;

            if (babelHelpers.get(babelHelpers.getPrototypeOf(_class.prototype), "updated", this)) {
              babelHelpers.get(babelHelpers.getPrototypeOf(_class.prototype), "updated", this).call(this, changedProperties);
            }

            changedProperties.forEach(function (oldValue, propName) {
              if (propName == "schemaMap") {
                _this2._schemaMapChanged(_this2[propName], oldValue);
              }
            });
          }
          /**
           * Notice the schema map has changed, reprocess attributes.
           */

        }, {
          key: "_schemaMapChanged",
          value: function _schemaMapChanged(newValue, oldValue) {
            if (babelHelpers.typeof(newValue) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
              // use this to tie into schemaResourceID build
              this.schemaResourceID = this.getAttribute("resource"); // if it still doesn't have one then we have to check

              if (this.schemaResourceID == "" || this.schemaResourceID == null) {
                this.schemaResourceID = this.generateResourceID();
                this.setAttribute("resource", this.schemaResourceID);
              }

              var prefixes = newValue.prefix;
              var prefix = ""; // build prefix string

              for (var property in prefixes) {
                if (prefixes.hasOwnProperty(property)) {
                  prefix += property + ":" + prefixes[property] + " ";
                }
              } // set prefix on the main element itself


              if (prefix != "") {
                this.setAttribute("prefix", prefix);
              }
            }
          }
          /**
           * Generate a uinque ID
           */

        }, {
          key: "generateResourceID",
          value: function generateResourceID() {
            function idPart() {
              return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
            }

            return "#" + idPart() + idPart() + "-" + idPart() + "-" + idPart() + "-" + idPart();
          }
        }], [{
          key: "properties",
          get: function get() {
            return babelHelpers.objectSpread({}, babelHelpers.get(babelHelpers.getPrototypeOf(_class), "properties", this), {
              /**
               * Unique Resource ID, generated when schemaMap processes.
               */
              schemaResourceID: {
                type: String
              },

              /**
               * Schema Map for the element, used to generate a valid prefix on the fly
               * Props set for Polymer compatibility
               */
              schemaMap: {
                type: Object,
                readOnly: true,
                observer: "_schemaMapChanged"
              }
            });
          }
        }]);
        return _class;
      }(SuperClass)
    );
  };

  _exports.SchemaBehaviors = SchemaBehaviors;
});