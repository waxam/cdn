define(["exports", "./webaudio.js", "./util/index.js"], function (_exports, _webaudio, util) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = void 0;
  _webaudio = babelHelpers.interopRequireDefault(_webaudio);
  util = babelHelpers.interopRequireWildcard(util);

  /**
   * MediaElement backend
   */
  var MediaElement =
  /*#__PURE__*/
  function (_WebAudio) {
    babelHelpers.inherits(MediaElement, _WebAudio);

    /**
     * Construct the backend
     *
     * @param {WavesurferParams} params
     */
    function MediaElement(params) {
      var _this;

      babelHelpers.classCallCheck(this, MediaElement);
      _this = babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(MediaElement).call(this, params));
      /** @private */

      _this.params = params; // Dummy media to catch errors

      /** @private */

      _this.media = {
        currentTime: 0,
        duration: 0,
        paused: true,
        playbackRate: 1,
        play: function play() {},
        pause: function pause() {},
        volume: 0
      };
      /** @private */

      _this.mediaType = params.mediaType.toLowerCase();
      /** @private */

      _this.elementPosition = params.elementPosition;
      /** @private */

      _this.peaks = null;
      /** @private */

      _this.playbackRate = 1;
      /** @private */

      _this.volume = 1;
      /** @private */

      _this.buffer = null;
      /** @private */

      _this.onPlayEnd = null;
      return _this;
    }
    /**
     * Initialise the backend, called in `wavesurfer.createBackend()`
     */


    babelHelpers.createClass(MediaElement, [{
      key: "init",
      value: function init() {
        this.setPlaybackRate(this.params.audioRate);
        this.createTimer();
      }
      /**
       * Create a timer to provide a more precise `audioprocess` event.
       *
       * @private
       */

    }, {
      key: "createTimer",
      value: function createTimer() {
        var _this2 = this;

        var onAudioProcess = function onAudioProcess() {
          if (_this2.isPaused()) {
            return;
          }

          _this2.fireEvent("audioprocess", _this2.getCurrentTime()); // Call again in the next frame


          var requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame;
          requestAnimationFrame(onAudioProcess);
        };

        this.on("play", onAudioProcess); // Update the progress one more time to prevent it from being stuck in case of lower framerates

        this.on("pause", function () {
          _this2.fireEvent("audioprocess", _this2.getCurrentTime());
        });
      }
      /**
       * Create media element with url as its source,
       * and append to container element.
       *
       * @param {string} url Path to media file
       * @param {HTMLElement} container HTML element
       * @param {number[]|number[][]} peaks Array of peak data
       * @param {string} preload HTML 5 preload attribute value
       */

    }, {
      key: "load",
      value: function load(url, container, peaks, preload) {
        var media = document.createElement(this.mediaType);
        media.controls = this.params.mediaControls;
        media.autoplay = this.params.autoplay || false;
        media.preload = preload == null ? "auto" : preload;
        media.src = url;
        media.style.width = "100%";
        var prevMedia = container.querySelector(this.mediaType);

        if (prevMedia) {
          container.removeChild(prevMedia);
        }

        container.appendChild(media);

        this._load(media, peaks);
      }
      /**
       * Load existing media element.
       *
       * @param {HTMLMediaElement} elt HTML5 Audio or Video element
       * @param {number[]|number[][]} peaks Array of peak data
       */

    }, {
      key: "loadElt",
      value: function loadElt(elt, peaks) {
        elt.controls = this.params.mediaControls;
        elt.autoplay = this.params.autoplay || false;

        this._load(elt, peaks);
      }
      /**
       * Private method called by both load (from url)
       * and loadElt (existing media element).
       *
       * @param {HTMLMediaElement} media HTML5 Audio or Video element
       * @param {number[]|number[][]} peaks Array of peak data
       * @private
       */

    }, {
      key: "_load",
      value: function _load(media, peaks) {
        var _this3 = this;

        // load must be called manually on iOS, otherwise peaks won't draw
        // until a user interaction triggers load --> 'ready' event
        if (typeof media.load == "function") {
          // Resets the media element and restarts the media resource. Any
          // pending events are discarded. How much media data is fetched is
          // still affected by the preload attribute.
          media.load();
        }

        media.addEventListener("error", function () {
          _this3.fireEvent("error", "Error loading media element");
        });
        media.addEventListener("canplay", function () {
          _this3.fireEvent("canplay");
        });
        media.addEventListener("ended", function () {
          _this3.fireEvent("finish");
        }); // Listen to and relay play and pause events to enable
        // playback control from the external media element

        media.addEventListener("play", function () {
          _this3.fireEvent("play");
        });
        media.addEventListener("pause", function () {
          _this3.fireEvent("pause");
        });
        this.media = media;
        this.peaks = peaks;
        this.onPlayEnd = null;
        this.buffer = null;
        this.setPlaybackRate(this.playbackRate);
        this.setVolume(this.volume);
      }
      /**
       * Used by `wavesurfer.isPlaying()` and `wavesurfer.playPause()`
       *
       * @return {boolean}
       */

    }, {
      key: "isPaused",
      value: function isPaused() {
        return !this.media || this.media.paused;
      }
      /**
       * Used by `wavesurfer.getDuration()`
       *
       * @return {number}
       */

    }, {
      key: "getDuration",
      value: function getDuration() {
        if (this.explicitDuration) {
          return this.explicitDuration;
        }

        var duration = (this.buffer || this.media).duration;

        if (duration >= Infinity) {
          // streaming audio
          duration = this.media.seekable.end(0);
        }

        return duration;
      }
      /**
       * Returns the current time in seconds relative to the audioclip's
       * duration.
       *
       * @return {number}
       */

    }, {
      key: "getCurrentTime",
      value: function getCurrentTime() {
        return this.media && this.media.currentTime;
      }
      /**
       * Get the position from 0 to 1
       *
       * @return {number}
       */

    }, {
      key: "getPlayedPercents",
      value: function getPlayedPercents() {
        return this.getCurrentTime() / this.getDuration() || 0;
      }
      /**
       * Get the audio source playback rate.
       *
       * @return {number}
       */

    }, {
      key: "getPlaybackRate",
      value: function getPlaybackRate() {
        return this.playbackRate || this.media.playbackRate;
      }
      /**
       * Set the audio source playback rate.
       *
       * @param {number} value
       */

    }, {
      key: "setPlaybackRate",
      value: function setPlaybackRate(value) {
        this.playbackRate = value || 1;
        this.media.playbackRate = this.playbackRate;
      }
      /**
       * Used by `wavesurfer.seekTo()`
       *
       * @param {number} start Position to start at in seconds
       */

    }, {
      key: "seekTo",
      value: function seekTo(start) {
        if (start != null) {
          this.media.currentTime = start;
        }

        this.clearPlayEnd();
      }
      /**
       * Plays the loaded audio region.
       *
       * @param {number} start Start offset in seconds, relative to the beginning
       * of a clip.
       * @param {number} end When to stop, relative to the beginning of a clip.
       * @emits MediaElement#play
       * @return {Promise}
       */

    }, {
      key: "play",
      value: function play(start, end) {
        this.seekTo(start);
        var promise = this.media.play();
        end && this.setPlayEnd(end);
        return promise;
      }
      /**
       * Pauses the loaded audio.
       *
       * @emits MediaElement#pause
       * @return {Promise}
       */

    }, {
      key: "pause",
      value: function pause() {
        var promise;

        if (this.media) {
          promise = this.media.pause();
        }

        this.clearPlayEnd();
        return promise;
      }
      /** @private */

    }, {
      key: "setPlayEnd",
      value: function setPlayEnd(end) {
        var _this4 = this;

        this._onPlayEnd = function (time) {
          if (time >= end) {
            _this4.pause();

            _this4.seekTo(end);
          }
        };

        this.on("audioprocess", this._onPlayEnd);
      }
      /** @private */

    }, {
      key: "clearPlayEnd",
      value: function clearPlayEnd() {
        if (this._onPlayEnd) {
          this.un("audioprocess", this._onPlayEnd);
          this._onPlayEnd = null;
        }
      }
      /**
       * Compute the max and min value of the waveform when broken into
       * <length> subranges.
       *
       * @param {number} length How many subranges to break the waveform into.
       * @param {number} first First sample in the required range.
       * @param {number} last Last sample in the required range.
       * @return {number[]|number[][]} Array of 2*<length> peaks or array of
       * arrays of peaks consisting of (max, min) values for each subrange.
       */

    }, {
      key: "getPeaks",
      value: function getPeaks(length, first, last) {
        if (this.buffer) {
          return babelHelpers.get(babelHelpers.getPrototypeOf(MediaElement.prototype), "getPeaks", this).call(this, length, first, last);
        }

        return this.peaks || [];
      }
      /**
       * Set the sink id for the media player
       *
       * @param {string} deviceId String value representing audio device id.
       */

    }, {
      key: "setSinkId",
      value: function setSinkId(deviceId) {
        if (deviceId) {
          if (!this.media.setSinkId) {
            return Promise.reject(new Error("setSinkId is not supported in your browser"));
          }

          return this.media.setSinkId(deviceId);
        }

        return Promise.reject(new Error("Invalid deviceId: " + deviceId));
      }
      /**
       * Get the current volume
       *
       * @return {number} value A floating point value between 0 and 1.
       */

    }, {
      key: "getVolume",
      value: function getVolume() {
        return this.volume || this.media.volume;
      }
      /**
       * Set the audio volume
       *
       * @param {number} value A floating point value between 0 and 1.
       */

    }, {
      key: "setVolume",
      value: function setVolume(value) {
        this.volume = value;
        this.media.volume = this.volume;
      }
      /**
       * This is called when wavesurfer is destroyed
       *
       */

    }, {
      key: "destroy",
      value: function destroy() {
        this.pause();
        this.unAll();

        if (this.params.removeMediaElementOnDestroy && this.media && this.media.parentNode) {
          this.media.parentNode.removeChild(this.media);
        }

        this.media = null;
      }
    }]);
    return MediaElement;
  }(_webaudio.default);

  _exports.default = MediaElement;
});