define(["exports", "./util/index.js"], function (_exports, util) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = void 0;
  util = babelHelpers.interopRequireWildcard(util);

  /**
   * Parent class for renderers
   *
   * @extends {Observer}
   */
  var Drawer =
  /*#__PURE__*/
  function (_util$Observer) {
    babelHelpers.inherits(Drawer, _util$Observer);

    /**
     * @param {HTMLElement} container The container node of the wavesurfer instance
     * @param {WavesurferParams} params The wavesurfer initialisation options
     */
    function Drawer(container, params) {
      var _this;

      babelHelpers.classCallCheck(this, Drawer);
      _this = babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(Drawer).call(this));
      /** @private */

      _this.container = container;
      /**
       * @type {WavesurferParams}
       * @private
       */

      _this.params = params;
      /**
       * The width of the renderer
       * @type {number}
       */

      _this.width = 0;
      /**
       * The height of the renderer
       * @type {number}
       */

      _this.height = params.height * _this.params.pixelRatio;
      /** @private */

      _this.lastPos = 0;
      /**
       * The `<wave>` element which is added to the container
       * @type {HTMLElement}
       */

      _this.wrapper = null;
      return _this;
    }
    /**
     * Alias of `util.style`
     *
     * @param {HTMLElement} el The element that the styles will be applied to
     * @param {Object} styles The map of propName: attribute, both are used as-is
     * @return {HTMLElement} el
     */


    babelHelpers.createClass(Drawer, [{
      key: "style",
      value: function style(el, styles) {
        return util.style(el, styles);
      }
      /**
       * Create the wrapper `<wave>` element, style it and set up the events for
       * interaction
       */

    }, {
      key: "createWrapper",
      value: function createWrapper() {
        this.wrapper = this.container.appendChild(document.createElement("wave"));
        this.style(this.wrapper, {
          display: "block",
          position: "relative",
          userSelect: "none",
          webkitUserSelect: "none",
          height: this.params.height + "px"
        });

        if (this.params.fillParent || this.params.scrollParent) {
          this.style(this.wrapper, {
            width: "100%",
            overflowX: this.params.hideScrollbar ? "hidden" : "auto",
            overflowY: "hidden"
          });
        }

        this.setupWrapperEvents();
      }
      /**
       * Handle click event
       *
       * @param {Event} e Click event
       * @param {?boolean} noPrevent Set to true to not call `e.preventDefault()`
       * @return {number} Playback position from 0 to 1
       */

    }, {
      key: "handleEvent",
      value: function handleEvent(e, noPrevent) {
        !noPrevent && e.preventDefault();
        var clientX = e.targetTouches ? e.targetTouches[0].clientX : e.clientX;
        var bbox = this.wrapper.getBoundingClientRect();
        var nominalWidth = this.width;
        var parentWidth = this.getWidth();
        var progress;

        if (!this.params.fillParent && nominalWidth < parentWidth) {
          progress = (clientX - bbox.left) * (this.params.pixelRatio / nominalWidth) || 0;

          if (progress > 1) {
            progress = 1;
          }
        } else {
          progress = (clientX - bbox.left + this.wrapper.scrollLeft) / this.wrapper.scrollWidth || 0;
        }

        return progress;
      }
      /**
       * @private
       */

    }, {
      key: "setupWrapperEvents",
      value: function setupWrapperEvents() {
        var _this2 = this;

        this.wrapper.addEventListener("click", function (e) {
          var scrollbarHeight = _this2.wrapper.offsetHeight - _this2.wrapper.clientHeight;

          if (scrollbarHeight != 0) {
            // scrollbar is visible.  Check if click was on it
            var bbox = _this2.wrapper.getBoundingClientRect();

            if (e.clientY >= bbox.bottom - scrollbarHeight) {
              // ignore mousedown as it was on the scrollbar
              return;
            }
          }

          if (_this2.params.interact) {
            _this2.fireEvent("click", e, _this2.handleEvent(e));
          }
        });
        this.wrapper.addEventListener("scroll", function (e) {
          return _this2.fireEvent("scroll", e);
        });
      }
      /**
       * Draw peaks on the canvas
       *
       * @param {number[]|number[][]} peaks Can also be an array of arrays for split channel
       * rendering
       * @param {number} length The width of the area that should be drawn
       * @param {number} start The x-offset of the beginning of the area that
       * should be rendered
       * @param {number} end The x-offset of the end of the area that should be
       * rendered
       */

    }, {
      key: "drawPeaks",
      value: function drawPeaks(peaks, length, start, end) {
        if (!this.setWidth(length)) {
          this.clearWave();
        }

        this.params.barWidth ? this.drawBars(peaks, 0, start, end) : this.drawWave(peaks, 0, start, end);
      }
      /**
       * Scroll to the beginning
       */

    }, {
      key: "resetScroll",
      value: function resetScroll() {
        if (this.wrapper !== null) {
          this.wrapper.scrollLeft = 0;
        }
      }
      /**
       * Recenter the viewport at a certain percent of the waveform
       *
       * @param {number} percent Value from 0 to 1 on the waveform
       */

    }, {
      key: "recenter",
      value: function recenter(percent) {
        var position = this.wrapper.scrollWidth * percent;
        this.recenterOnPosition(position, true);
      }
      /**
       * Recenter the viewport on a position, either scroll there immediately or
       * in steps of 5 pixels
       *
       * @param {number} position X-offset in pixels
       * @param {boolean} immediate Set to true to immediately scroll somewhere
       */

    }, {
      key: "recenterOnPosition",
      value: function recenterOnPosition(position, immediate) {
        var scrollLeft = this.wrapper.scrollLeft;
        var half = ~~(this.wrapper.clientWidth / 2);
        var maxScroll = this.wrapper.scrollWidth - this.wrapper.clientWidth;
        var target = position - half;
        var offset = target - scrollLeft;

        if (maxScroll == 0) {
          // no need to continue if scrollbar is not there
          return;
        } // if the cursor is currently visible...


        if (!immediate && -half <= offset && offset < half) {
          // we'll limit the "re-center" rate.
          var rate = 5;
          offset = Math.max(-rate, Math.min(rate, offset));
          target = scrollLeft + offset;
        } // limit target to valid range (0 to maxScroll)


        target = Math.max(0, Math.min(maxScroll, target)); // no use attempting to scroll if we're not moving

        if (target != scrollLeft) {
          this.wrapper.scrollLeft = target;
        }
      }
      /**
       * Get the current scroll position in pixels
       *
       * @return {number}
       */

    }, {
      key: "getScrollX",
      value: function getScrollX() {
        var pixelRatio = this.params.pixelRatio;
        var x = Math.round(this.wrapper.scrollLeft * pixelRatio); // In cases of elastic scroll (safari with mouse wheel) you can
        // scroll beyond the limits of the container
        // Calculate and floor the scrollable extent to make sure an out
        // of bounds value is not returned
        // Ticket #1312

        if (this.params.scrollParent) {
          var maxScroll = ~~(this.wrapper.scrollWidth * pixelRatio - this.getWidth());
          x = Math.min(maxScroll, Math.max(0, x));
        }

        return x;
      }
      /**
       * Get the width of the container
       *
       * @return {number}
       */

    }, {
      key: "getWidth",
      value: function getWidth() {
        return Math.round(this.container.clientWidth * this.params.pixelRatio);
      }
      /**
       * Set the width of the container
       *
       * @param {number} width
       */

    }, {
      key: "setWidth",
      value: function setWidth(width) {
        if (this.width == width) {
          return false;
        }

        this.width = width;

        if (this.params.fillParent || this.params.scrollParent) {
          this.style(this.wrapper, {
            width: ""
          });
        } else {
          this.style(this.wrapper, {
            width: ~~(this.width / this.params.pixelRatio) + "px"
          });
        }

        this.updateSize();
        return true;
      }
      /**
       * Set the height of the container
       *
       * @param {number} height
       */

    }, {
      key: "setHeight",
      value: function setHeight(height) {
        if (height == this.height) {
          return false;
        }

        this.height = height;
        this.style(this.wrapper, {
          height: ~~(this.height / this.params.pixelRatio) + "px"
        });
        this.updateSize();
        return true;
      }
      /**
       * Called by wavesurfer when progress should be renderered
       *
       * @param {number} progress From 0 to 1
       */

    }, {
      key: "progress",
      value: function progress(_progress) {
        var minPxDelta = 1 / this.params.pixelRatio;
        var pos = Math.round(_progress * this.width) * minPxDelta;

        if (pos < this.lastPos || pos - this.lastPos >= minPxDelta) {
          this.lastPos = pos;

          if (this.params.scrollParent && this.params.autoCenter) {
            var newPos = ~~(this.wrapper.scrollWidth * _progress);
            this.recenterOnPosition(newPos);
          }

          this.updateProgress(pos);
        }
      }
      /**
       * This is called when wavesurfer is destroyed
       */

    }, {
      key: "destroy",
      value: function destroy() {
        this.unAll();

        if (this.wrapper) {
          if (this.wrapper.parentNode == this.container) {
            this.container.removeChild(this.wrapper);
          }

          this.wrapper = null;
        }
      }
      /* Renderer-specific methods */

      /**
       * Called after cursor related params have changed.
       *
       * @abstract
       */

    }, {
      key: "updateCursor",
      value: function updateCursor() {}
      /**
       * Called when the size of the container changes so the renderer can adjust
       *
       * @abstract
       */

    }, {
      key: "updateSize",
      value: function updateSize() {}
      /**
       * Draw a waveform with bars
       *
       * @abstract
       * @param {number[]|number[][]} peaks Can also be an array of arrays for split channel
       * rendering
       * @param {number} channelIndex The index of the current channel. Normally
       * should be 0
       * @param {number} start The x-offset of the beginning of the area that
       * should be rendered
       * @param {number} end The x-offset of the end of the area that should be
       * rendered
       */

    }, {
      key: "drawBars",
      value: function drawBars(peaks, channelIndex, start, end) {}
      /**
       * Draw a waveform
       *
       * @abstract
       * @param {number[]|number[][]} peaks Can also be an array of arrays for split channel
       * rendering
       * @param {number} channelIndex The index of the current channel. Normally
       * should be 0
       * @param {number} start The x-offset of the beginning of the area that
       * should be rendered
       * @param {number} end The x-offset of the end of the area that should be
       * rendered
       */

    }, {
      key: "drawWave",
      value: function drawWave(peaks, channelIndex, start, end) {}
      /**
       * Clear the waveform
       *
       * @abstract
       */

    }, {
      key: "clearWave",
      value: function clearWave() {}
      /**
       * Render the new progress
       *
       * @abstract
       * @param {number} position X-Offset of progress position in pixels
       */

    }, {
      key: "updateProgress",
      value: function updateProgress(position) {}
    }]);
    return Drawer;
  }(util.Observer);

  _exports.default = Drawer;
});