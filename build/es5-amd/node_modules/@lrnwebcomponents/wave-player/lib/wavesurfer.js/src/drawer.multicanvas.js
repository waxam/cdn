define(["exports", "./drawer.js", "./util/index.js"], function (_exports, _drawer, util) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = void 0;
  _drawer = babelHelpers.interopRequireDefault(_drawer);
  util = babelHelpers.interopRequireWildcard(util);

  /**
   * @typedef {Object} CanvasEntry
   * @private
   * @property {HTMLElement} wave The wave node
   * @property {CanvasRenderingContext2D} waveCtx The canvas rendering context
   * @property {?HTMLElement} progress The progress wave node
   * @property {?CanvasRenderingContext2D} progressCtx The progress wave canvas
   * rendering context
   * @property {?number} start Start of the area the canvas should render, between 0 and 1
   * @property {?number} end End of the area the canvas should render, between 0 and 1
   */

  /**
   * MultiCanvas renderer for wavesurfer. Is currently the default and sole built
   * in renderer.
   */
  var MultiCanvas =
  /*#__PURE__*/
  function (_Drawer) {
    babelHelpers.inherits(MultiCanvas, _Drawer);

    /**
     * @param {HTMLElement} container The container node of the wavesurfer instance
     * @param {WavesurferParams} params The wavesurfer initialisation options
     */
    function MultiCanvas(container, params) {
      var _this;

      babelHelpers.classCallCheck(this, MultiCanvas);
      _this = babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(MultiCanvas).call(this, container, params));
      /**
       * @type {number}
       * @private
       */

      _this.maxCanvasWidth = params.maxCanvasWidth;
      /**
       * @private
       * @type {number}
       */

      _this.maxCanvasElementWidth = Math.round(params.maxCanvasWidth / params.pixelRatio);
      /**
       * Whether or not the progress wave is renderered. If the `waveColor`
       * and `progressColor` are the same colour it is not.
       * @type {boolean}
       */

      _this.hasProgressCanvas = params.waveColor != params.progressColor;
      /**
       * @private
       * @type {number}
       */

      _this.halfPixel = 0.5 / params.pixelRatio;
      /**
       * @private
       * @type {Array}
       */

      _this.canvases = [];
      /** @private */

      _this.progressWave = null;
      return _this;
    }
    /**
     * Initialise the drawer
     */


    babelHelpers.createClass(MultiCanvas, [{
      key: "init",
      value: function init() {
        this.createWrapper();
        this.createElements();
      }
      /**
       * Create the canvas elements and style them
       *
       * @private
       */

    }, {
      key: "createElements",
      value: function createElements() {
        this.progressWave = this.wrapper.appendChild(this.style(document.createElement("wave"), {
          position: "absolute",
          zIndex: 3,
          left: 0,
          top: 0,
          bottom: 0,
          overflow: "hidden",
          width: "0",
          display: "none",
          boxSizing: "border-box",
          borderRightStyle: "solid",
          pointerEvents: "none"
        }));
        this.addCanvas();
        this.updateCursor();
      }
      /**
       * Update cursor style from params.
       */

    }, {
      key: "updateCursor",
      value: function updateCursor() {
        this.style(this.progressWave, {
          borderRightWidth: this.params.cursorWidth + "px",
          borderRightColor: this.params.cursorColor
        });
      }
      /**
       * Adjust to the updated size by adding or removing canvases
       */

    }, {
      key: "updateSize",
      value: function updateSize() {
        var _this2 = this;

        var totalWidth = Math.round(this.width / this.params.pixelRatio);
        var requiredCanvases = Math.ceil(totalWidth / this.maxCanvasElementWidth);

        while (this.canvases.length < requiredCanvases) {
          this.addCanvas();
        }

        while (this.canvases.length > requiredCanvases) {
          this.removeCanvas();
        }

        this.canvases.forEach(function (entry, i) {
          // Add some overlap to prevent vertical white stripes, keep the width even for simplicity.
          var canvasWidth = _this2.maxCanvasWidth + 2 * Math.ceil(_this2.params.pixelRatio / 2);

          if (i == _this2.canvases.length - 1) {
            canvasWidth = _this2.width - _this2.maxCanvasWidth * (_this2.canvases.length - 1);
          }

          _this2.updateDimensions(entry, canvasWidth, _this2.height);

          _this2.clearWaveForEntry(entry);
        });
      }
      /**
       * Add a canvas to the canvas list
       *
       * @private
       */

    }, {
      key: "addCanvas",
      value: function addCanvas() {
        var entry = {};
        var leftOffset = this.maxCanvasElementWidth * this.canvases.length;
        entry.wave = this.wrapper.appendChild(this.style(document.createElement("canvas"), {
          position: "absolute",
          zIndex: 2,
          left: leftOffset + "px",
          top: 0,
          bottom: 0,
          height: "100%",
          pointerEvents: "none"
        }));
        entry.waveCtx = entry.wave.getContext("2d");

        if (this.hasProgressCanvas) {
          entry.progress = this.progressWave.appendChild(this.style(document.createElement("canvas"), {
            position: "absolute",
            left: leftOffset + "px",
            top: 0,
            bottom: 0,
            height: "100%"
          }));
          entry.progressCtx = entry.progress.getContext("2d");
        }

        this.canvases.push(entry);
      }
      /**
       * Pop one canvas from the list
       *
       * @private
       */

    }, {
      key: "removeCanvas",
      value: function removeCanvas() {
        var lastEntry = this.canvases.pop();
        lastEntry.wave.parentElement.removeChild(lastEntry.wave);

        if (this.hasProgressCanvas) {
          lastEntry.progress.parentElement.removeChild(lastEntry.progress);
        }
      }
      /**
       * Update the dimensions of a canvas element
       *
       * @private
       * @param {CanvasEntry} entry
       * @param {number} width The new width of the element
       * @param {number} height The new height of the element
       */

    }, {
      key: "updateDimensions",
      value: function updateDimensions(entry, width, height) {
        var elementWidth = Math.round(width / this.params.pixelRatio);
        var totalWidth = Math.round(this.width / this.params.pixelRatio); // Where the canvas starts and ends in the waveform, represented as a decimal between 0 and 1.

        entry.start = entry.waveCtx.canvas.offsetLeft / totalWidth || 0;
        entry.end = entry.start + elementWidth / totalWidth;
        entry.waveCtx.canvas.width = width;
        entry.waveCtx.canvas.height = height;
        this.style(entry.waveCtx.canvas, {
          width: elementWidth + "px"
        });
        this.style(this.progressWave, {
          display: "block"
        });

        if (this.hasProgressCanvas) {
          entry.progressCtx.canvas.width = width;
          entry.progressCtx.canvas.height = height;
          this.style(entry.progressCtx.canvas, {
            width: elementWidth + "px"
          });
        }
      }
      /**
       * Clear the whole waveform
       */

    }, {
      key: "clearWave",
      value: function clearWave() {
        var _this3 = this;

        this.canvases.forEach(function (entry) {
          return _this3.clearWaveForEntry(entry);
        });
      }
      /**
       * Clear one canvas
       *
       * @private
       * @param {CanvasEntry} entry
       */

    }, {
      key: "clearWaveForEntry",
      value: function clearWaveForEntry(entry) {
        entry.waveCtx.clearRect(0, 0, entry.waveCtx.canvas.width, entry.waveCtx.canvas.height);

        if (this.hasProgressCanvas) {
          entry.progressCtx.clearRect(0, 0, entry.progressCtx.canvas.width, entry.progressCtx.canvas.height);
        }
      }
      /**
       * Draw a waveform with bars
       *
       * @param {number[]|number[][]} peaks Can also be an array of arrays for split channel
       * rendering
       * @param {number} channelIndex The index of the current channel. Normally
       * should be 0. Must be an integer.
       * @param {number} start The x-offset of the beginning of the area that
       * should be rendered
       * @param {number} end The x-offset of the end of the area that should be
       * rendered
       */

    }, {
      key: "drawBars",
      value: function drawBars(peaks, channelIndex, start, end) {
        var _this4 = this;

        return this.prepareDraw(peaks, channelIndex, start, end, function (_ref) {
          var absmax = _ref.absmax,
              hasMinVals = _ref.hasMinVals,
              height = _ref.height,
              offsetY = _ref.offsetY,
              halfH = _ref.halfH,
              peaks = _ref.peaks;

          // if drawBars was called within ws.empty we don't pass a start and
          // don't want anything to happen
          if (start === undefined) {
            return;
          } // Skip every other value if there are negatives.


          var peakIndexScale = hasMinVals ? 2 : 1;
          var length = peaks.length / peakIndexScale;
          var bar = _this4.params.barWidth * _this4.params.pixelRatio;
          var gap = _this4.params.barGap === null ? Math.max(_this4.params.pixelRatio, ~~(bar / 2)) : Math.max(_this4.params.pixelRatio, _this4.params.barGap * _this4.params.pixelRatio);
          var step = bar + gap;
          var scale = length / _this4.width;
          var first = start;
          var last = end;
          var i;

          for (i = first; i < last; i += step) {
            var peak = peaks[Math.floor(i * scale * peakIndexScale)] || 0;
            var h = Math.round(peak / absmax * halfH);

            _this4.fillRect(i + _this4.halfPixel, halfH - h + offsetY, bar + _this4.halfPixel, h * 2);
          }
        });
      }
      /**
       * Draw a waveform
       *
       * @param {number[]|number[][]} peaks Can also be an array of arrays for split channel
       * rendering
       * @param {number} channelIndex The index of the current channel. Normally
       * should be 0
       * @param {number?} start The x-offset of the beginning of the area that
       * should be rendered (If this isn't set only a flat line is rendered)
       * @param {number?} end The x-offset of the end of the area that should be
       * rendered
       */

    }, {
      key: "drawWave",
      value: function drawWave(peaks, channelIndex, start, end) {
        var _this5 = this;

        return this.prepareDraw(peaks, channelIndex, start, end, function (_ref2) {
          var absmax = _ref2.absmax,
              hasMinVals = _ref2.hasMinVals,
              height = _ref2.height,
              offsetY = _ref2.offsetY,
              halfH = _ref2.halfH,
              peaks = _ref2.peaks;

          if (!hasMinVals) {
            var reflectedPeaks = [];
            var len = peaks.length;
            var i;

            for (i = 0; i < len; i++) {
              reflectedPeaks[2 * i] = peaks[i];
              reflectedPeaks[2 * i + 1] = -peaks[i];
            }

            peaks = reflectedPeaks;
          } // if drawWave was called within ws.empty we don't pass a start and
          // end and simply want a flat line


          if (start !== undefined) {
            _this5.drawLine(peaks, absmax, halfH, offsetY, start, end);
          } // Always draw a median line


          _this5.fillRect(0, halfH + offsetY - _this5.halfPixel, _this5.width, _this5.halfPixel);
        });
      }
      /**
       * Tell the canvas entries to render their portion of the waveform
       *
       * @private
       * @param {number[]} peaks Peak data
       * @param {number} absmax Maximum peak value (absolute)
       * @param {number} halfH Half the height of the waveform
       * @param {number} offsetY Offset to the top
       * @param {number} start The x-offset of the beginning of the area that
       * should be rendered
       * @param {number} end The x-offset of the end of the area that
       * should be rendered
       */

    }, {
      key: "drawLine",
      value: function drawLine(peaks, absmax, halfH, offsetY, start, end) {
        var _this6 = this;

        this.canvases.forEach(function (entry) {
          _this6.setFillStyles(entry);

          _this6.drawLineToContext(entry, entry.waveCtx, peaks, absmax, halfH, offsetY, start, end);

          _this6.drawLineToContext(entry, entry.progressCtx, peaks, absmax, halfH, offsetY, start, end);
        });
      }
      /**
       * Render the actual waveform line on a canvas
       *
       * @private
       * @param {CanvasEntry} entry
       * @param {Canvas2DContextAttributes} ctx Essentially `entry.[wave|progress]Ctx`
       * @param {number[]} peaks
       * @param {number} absmax Maximum peak value (absolute)
       * @param {number} halfH Half the height of the waveform
       * @param {number} offsetY Offset to the top
       * @param {number} start The x-offset of the beginning of the area that
       * should be rendered
       * @param {number} end The x-offset of the end of the area that
       * should be rendered
       */

    }, {
      key: "drawLineToContext",
      value: function drawLineToContext(entry, ctx, peaks, absmax, halfH, offsetY, start, end) {
        if (!ctx) {
          return;
        }

        var length = peaks.length / 2;
        var scale = this.params.fillParent && this.width != length ? this.width / length : 1;
        var first = Math.round(length * entry.start); // Use one more peak value to make sure we join peaks at ends -- unless,
        // of course, this is the last canvas.

        var last = Math.round(length * entry.end) + 1;

        if (first > end || last < start) {
          return;
        }

        var canvasStart = Math.min(first, start);
        var canvasEnd = Math.max(last, end);
        var i;
        var j;
        ctx.beginPath();
        ctx.moveTo((canvasStart - first) * scale + this.halfPixel, halfH + offsetY);

        for (i = canvasStart; i < canvasEnd; i++) {
          var peak = peaks[2 * i] || 0;
          var h = Math.round(peak / absmax * halfH);
          ctx.lineTo((i - first) * scale + this.halfPixel, halfH - h + offsetY);
        } // Draw the bottom edge going backwards, to make a single
        // closed hull to fill.


        for (j = canvasEnd - 1; j >= canvasStart; j--) {
          var _peak = peaks[2 * j + 1] || 0;

          var _h = Math.round(_peak / absmax * halfH);

          ctx.lineTo((j - first) * scale + this.halfPixel, halfH - _h + offsetY);
        }

        ctx.closePath();
        ctx.fill();
      }
      /**
       * Draw a rectangle on the waveform
       *
       * @param {number} x
       * @param {number} y
       * @param {number} width
       * @param {number} height
       */

    }, {
      key: "fillRect",
      value: function fillRect(x, y, width, height) {
        var startCanvas = Math.floor(x / this.maxCanvasWidth);
        var endCanvas = Math.min(Math.ceil((x + width) / this.maxCanvasWidth) + 1, this.canvases.length);
        var i;

        for (i = startCanvas; i < endCanvas; i++) {
          var entry = this.canvases[i];
          var leftOffset = i * this.maxCanvasWidth;
          var intersection = {
            x1: Math.max(x, i * this.maxCanvasWidth),
            y1: y,
            x2: Math.min(x + width, i * this.maxCanvasWidth + entry.waveCtx.canvas.width),
            y2: y + height
          };

          if (intersection.x1 < intersection.x2) {
            this.setFillStyles(entry);
            this.fillRectToContext(entry.waveCtx, intersection.x1 - leftOffset, intersection.y1, intersection.x2 - intersection.x1, intersection.y2 - intersection.y1);
            this.fillRectToContext(entry.progressCtx, intersection.x1 - leftOffset, intersection.y1, intersection.x2 - intersection.x1, intersection.y2 - intersection.y1);
          }
        }
      }
      /**
       * Performs preparation tasks and calculations which are shared by drawBars and drawWave
       *
       * @private
       * @param {number[]|number[][]} peaks Can also be an array of arrays for split channel
       * rendering
       * @param {number} channelIndex The index of the current channel. Normally
       * should be 0
       * @param {number?} start The x-offset of the beginning of the area that
       * should be rendered (If this isn't set only a flat line is rendered)
       * @param {number?} end The x-offset of the end of the area that should be
       * rendered
       * @param {function} fn The render function to call
       */

    }, {
      key: "prepareDraw",
      value: function prepareDraw(peaks, channelIndex, start, end, fn) {
        var _this7 = this;

        return util.frame(function () {
          // Split channels and call this function with the channelIndex set
          if (babelHelpers.instanceof(peaks[0], Array)) {
            var channels = peaks;

            if (_this7.params.splitChannels) {
              _this7.setHeight(channels.length * _this7.params.height * _this7.params.pixelRatio);

              return channels.forEach(function (channelPeaks, i) {
                return _this7.prepareDraw(channelPeaks, i, start, end, fn);
              });
            }

            peaks = channels[0];
          } // calculate maximum modulation value, either from the barHeight
          // parameter or if normalize=true from the largest value in the peak
          // set


          var absmax = 1 / _this7.params.barHeight;

          if (_this7.params.normalize) {
            var max = util.max(peaks);
            var min = util.min(peaks);
            absmax = -min > max ? -min : max;
          } // Bar wave draws the bottom only as a reflection of the top,
          // so we don't need negative values


          var hasMinVals = [].some.call(peaks, function (val) {
            return val < 0;
          });
          var height = _this7.params.height * _this7.params.pixelRatio;
          var offsetY = height * channelIndex || 0;
          var halfH = height / 2;
          return fn({
            absmax: absmax,
            hasMinVals: hasMinVals,
            height: height,
            offsetY: offsetY,
            halfH: halfH,
            peaks: peaks
          });
        })();
      }
      /**
       * Draw the actual rectangle on a canvas
       *
       * @private
       * @param {Canvas2DContextAttributes} ctx
       * @param {number} x
       * @param {number} y
       * @param {number} width
       * @param {number} height
       */

    }, {
      key: "fillRectToContext",
      value: function fillRectToContext(ctx, x, y, width, height) {
        if (!ctx) {
          return;
        }

        ctx.fillRect(x, y, width, height);
      }
      /**
       * Set the fill styles for a certain entry (wave and progress)
       *
       * @private
       * @param {CanvasEntry} entry
       */

    }, {
      key: "setFillStyles",
      value: function setFillStyles(entry) {
        entry.waveCtx.fillStyle = this.params.waveColor;

        if (this.hasProgressCanvas) {
          entry.progressCtx.fillStyle = this.params.progressColor;
        }
      }
      /**
       * Return image data of the waveform
       *
       * @param {string} type='image/png' An optional value of a format type.
       * @param {number} quality=0.92 An optional value between 0 and 1.
       * @return {string|string[]} images A data URL or an array of data URLs
       */

    }, {
      key: "getImage",
      value: function getImage(type, quality) {
        var images = this.canvases.map(function (entry) {
          return entry.wave.toDataURL(type, quality);
        });
        return images.length > 1 ? images : images[0];
      }
      /**
       * Render the new progress
       *
       * @param {number} position X-Offset of progress position in pixels
       */

    }, {
      key: "updateProgress",
      value: function updateProgress(position) {
        this.style(this.progressWave, {
          width: position + "px"
        });
      }
    }]);
    return MultiCanvas;
  }(_drawer.default);

  _exports.default = MultiCanvas;
});