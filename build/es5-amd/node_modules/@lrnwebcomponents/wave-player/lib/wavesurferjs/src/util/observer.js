define(["exports"], function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = void 0;

  /**
   * @typedef {Object} ListenerDescriptor
   * @property {string} name The name of the event
   * @property {function} callback The callback
   * @property {function} un The function to call to remove the listener
   */

  /**
   * Observer class
   */
  var Observer = /*#__PURE__*/function () {
    /**
     * Instantiate Observer
     */
    function Observer() {
      babelHelpers.classCallCheck(this, Observer);

      /**
       * @private
       * @todo Initialise the handlers here already and remove the conditional
       * assignment in `on()`
       */
      this.handlers = null;
    }
    /**
     * Attach a handler function for an event.
     *
     * @param {string} event Name of the event to listen to
     * @param {function} fn The callback to trigger when the event is fired
     * @return {ListenerDescriptor}
     */


    babelHelpers.createClass(Observer, [{
      key: "on",
      value: function on(event, fn) {
        var _this = this;

        if (!this.handlers) {
          this.handlers = {};
        }

        var handlers = this.handlers[event];

        if (!handlers) {
          handlers = this.handlers[event] = [];
        }

        handlers.push(fn); // Return an event descriptor

        return {
          name: event,
          callback: fn,
          un: function un(e, fn) {
            return _this.un(e, fn);
          }
        };
      }
      /**
       * Remove an event handler.
       *
       * @param {string} event Name of the event the listener that should be
       * removed listens to
       * @param {function} fn The callback that should be removed
       */

    }, {
      key: "un",
      value: function un(event, fn) {
        if (!this.handlers) {
          return;
        }

        var handlers = this.handlers[event];
        var i;

        if (handlers) {
          if (fn) {
            for (i = handlers.length - 1; i >= 0; i--) {
              if (handlers[i] == fn) {
                handlers.splice(i, 1);
              }
            }
          } else {
            handlers.length = 0;
          }
        }
      }
      /**
       * Remove all event handlers.
       */

    }, {
      key: "unAll",
      value: function unAll() {
        this.handlers = null;
      }
      /**
       * Attach a handler to an event. The handler is executed at most once per
       * event type.
       *
       * @param {string} event The event to listen to
       * @param {function} handler The callback that is only to be called once
       * @return {ListenerDescriptor}
       */

    }, {
      key: "once",
      value: function once(event, handler) {
        var _this2 = this;

        var fn = function fn() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          /*  eslint-disable no-invalid-this */
          handler.apply(_this2, args);
          /*  eslint-enable no-invalid-this */

          setTimeout(function () {
            _this2.un(event, fn);
          }, 0);
        };

        return this.on(event, fn);
      }
      /**
       * Manually fire an event
       *
       * @param {string} event The event to fire manually
       * @param {...any} args The arguments with which to call the listeners
       */

    }, {
      key: "fireEvent",
      value: function fireEvent(event) {
        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }

        if (!this.handlers) {
          return;
        }

        var handlers = this.handlers[event];
        handlers && handlers.forEach(function (fn) {
          fn.apply(void 0, args);
        });
      }
    }]);
    return Observer;
  }();

  _exports.default = Observer;
});