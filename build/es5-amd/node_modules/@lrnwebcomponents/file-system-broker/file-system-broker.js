define(["exports"], function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.FileSystemBrokerSingleton = _exports.FileSystemBroker = void 0;

  function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && babelHelpers.instanceof(outerFn.prototype, Generator) ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == babelHelpers.typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  function _asyncIterator(iterable) { var method, async, sync, retry = 2; for ("undefined" != typeof Symbol && (async = Symbol.asyncIterator, sync = Symbol.iterator); retry--;) { if (async && null != (method = iterable[async])) return method.call(iterable); if (sync && null != (method = iterable[sync])) return new AsyncFromSyncIterator(method.call(iterable)); async = "@@asyncIterator", sync = "@@iterator"; } throw new TypeError("Object is not async iterable"); }

  function AsyncFromSyncIterator(s) { function AsyncFromSyncIteratorContinuation(r) { if (Object(r) !== r) return Promise.reject(new TypeError(r + " is not an object.")); var done = r.done; return Promise.resolve(r.value).then(function (value) { return { value: value, done: done }; }); } return AsyncFromSyncIterator = function AsyncFromSyncIterator(s) { this.s = s, this.n = s.next; }, AsyncFromSyncIterator.prototype = { s: null, n: null, next: function next() { return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments)); }, return: function _return(value) { var ret = this.s.return; return void 0 === ret ? Promise.resolve({ value: value, done: !0 }) : AsyncFromSyncIteratorContinuation(ret.apply(this.s, arguments)); }, throw: function _throw(value) { var thr = this.s.return; return void 0 === thr ? Promise.reject(value) : AsyncFromSyncIteratorContinuation(thr.apply(this.s, arguments)); } }, new AsyncFromSyncIterator(s); }

  /**
   * Copyright 2021 The Pennsylvania State University
   * @license Apache-2.0, see License.md for full text.
   */

  /**
   * `file-system-broker`
   * `singleton to simplify interactions with the file system on a user&#39;s device`
   *
   * @demo demo/index.html Demo
   * @demo demo/xlsx.html XLSX loader
   * @demo demo/docx.html DOCX loader
   * @element file-system-broker
   */
  var FileSystemBroker = /*#__PURE__*/function (_HTMLElement) {
    babelHelpers.inherits(FileSystemBroker, _HTMLElement);

    var _super = _createSuper(FileSystemBroker);

    /**
     * object life cycle
     */
    function FileSystemBroker() {
      var _this;

      babelHelpers.classCallCheck(this, FileSystemBroker);
      _this = _super.call(this);
      _this.dirHandler = null;
      _this.fileHandler = null;
      _this.files = [];
      return _this;
    }
    /**
     * This is a convention, not the standard
     */


    babelHelpers.createClass(FileSystemBroker, [{
      key: "loadFile",
      value:
      /**
       * Get contents of a file based on type
       * @param {String} type
       * @param {Boolean} multiple
       * @param {Boolean} excludeAll
       * @returns
       */
      function () {
        var _loadFile = babelHelpers.asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(type) {
          var multiple,
              excludeAll,
              accept,
              fileHandle,
              description,
              _yield$window$showOpe,
              _yield$window$showOpe2,
              _args = arguments;

          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  multiple = _args.length > 1 && _args[1] !== undefined ? _args[1] : false;
                  excludeAll = _args.length > 2 && _args[2] !== undefined ? _args[2] : true;
                  accept = this.typeToAccept(type);
                  description = "".concat(type, " file");
                  _context.next = 6;
                  return window.showOpenFilePicker({
                    types: [{
                      description: description,
                      accept: accept
                    }],
                    excludeAcceptAllOption: excludeAll,
                    multiple: multiple
                  });

                case 6:
                  _yield$window$showOpe = _context.sent;
                  _yield$window$showOpe2 = babelHelpers.slicedToArray(_yield$window$showOpe, 1);
                  fileHandle = _yield$window$showOpe2[0];
                  _context.next = 11;
                  return fileHandle.getFile();

                case 11:
                  this.fileHandler = _context.sent;
                  return _context.abrupt("return", this.fileHandler);

                case 13:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));

        function loadFile(_x) {
          return _loadFile.apply(this, arguments);
        }

        return loadFile;
      }()
      /**
       * Get contents of a file based on type
       * @param {String} type
       * @param {Boolean} multiple
       * @param {Boolean} excludeAll
       * @returns
       */

    }, {
      key: "getFileContents",
      value: function () {
        var _getFileContents = babelHelpers.asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(type) {
          var multiple,
              excludeAll,
              _args2 = arguments;
          return _regeneratorRuntime().wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  multiple = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : false;
                  excludeAll = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : true;
                  _context2.next = 4;
                  return this.loadFile(type, multiple, excludeAll);

                case 4:
                  _context2.next = 6;
                  return this.fileHandler.text();

                case 6:
                  return _context2.abrupt("return", _context2.sent);

                case 7:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, this);
        }));

        function getFileContents(_x2) {
          return _getFileContents.apply(this, arguments);
        }

        return getFileContents;
      }()
    }, {
      key: "typeToAccept",
      value: function typeToAccept(type) {
        var accept = {};

        switch (type) {
          case "xls":
          case "xlsx":
          case "ods":
            accept = {
              "text/csv": [".csv"],
              "application/*": [".xls", ".xlsx", ".ods"]
            };
            break;

          case "csv":
            accept = {
              "text/*": [".csv", ".txt"]
            };
            break;

          case "image":
            accept = {
              "image/*": [".jpg", ".jpeg", ".gif", ".png"]
            };
            break;

          case "video":
            accept = {
              "video/*": [".mp4"]
            };
            break;

          case "markdown":
            accept = {
              "text/*": [".txt", ".md"]
            };
            break;
        }

        return accept;
      }
    }, {
      key: "saveFile",
      value: function () {
        var _saveFile = babelHelpers.asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(type, content) {
          var accept, description, options, writable;
          return _regeneratorRuntime().wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  accept = this.typeToAccept(type);
                  description = "Save ".concat(type, " file");
                  options = {
                    types: [{
                      description: description,
                      accept: accept
                    }]
                  };
                  _context3.next = 5;
                  return window.showSaveFilePicker(options);

                case 5:
                  this.fileHandler = _context3.sent;
                  _context3.next = 8;
                  return this.fileHandler.createWritable();

                case 8:
                  writable = _context3.sent;
                  _context3.next = 11;
                  return writable.write(content);

                case 11:
                  _context3.next = 13;
                  return writable.close();

                case 13:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3, this);
        }));

        function saveFile(_x3, _x4) {
          return _saveFile.apply(this, arguments);
        }

        return saveFile;
      }()
      /**
       * Open directory
       */

    }, {
      key: "openDir",
      value: function () {
        var _openDir = babelHelpers.asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
          var recursive,
              _args4 = arguments;
          return _regeneratorRuntime().wrap(function _callee4$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  recursive = _args4.length > 0 && _args4[0] !== undefined ? _args4[0] : true;
                  _context4.prev = 1;
                  _context4.next = 4;
                  return window.showDirectoryPicker();

                case 4:
                  this.dirHandler = _context4.sent;
                  _context4.next = 10;
                  break;

                case 7:
                  _context4.prev = 7;
                  _context4.t0 = _context4["catch"](1);
                  console.log(_context4.t0);

                case 10:
                  this.files = [];
                  _context4.next = 13;
                  return this.__readDir(this.dirHandler, recursive, this.dirHandler.name || "", this.dirHandler);

                case 13:
                  this.files = _context4.sent;
                  return _context4.abrupt("return", this.files);

                case 15:
                case "end":
                  return _context4.stop();
              }
            }
          }, _callee4, this, [[1, 7]]);
        }));

        function openDir() {
          return _openDir.apply(this, arguments);
        }

        return openDir;
      }()
    }, {
      key: "readFileInDir",
      value: function () {
        var _readFileInDir = babelHelpers.asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(fileName) {
          var _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, entry, file;

          return _regeneratorRuntime().wrap(function _callee5$(_context5) {
            while (1) {
              switch (_context5.prev = _context5.next) {
                case 0:
                  _context5.prev = 0;
                  _context5.next = 3;
                  return window.showDirectoryPicker();

                case 3:
                  this.dirHandler = _context5.sent;
                  // need to load references found in the directory
                  _iteratorAbruptCompletion = false;
                  _didIteratorError = false;
                  _context5.prev = 6;
                  _iterator = _asyncIterator(this.dirHandler.values());

                case 8:
                  _context5.next = 10;
                  return _iterator.next();

                case 10:
                  if (!(_iteratorAbruptCompletion = !(_step = _context5.sent).done)) {
                    _context5.next = 22;
                    break;
                  }

                  entry = _step.value;

                  if (!(fileName && typeof entry.getFile === "function" && entry.name === fileName)) {
                    _context5.next = 19;
                    break;
                  }

                  _context5.next = 15;
                  return entry.getFile();

                case 15:
                  file = _context5.sent;
                  _context5.next = 18;
                  return file.text();

                case 18:
                  return _context5.abrupt("return", _context5.sent);

                case 19:
                  _iteratorAbruptCompletion = false;
                  _context5.next = 8;
                  break;

                case 22:
                  _context5.next = 28;
                  break;

                case 24:
                  _context5.prev = 24;
                  _context5.t0 = _context5["catch"](6);
                  _didIteratorError = true;
                  _iteratorError = _context5.t0;

                case 28:
                  _context5.prev = 28;
                  _context5.prev = 29;

                  if (!(_iteratorAbruptCompletion && _iterator.return != null)) {
                    _context5.next = 33;
                    break;
                  }

                  _context5.next = 33;
                  return _iterator.return();

                case 33:
                  _context5.prev = 33;

                  if (!_didIteratorError) {
                    _context5.next = 36;
                    break;
                  }

                  throw _iteratorError;

                case 36:
                  return _context5.finish(33);

                case 37:
                  return _context5.finish(28);

                case 38:
                  _context5.next = 43;
                  break;

                case 40:
                  _context5.prev = 40;
                  _context5.t1 = _context5["catch"](0);
                  console.log(_context5.t1);

                case 43:
                  return _context5.abrupt("return", "");

                case 44:
                case "end":
                  return _context5.stop();
              }
            }
          }, _callee5, this, [[0, 40], [6, 24, 28, 38], [29,, 33, 37]]);
        }));

        function readFileInDir(_x5) {
          return _readFileInDir.apply(this, arguments);
        }

        return readFileInDir;
      }()
    }, {
      key: "writeFileInDir",
      value: function () {
        var _writeFileInDir = babelHelpers.asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(fileName) {
          var content,
              _iteratorAbruptCompletion2,
              _didIteratorError2,
              _iteratorError2,
              _iterator2,
              _step2,
              entry,
              FileSystemFileHandle,
              writable,
              _args6 = arguments;

          return _regeneratorRuntime().wrap(function _callee6$(_context6) {
            while (1) {
              switch (_context6.prev = _context6.next) {
                case 0:
                  content = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : "";
                  _context6.prev = 1;
                  _context6.next = 4;
                  return window.showDirectoryPicker();

                case 4:
                  this.dirHandler = _context6.sent;
                  // need to load references found in the directory
                  _iteratorAbruptCompletion2 = false;
                  _didIteratorError2 = false;
                  _context6.prev = 7;
                  _iterator2 = _asyncIterator(this.dirHandler.values());

                case 9:
                  _context6.next = 11;
                  return _iterator2.next();

                case 11:
                  if (!(_iteratorAbruptCompletion2 = !(_step2 = _context6.sent).done)) {
                    _context6.next = 28;
                    break;
                  }

                  entry = _step2.value;

                  if (!(fileName && typeof entry.getFile === "function" && entry.name === fileName)) {
                    _context6.next = 25;
                    break;
                  }

                  _context6.next = 16;
                  return this.dirHandler.getFileHandle(entry.name);

                case 16:
                  FileSystemFileHandle = _context6.sent;
                  _context6.next = 19;
                  return FileSystemFileHandle.createWritable();

                case 19:
                  writable = _context6.sent;
                  _context6.next = 22;
                  return writable.write(content);

                case 22:
                  _context6.next = 24;
                  return writable.close();

                case 24:
                  return _context6.abrupt("return", true);

                case 25:
                  _iteratorAbruptCompletion2 = false;
                  _context6.next = 9;
                  break;

                case 28:
                  _context6.next = 34;
                  break;

                case 30:
                  _context6.prev = 30;
                  _context6.t0 = _context6["catch"](7);
                  _didIteratorError2 = true;
                  _iteratorError2 = _context6.t0;

                case 34:
                  _context6.prev = 34;
                  _context6.prev = 35;

                  if (!(_iteratorAbruptCompletion2 && _iterator2.return != null)) {
                    _context6.next = 39;
                    break;
                  }

                  _context6.next = 39;
                  return _iterator2.return();

                case 39:
                  _context6.prev = 39;

                  if (!_didIteratorError2) {
                    _context6.next = 42;
                    break;
                  }

                  throw _iteratorError2;

                case 42:
                  return _context6.finish(39);

                case 43:
                  return _context6.finish(34);

                case 44:
                  _context6.next = 49;
                  break;

                case 46:
                  _context6.prev = 46;
                  _context6.t1 = _context6["catch"](1);
                  console.log(_context6.t1);

                case 49:
                  return _context6.abrupt("return", false);

                case 50:
                case "end":
                  return _context6.stop();
              }
            }
          }, _callee6, this, [[1, 46], [7, 30, 34, 44], [35,, 39, 43]]);
        }));

        function writeFileInDir(_x6) {
          return _writeFileInDir.apply(this, arguments);
        }

        return writeFileInDir;
      }()
      /**
       * Read contents of a directory and recursively load down from there
       */

    }, {
      key: "__readDir",
      value: function () {
        var _readDir = babelHelpers.asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(dirHandle, recursive, folder, parentHandler) {
          var files, _iteratorAbruptCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, _step3$value, name, handle, kind;

          return _regeneratorRuntime().wrap(function _callee7$(_context7) {
            while (1) {
              switch (_context7.prev = _context7.next) {
                case 0:
                  files = [];
                  _iteratorAbruptCompletion3 = false;
                  _didIteratorError3 = false;
                  _context7.prev = 3;
                  _iterator3 = _asyncIterator(dirHandle);

                case 5:
                  _context7.next = 7;
                  return _iterator3.next();

                case 7:
                  if (!(_iteratorAbruptCompletion3 = !(_step3 = _context7.sent).done)) {
                    _context7.next = 27;
                    break;
                  }

                  _step3$value = babelHelpers.slicedToArray(_step3.value, 2), name = _step3$value[0], handle = _step3$value[1];
                  kind = handle.kind;

                  if (!(handle.kind === "directory")) {
                    _context7.next = 23;
                    break;
                  }

                  files.push({
                    name: name,
                    kind: kind,
                    handle: handle,
                    folder: folder,
                    parentHandler: parentHandler
                  });

                  if (!(name !== ".git" && recursive)) {
                    _context7.next = 21;
                    break;
                  }

                  _context7.t0 = files.push;
                  _context7.t1 = files;
                  _context7.t2 = babelHelpers;
                  _context7.next = 18;
                  return this.__readDir(handle, recursive, folder + "/" + name, handle);

                case 18:
                  _context7.t3 = _context7.sent;
                  _context7.t4 = _context7.t2.toConsumableArray.call(_context7.t2, _context7.t3);

                  _context7.t0.apply.call(_context7.t0, _context7.t1, _context7.t4);

                case 21:
                  _context7.next = 24;
                  break;

                case 23:
                  files.push({
                    name: name,
                    kind: kind,
                    handle: handle,
                    folder: folder,
                    parentHandler: parentHandler
                  });

                case 24:
                  _iteratorAbruptCompletion3 = false;
                  _context7.next = 5;
                  break;

                case 27:
                  _context7.next = 33;
                  break;

                case 29:
                  _context7.prev = 29;
                  _context7.t5 = _context7["catch"](3);
                  _didIteratorError3 = true;
                  _iteratorError3 = _context7.t5;

                case 33:
                  _context7.prev = 33;
                  _context7.prev = 34;

                  if (!(_iteratorAbruptCompletion3 && _iterator3.return != null)) {
                    _context7.next = 38;
                    break;
                  }

                  _context7.next = 38;
                  return _iterator3.return();

                case 38:
                  _context7.prev = 38;

                  if (!_didIteratorError3) {
                    _context7.next = 41;
                    break;
                  }

                  throw _iteratorError3;

                case 41:
                  return _context7.finish(38);

                case 42:
                  return _context7.finish(33);

                case 43:
                  return _context7.abrupt("return", files);

                case 44:
                case "end":
                  return _context7.stop();
              }
            }
          }, _callee7, this, [[3, 29, 33, 43], [34,, 38, 42]]);
        }));

        function __readDir(_x7, _x8, _x9, _x10) {
          return _readDir.apply(this, arguments);
        }

        return __readDir;
      }()
    }], [{
      key: "tag",
      get: function get() {
        return "file-system-broker";
      }
    }]);
    return FileSystemBroker;
  }( /*#__PURE__*/babelHelpers.wrapNativeSuper(HTMLElement)); // register globally so we can make sure there is only one


  _exports.FileSystemBroker = FileSystemBroker;
  window.FileSystemBroker = window.FileSystemBroker || {};

  window.FileSystemBroker.requestAvailability = function () {
    // if there is no single instance, generate one and append it to end of the document
    if (!window.FileSystemBroker.instance) {
      window.FileSystemBroker.instance = document.createElement("file-system-broker");
      document.body.appendChild(window.FileSystemBroker.instance);
    }

    return window.FileSystemBroker.instance;
  }; // forces appending


  var FileSystemBrokerSingleton = window.FileSystemBroker.requestAvailability();
  _exports.FileSystemBrokerSingleton = FileSystemBrokerSingleton;
  customElements.define(FileSystemBroker.tag, FileSystemBroker);
});