var assert = require("assert");

var htmlPaths = require("../lib/styles/html-paths");

var documentMatchers = require("../lib/styles/document-matchers");

var styleReader = require("../lib/style-reader");

var results = require("../lib/results");

var test = require("./test")(module);

var readHtmlPath = styleReader.readHtmlPath;
var readDocumentMatcher = styleReader.readDocumentMatcher;
var readStyle = styleReader.readStyle;
test("styleReader.readHtmlPath", {
  "reads empty path": function readsEmptyPath() {
    assertHtmlPath("", htmlPaths.empty);
  },
  "reads single element": function readsSingleElement() {
    assertHtmlPath("p", htmlPaths.elements(["p"]));
  },
  "reads choice of elements": function readsChoiceOfElements() {
    assertHtmlPath("ul|ol", htmlPaths.elements([htmlPaths.element(["ul", "ol"])]));
  },
  "reads nested elements": function readsNestedElements() {
    assertHtmlPath("ul > li", htmlPaths.elements(["ul", "li"]));
  },
  "reads class on element": function readsClassOnElement() {
    var expected = htmlPaths.elements([htmlPaths.element("p", {
      class: "tip"
    })]);
    assertHtmlPath("p.tip", expected);
  },
  "reads class with escaped colon": function readsClassWithEscapedColon() {
    var expected = htmlPaths.elements([htmlPaths.element("p", {
      class: "a:b"
    })]);
    assertHtmlPath("p.a\\:b", expected);
  },
  "reads multiple classes on element": function readsMultipleClassesOnElement() {
    var expected = htmlPaths.elements([htmlPaths.element("p", {
      class: "tip help"
    })]);
    assertHtmlPath("p.tip.help", expected);
  },
  "reads when element must be fresh": function readsWhenElementMustBeFresh() {
    var expected = htmlPaths.elements([htmlPaths.element("p", {}, {
      fresh: true
    })]);
    assertHtmlPath("p:fresh", expected);
  },
  "reads separator for elements": function readsSeparatorForElements() {
    var expected = htmlPaths.elements([htmlPaths.element("p", {}, {
      separator: "x"
    })]);
    assertHtmlPath("p:separator('x')", expected);
  },
  "reads separator with escape sequence": function readsSeparatorWithEscapeSequence() {
    var expected = htmlPaths.elements([htmlPaths.element("p", {}, {
      separator: "\r\n\t'\\"
    })]);
    assertHtmlPath("p:separator('\\r\\n\\t\\'\\\\')", expected);
  },
  "reads ignore element": function readsIgnoreElement() {
    assertHtmlPath("!", htmlPaths.ignore);
  }
});

function assertHtmlPath(input, expected) {
  assert.deepEqual(readHtmlPath(input), results.success(expected));
}

test("styleReader.readDocumentMatcher", {
  "reads plain paragraph": function readsPlainParagraph() {
    assertDocumentMatcher("p", documentMatchers.paragraph());
  },
  "reads paragraph with style ID": function readsParagraphWithStyleID() {
    assertDocumentMatcher("p.Heading1", documentMatchers.paragraph({
      styleId: "Heading1"
    }));
  },
  "reads paragraph with exact style name": function readsParagraphWithExactStyleName() {
    assertDocumentMatcher("p[style-name='Heading 1']", documentMatchers.paragraph({
      styleName: documentMatchers.equalTo("Heading 1")
    }));
  },
  "reads paragraph with style name prefix": function readsParagraphWithStyleNamePrefix() {
    assertDocumentMatcher("p[style-name^='Heading']", documentMatchers.paragraph({
      styleName: documentMatchers.startsWith("Heading")
    }));
  },
  "reads p:ordered-list(1) as ordered list with index of 0": function readsPOrderedList1AsOrderedListWithIndexOf0() {
    assertDocumentMatcher("p:ordered-list(1)", documentMatchers.paragraph({
      list: {
        isOrdered: true,
        levelIndex: 0
      }
    }));
  },
  "reads p:unordered-list(1) as unordered list with index of 0": function readsPUnorderedList1AsUnorderedListWithIndexOf0() {
    assertDocumentMatcher("p:unordered-list(1)", documentMatchers.paragraph({
      list: {
        isOrdered: false,
        levelIndex: 0
      }
    }));
  },
  "reads plain run": function readsPlainRun() {
    assertDocumentMatcher("r", documentMatchers.run());
  },
  "reads plain table": function readsPlainTable() {
    assertDocumentMatcher("table", documentMatchers.table());
  },
  "reads table with style ID": function readsTableWithStyleID() {
    assertDocumentMatcher("table.TableNormal", documentMatchers.table({
      styleId: "TableNormal"
    }));
  },
  "reads table with style name": function readsTableWithStyleName() {
    assertDocumentMatcher("table[style-name='Normal Table']", documentMatchers.table({
      styleName: documentMatchers.equalTo("Normal Table")
    }));
  },
  "reads bold": function readsBold() {
    assertDocumentMatcher("b", documentMatchers.bold);
  },
  "reads italic": function readsItalic() {
    assertDocumentMatcher("i", documentMatchers.italic);
  },
  "reads underline": function readsUnderline() {
    assertDocumentMatcher("u", documentMatchers.underline);
  },
  "reads strikethrough": function readsStrikethrough() {
    assertDocumentMatcher("strike", documentMatchers.strikethrough);
  },
  "reads all-caps": function readsAllCaps() {
    assertDocumentMatcher("all-caps", documentMatchers.allCaps);
  },
  "reads small-caps": function readsSmallCaps() {
    assertDocumentMatcher("small-caps", documentMatchers.smallCaps);
  },
  "reads comment-reference": function readsCommentReference() {
    assertDocumentMatcher("comment-reference", documentMatchers.commentReference);
  },
  "reads line breaks": function readsLineBreaks() {
    assertDocumentMatcher("br[type='line']", documentMatchers.lineBreak);
  },
  "reads page breaks": function readsPageBreaks() {
    assertDocumentMatcher("br[type='page']", documentMatchers.pageBreak);
  },
  "reads column breaks": function readsColumnBreaks() {
    assertDocumentMatcher("br[type='column']", documentMatchers.columnBreak);
  }
});

function assertDocumentMatcher(input, expected) {
  assert.deepEqual(readDocumentMatcher(input), results.success(expected));
}

test("styleReader.read", {
  "document matcher is mapped to HTML path using arrow": function documentMatcherIsMappedToHTMLPathUsingArrow() {
    assertStyleMapping("p => h1", {
      from: documentMatchers.paragraph(),
      to: htmlPaths.elements(["h1"])
    });
  },
  "reads style mapping with no HTML path": function readsStyleMappingWithNoHTMLPath() {
    assertStyleMapping("r =>", {
      from: documentMatchers.run(),
      to: htmlPaths.empty
    });
  },
  "error when not all input is consumed": function errorWhenNotAllInputIsConsumed() {
    assert.deepEqual(readStyle("r => span a"), new results.Result(null, [results.warning("Did not understand this style mapping, so ignored it: r => span a\nError was at character number 10: Expected end but got whitespace")]));
  }
});

function assertStyleMapping(input, expected) {
  assert.deepEqual(readStyle(input), results.success(expected));
}