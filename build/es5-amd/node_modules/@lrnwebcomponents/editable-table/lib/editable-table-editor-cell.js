define(["exports", "../../../@polymer/polymer/polymer-element.js", "../../../@polymer/iron-autogrow-textarea/iron-autogrow-textarea.js", "../../../@polymer/iron-a11y-keys/iron-a11y-keys.js", "./editable-table-behaviors.js"], function (_exports, _polymerElement, _ironAutogrowTextarea, _ironA11yKeys, _editableTableBehaviors) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.EditableTableEditorCell = void 0;

  function _templateObject_6720b240d34d11ea880ba1e93364c49c() {
    var data = babelHelpers.taggedTemplateLiteral(["\n      <style is=\"custom-style\">\n        :host {\n          padding: 0;\n          margin: 0;\n          width: calc(\n            100% - var(--editable-table-row-horizontal-padding) -\n              var(--editable-table-row-horizontal-padding)\n          );\n          min-width: unset;\n          display: inline-flex;\n          justify-content: space-between;\n          align-items: center;\n          align-content: stretch;\n        }\n        :host iron-autogrow-textarea {\n          width: 100%;\n          padding: 0;\n          border: none;\n          font-weight: unset;\n          resize: none;\n          -webkit-appearance: none;\n          -mozilla-appearance: none;\n          flex-grow: 1;\n          --iron-autogrow-textarea: {\n            padding: 0;\n            font-weight: unset;\n            border: none;\n            resize: none;\n            flex-direction: column;\n            -webkit-flex-direction: column;\n            -webkit-appearance: none;\n            -mozilla-appearance: none;\n          }\n        }\n        :host iron-autogrow-textarea > * {\n          padding: 0;\n          font-weight: unset;\n          border: none;\n          resize: none;\n          flex-direction: column;\n          -webkit-flex-direction: column;\n          -webkit-appearance: none;\n          -mozilla-appearance: none;\n        }\n      </style>\n      <iron-autogrow-textarea\n        autofocus\n        id=\"cell\"\n        label$=\"[[label]]\"\n        on-value-changed=\"_onValueChanged\"\n        value$=\"{{value}}\"\n      >\n      </iron-autogrow-textarea>\n      <div id=\"icons\"><slot></slot></div>\n    "]);

    _templateObject_6720b240d34d11ea880ba1e93364c49c = function _templateObject_6720b240d34d11ea880ba1e93364c49c() {
      return data;
    };

    return data;
  }

  /**
   * `editable-table-editor-cell`
   * An editable cell in the editable-table-editor (editable-table-editor.html) interface.
   *
   * @demo ./demo/editor.html
   *
   * @polymer
   * @element editable-table-editor-cell
   * @appliesMixin cellBehaviors
   */
  var EditableTableEditorCell =
  /*#__PURE__*/
  function (_cellBehaviors) {
    babelHelpers.inherits(EditableTableEditorCell, _cellBehaviors);

    function EditableTableEditorCell() {
      babelHelpers.classCallCheck(this, EditableTableEditorCell);
      return babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(EditableTableEditorCell).apply(this, arguments));
    }

    babelHelpers.createClass(EditableTableEditorCell, [{
      key: "ready",

      /**
       * Sets iron-a11y-keys target to this
       */
      value: function ready() {
        babelHelpers.get(babelHelpers.getPrototypeOf(EditableTableEditorCell.prototype), "ready", this).call(this);
        this.cell = this.shadowRoot.querySelector("#cell");
      }
      /**
       * Focuses the on text area
       */

    }, {
      key: "focus",
      value: function focus() {
        this.cell.textarea.focus();
      }
      /**
       * Gets the cell label, as in "Cell B2"
       * @param {number} column the column index
       * @param {number} row the row index
       * @returns {string} a label (eg., "Cell B2")
       */

    }, {
      key: "_getCellLabel",
      value: function _getCellLabel(column, row) {
        return this._getLabel(column, false) + this._getLabel(row, true) + "(editable table cell)";
      }
      /**
       * Fires when cell value changes to notify table
       * @event cell-value-changed
       * @param {event} e the change event
       */

    }, {
      key: "_onValueChanged",
      value: function _onValueChanged(e) {
        this.dispatchEvent(new CustomEvent("change", {
          bubbles: true,
          cancelable: true,
          composed: true,
          detail: {
            row: this.row,
            column: this.column,
            value: e.detail.value
          }
        }));
      }
      /**
       * Returns the caret (cursor) position of the specified text field.
       * FROM: https://stackoverflow.com/questions/2897155/get-cursor-position-in-characters-within-a-text-input-field
       * @returns {number} the caret position (value range is 0-oField.value.length).
       */

    }, {
      key: "getCaretPosition",
      value: function getCaretPosition() {
        var caret = 0; // IE Support

        if (document.selection) {
          // Set focus on the element
          this.shadowRoot.querySelector("#cell").focus(); // To get cursor position, get empty selection range

          var sel = document.selection.createRange(); // Move selection start to 0 position

          sel.moveStart("character", -this.shadowRoot.querySelector("#cell").value.length); // The caret position is selection length

          caret = sel.text.length;
        } else if (this.shadowRoot.querySelector("#cell").shadowRoot.querySelector("textarea").selectionStart || this.shadowRoot.querySelector("#cell").shadowRoot.querySelector("textarea").selectionStart == "0") {
          caret = this.shadowRoot.querySelector("#cell").shadowRoot.querySelector("textarea").selectionStart;
        }

        return caret;
      }
      /**
       * make sure caret is in the correct position
       * @param {number} start the start position of the caret
       * @param {number} end the start position of the caret
       */

    }, {
      key: "setCaretPosition",
      value: function setCaretPosition(start, end) {
        var textarea = this.shadowRoot.querySelector("#cell").shadowRoot.querySelector("textarea");
        textarea.focus();

        if (textarea.createTextRange) {
          var range = textarea.createTextRange();
          range.collapse(true);
          range.moveEnd("character", end);
          range.moveStart("character", start);
          range.select();
        } else if (textarea.setSelectionRange) {
          textarea.setSelectionRange(start, end);
          textarea.selectionStart = start;
          textarea.selectionEnd = end;
        }
      }
      /**
       * set focus to textarea and selects text as needed
       * @param {number} start the start position of the caret
       * @param {number} end the start position of the caret
       */

    }, {
      key: "setFocus",
      value: function setFocus(start, end) {
        this.shadowRoot.querySelector("#cell").shadowRoot.querySelector("textarea").focus();

        if (start !== undefined && end !== undefined) {
          this.setCaretPosition(start, this.getCaretPosition() - end);
        } else if (start !== undefined && start > -1) {
          this.setCaretPosition(start, start);
        } else if (start == -1 && end !== undefined) {
          this.setCaretPosition(start, this.getCaretPosition() - end);
        } else {
          this.setCaretPosition(0, 0);
        }
      }
      /**
       * fired when using keyboard to navigate left
       * @event cell-move
       */

    }, {
      key: "_onCellLeft",
      value: function _onCellLeft() {
        this.dispatchEvent(new CustomEvent("cell-move", {
          bubbles: true,
          cancelable: true,
          composed: true,
          detail: {
            cell: this.parentNode,
            direction: "left"
          }
        }));
      }
      /**
       * fired when using keyboard to navigate right
       * @event cell-move
       */

    }, {
      key: "_onCellRight",
      value: function _onCellRight() {
        this.dispatchEvent(new CustomEvent("cell-move", {
          bubbles: true,
          cancelable: true,
          composed: true,
          detail: {
            cell: this.parentNode,
            direction: "right"
          }
        }));
      }
      /**
       * fired when using keyboard to navigate up
       * @event cell-move
       */

    }, {
      key: "_onCellAbove",
      value: function _onCellAbove() {
        this.dispatchEvent(new CustomEvent("cell-move", {
          bubbles: true,
          cancelable: true,
          composed: true,
          detail: {
            cell: this.parentNode,
            direction: "up"
          }
        }));
      }
      /**
       * fired when using keyboard to navigate down
       * @event cell-move
       */

    }, {
      key: "_onCellBelow",
      value: function _onCellBelow() {
        this.dispatchEvent(new CustomEvent("cell-move", {
          bubbles: true,
          cancelable: true,
          composed: true,
          detail: {
            cell: this.parentNode,
            direction: "down"
          }
        }));
      }
    }], [{
      key: "template",
      get: function get() {
        return (0, _polymerElement.html)(_templateObject_6720b240d34d11ea880ba1e93364c49c());
      }
    }, {
      key: "tag",
      get: function get() {
        return "editable-table-editor-cell";
      }
    }, {
      key: "properties",
      get: function get() {
        return {
          /**
           * Cell row
           */
          row: {
            type: Number,
            value: null
          },

          /**
           * Cell column
           */
          column: {
            type: Number,
            value: null
          },

          /**
           * Cell label
           */
          label: {
            type: String,
            computed: "_getCellLabel(column,row)"
          },

          /**
           * Cell contents
           */
          value: {
            type: String,
            value: false
          }
        };
      }
    }]);
    return EditableTableEditorCell;
  }((0, _editableTableBehaviors.cellBehaviors)(_polymerElement.PolymerElement));

  _exports.EditableTableEditorCell = EditableTableEditorCell;
  window.customElements.define(EditableTableEditorCell.tag, EditableTableEditorCell);
});