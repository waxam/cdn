define(["exports", "../moment/constructor.js", "./from-string-and-format.js", "./parsing-flags.js", "./valid.js", "../utils/extend.js"], function (_exports, _constructor, _fromStringAndFormat, _parsingFlags, _valid, _extend) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.configFromStringAndArray = configFromStringAndArray;
  _parsingFlags = babelHelpers.interopRequireDefault(_parsingFlags);
  _extend = babelHelpers.interopRequireDefault(_extend);

  // date from string and array of format strings
  function configFromStringAndArray(config) {
    var tempConfig, bestMoment, scoreToBeat, i, currentScore;

    if (config._f.length === 0) {
      (0, _parsingFlags.default)(config).invalidFormat = true;
      config._d = new Date(NaN);
      return;
    }

    for (i = 0; i < config._f.length; i++) {
      currentScore = 0;
      tempConfig = (0, _constructor.copyConfig)({}, config);

      if (config._useUTC != null) {
        tempConfig._useUTC = config._useUTC;
      }

      tempConfig._f = config._f[i];
      (0, _fromStringAndFormat.configFromStringAndFormat)(tempConfig);

      if (!(0, _valid.isValid)(tempConfig)) {
        continue;
      } // if there is any input that was not parsed add a penalty for that format


      currentScore += (0, _parsingFlags.default)(tempConfig).charsLeftOver; //or tokens

      currentScore += (0, _parsingFlags.default)(tempConfig).unusedTokens.length * 10;
      (0, _parsingFlags.default)(tempConfig).score = currentScore;

      if (scoreToBeat == null || currentScore < scoreToBeat) {
        scoreToBeat = currentScore;
        bestMoment = tempConfig;
      }
    }

    (0, _extend.default)(config, bestMoment || tempConfig);
  }
});