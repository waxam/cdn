define(["exports", "../utils/hooks.js", "./date-from-array.js", "../units/year.js", "../units/week-calendar-utils.js", "../units/constants.js", "./local.js", "../utils/defaults.js", "./parsing-flags.js"], function (_exports, _hooks, _dateFromArray, _year, _weekCalendarUtils, _constants, _local, _defaults, _parsingFlags) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.configFromArray = configFromArray;
  _defaults = babelHelpers.interopRequireDefault(_defaults);
  _parsingFlags = babelHelpers.interopRequireDefault(_parsingFlags);

  function currentDateArray(config) {
    // hooks is actually the exported moment object
    var nowValue = new Date(_hooks.hooks.now());

    if (config._useUTC) {
      return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
    }

    return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
  } // convert an array to a date.
  // the array should mirror the parameters below
  // note: all values past the year are optional and will default to the lowest possible value.
  // [year, month, day , hour, minute, second, millisecond]


  function configFromArray(config) {
    var i,
        date,
        input = [],
        currentDate,
        expectedWeekday,
        yearToUse;

    if (config._d) {
      return;
    }

    currentDate = currentDateArray(config); //compute day of the year from weeks and weekdays

    if (config._w && config._a[_constants.DATE] == null && config._a[_constants.MONTH] == null) {
      dayOfYearFromWeekInfo(config);
    } //if the day of the year is set, figure out what it is


    if (config._dayOfYear != null) {
      yearToUse = (0, _defaults.default)(config._a[_constants.YEAR], currentDate[_constants.YEAR]);

      if (config._dayOfYear > (0, _year.daysInYear)(yearToUse) || config._dayOfYear === 0) {
        (0, _parsingFlags.default)(config)._overflowDayOfYear = true;
      }

      date = (0, _dateFromArray.createUTCDate)(yearToUse, 0, config._dayOfYear);
      config._a[_constants.MONTH] = date.getUTCMonth();
      config._a[_constants.DATE] = date.getUTCDate();
    } // Default to current date.
    // * if no year, month, day of month are given, default to today
    // * if day of month is given, default month and year
    // * if month is given, default only year
    // * if year is given, don't default anything


    for (i = 0; i < 3 && config._a[i] == null; ++i) {
      config._a[i] = input[i] = currentDate[i];
    } // Zero out whatever was not defaulted, including time


    for (; i < 7; i++) {
      config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
    } // Check for 24:00:00.000


    if (config._a[_constants.HOUR] === 24 && config._a[_constants.MINUTE] === 0 && config._a[_constants.SECOND] === 0 && config._a[_constants.MILLISECOND] === 0) {
      config._nextDay = true;
      config._a[_constants.HOUR] = 0;
    }

    config._d = (config._useUTC ? _dateFromArray.createUTCDate : _dateFromArray.createDate).apply(null, input);
    expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay(); // Apply timezone offset from input. The actual utcOffset can be changed
    // with parseZone.

    if (config._tzm != null) {
      config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
    }

    if (config._nextDay) {
      config._a[_constants.HOUR] = 24;
    } // check for mismatching day of week


    if (config._w && typeof config._w.d !== "undefined" && config._w.d !== expectedWeekday) {
      (0, _parsingFlags.default)(config).weekdayMismatch = true;
    }
  }

  function dayOfYearFromWeekInfo(config) {
    var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;
    w = config._w;

    if (w.GG != null || w.W != null || w.E != null) {
      dow = 1;
      doy = 4; // TODO: We need to take the current isoWeekYear, but that depends on
      // how we interpret now (local, utc, fixed offset). So create
      // a now version of current config (take local/utc/offset flags, and
      // create now).

      weekYear = (0, _defaults.default)(w.GG, config._a[_constants.YEAR], (0, _weekCalendarUtils.weekOfYear)((0, _local.createLocal)(), 1, 4).year);
      week = (0, _defaults.default)(w.W, 1);
      weekday = (0, _defaults.default)(w.E, 1);

      if (weekday < 1 || weekday > 7) {
        weekdayOverflow = true;
      }
    } else {
      dow = config._locale._week.dow;
      doy = config._locale._week.doy;
      var curWeek = (0, _weekCalendarUtils.weekOfYear)((0, _local.createLocal)(), dow, doy);
      weekYear = (0, _defaults.default)(w.gg, config._a[_constants.YEAR], curWeek.year); // Default to current week.

      week = (0, _defaults.default)(w.w, curWeek.week);

      if (w.d != null) {
        // weekday -- low day numbers are considered next week
        weekday = w.d;

        if (weekday < 0 || weekday > 6) {
          weekdayOverflow = true;
        }
      } else if (w.e != null) {
        // local weekday -- counting starts from begining of week
        weekday = w.e + dow;

        if (w.e < 0 || w.e > 6) {
          weekdayOverflow = true;
        }
      } else {
        // default to begining of week
        weekday = dow;
      }
    }

    if (week < 1 || week > (0, _weekCalendarUtils.weeksInYear)(weekYear, dow, doy)) {
      (0, _parsingFlags.default)(config)._overflowWeeks = true;
    } else if (weekdayOverflow != null) {
      (0, _parsingFlags.default)(config)._overflowWeekday = true;
    } else {
      temp = (0, _weekCalendarUtils.dayOfYearFromWeeks)(weekYear, week, weekday, dow, doy);
      config._a[_constants.YEAR] = temp.year;
      config._dayOfYear = temp.dayOfYear;
    }
  }
});