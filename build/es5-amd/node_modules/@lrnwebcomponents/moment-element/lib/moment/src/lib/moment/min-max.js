define(["exports", "../utils/deprecate.js", "../utils/is-array.js", "../create/local.js", "../create/valid.js"], function (_exports, _deprecate, _isArray, _local, _valid) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.max = max;
  _exports.min = min;
  _exports.prototypeMin = _exports.prototypeMax = void 0;
  _isArray = babelHelpers.interopRequireDefault(_isArray);
  var prototypeMin = (0, _deprecate.deprecate)("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/", function () {
    var other = _local.createLocal.apply(null, arguments);

    if (this.isValid() && other.isValid()) {
      return other < this ? this : other;
    } else {
      return (0, _valid.createInvalid)();
    }
  });
  _exports.prototypeMin = prototypeMin;
  var prototypeMax = (0, _deprecate.deprecate)("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/", function () {
    var other = _local.createLocal.apply(null, arguments);

    if (this.isValid() && other.isValid()) {
      return other > this ? this : other;
    } else {
      return (0, _valid.createInvalid)();
    }
  }); // Pick a moment m from moments so that m[fn](other) is true for all
  // other. This relies on the function fn to be transitive.
  //
  // moments should either be an array of moment objects or an array, whose
  // first element is an array of moment objects.

  _exports.prototypeMax = prototypeMax;

  function pickBy(fn, moments) {
    var res, i;

    if (moments.length === 1 && (0, _isArray.default)(moments[0])) {
      moments = moments[0];
    }

    if (!moments.length) {
      return (0, _local.createLocal)();
    }

    res = moments[0];

    for (i = 1; i < moments.length; ++i) {
      if (!moments[i].isValid() || moments[i][fn](res)) {
        res = moments[i];
      }
    }

    return res;
  } // TODO: Use [].sort instead?


  function min() {
    var args = [].slice.call(arguments, 0);
    return pickBy("isBefore", args);
  }

  function max() {
    var args = [].slice.call(arguments, 0);
    return pickBy("isAfter", args);
  }
});