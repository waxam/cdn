define(["exports", "../utils/zero-fill.js", "../duration/create.js", "../moment/add-subtract.js", "../moment/constructor.js", "../format/format.js", "../parse/regex.js", "../parse/token.js", "../create/local.js", "../create/from-anything.js", "../create/utc.js", "../utils/is-date.js", "../utils/to-int.js", "../utils/is-undefined.js", "../utils/compare-arrays.js", "../utils/hooks.js"], function (_exports, _zeroFill, _create, _addSubtract, _constructor, _format, _regex, _token, _local, _fromAnything, _utc, _isDate, _toInt, _isUndefined, _compareArrays, _hooks) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.cloneWithOffset = cloneWithOffset;
  _exports.getSetOffset = getSetOffset;
  _exports.getSetZone = getSetZone;
  _exports.hasAlignedHourOffset = hasAlignedHourOffset;
  _exports.isDaylightSavingTime = isDaylightSavingTime;
  _exports.isDaylightSavingTimeShifted = isDaylightSavingTimeShifted;
  _exports.isLocal = isLocal;
  _exports.isUtc = isUtc;
  _exports.isUtcOffset = isUtcOffset;
  _exports.setOffsetToLocal = setOffsetToLocal;
  _exports.setOffsetToParsedOffset = setOffsetToParsedOffset;
  _exports.setOffsetToUTC = setOffsetToUTC;
  _zeroFill = babelHelpers.interopRequireDefault(_zeroFill);
  _isDate = babelHelpers.interopRequireDefault(_isDate);
  _toInt = babelHelpers.interopRequireDefault(_toInt);
  _isUndefined = babelHelpers.interopRequireDefault(_isUndefined);
  _compareArrays = babelHelpers.interopRequireDefault(_compareArrays);

  // FORMATTING
  function offset(token, separator) {
    (0, _format.addFormatToken)(token, 0, 0, function () {
      var offset = this.utcOffset();
      var sign = "+";

      if (offset < 0) {
        offset = -offset;
        sign = "-";
      }

      return sign + (0, _zeroFill.default)(~~(offset / 60), 2) + separator + (0, _zeroFill.default)(~~offset % 60, 2);
    });
  }

  offset("Z", ":");
  offset("ZZ", ""); // PARSING

  (0, _regex.addRegexToken)("Z", _regex.matchShortOffset);
  (0, _regex.addRegexToken)("ZZ", _regex.matchShortOffset);
  (0, _token.addParseToken)(["Z", "ZZ"], function (input, array, config) {
    config._useUTC = true;
    config._tzm = offsetFromString(_regex.matchShortOffset, input);
  }); // HELPERS
  // timezone chunker
  // '+10:00' > ['10',  '00']
  // '-1530'  > ['-15', '30']

  var chunkOffset = /([\+\-]|\d\d)/gi;

  function offsetFromString(matcher, string) {
    var matches = (string || "").match(matcher);

    if (matches === null) {
      return null;
    }

    var chunk = matches[matches.length - 1] || [];
    var parts = (chunk + "").match(chunkOffset) || ["-", 0, 0];
    var minutes = +(parts[1] * 60) + (0, _toInt.default)(parts[2]);
    return minutes === 0 ? 0 : parts[0] === "+" ? minutes : -minutes;
  } // Return a moment from input, that is local/utc/zone equivalent to model.


  function cloneWithOffset(input, model) {
    var res, diff;

    if (model._isUTC) {
      res = model.clone();
      diff = ((0, _constructor.isMoment)(input) || (0, _isDate.default)(input) ? input.valueOf() : (0, _local.createLocal)(input).valueOf()) - res.valueOf(); // Use low-level api, because this fn is low-level api.

      res._d.setTime(res._d.valueOf() + diff);

      _hooks.hooks.updateOffset(res, false);

      return res;
    } else {
      return (0, _local.createLocal)(input).local();
    }
  }

  function getDateOffset(m) {
    // On Firefox.24 Date#getTimezoneOffset returns a floating point.
    // https://github.com/moment/moment/pull/1871
    return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
  } // HOOKS
  // This function will be called whenever a moment is mutated.
  // It is intended to keep the offset in sync with the timezone.


  _hooks.hooks.updateOffset = function () {}; // MOMENTS
  // keepLocalTime = true means only change the timezone, without
  // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
  // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
  // +0200, so we adjust the time as needed, to be valid.
  //
  // Keeping the time actually adds/subtracts (one hour)
  // from the actual represented time. That is why we call updateOffset
  // a second time. In case it wants us to change the offset again
  // _changeInProgress == true case, then we have to adjust, because
  // there is no such time in the given timezone.


  function getSetOffset(input, keepLocalTime, keepMinutes) {
    var offset = this._offset || 0,
        localAdjust;

    if (!this.isValid()) {
      return input != null ? this : NaN;
    }

    if (input != null) {
      if (typeof input === "string") {
        input = offsetFromString(_regex.matchShortOffset, input);

        if (input === null) {
          return this;
        }
      } else if (Math.abs(input) < 16 && !keepMinutes) {
        input = input * 60;
      }

      if (!this._isUTC && keepLocalTime) {
        localAdjust = getDateOffset(this);
      }

      this._offset = input;
      this._isUTC = true;

      if (localAdjust != null) {
        this.add(localAdjust, "m");
      }

      if (offset !== input) {
        if (!keepLocalTime || this._changeInProgress) {
          (0, _addSubtract.addSubtract)(this, (0, _create.createDuration)(input - offset, "m"), 1, false);
        } else if (!this._changeInProgress) {
          this._changeInProgress = true;

          _hooks.hooks.updateOffset(this, true);

          this._changeInProgress = null;
        }
      }

      return this;
    } else {
      return this._isUTC ? offset : getDateOffset(this);
    }
  }

  function getSetZone(input, keepLocalTime) {
    if (input != null) {
      if (typeof input !== "string") {
        input = -input;
      }

      this.utcOffset(input, keepLocalTime);
      return this;
    } else {
      return -this.utcOffset();
    }
  }

  function setOffsetToUTC(keepLocalTime) {
    return this.utcOffset(0, keepLocalTime);
  }

  function setOffsetToLocal(keepLocalTime) {
    if (this._isUTC) {
      this.utcOffset(0, keepLocalTime);
      this._isUTC = false;

      if (keepLocalTime) {
        this.subtract(getDateOffset(this), "m");
      }
    }

    return this;
  }

  function setOffsetToParsedOffset() {
    if (this._tzm != null) {
      this.utcOffset(this._tzm, false, true);
    } else if (typeof this._i === "string") {
      var tZone = offsetFromString(_regex.matchOffset, this._i);

      if (tZone != null) {
        this.utcOffset(tZone);
      } else {
        this.utcOffset(0, true);
      }
    }

    return this;
  }

  function hasAlignedHourOffset(input) {
    if (!this.isValid()) {
      return false;
    }

    input = input ? (0, _local.createLocal)(input).utcOffset() : 0;
    return (this.utcOffset() - input) % 60 === 0;
  }

  function isDaylightSavingTime() {
    return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
  }

  function isDaylightSavingTimeShifted() {
    if (!(0, _isUndefined.default)(this._isDSTShifted)) {
      return this._isDSTShifted;
    }

    var c = {};
    (0, _constructor.copyConfig)(c, this);
    c = (0, _fromAnything.prepareConfig)(c);

    if (c._a) {
      var other = c._isUTC ? (0, _utc.createUTC)(c._a) : (0, _local.createLocal)(c._a);
      this._isDSTShifted = this.isValid() && (0, _compareArrays.default)(c._a, other.toArray()) > 0;
    } else {
      this._isDSTShifted = false;
    }

    return this._isDSTShifted;
  }

  function isLocal() {
    return this.isValid() ? !this._isUTC : false;
  }

  function isUtcOffset() {
    return this.isValid() ? this._isUTC : false;
  }

  function isUtc() {
    return this.isValid() ? this._isUTC && this._offset === 0 : false;
  }
});