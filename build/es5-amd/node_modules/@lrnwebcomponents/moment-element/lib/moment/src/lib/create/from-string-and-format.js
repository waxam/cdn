define(["exports", "./from-string.js", "./from-array.js", "../parse/regex.js", "../parse/token.js", "../format/format.js", "./check-overflow.js", "../units/constants.js", "../utils/hooks.js", "./parsing-flags.js"], function (_exports, _fromString, _fromArray, _regex, _token, _format, _checkOverflow, _constants, _hooks, _parsingFlags) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.configFromStringAndFormat = configFromStringAndFormat;
  _checkOverflow = babelHelpers.interopRequireDefault(_checkOverflow);
  _parsingFlags = babelHelpers.interopRequireDefault(_parsingFlags);

  // constant that refers to the ISO standard
  _hooks.hooks.ISO_8601 = function () {}; // constant that refers to the RFC 2822 form


  _hooks.hooks.RFC_2822 = function () {}; // date from string and format string


  function configFromStringAndFormat(config) {
    // TODO: Move this to another part of the creation flow to prevent circular deps
    if (config._f === _hooks.hooks.ISO_8601) {
      (0, _fromString.configFromISO)(config);
      return;
    }

    if (config._f === _hooks.hooks.RFC_2822) {
      (0, _fromString.configFromRFC2822)(config);
      return;
    }

    config._a = [];
    (0, _parsingFlags.default)(config).empty = true; // This array is used to make a Date, either with `new Date` or `Date.UTC`

    var string = "" + config._i,
        i,
        parsedInput,
        tokens,
        token,
        skipped,
        stringLength = string.length,
        totalParsedInputLength = 0;
    tokens = (0, _format.expandFormat)(config._f, config._locale).match(_format.formattingTokens) || [];

    for (i = 0; i < tokens.length; i++) {
      token = tokens[i];
      parsedInput = (string.match((0, _regex.getParseRegexForToken)(token, config)) || [])[0]; // console.log('token', token, 'parsedInput', parsedInput,
      //         'regex', getParseRegexForToken(token, config));

      if (parsedInput) {
        skipped = string.substr(0, string.indexOf(parsedInput));

        if (skipped.length > 0) {
          (0, _parsingFlags.default)(config).unusedInput.push(skipped);
        }

        string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
        totalParsedInputLength += parsedInput.length;
      } // don't parse if it's not a known token


      if (_format.formatTokenFunctions[token]) {
        if (parsedInput) {
          (0, _parsingFlags.default)(config).empty = false;
        } else {
          (0, _parsingFlags.default)(config).unusedTokens.push(token);
        }

        (0, _token.addTimeToArrayFromToken)(token, parsedInput, config);
      } else if (config._strict && !parsedInput) {
        (0, _parsingFlags.default)(config).unusedTokens.push(token);
      }
    } // add remaining unparsed input length to the string


    (0, _parsingFlags.default)(config).charsLeftOver = stringLength - totalParsedInputLength;

    if (string.length > 0) {
      (0, _parsingFlags.default)(config).unusedInput.push(string);
    } // clear _12h flag if hour is <= 12


    if (config._a[_constants.HOUR] <= 12 && (0, _parsingFlags.default)(config).bigHour === true && config._a[_constants.HOUR] > 0) {
      (0, _parsingFlags.default)(config).bigHour = undefined;
    }

    (0, _parsingFlags.default)(config).parsedDateParts = config._a.slice(0);
    (0, _parsingFlags.default)(config).meridiem = config._meridiem; // handle meridiem

    config._a[_constants.HOUR] = meridiemFixWrap(config._locale, config._a[_constants.HOUR], config._meridiem);
    (0, _fromArray.configFromArray)(config);
    (0, _checkOverflow.default)(config);
  }

  function meridiemFixWrap(locale, hour, meridiem) {
    var isPm;

    if (meridiem == null) {
      // nothing to do
      return hour;
    }

    if (locale.meridiemHour != null) {
      return locale.meridiemHour(hour, meridiem);
    } else if (locale.isPM != null) {
      // Fallback
      isPm = locale.isPM(meridiem);

      if (isPm && hour < 12) {
        hour += 12;
      }

      if (!isPm && hour === 12) {
        hour = 0;
      }

      return hour;
    } else {
      // this is not supposed to happen
      return hour;
    }
  }
});