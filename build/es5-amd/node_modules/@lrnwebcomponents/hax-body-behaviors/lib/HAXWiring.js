define(["exports","meta","require","../../simple-fields/simple-fields.js"],function(_exports,meta,_require,_simpleFields){"use strict";Object.defineProperty(_exports,"__esModule",{value:!0});_exports.HAXElement=_exports.HAXWiring=void 0;meta=babelHelpers.interopRequireWildcard(meta);_require=babelHelpers.interopRequireWildcard(_require);function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);if(enumerableOnly)symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable});keys.push.apply(keys,symbols)}return keys}function _objectSpread(target){for(var i=1,source;i<arguments.length;i++){source=null!=arguments[i]?arguments[i]:{};if(i%2){ownKeys(Object(source),!0).forEach(function(key){babelHelpers.defineProperty(target,key,source[key])})}else if(Object.getOwnPropertyDescriptors){Object.defineProperties(target,Object.getOwnPropertyDescriptors(source))}else{ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key))})}}return target}/**
 * Object to validate HAX schema. Can be used in and out of element contexts
 */var HAXWiring=function HAXWiring(){var _this=this;babelHelpers.classCallCheck(this,HAXWiring);/**
     * haxProperties
     */this.haxProperties={canScale:!1,canPosition:!1,canEditSource:!1,settings:{quick:[],configure:[],advanced:[]},wipeSlot:{}};this.pathFromUrl=function(url){return url.substring(0,url.lastIndexOf("/")+1)};/**
     * Setter to bridge private haxProperties setter.
     * This is to then be implemented by the ready state of whatever is supplying the
     * properties in order to be able to bubble up the properties for a tag.
     */this.setup=function(props){var tag=1<arguments.length&&arguments[1]!==void 0?arguments[1]:"",context=2<arguments.length&&arguments[2]!==void 0?arguments[2]:_this;if(babelHelpers.typeof(_this.tagName)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){tag=_this.tagName.toLowerCase()}window.addEventListener("hax-store-ready",_this._haxStoreReady.bind(_this));if(babelHelpers.typeof(window.HaxStore)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))&&null!=window.HaxStore.instance&&window.HaxStore.ready){return _this.setHaxProperties(props,tag,context,!0)}else{return _this.setHaxProperties(props,tag,context,!1)}};/**
     * HAX store is ready so now we can fire events
     */this._haxStoreReady=function(e){if(e.detail&&babelHelpers.typeof(_this.tagName)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))&&babelHelpers.typeof(_this.haxProperties)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){var tag=_this.tagName,props=_this.haxProperties,context=_this;if(""!=tag&&babelHelpers.typeof(window.HaxStore)===("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){var evt=new CustomEvent("hax-register-properties",{bubbles:!0,composed:!0,cancelable:!0,detail:{tag:tag.toLowerCase(),properties:props,polymer:!1}});context.dispatchEvent(evt)}else if(""!=tag&&babelHelpers.typeof(window.HaxStore.instance.elementList[tag.toLowerCase()])===("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){var _evt=new CustomEvent("hax-register-properties",{bubbles:!0,composed:!0,cancelable:!0,detail:{tag:tag.toLowerCase(),properties:props}});context.dispatchEvent(_evt)}else if(babelHelpers.typeof(_this.tagName)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))&&babelHelpers.typeof(window.HaxStore.instance.elementList[_this.tagName.toLowerCase()])===("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){var _evt2=new CustomEvent("hax-register-properties",{bubbles:!0,composed:!0,cancelable:!0,detail:{tag:_this.tagName.toLowerCase(),properties:props}});context.dispatchEvent(_evt2)}}};/**
     * Setter to bridge private haxProperties setter.
     * This is to then be implemented by the ready state of whatever is supplying the
     * properties in order to be able to bubble up the properties for a tag.
     */this.setHaxProperties=function(){var props=0<arguments.length&&arguments[0]!==void 0?arguments[0]:{},tag=1<arguments.length&&arguments[1]!==void 0?arguments[1]:"",context=2<arguments.length&&arguments[2]!==void 0?arguments[2]:document,isReady=3<arguments.length&&arguments[3]!==void 0?arguments[3]:!1;// these are a core piece of hax capabilities
// set them in the event this got called without anything
// so we at least won't bomb
if(babelHelpers.typeof(props.api)===("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){props.api="1"}// sets us up for future API versioning of property validation
// and clean up.
if("1"==props.api){if(babelHelpers.typeof(props.canPosition)===("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){props.canPosition=!0}if(babelHelpers.typeof(props.canScale)===("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){props.canScale=!0}if(babelHelpers.typeof(props.canEditSource)===("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){props.canEditSource=!1}if(babelHelpers.typeof(props.gizmo)===("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){props.gizmo=!1}else{// support possible dynamic import of iconset
// this would be if the user defined their own icons
if(babelHelpers.typeof(props.gizmo.iconLib)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){var basePath=_this.pathFromUrl(decodeURIComponent(meta.url));new Promise(function(res,rej){return _require.default(["".concat(basePath,"../../../").concat(props.gizmo.iconLib)],res,rej)})}}// while not required, this is where all the raw power of this
// approach really lies since this wires properties/slots to HAX's
// ability to manipulate things via contextual menus
if(babelHelpers.typeof(props.settings)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){// loop through any potential settings in each of the three
// groupings of possible settings and validate that each setting is accurate
if(babelHelpers.typeof(props.settings.quick)===("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){props.settings.quick=[]}for(var i=0;i<props.settings.quick.length;i++){props.settings.quick[i]=_this.validateSetting(props.settings.quick[i]);// account for a bad property and remove it
if(!props.settings.quick[i]){props.settings.quick.splice(i,1)}}if(babelHelpers.typeof(props.settings.configure)===("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){props.settings.configure=[]}for(var _i=0;_i<props.settings.configure.length;_i++){props.settings.configure[_i]=_this.validateSetting(props.settings.configure[_i]);if(!props.settings.configure[_i]){props.settings.configure.splice(_i,1)}}if(babelHelpers.typeof(props.settings.advanced)===("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){props.settings.advanced=[]}for(var _i2=0;_i2<props.settings.advanced.length;_i2++){props.settings.advanced[_i2]=_this.validateSetting(props.settings.advanced[_i2]);if(!props.settings.advanced[_i2]){props.settings.advanced.splice(_i2,1)}}props=_this.standardAdvancedProps(props)}// support for advanced save options
if(babelHelpers.typeof(props.saveOptions)===("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){props.saveOptions={wipeSlot:!1}}// fire event so we know they have been set for the store to collect
// only fire if we haven't already so multiple elements don't keep bubbling
// if there's no global HaxStore then this means it is a custom
// implementation of the schema
if(isReady){_this.readyToFireHAXSchema(tag,props,context)}// only set these when tag hasn't been force fed
if(""===tag){if("function"===typeof _this._setHaxProperties){_this._setHaxProperties(props)}else{_this.haxProperties=props}}}else{// especially useful during development if we implement our own API
// incorrectly. Don't hard brick cause it'll still more or less work
// but would probably default to an iframe which is less then ideal
// but at least wouldn't brick the AX.
console.warn("This is't a valid usage of hax API. See hax-body-behaviors/lib/HAXWiring.js for more details on how to implement the API. https://haxtheweb.org/hax-schema for details but we will try and guess the wiring")}};this.readyToFireHAXSchema=function(tag,props,context){if(""!=tag&&babelHelpers.typeof(window.HaxStore)===("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){var evt=new CustomEvent("hax-register-properties",{bubbles:!0,composed:!0,cancelable:!0,detail:{tag:tag.toLowerCase(),properties:props,polymer:!1}});context.dispatchEvent(evt)}else if(""!=tag){var _evt3=new CustomEvent("hax-register-properties",{bubbles:!0,composed:!0,cancelable:!0,detail:{tag:tag.toLowerCase(),properties:props}});context.dispatchEvent(_evt3)}else if(babelHelpers.typeof(_this.tagName)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){var _evt4=new CustomEvent("hax-register-properties",{bubbles:!0,composed:!0,cancelable:!0,detail:{tag:_this.tagName.toLowerCase(),properties:props}});context.dispatchEvent(_evt4)}else{console.warn("".concat(tag," missed our checks and has an issue in implementation with HAX"))}};/**
     * Standard advanced properties we support for all forms
     */this.standardAdvancedProps=function(props){// allow classes to be modified this way
props.settings.advanced.push({attribute:"class",title:"Classes",description:"CSS classes applied manually to the element",inputMethod:"textfield"});// allow styles to be modified this way
props.settings.advanced.push({attribute:"style",title:"Styles",description:"Custom CSS styles as applied to the element",inputMethod:"textfield"});// allow schema definitions
props.settings.advanced.push({attribute:"prefix",title:"Schema: prefix",description:"Schema prefixes",inputMethod:"textfield"});props.settings.advanced.push({attribute:"typeof",title:"Schema: TypeOf",description:"typeof definition for Schema usage",inputMethod:"textfield"});props.settings.advanced.push({attribute:"property",title:"Schema: Property",description:"typeof definition for Schema usage",inputMethod:"textfield"});props.settings.advanced.push({attribute:"resource",title:"Schema: Resource ID",description:"Schema resource identifier",inputMethod:"textfield"});// allow the id to be modified
props.settings.advanced.push({attribute:"id",title:"ID",description:"element ID, only set this if you know why",inputMethod:"textfield"});// we need to support slot in the UI but actually shift it around under the hood
// this is so that shadow roots don't get mad when previewing
props.settings.advanced.push({attribute:"slot",title:"slot",description:"DOM slot area",inputMethod:"textfield"});return props};/**
     * Validate settings object.
     */this.validateSetting=function(setting){// we don't have a property or slot so it's not valid.
if(babelHelpers.typeof(setting.property)===("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))&&babelHelpers.typeof(setting.slot)===("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))&&babelHelpers.typeof(setting.attribute)===("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){return!1}// ensure there's a title
if(babelHelpers.typeof(setting.title)===("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){if(babelHelpers.typeof(setting.attribute)===("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){setting.title=setting.property}else{setting.title=setting.attribute}}// ensure there's at least an empty description
if(babelHelpers.typeof(setting.description)===("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){setting.description=""}// ensure there's at least an input method
if(babelHelpers.typeof(setting.inputMethod)===("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){setting.inputMethod="textfield"}// ensure there's at least a type
if(babelHelpers.typeof(setting.type)===("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){setting.type="settings"}// ensure there's at least an icon
if(babelHelpers.typeof(setting.icon)===("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){setting.icon="android"}// ensure there's at least an empty options area
if(babelHelpers.typeof(setting.options)===("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){setting.options={}}// ensure there's required set
if(babelHelpers.typeof(setting.required)===("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){setting.required=!1}// ensure there's required set
if(babelHelpers.typeof(setting.disabled)===("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){setting.disabled=!1}// ensure there's validation or make it anything if none set
if(babelHelpers.typeof(setting.validation)===("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){setting.validation=".*"}// ensure there's validation or make it anything if none set
if(babelHelpers.typeof(setting.validationType)===("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){setting.validationType=""}// slot can have a slot wrapper property
if(babelHelpers.typeof(setting.slot)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){if(babelHelpers.typeof(setting.slotWrapper)===("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){setting.slotWrapper="span"}if(babelHelpers.typeof(setting.slotAttributes)===("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){setting.slotAttributes={}}}return setting};/**
     * Match convention for set.
     */this.getHaxProperties=function(){return _this.haxProperties};/**
     * Convert haxProperties structure to a simple json-schema.
     * This allows for complex form building systems based on this data.
     * type is configure or advanced
     */this.getHaxJSONSchema=function(type,haxProperties){var target=2<arguments.length&&arguments[2]!==void 0?arguments[2]:_this;if(babelHelpers.typeof(type)===("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){type="configure"}if(babelHelpers.typeof(haxProperties)===("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){haxProperties=target.haxProperties}var settings=haxProperties.settings[type],schema={$schema:"http://json-schema.org/schema#",title:"HAX "+type+" form schema",type:"object",properties:{}};schema.properties=_simpleFields.SimpleFields.fieldsToSchema(settings);// support post processing of schema in order to allow for really
// custom implementations that are highly dynamic in nature
// post process hook needs to see if there's a class overriding this
// if we have a definition for this component then we should run its postProcess
// just to be safe
if(haxProperties.gizmo&&haxProperties.gizmo.tag&&window.customElements.get(haxProperties.gizmo.tag)){var tmp=document.createElement(haxProperties.gizmo.tag);if("function"===typeof tmp.postProcessgetHaxJSONSchema){schema=tmp.postProcessgetHaxJSONSchema(schema)}else{schema=target.postProcessgetHaxJSONSchema(schema)}}else{schema=target.postProcessgetHaxJSONSchema(schema)}return schema};/**
     * Default postProcessgetHaxJSONSchema to be overridden.
     */this.postProcessgetHaxJSONSchema=function(schema){return schema};/**
     * Internal helper for getHaxJSONSchema to buiild the properties object
     * correctly with support for recursive nesting thx to objects / arrays.
     */this._getHaxJSONSchemaProperty=function(settings){return _simpleFields.SimpleFields.fieldsToSchema(settings)};/**
     * Convert input method to schema type
     */this.getHaxJSONSchemaType=function(inputMethod){var method=_simpleFields.SimpleFields.fieldsConversion.inputMethod[inputMethod]||_simpleFields.SimpleFields.fieldsConversion;return method&&method.defaultSettings&&method.defaultSettings.type?method.defaultSettings.type:"string"};/**
     * List valid input methods.
     */this.validHAXPropertyInputMethod=function(){var methods=Object.keys(_simpleFields.SimpleFields.fieldsConversion.inputMethod);return methods};/**
     * Return a haxProperties prototype / example structure
     */this.prototypeHaxProperties=function(){// example properties valid for HAX context menu.
var props={api:"1",canScale:!0,canPosition:!0,canEditSource:!1,gizmo:{title:"Tag name",description:"",icon:"icons:android",color:"purple",groups:["Content"],handles:[{type:"data",type_exclusive:!1,url:"src"}],meta:{author:"auto"}},settings:{quick:[{property:"title",title:"Title",inputMethod:"textfield",icon:"android"},{property:"primaryColor",title:"Primary color",inputMethod:"colorpicker",icon:"color"}],configure:[{slot:"",title:"Inner content",description:"The slotted content that lives inside the tag",inputMethod:"textfield",icon:"android",required:!0,validationType:"text"},{slot:"button",title:"Button content",description:"The content that can override the button",inputMethod:"textfield",icon:"android",required:!0,validationType:"text"},{property:"title",title:"Title",description:"",inputMethod:"textfield",icon:"android",required:!0,validationType:"text"},{property:"primaryColor",title:"Title",description:"",inputMethod:"textfield",icon:"android",required:!1,validation:".*",validationType:"text"}],advanced:[{property:"secondaryColor",title:"Secondary color",description:"An optional secondary color used in certain edge cases.",inputMethod:"colorpicker",icon:"color"},{property:"endPoint",title:"API endpoint",description:"An optional endpoint to hit and load in more data dymaically.",inputMethod:"textfield",icon:"android",validation:"[a-z0-9]",validationType:"url"}]},saveOptions:{wipeSlot:!1,unsetAttributes:["end-point","secondary-color"]}};return props}};/**
 * Super class element partial. This mixes the HAXWiring capabilities into the element itself.
 * Use this in instances where you want direct access to all the functions in the element itself
 */_exports.HAXWiring=HAXWiring;var HAXElement=function HAXElement(SuperClass){return(/*#__PURE__*/function(_SuperClass){babelHelpers.inherits(_class,_SuperClass);function _class(){var _this2;babelHelpers.classCallCheck(this,_class);_this2=babelHelpers.possibleConstructorReturn(this,babelHelpers.getPrototypeOf(_class).call(this));_this2.HAXWiring=new HAXWiring;return _this2}babelHelpers.createClass(_class,[{key:"setHaxProperties",/**
     * Setter to bridge private haxProperties setter.
     * This is to then be implemented by the ready state of whatever is supplying the
     * properties in order to be able to bubble up the properties for a tag.
     */value:function setHaxProperties(props){var tag=1<arguments.length&&arguments[1]!==void 0?arguments[1]:"",context=2<arguments.length&&arguments[2]!==void 0?arguments[2]:this;if(""==tag&&babelHelpers.typeof(this.tagName)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){tag=this.tagName.toLowerCase()}window.addEventListener("hax-store-ready",this._haxStoreReady.bind(this));if(babelHelpers.typeof(window.HaxStore)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))&&null!=window.HaxStore.instance&&window.HaxStore.ready){return this.HAXWiring.setHaxProperties(props,tag,context,!0)}else{return this.HAXWiring.setHaxProperties(props,tag,context,!1)}}/**
     * Clean up
     */},{key:"disconnectedCallback",value:function disconnectedCallback(){window.removeEventListener("hax-store-ready",this._haxStoreReady.bind(this));if(babelHelpers.get(babelHelpers.getPrototypeOf(_class.prototype),"disconnectedCallback",this)){babelHelpers.get(babelHelpers.getPrototypeOf(_class.prototype),"disconnectedCallback",this).call(this)}}/**
     * Setter to bridge private haxProperties setter.
     * This is to then be implemented by the ready state of whatever is supplying the
     * properties in order to be able to bubble up the properties for a tag.
     */},{key:"setup",value:function setup(props){var tag=1<arguments.length&&arguments[1]!==void 0?arguments[1]:"",context=2<arguments.length&&arguments[2]!==void 0?arguments[2]:this;return this.HAXWiring.setup(props,tag="",context=this)}/**
     * Private function to fire off props when ready
     */},{key:"_haxStoreReady",value:function _haxStoreReady(e){return this.HAXWiring._haxStoreReady(e)}/**
     * Validate settings object.
     */},{key:"validateSetting",value:function validateSetting(setting){return this.HAXWiring.validateSetting(setting)}/**
     * Match convention for set.
     */},{key:"getHaxProperties",value:function getHaxProperties(){return this.haxProperties}/**
     * Convert haxProperties structure to a simple json-schema.
     * This allows for complex form building systems based on this data.
     * type is configure or advanced
     */},{key:"getHaxJSONSchema",value:function getHaxJSONSchema(type,haxProperties){var target=2<arguments.length&&arguments[2]!==void 0?arguments[2]:this;return this.HAXWiring.getHaxJSONSchema(type,haxProperties,target)}/**
     * Default postProcessgetHaxJSONSchema to be overridden.
     */},{key:"postProcessgetHaxJSONSchema",value:function postProcessgetHaxJSONSchema(schema){return this.HAXWiring.postProcessgetHaxJSONSchema(schema)}/**
     * Internal helper for getHaxJSONSchema to buiild the properties object
     * correctly with support for recursive nesting thx to objects / arrays.
     */},{key:"_getHaxJSONSchemaProperty",value:function _getHaxJSONSchemaProperty(settings){return _simpleFields.SimpleFields.fieldsToSchema(settings)}/**
     * Convert input method to schedma type
     */},{key:"getHaxJSONSchemaType",value:function getHaxJSONSchemaType(inputMethod){return this.HAXWiring.getHaxJSONSchemaType(inputMethod)}/**
     * List valid input methods.
     */},{key:"validHAXPropertyInputMethod",value:function validHAXPropertyInputMethod(){return this.HAXWiring.validHAXPropertyInputMethod()}/**
     * Return a haxProperties prototype / example structure
     */},{key:"prototypeHaxProperties",value:function prototypeHaxProperties(){return this.HAXWiring.prototypeHaxProperties()}}],[{key:"properties",get:function get(){return _objectSpread({},babelHelpers.get(babelHelpers.getPrototypeOf(_class),"properties",this),{/**
         * haxProperties
         */haxProperties:window.HAXWiring.haxProperties})}}]);return _class}(SuperClass))};// LEGACY. This is a Polymer 1.x syntax element "behavior"
// This has been replaced with HAXElement, a super class which can be used to wrap classes
// invoke an instance so we can support behaviors as well
_exports.HAXElement=HAXElement;window.HAXWiring=new HAXWiring;// ensure HAXPropertiesBehaviors exists
window.HAXBehaviors=window.HAXBehaviors||{};window.HAXBehaviors.PropertiesBehaviors={properties:{/**
     * haxProperties
     */haxProperties:window.HAXWiring.haxProperties},/**
   * Setter to bridge private haxProperties setter.
   * This is to then be implemented by the ready state of whatever is supplying the
   * properties in order to be able to bubble up the properties for a tag.
   */setHaxProperties:function setHaxProperties(props){var tag=1<arguments.length&&arguments[1]!==void 0?arguments[1]:"",context=2<arguments.length&&arguments[2]!==void 0?arguments[2]:this;if(""==tag&&babelHelpers.typeof(this.tagName)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))){tag=this.tagName.toLowerCase()}window.addEventListener("hax-store-ready",this._haxStoreReady.bind(this));if(babelHelpers.typeof(window.HaxStore)!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))&&null!=window.HaxStore.instance&&window.HaxStore.ready){return window.HAXWiring.setHaxProperties(props,tag,context,!0)}else{return window.HAXWiring.setHaxProperties(props,tag,context,!1)}},/**
   * Private function to fire off props when ready
   */_haxStoreReady:function _haxStoreReady(e){return window.HAXWiring._haxStoreReady(e)},/**
   * Validate settings object.
   */validateSetting:function validateSetting(setting){return window.HAXWiring.validateSetting(setting)},/**
   * Match convention for set.
   */getHaxProperties:function getHaxProperties(){return this.haxProperties},/**
   * Convert haxProperties structure to a simple json-schema.
   * This allows for complex form building systems based on this data.
   * type is configure or advanced
   */getHaxJSONSchema:function getHaxJSONSchema(type,haxProperties){var target=2<arguments.length&&arguments[2]!==void 0?arguments[2]:this;return window.HAXWiring.getHaxJSONSchema(type,haxProperties,target)},/**
   * Default postProcessgetHaxJSONSchema to be overridden.
   */postProcessgetHaxJSONSchema:function postProcessgetHaxJSONSchema(schema){return window.HAXWiring.postProcessgetHaxJSONSchema(schema)},/**
   * Internal helper for getHaxJSONSchema to buiild the properties object
   * correctly with support for recursive nesting thx to objects / arrays.
   */_getHaxJSONSchemaProperty:function _getHaxJSONSchemaProperty(settings){return _simpleFields.SimpleFields.fieldsToSchema(settings)},/**
   * Convert input method to schedma type
   */getHaxJSONSchemaType:function getHaxJSONSchemaType(inputMethod){return window.HAXWiring.getHaxJSONSchemaType(inputMethod)},/**
   * List valid input methods.
   */validHAXPropertyInputMethod:function validHAXPropertyInputMethod(){return window.HAXWiring.validHAXPropertyInputMethod()},/**
   * Return a haxProperties prototype / example structure
   */prototypeHaxProperties:function prototypeHaxProperties(){return window.HAXWiring.prototypeHaxProperties()}}});