define(["exports", "require", "../../@polymer/polymer/polymer-element.js", "../../@polymer/polymer/lib/utils/render-status.js", "../smooth-scroll/smooth-scroll.js", "./lib/map-menu-builder.js"], function (_exports, _require, _polymerElement, _renderStatus, _smoothScroll, _mapMenuBuilder) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.MapMenu = void 0;
  _require = babelHelpers.interopRequireWildcard(_require);

  function _templateObject_be5b59e0dedc11e9bf5a076df0f16721() {
    var data = babelHelpers.taggedTemplateLiteral(["\n      <style>\n        :host {\n          --map-menu-active-color: rgba(0, 0, 0, 0.1);\n          --map-menu-size: 1;\n          --map-menu-font-size: 16px;\n          display: block;\n          overflow-y: scroll;\n          position: relative;\n          height: 100%;\n          transition: 0.2s linear all;\n          opacity: 1;\n          background-color: transparent;\n        }\n\n        #itemslist {\n          @apply --map-menu-items-list;\n        }\n\n        #activeIndicator {\n          background: var(--map-menu-active-color);\n          transition: all 0.3s ease-in-out;\n          position: absolute;\n          @apply --map-menu-active-indicator;\n        }\n\n        map-menu-container {\n          padding: var(--map-menu-container-padding, 0);\n          @apply --map-menu-container;\n        }\n\n        /* turn default active color if indicator is on */\n        :host([active-indicator]) map-menu-builder {\n          --map-menu-active-color: transparent;\n        }\n      </style>\n      <div id=\"itemslist\">\n        <map-menu-container>\n          <div id=\"activeIndicator\"></div>\n          <map-menu-builder\n            id=\"builder\"\n            items=\"[[items]]\"\n            selected=\"[[selected]]\"\n          ></map-menu-builder>\n        </map-menu-container>\n      </div>\n      <smooth-scroll id=\"smoothScroll\"></smooth-scroll>\n    "]);

    _templateObject_be5b59e0dedc11e9bf5a076df0f16721 = function _templateObject_be5b59e0dedc11e9bf5a076df0f16721() {
      return data;
    };

    return data;
  }

  /**
   * `map-menu`
   * `A series of elements that generate a hierarchical menu`
   *
   * @demo demo/index.html
   */
  var MapMenu =
  /*#__PURE__*/
  function (_PolymerElement) {
    babelHelpers.inherits(MapMenu, _PolymerElement);

    function MapMenu() {
      var _this;

      babelHelpers.classCallCheck(this, MapMenu);
      _this = babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(MapMenu).call(this));
      new Promise(function (res, rej) {
        return _require.default(["./lib/map-menu-container.js"], res, rej);
      });
      return _this;
    }

    babelHelpers.createClass(MapMenu, [{
      key: "ready",
      value: function ready() {
        babelHelpers.get(babelHelpers.getPrototypeOf(MapMenu.prototype), "ready", this).call(this);
        (0, _renderStatus.afterNextRender)(this, function () {
          this.addEventListener("link-clicked", this.__linkClickedHandler.bind(this));
          this.addEventListener("toggle-updated", this.__toggleUpdated.bind(this));
          this.addEventListener("active-item", this.__activeItemHandler.bind(this));
          this.addEventListener("map-meu-item-hidden-check", this._mapMeuItemHiddenCheckHandler.bind(this));
        });
      }
    }, {
      key: "__activeItemHandler",
      value: function __activeItemHandler(e) {
        var target = e.detail;
        this.refreshActiveChildren(target);
      }
    }, {
      key: "_mapMeuItemHiddenCheckHandler",
      value: function _mapMeuItemHiddenCheckHandler(e) {
        var action = e.detail.action;
        var target = e.detail.target;
        var hiddenChild = e.detail.hiddenChild;

        if (action === "closed" && hiddenChild === true) {
          this.__updateActiveIndicator(this._activeItem, 200, true);
        } else {
          this.__updateActiveIndicator(this._activeItem, 200, false);
        }
      }
      /**
       * Set and unset active properties on children
       * @param {string} activeItem
       * @param {number} timeoutTime
       */

    }, {
      key: "refreshActiveChildren",
      value: function refreshActiveChildren(activeItem) {
        var timeoutTime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 200;
        var oldActiveItem = this._activeItem;
        var newActiveItem = activeItem;

        if (newActiveItem && newActiveItem !== "") {
          // set the new active attribute to the item
          newActiveItem.setAttribute("active", true); // move the highlight thingy

          if (this.activeIndicator) {
            this.__updateActiveIndicator(newActiveItem, timeoutTime);
          } // if auto scroll enabled then scroll element into view


          if (this.autoScroll) {
            // kick off smooth scroll
            this.$.smoothScroll.scroll(newActiveItem, {
              duration: 300,
              scrollElement: this
            });
          }
        }

        if (oldActiveItem) {
          oldActiveItem.removeAttribute("active");

          this.__updateActiveIndicator(newActiveItem, timeoutTime);
        }

        this._activeItem = newActiveItem;
      }
    }, {
      key: "_manifestChanged",
      value: function _manifestChanged(newValue, oldValue) {
        if (newValue) {
          this.set("data", newValue.items);
        }
      }
      /**
       * Set data property
       */

    }, {
      key: "setData",
      value: function setData(data) {
        this.set("data", []);
        this.set("data", data);
      }
      /**
       * Convert data from a linear array
       * to a nested array for template rendering
       */

    }, {
      key: "_dataChanged",
      value: function _dataChanged(data) {
        var _this2 = this;

        var items = [];
        if (!data) return; // find parents

        data.forEach(function (element) {
          // find top level parents
          if (!element.parent) {
            items.push(element);
          }
        }); // Recursively find and set children

        items.forEach(function (item, i) {
          _this2._setChildren(item, data);
        }); // Update items array

        this.set("items", []);
        this.set("items", items);
      }
      /**
       * Recursively search through a data to find children
       * of a specified item.
       * @param {object} item item of an array to search on. Passed by reference.
       * @param {array} data linear array of the data set.
       * @return {void}
       */

    }, {
      key: "_setChildren",
      value: function _setChildren(item, data) {
        var _this3 = this;

        // find all children
        var children = data.filter(function (d) {
          return item.id === d.parent;
        });
        item.children = children;

        if (item.children.length > 0) {
          item.children.forEach(function (child) {
            // recursively call itself
            _this3._setChildren(child, data);
          });
        }
      }
      /**
       * Determine if a menu item has children
       */

    }, {
      key: "__hasChildren",
      value: function __hasChildren(item) {
        return item.children.length > 0;
      }
      /**
       * asdf
       */

    }, {
      key: "__linkClickedHandler",
      value: function __linkClickedHandler(e) {
        this.selected = e.detail.id;
        this.dispatchEvent(new CustomEvent("selected", {
          bubbles: true,
          cancelable: true,
          composed: true,
          detail: e.detail.id
        }));
      }
      /**
       * When a user clicks the toggle button to collapse or
       * expand a submenu, this event gets triggered after
       * the animation has been triggered
       */

    }, {
      key: "__toggleUpdated",
      value: function __toggleUpdated(e) {
        var action = e.detail.opened ? "opened" : "closed";
        var target = e.path[0];

        if (typeof this._activeItem !== "undefined") {
          this._activeItem.dispatchEvent(new CustomEvent("map-menu-item-hidden-check", {
            bubbles: true,
            cancelable: true,
            composed: true,
            detail: Object.assign({}, {
              action: action,
              target: target
            })
          }));
        }
      }
      /**
       * Find out if
       */

    }, {
      key: "__isInViewport",
      value: function __isInViewport(element) {
        var scrollParent = this.__getScrollParent(element);

        if (!scrollParent) return false;
        var elementTop = element.offsetTop;
        var elementBottom = elementTop + element.offsetHeight;
        var viewportTop = scrollParent.offsetTop;
        var viewportBottom = viewportTop + scrollParent.offsetHeight;
        return elementBottom > viewportTop && elementTop < viewportBottom;
      }
      /**
       * Get scroll parent
       */

    }, {
      key: "__getScrollParent",
      value: function __getScrollParent(node) {
        if (node == null) {
          return null;
        }

        if (node.scrollHeight > node.clientHeight) {
          return node;
        } else {
          return this.__getScrollParent(node.parentNode);
        }
      }
      /**
       * Move the highlight widget over active element
       */

    }, {
      key: "__updateActiveIndicator",
      value: function __updateActiveIndicator(element) {
        var _this4 = this;

        var timeoutTime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 200;
        var hidden = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        // run it through to set time just to let stuff set up
        setTimeout(function () {
          var activeIndicator = _this4.$.activeIndicator;
          var left = element.offsetLeft;
          var bottom = element.offsetBottom;
          var top = element.offsetTop;
          var width = element.offsetWidth; // if the element is hidden the set the indicator height to zero to make it disapear

          var height = !hidden ? element.offsetHeight : 0; // if the height is zero then make the timeoutTime faster

          timeoutTime = height > 0 ? timeoutTime : 10;
          activeIndicator.setAttribute("style", "width:".concat(width, "px;height:").concat(height, "px;top:").concat(top, "px;left:").concat(left, "px"));
        }, timeoutTime);
      }
      /**
       * Find out if any parents of the item are collapsed
       */

    }, {
      key: "__parentsHidden",
      value: function __parentsHidden(node) {
        // get the parent node
        var parent = node.parentNode; // bail if we have no node to work with

        if (parent == null) return null; // if we found a submenu check if it is hidden

        if (parent.tagName === "MAP-MENU-SUBMENU") {
          // if open is set to false then we have
          // found a hidden parent
          if (!parent.opened) return true;
        } // wrap up and exit if we came all the way back to map-menu


        if (parent.tagName === "MAP-MENU") return false; // if we got all the way here then we need recursively run this
        // against the parent node

        return this.__parentsHidden(parent);
      }
    }], [{
      key: "template",
      get: function get() {
        return (0, _polymerElement.html)(_templateObject_be5b59e0dedc11e9bf5a076df0f16721());
      }
    }, {
      key: "tag",
      get: function get() {
        return "map-menu";
      }
    }, {
      key: "properties",
      get: function get() {
        return {
          disabled: {
            type: Boolean,
            value: false,
            reflectToAttribute: true
          },
          title: {
            type: String,
            value: "Content Outline"
          },
          data: {
            type: Array,
            value: null
          },

          /**
           * Support for JSON Outline Schema manifest format
           */
          manifest: {
            type: Object,
            notify: true,
            observer: "_manifestChanged"
          },
          items: {
            type: Array,
            value: null,
            notify: true
          },

          /**
           * Current selected item.
           */
          selected: {
            type: String,
            notify: true
          },

          /**
           * Auto scroll an active element if not in view
           */
          autoScroll: {
            type: Boolean,
            value: false
          },

          /**
           * Show active indicator animation
           */
          activeIndicator: {
            type: Boolean,
            value: false
          }
        };
      }
    }, {
      key: "observers",
      get: function get() {
        return ["_dataChanged(data)"];
      }
    }]);
    return MapMenu;
  }(_polymerElement.PolymerElement);

  _exports.MapMenu = MapMenu;
  window.customElements.define(MapMenu.tag, MapMenu);
});