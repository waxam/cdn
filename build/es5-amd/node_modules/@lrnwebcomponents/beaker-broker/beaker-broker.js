define(["exports", "../../lit/index.js"], function (_exports, _index) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.BeakerBroker = void 0;

  var _templateObject_d9183e40ce4611ecb13bcf602138080f;

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  /**
   * `beaker-broker`
   * `An element to help check for and broker calls to read and write beaker browser dat sites.
   * This allows for data binding and figuring out if we're in an environment that we can even use this.`
   *
   * @microcopy - language worth noting:
   *  - beaker browser - a transformative, decentralized platform
   *  - dat - a communication protocol for serving sites up p2p
   *
   * @demo demo/index.html
   * @element beaker-broker
   */
  var BeakerBroker = /*#__PURE__*/function (_LitElement) {
    babelHelpers.inherits(BeakerBroker, _LitElement);

    var _super = _createSuper(BeakerBroker);

    /**
     * HTMLElement
     */
    function BeakerBroker() {
      var _this;

      babelHelpers.classCallCheck(this, BeakerBroker);
      _this = _super.call(this);
      _this.datUrl = window.location.host;
      return _this;
    }
    /**
     * LitElement properties changed
     */


    babelHelpers.createClass(BeakerBroker, [{
      key: "render",
      value: // render function
      function render() {
        return (0, _index.html)(_templateObject_d9183e40ce4611ecb13bcf602138080f || (_templateObject_d9183e40ce4611ecb13bcf602138080f = babelHelpers.taggedTemplateLiteral([" <style>\n        :host {\n          display: block;\n        }\n\n        :host([hidden]) {\n          display: none;\n        }\n      </style>\n      <slot></slot>"])));
      } // haxProperty definition

    }, {
      key: "firstUpdated",
      value:
      /**
       * LitElement ready
       */
      function firstUpdated() {
        if ((typeof DatArchive === "undefined" ? "undefined" : babelHelpers.typeof(DatArchive)) === (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
          console.warn("Beaker is not available from this site loading methodology");
        }
      }
    }, {
      key: "updated",
      value: function updated(changedProperties) {
        var _this2 = this;

        changedProperties.forEach(function (oldValue, propName) {
          if (propName == "archive") {
            // notify
            _this2.dispatchEvent(new CustomEvent("archive-changed", {
              detail: {
                value: _this2[propName]
              }
            }));
          }

          if (propName == "datUrl") {
            _this2._datUrlChanged(_this2[propName]); // notify


            _this2.dispatchEvent(new CustomEvent("dat-url-changed", {
              detail: {
                value: _this2[propName]
              }
            }));
          }
        });
      }
      /**
       * notice dat address has changed, build the object for it
       */

    }, {
      key: "_datUrlChanged",
      value: function () {
        var _datUrlChanged2 = babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(newValue) {
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  if ((typeof DatArchive === "undefined" ? "undefined" : babelHelpers.typeof(DatArchive)) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && newValue) {
                    // load current site, set to archive
                    this.archive = new DatArchive(newValue);
                  }

                case 1:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));

        function _datUrlChanged(_x) {
          return _datUrlChanged2.apply(this, arguments);
        }

        return _datUrlChanged;
      }()
      /**
       * Write to file
       * @usage - this.write('hello.txt', 'things and stuff');
       */

    }, {
      key: "write",
      value: function () {
        var _write = babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(path, data) {
          return regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  _context2.next = 2;
                  return this.archive.writeFile(path, data);

                case 2:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, this);
        }));

        function write(_x2, _x3) {
          return _write.apply(this, arguments);
        }

        return write;
      }()
      /**
       * Read to file
       * @var path - location of file
       * @var type - utf8, base64, hex, binary or specialized ones jpeg / png
       * @return Promise() with reference to the data in the file if await / async is active
       * @usage - await this.read('index.html'); to get this file
       */

    }, {
      key: "read",
      value: function () {
        var _read = babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(path, type) {
          var ftype, response, buf, blob, str;
          return regeneratorRuntime.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  ftype = "utf8";
                  _context3.t0 = type;
                  _context3.next = _context3.t0 === "jpeg" ? 4 : _context3.t0 === "jpg" ? 4 : _context3.t0 === "png" ? 11 : _context3.t0 === "base64" ? 18 : 23;
                  break;

                case 4:
                  ftype = "binary";
                  _context3.next = 7;
                  return this.archive.readFile(path, ftype);

                case 7:
                  buf = _context3.sent;
                  blob = new Blob([buf], {
                    type: "image/jpeg"
                  });
                  response = URL.createObjectURL(blob);
                  return _context3.abrupt("break", 28);

                case 11:
                  ftype = "binary";
                  _context3.next = 14;
                  return this.archive.readFile(path, ftype);

                case 14:
                  buf = _context3.sent;
                  blob = new Blob([buf], {
                    type: "image/png"
                  });
                  response = URL.createObjectURL(blob);
                  return _context3.abrupt("break", 28);

                case 18:
                  _context3.next = 20;
                  return this.archive.readFile(path, type);

                case 20:
                  str = _context3.sent;
                  response = "data:image/png;base64," + str;
                  return _context3.abrupt("break", 28);

                case 23:
                  _context3.next = 25;
                  return this.archive.readFile(path, type);

                case 25:
                  str = _context3.sent;
                  response = str;
                  return _context3.abrupt("break", 28);

                case 28:
                  _context3.next = 30;
                  return response;

                case 30:
                  return _context3.abrupt("return", _context3.sent);

                case 31:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3, this);
        }));

        function read(_x4, _x5) {
          return _read.apply(this, arguments);
        }

        return read;
      }()
    }], [{
      key: "haxProperties",
      get: function get() {
        return {};
      } // properties available to the custom element for data binding

    }, {
      key: "properties",
      get: function get() {
        return _objectSpread(_objectSpread({}, babelHelpers.get(babelHelpers.getPrototypeOf(BeakerBroker), "properties", this)), {}, {
          /**
           * Archive
           */
          archive: {
            type: Object
          },

          /**
           * datUrl
           */
          datUrl: {
            type: String,
            attribute: "dat-url"
          }
        });
      }
      /**
       * Store the tag name to make it easier to obtain directly.
       * @notice function name must be here for tooling to operate correctly
       */

    }, {
      key: "tag",
      get: function get() {
        return "beaker-broker";
      }
    }]);
    return BeakerBroker;
  }(_index.LitElement);

  _exports.BeakerBroker = BeakerBroker;
  window.customElements.define(BeakerBroker.tag, BeakerBroker);
});