define(["exports", "../../../../@polymer/polymer/polymer-element.js", "../rich-text-editor-styles.js"], function (_exports, _polymerElement, _richTextEditorStyles) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.RichTextEditorSelection = void 0;

  function _templateObject_6f828a30d34d11ea880ba1e93364c49c() {
    var data = babelHelpers.taggedTemplateLiteral(["\n      <style include=\"rich-text-editor-styles\">\n        :host {\n          background-color: var(--rich-text-editor-selection-bg);\n          @apply --rich-text-editor-content-selection;\n        }\n        :host([hidden]) {\n          display: none;\n        }\n      </style>\n      <slot></slot>\n    "]);

    _templateObject_6f828a30d34d11ea880ba1e93364c49c = function _templateObject_6f828a30d34d11ea880ba1e93364c49c() {
      return data;
    };

    return data;
  }

  /**
   * `rich-text-editor-selection`
   * `a button for rich text editor (custom buttons can extend this)`
   *
   * @microcopy - language worth noting:
   *  -
   *
  
   * @polymer
   */
  var RichTextEditorSelection =
  /*#__PURE__*/
  function (_PolymerElement) {
    babelHelpers.inherits(RichTextEditorSelection, _PolymerElement);

    function RichTextEditorSelection() {
      babelHelpers.classCallCheck(this, RichTextEditorSelection);
      return babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(RichTextEditorSelection).apply(this, arguments));
    }

    babelHelpers.createClass(RichTextEditorSelection, [{
      key: "connectedCallback",

      /**
       * life cycle, element is afixed to the DOM
       */
      value: function connectedCallback() {
        babelHelpers.get(babelHelpers.getPrototypeOf(RichTextEditorSelection.prototype), "connectedCallback", this).call(this);
        var root = this;
        document.addEventListener("selectionchange", function (e) {
          root.range = root.getRange();
        });
        document.addEventListener("select-rich-text-editor-editor", function (e) {
          root._editorChange(e);
        });
        document.addEventListener("deselect-rich-text-editor-editor", function (e) {
          root._editorChange(e);
        });
        this.setAttribute("id", this._generateUUID());
      }
      /**
       * life cycle, element is disconnected
       */

    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        babelHelpers.get(babelHelpers.getPrototypeOf(RichTextEditorSelection.prototype), "disconnectedCallback", this).call(this);
        var root = this;
        document.removeEventListener("selectionchange", function (e) {
          root.range = root.getRange();
        });
        document.removeEventListener("select-rich-text-editor-editor", function (e) {
          root._editorChange(e);
        });
        document.removeEventListener("deselect-rich-text-editor-editor", function (e) {
          root._editorChange(e);
        });
      }
      /**
       * expands the selection to a specific ancestor or wraps the selection in a default tag
       * @param {string} searchTag the ancestor tagName to find
       * @param {string} wrapTag the tagName to use if ancestor cannot be found
       * @returns {object} the selected node
       */

    }, {
      key: "expandSelection",
      value: function expandSelection() {
        var searchTag = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        var wrapTag = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        return this.selectAncestor(searchTag) || this.wrap(wrapTag ? document.createElement(wrapTag) : null);
      }
      /**
       * Normalizes selected range data.
       *
       * @returns {object} the selected range
       */

    }, {
      key: "getRange",
      value: function getRange() {
        var sel = window.getSelection();

        if (sel.getRangeAt && sel.rangeCount) {
          return sel.getRangeAt(0);
        } else if (sel) {
          return sel;
        } else false;
      }
      /**
       * adds or removes the hightlight
       * @param {object} contents the contents to be highlighted
       * @returns {void}
       */

    }, {
      key: "addHighlight",
      value: function addHighlight() {
        var root = this;
        root.range.surroundContents(root);
        root.range.selectNode(root.firstChild);
        root.dispatchEvent(new CustomEvent("highlight", {
          detail: root
        }));
        root.hidden = false;
      }
      /**
       * gets the contents of the selected range
       * @returns {object} the range contents
       */

    }, {
      key: "getRangeContents",
      value: function getRangeContents() {
        return this.range ? this.range.cloneContents() : null;
      }
      /**
       * searches for a closest ancestor by tagname,
       * expands the selection to the matching ancestor,
       * and returns the ancestor, or returns null if not found
       * @param {string} tag the tag to expand the selection to
       * @returns {object} the selected node
       */

    }, {
      key: "selectAncestor",
      value: function selectAncestor() {
        var tagName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

        var wrapper = null,
            getMatchingTag = function getMatchingTag(ancestor) {
          if (ancestor && ancestor.tagName && (!tagName || ancestor.tagName.toLowerCase() === tagName.toLowerCase())) {
            return ancestor;
          } else if (ancestor.parentNode && ancestor.parentNode.childNodes.length === 1) {
            return getMatchingTag(ancestor.parentNode);
          } else {
            return null;
          }
        }; //try to find an ancestor that matches the tag


        if (this.range) {
          var ancestor = this.range.commonAncestorContainer;
          wrapper = getMatchingTag(ancestor);
          if (wrapper) this.range.selectNode(wrapper);
        }

        return wrapper;
      }
      /**
       * sets the selection range to the specified node
       * @param {object} node the node to select
       * @returns {void}
       */

    }, {
      key: "selectNode",
      value: function selectNode() {
        var node = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

        if (node) {
          if (!this.range) {
            var sel = window.getSelection();
            this.range = document.createRange();
            sel.removeAllRanges();
            sel.addRange(this.range);
          }

          this.range.selectNode(node);
        }
      }
      /**
       * sets the selection range to the specified node's contents
       * @param {object} node the node to select
       * @returns {void}
       */

    }, {
      key: "selectNodeContents",
      value: function selectNodeContents() {
        var node = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

        if (node) {
          if (!this.range) {
            var sel = window.getSelection();
            this.range = document.createRange();
            sel.removeAllRanges();
            sel.addRange(this.range);
          }

          this.range.selectNodeContents(node);
        }
      }
      /**
       * gets the range contents in specified wrapper
       * @param {object} wrapper a node to wrap the range contents in
       * @returns {object} the range which oncludes the wrapper and wrapped contents
       */

    }, {
      key: "wrap",
      value: function wrap(wrapper) {
        wrapper = wrapper || document.createElement("span");
        this.range.surroundContents(wrapper);
        return wrapper;
      }
      /**
       * Updates the selected range based on toolbar and editor
       * @param {event} e the editor change event
       * @param {deselect} if the editor is being deselected
       * @returns {void}
       */

    }, {
      key: "_editorChange",
      value: function _editorChange(e) {
        var deselect = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var root = this,
            editorChange = root.editor !== e.detail.editor,
            toolbarChange = root.toolbar !== e.detail.toolbar;

        if (deselect || editorChange || toolbarChange) {
          var sel = window.getSelection();
          sel.removeAllRanges();
          root.editor = e.detail.editor;
          root.toolbar = e.detail.toolbar;
          if (root.observer) root.observer.disconnect();

          if (!deselect && e.detail.editor) {
            root.observer = new MutationObserver(function (evt) {
              root.range = root.getRange();
            });
            root.observer.observe(e.detail.editor, {
              attributes: false,
              childList: true,
              subtree: true,
              characterData: false
            });
          }
        }
      }
      /**
       * Generate a UUID
       * @returns {string} the unique id
       */

    }, {
      key: "_generateUUID",
      value: function _generateUUID() {
        var hex = Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
        return "rte-" + "ss-s-s-s-sss".replace(/s/g, hex);
      }
      /**
       * Updates the toolbar
       */

    }, {
      key: "_updateToolbar",
      value: function _updateToolbar() {
        if (this.toolbar) this.toolbar.range = this.range;
      }
    }], [{
      key: "template",
      // render function
      get: function get() {
        return (0, _polymerElement.html)(_templateObject_6f828a30d34d11ea880ba1e93364c49c());
      } // properties available to the custom element for data binding

    }, {
      key: "properties",
      get: function get() {
        return {
          editor: {
            type: Object,
            value: null
          },
          hidden: {
            type: Boolean,
            value: true,
            reflectToAttribute: true
          },
          observer: {
            type: Object,
            value: null
          },
          range: {
            type: Object,
            value: null,
            observer: "_updateToolbar"
          },
          toolbar: {
            type: Object,
            value: null
          }
        };
      }
      /**
       * Store the tag name to make it easier to obtain directly.
       */

    }, {
      key: "tag",
      get: function get() {
        return "rich-text-editor-selection";
      }
    }]);
    return RichTextEditorSelection;
  }(_polymerElement.PolymerElement);

  _exports.RichTextEditorSelection = RichTextEditorSelection;
  window.customElements.define(RichTextEditorSelection.tag, RichTextEditorSelection);
  window.RichTextEditorSelection = {};
  window.RichTextEditorSelection.instance = null;
  /**
   * Checks to see if there is an instance available, and if not appends one
   */

  window.RichTextEditorSelection.requestAvailability = function () {
    if (window.RichTextEditorSelection.instance == null) {
      window.RichTextEditorSelection.instance = document.createElement("rich-text-editor-selection");
      document.body.appendChild(window.RichTextEditorSelection.instance);
    }

    return window.RichTextEditorSelection.instance;
  };
});