define(["exports", "../../../../lit-element/lit-element.js", "../rich-text-editor-styles.js", "../../../utils/utils.js"], function (_exports, _litElement, _richTextEditorStyles, _utils) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.RichTextEditorSelection = void 0;

  function _templateObject2_e6b4a7b0576311eba9ce094baa5ca644() {
    var data = babelHelpers.taggedTemplateLiteral(["\n        :host {\n          background-color: var(--rich-text-editor-selection-bg);\n          margin: 0;\n          padding: 0;\n          display: inline;\n        }\n        :host([hidden]) {\n          display: none;\n        }\n        :host([collapsed]):after {\n          content: '|';\n          color: var(--rich-text-editor-selection-bg);\n          background-color: transparent;\n        }\n\xA0\xA0\xA0\xA0\xA0\xA0"]);

    _templateObject2_e6b4a7b0576311eba9ce094baa5ca644 = function _templateObject2_e6b4a7b0576311eba9ce094baa5ca644() {
      return data;
    };

    return data;
  }

  function _templateObject_e6b4a7b0576311eba9ce094baa5ca644() {
    var data = babelHelpers.taggedTemplateLiteral([" <slot></slot> "]);

    _templateObject_e6b4a7b0576311eba9ce094baa5ca644 = function _templateObject_e6b4a7b0576311eba9ce094baa5ca644() {
      return data;
    };

    return data;
  }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  /**
   * `rich-text-editor-selection`
   * `a button for rich text editor (custom buttons can extend this)`
   *
   * @element rich-text-editor-selection
   * @demo ./demo/selection.html
   */
  var RichTextEditorSelection = /*#__PURE__*/function (_RichTextEditorStyles) {
    babelHelpers.inherits(RichTextEditorSelection, _RichTextEditorStyles);

    var _super = _createSuper(RichTextEditorSelection);

    babelHelpers.createClass(RichTextEditorSelection, [{
      key: "render",
      value: function render() {
        return (0, _litElement.html)(_templateObject_e6b4a7b0576311eba9ce094baa5ca644());
      }
    }], [{
      key: "tag",

      /**
       * Store tag name to make it easier to obtain directly.
       */
      get: function get() {
        return "rich-text-editor-selection";
      }
    }, {
      key: "styles",
      get: function get() {
        return [].concat(babelHelpers.toConsumableArray(babelHelpers.get(babelHelpers.getPrototypeOf(RichTextEditorSelection), "styles", this)), [(0, _litElement.css)(_templateObject2_e6b4a7b0576311eba9ce094baa5ca644())]);
      }
    }, {
      key: "properties",
      get: function get() {
        return {
          editor: {
            type: Object
          },
          collapsed: {
            type: Boolean,
            reflect: true,
            attribute: "collapsed"
          },
          hidden: {
            type: Boolean,
            reflect: true,
            attribute: "hidden"
          },
          id: {
            type: String,
            reflect: true,
            attribute: "id"
          },
          observer: {
            type: Object
          },
          range: {
            type: Object
          },
          toolbar: {
            type: Object
          },
          __toolbars: {
            type: Array
          }
        };
      }
    }]);

    function RichTextEditorSelection() {
      var _this;

      babelHelpers.classCallCheck(this, RichTextEditorSelection);
      _this = _super.call(this);
      var sel = babelHelpers.assertThisInitialized(_this);
      _this.hidden = true;
      _this.__toolbars = [];
      _this.__clipboard = document.createElement("textarea");

      _this.__clipboard.setAttribute("aria-hidden", true);

      _this.__clipboard.style.position = "absolute";
      _this.__clipboard.style.left = "-9999px";
      _this.__clipboard.style.top = "0px";
      _this.__clipboard.style.width = "0px";
      _this.__clipboard.style.height = "0px";
      _this.id = _this._generateUUID();
      document.body.appendChild(_this.__clipboard);
      window.addEventListener("paste", function (e) {
        return console.log("paste", e);
      });
      window.addEventListener("register", _this._handleRegistration.bind(sel));
      /*
      extendForward.addEventListener('click', () => {
        window.getSelection().modify('extend', 'forward', 'character');
      });
       extendBackward.addEventListener('click', () => {
        window.getSelection().modify('extend', 'backward', 'character');
      });*/

      return _this;
    }

    babelHelpers.createClass(RichTextEditorSelection, [{
      key: "updated",
      value: function updated(changedProperties) {
        babelHelpers.get(babelHelpers.getPrototypeOf(RichTextEditorSelection.prototype), "updated", this).call(this, changedProperties);
        changedProperties.forEach(function (oldValue, propName) {});
      }
      /**
       * life cycle, element is disconnected
       */

    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        babelHelpers.get(babelHelpers.getPrototypeOf(RichTextEditorSelection.prototype), "disconnectedCallback", this).call(this);
      }
      /**
       * undo for canceled edits
       *
       * @param {object} editor
       * @memberof RichTextEditorSelection
       */

    }, {
      key: "cancelEdits",
      value: function cancelEdits(editor) {
        editor.revert();
        this.edit(editor, false);
      }
      /**
       * disables contenteditable
       *
       * @param {object} editor
       * @memberof RichTextEditorSelection
       */

    }, {
      key: "disableEditing",
      value: function disableEditing(editor) {
        if (!!editor) {
          this.getRoot(editor).onselectionchange = undefined; //editor.observeChanges(false);

          editor.contenteditable = false;
          editor.makeSticky(false);
        }
      }
      /**
       * executes button command on current range
       *
       */

    }, {
      key: "execCommand",
      value: function execCommand(command, val, range, toolbar) {
        console.log(">>>>>>>> execCommand", command, val, range, toolbar, !range || range.cloneContents());
        var editor = toolbar.editor;

        if (range) {
          this.range = editor.range;
          this.updateRange(editor, range);
          this.selectRange(range, editor);

          if (command === "replaceHTML") {
            var node = this.getRangeNode();
            node.innerHTML = val;
          } else if (command !== "paste") {
            console.log("command", range, this.getRangeNode());
            document.execCommand(command, false, val);
          } else if (navigator.clipboard) {
            this.pasteFromClipboard(editor);
          }

          this.highlight(toolbar, false);
        }
      }
      /**
       * Updates selected range based on toolbar and editor
       * @param {event} e editor change event
       * @param {deselect} if editor is being deselected
       * @returns {void}
       */

    }, {
      key: "edit",
      value: function edit(editor) {
        var editable = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        var toolbar = !editor ? undefined : this.getConnectedToolbar(editor),
            oldEditor = editable ? toolbar.editor : undefined;
        this.highlight(editor, false);

        if (toolbar && oldEditor !== editor) {
          this.disableEditing(oldEditor);
          toolbar.editor = editor;
          this.enableEditing(editor, toolbar);
        }
      }
      /**
       * enables content editable
       *
       * @param {*} editor
       * @param {*} [toolbar=this.getConnectedToolbar(editor)]
       * @memberof RichTextEditorSelection
       */

    }, {
      key: "enableEditing",
      value: function enableEditing(editor) {
        var _this2 = this;

        var toolbar = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getConnectedToolbar(editor);

        if (!!editor) {
          editor.makeSticky(toolbar.sticky);
          editor.parentNode.insertBefore(toolbar, editor);
          editor.contenteditable = true;
          this.updateRange(editor); //editor.observeChanges(this.getRoot(editor));

          this.getRoot(editor).onselectionchange = function (e) {
            return _this2.updateRange(editor);
          };
        }
      }
      /**
       * expands selection to a specific ancestor
       * @param {string} selectors comma-separated list of selectors
       * @param {object} range
       * @returns {object} updated range
       */

    }, {
      key: "expandRangeTo",
      value: function expandRangeTo() {
        var selectors = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
        var range = arguments.length > 1 ? arguments[1] : undefined;
        var node = range ? this.getRangeNode(range) : undefined,
            tagName = node && node.tagName ? node.tagName.toLowerCase() : undefined,
            selectorsList = selectors.toLowerCase().replace(/\s*/g, "").split(",");

        if (selectorsList.includes(tagName)) {
          return node;
        } else if (node.closest(selectors)) {
          range.selectNode(node.closest(selectors));
          return range;
        }
      }
      /**
       * node selected or its parent node
       *
       * @param {object} range
       * @returns object
       * @memberof RichTextEditorSelection
       */

    }, {
      key: "getRangeNode",
      value: function getRangeNode(range) {
        var common = !range ? undefined : range.commonAncestorContainer,
            startContainer = !range ? undefined : range.startContainer,
            startOffset = !range ? undefined : range.startOffset,
            endContainer = !range ? undefined : range.endContainer,
            endOffset = !range ? undefined : range.endOffset,
            startNode = !startContainer || !startContainer.children ? undefined : startContainer.children[startOffset - 1],
            rootNode = startContainer === endContainer && endOffset - startOffset === 1 ? startNode : common;
        return rootNode;
      }
      /**
       * gets closest shadowRoot or document from node
       *
       * @param {object} node
       * @returns object
       * @memberof RichTextEditorSelection
       */

    }, {
      key: "getRoot",
      value: function getRoot(node) {
        return !node || node === document ? document : node.parentNode ? this.getRoot(node.parentNode) : node;
      }
      /**
       * paste content into a range;
       * override this function to make your own filters
       *
       * @param {string} pasteContent html to be pasted
       * @returns {string} filtered html as string
       */

    }, {
      key: "getSanitizeClipboard",
      value: function getSanitizeClipboard(pasteContent) {
        var regex = "<body(.*\n)*>(.*\n)*</body>";
        if (pasteContent.match(regex) && pasteContent.match(regex).length > 0) pasteContent = pasteContent.match(regex)[0].replace(/<\?body(.*\n)*\>/i);
        return pasteContent;
      }
      /**
       * gets toolbar currently assocatied with given editor
       *
       * @param {*} editor
       * @returns
       * @memberof RichTextEditorSelection
       */

    }, {
      key: "getConnectedToolbar",
      value: function getConnectedToolbar(editor) {
        if (!editor.id) editor.id = this._generateUUID();

        if (!editor.__connectedToolbar) {
          //get toolbar by id
          var toolbar,
              filter = !editor.toolbar ? [] : (this.__toolbars || []).filter(function (toolbar) {
            return toolbar.id === editor.toolbar;
          }); //get toolbar by type

          if (filter.length === 0) {
            filter = !editor.type ? [] : (this.__toolbars || []).filter(function (toolbar) {
              return toolbar.type === editor.type;
            });
          }

          if (filter[0]) {
            toolbar = filter[0];
          } else if (filter.length === 0) {
            //make toolbar
            toolbar = document.createElement(editor.type || "rich-text-editor-toolbar");
            editor.parentNode.insertBefore(toolbar, editor);
          }

          toolbar.id = editor.toolbar || this._generateUUID();
          editor.toolbar = toolbar.id;
          editor.__connectedToolbar = toolbar;
        }

        return editor.__connectedToolbar;
      }
      /**
       * selects and highlights a node
       *
       * @param {object} node
       * @param {object} toolbar
       * @returns {void}
       * @memberof RichTextEditorSelection
       */

    }, {
      key: "highlightNode",
      value: function highlightNode(node, toolbar) {
        this.selectNode(node, toolbar.range);
        this.highlight(toolbar);
      }
      /**
       * adds or removes hightlight
       * @param {object} contents contents to be highlighted
       * @param {boolean} [add=true] add highlight?
       * @returns {void}
       */

    }, {
      key: "highlight",
      value: function highlight(toolbar) {
        var add = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        this.toolbar = toolbar;
        var editor = toolbar.editor;

        if (add !== false) {
          if (toolbar.range) {
            this.hidden = false;
            toolbar.range.insertNode(this);
            toolbar.range.setStartAfter(this);
            this.range = toolbar.range;
          }
        } else {
          this.updateRange(toolbar.editor, toolbar.range);
          this.hidden = true;
          this.toolbar = undefined;
          this.range = undefined;
          document.body.appendChild(this);
        }
      }
      /**
       * gets clipboard data and pastes into an editor's range
       *
       * @param {obj} editor
       * @memberof RichTextEditorSelection
       */

    }, {
      key: "pasteFromClipboard",
      value: function pasteFromClipboard(editor) {
        var _this3 = this;

        console.log("pasteFromClipboard", editor);
        setTimeout( /*#__PURE__*/babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
          var sel, range, text;
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  sel = window.getSelection();
                  range = editor.range;
                  _context.next = 4;
                  return navigator.clipboard.readText();

                case 4:
                  text = _context.sent;
                  _this3.__clipboard.value = text;

                  _this3.__clipboard.focus();

                  _this3.__clipboard.select();

                  document.execCommand("paste");
                  sel.removeAllRanges();
                  sel.addRange(range);

                  _this3.pasteIntoEditor(editor, _this3.__clipboard.value);

                case 12:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        })), 2000);
      }
      /**
       * pastes content into editor's selected range
       *
       * @param {obj} editor editor
       * @param {obj} pasteContent content to paste
       * @param {boolean} [sanitize=true]
       * @memberof RichTextEditorSelection
       */

    }, {
      key: "pasteIntoEditor",
      value: function pasteIntoEditor(editor, pasteContent) {
        var sanitize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
        console.log("pasteIntoEditor", editor);
        if (editor) this.pasteIntoRange(editor, editor.range, sanitize ? this.getSanitizeClipboard(pasteContent) : pasteContent);
      }
      /**
       * paste content into a range
       *
       * @param {object} range where content will be pasted
       * @param {string} pasteContent html to be pasted
       * @returns {void}
       */

    }, {
      key: "pasteIntoRange",
      value: function pasteIntoRange(editor, range, pasteContent) {
        console.log("pasteIntoRange", editor);
        var div = document.createElement("div"),
            parent = range.commonAncestorContainer.parentNode,
            closest = parent.closest("[contenteditable=true]:not([disabled]),input:not([disabled]),textarea:not([disabled])");

        if (editor = closest) {
          div.innerHTML = pasteContent;

          if (range && range.extractContents) {
            range.extractContents();
          }

          range.insertNode(div);

          while (div.firstChild) {
            div.parentNode.insertBefore(div.firstChild, div);
          }

          div.parentNode.removeChild(div);
        }
      }
      /**
       * sets up editor's event listeners
       *
       * @param {object} editor
       * @param {boolean} [add=true]
       * @returns {object} toolbar
       * @memberof RichTextEditorSelection
       */

    }, {
      key: "registerEditor",
      value: function registerEditor(editor) {
        var _this4 = this;

        var remove = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var toolbar = !editor ? undefined : this.getConnectedToolbar(editor),
            handlers = {
          focus: function focus(e) {
            return _this4.edit(editor);
          },
          blur: function blur(e) {
            return _this4._handleBlur(editor, e);
          },
          keydown: function keydown(e) {
            return _this4._handleShortcutKeys(editor, e);
          },
          click: function click(e) {
            return _this4._handleEditorClick(editor, e);
          },
          getrange: function getrange(e) {
            _this4.toolbar = toolbar;

            _this4.updateRange(editor, editor.range);
          },
          pastefromclipboard: function pastefromclipboard(e) {
            return _this4.pasteFromClipboard(e.detail);
          },
          pastecontent: function pastecontent(e) {
            return _this4._handlePaste(e);
          }
        };

        if (!remove) {
          //add event listeners
          editor.addEventListener("mousedown", handlers.focus);
          editor.addEventListener("focus", handlers.focus);
          editor.addEventListener("keydown", handlers.keydown);
          editor.addEventListener("blur", handlers.blur);
          editor.addEventListener("getrange", handlers.getrange);
          editor.addEventListener("pastefromclipboard", handlers.pastefromclipboard);
          editor.addEventListener("pastecontent", handlers.pastecontent); //editor.addEventListener("click", handlers.click);
        } else {
          editor.removeEventListener("mousedown", handlers.focus);
          editor.removeEventListener("focus", handlers.focus);
          editor.removeEventListener("keydown", handlers.keydown);
          editor.removeEventListener("blur", handlers.blur);
          editor.removeEventListener("getrange", handlers.getrange);
          editor.removeEventListener("pastefromclipboard", handlers.pastefromclipboard);
          editor.removeEventListener("pastecontent", handlers.pastecontent);
        }

        return editor.__connectedToolbar;
      }
      /**
       * updates toolbar list
       *
       * @param {*} toolbar
       * @param {boolean} [remove=false]
       * @memberof RichTextEditorSelection
       */

    }, {
      key: "registerToolbar",
      value: function registerToolbar(toolbar) {
        var _this5 = this;

        var remove = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var handlers = {
          exec: function exec(e) {
            e.stopImmediatePropagation();

            _this5.execCommand(e.detail.command, e.detail.commandVal, e.detail.range, toolbar);
          },
          highlight: function highlight(e) {
            e.stopImmediatePropagation();

            _this5.highlight(toolbar.editor, e.detail);
          },
          highlightnode: function highlightnode(e) {
            e.stopImmediatePropagation();

            _this5.highlightNode(e.detail, toolbar);
          },
          selectnode: function selectnode(e) {
            e.stopImmediatePropagation();

            _this5.selectNode(e.detail, toolbar.range);
          },
          selectnodecontents: function selectnodecontents(e) {
            e.stopImmediatePropagation();

            _this5.selectNode(e.detail, toolbar.range);
          },
          selectrange: function selectrange(e) {
            e.stopImmediatePropagation();

            _this5.selectRange(e.detail, toolbar.editor);
          },
          pastefromclipboard: function pastefromclipboard(e) {
            e.stopImmediatePropagation();

            _this5.pasteFromClipboard(e.detail);
          },
          wrapselection: function wrapselection(e) {
            e.stopImmediatePropagation();

            _this5.surroundRange(e.detail, toolbar.range);
          }
        };

        if (!remove && !toolbar.registered) {
          this.__toolbars.push(toolbar);

          toolbar.addEventListener("command", handlers.exec);
          toolbar.addEventListener("highlight", handlers.highlight);
          toolbar.addEventListener("highlightnode", handlers.highlightnode);
          toolbar.addEventListener("selectnode", handlers.selectnode);
          toolbar.addEventListener("selectnodecontents", handlers.selectnodecontents);
          toolbar.addEventListener("selectrange", handlers.selectrange);
          toolbar.addEventListener("pastefromclipboard ", handlers.pastefromclipboard);
          toolbar.addEventListener("wrapselection ", handlers.wrapselection);
          toolbar.registered = true;
        } else {
          toolbar.registered = false;
          toolbar.removeEventListener("command", handlers.exec);
          toolbar.removeEventListener("highlight", handlers.highlight);
          toolbar.removeEventListener("highlightnode", handlers.highlightnode);
          toolbar.removeEventListener("selectnode", handlers.selectnode);
          toolbar.removeEventListener("selectnodecontents", handlers.selectnodecontents);
          toolbar.removeEventListener("selectrange", handlers.selectrange);
          toolbar.removeEventListener("pastefromclipboard ", handlers.pastefromclipboard);
          this.__toolbars = this.__toolbars.filter(function (bar) {
            return bar !== toolbar;
          });
        }
      }
      /**
       * sets selection range to specified node
       * @param {object} node node to select
       * @returns {void}
       */

    }, {
      key: "selectNode",
      value: function selectNode(node, range) {
        var editor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.toolbar.editor;

        if (range) {
          range.selectNode(node);
          if (editor) this.updateRange(editor, range);
        }
      }
      /**
       * sets selection range to specified node's contents
       * @param {object} node node to select
       * @returns {void}
       */

    }, {
      key: "selectNodeContents",
      value: function selectNodeContents(node, range) {
        var editor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.toolbar.editor;

        if (node) {
          if (!range) {
            var sel = window.getSelection();
            range = document.createRange();
            sel.removeAllRanges();
            sel.addRange(range);
          }

          if (editor) this.updateRange(editor);
        }
      }
      /**
       * selects or deselects(collapses) a range
       *
       * @param {object} range
       * @param {boolean} [select=true] select range?
       * @memberof RichTextEditorSelection
       */

    }, {
      key: "selectRange",
      value: function selectRange(range) {
        var select = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        var editor = arguments.length > 2 ? arguments[2] : undefined;

        if (range) {
          if (select) {
            var sel = window.getSelection();
            sel.removeAllRanges();
            sel.addRange(range);
          } else {
            if (!range.isCollapsed) range.collapse();
          }

          if (editor) this.updateRange(editor);
        }

        return range;
      }
    }, {
      key: "surroundRange",
      value: function surroundRange(node, range) {
        if (range) {
          range.surroundContents(node);
          if (editor) this.updateRange(editor);
        }

        return range;
      }
    }, {
      key: "updateRange",
      value: function updateRange(editor, range) {
        if (editor) {
          var toolbar = this.getConnectedToolbar(editor);
          this.toolbar = toolbar;
          if (!range) range = editor.range;
          editor.range = range;

          if (toolbar) {
            toolbar.selectedNode = editor.selectedNode;
            toolbar.selectionAncestors = editor.selectionAncestors;
            toolbar.range = range;
          }
        }
      }
      /**
       * Generate a UUID
       * @returns {string} unique id
       */

    }, {
      key: "_generateUUID",
      value: function _generateUUID() {
        var hex = Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
        return "rte-" + "ss-s-s-s-sss".replace(/s/g, hex);
      }
      /**
       * preserves highlight on editor selection when editor is not focus
       *
       * @param {*} editor
       * @param {*} e
       * @memberof RichTextEditorSelection
       */

    }, {
      key: "_handleBlur",
      value: function _handleBlur(editor, e) {
        if (e.relatedTarget === null || !e.relatedTarget.startsWith === "rich-text-editor") {
          this.edit(editor, true);
        } else if (editor) {
          this.highlight(editor);
        }
      }
    }, {
      key: "_handleEditorClick",
      value: function _handleEditorClick(editor, e) {
        var toolbar = !editor ? undefined : this.getConnectedToolbar(editor),
            target = (0, _utils.normalizeEventPath)(e)[0];
        /*if (editor.contenteditable && normalizeEventPath(e)[0] !== editor) {
          editor.range = editor.range;
          let button = toolbar.buttons.filter(
              button => button.tag === normalizeEventPath(e)[0].tagName.toLowerCase()
            ),
            range =
              editor.range
                ? editor.range
                : false,
            start =
              range && range.startContainer
                ? range.startContainer.childNodes[range.startOffset]
                : false,
            end =
              range && range.endContainer
                ? range.endContainer.childNodes[range.endOffset - 1]
                : false;
          if (button && button[0] && start === end && start === normalizeEventPath(e)[0]) {
            button[0]._buttonTap(e);
          } else if (button && button[0]) {
            this.selectNode(normalizeEventPath(e)[0],range);
          }
        } else if (editor.contenteditable){
          //this.selectNodeContents(editor);
        }*/
      }
      /**
       * registers parts of the editor so that selection can manage them
       *
       * @param {event} e
       * @memberof RichTextEditorSelection
       */

    }, {
      key: "_handleRegistration",
      value: function _handleRegistration(e) {
        if (e.detail) {
          if (e.detail.toolbar) this.registerToolbar(e.detail.toolbar, e.detail.remove);
          if (e.detail.editor) this.registerEditor(e.detail.editor, e.detail.remove);
        }
      }
      /**
       * when a shortcut key is pressed, fire keypressed event on button associated with it
       * @param {object} editor editor that detects a shortcut key
       * @param {event} e key event
       */

    }, {
      key: "_handleShortcutKeys",
      value: function _handleShortcutKeys(editor, e) {
        var toolbar = !editor ? undefined : this.getConnectedToolbar(editor);

        if (editor.contenteditable) {
          var key = e.key;
          if (e.shiftKey) key = "shift+" + key;
          if (e.altKey) key = "alt+" + key;

          if (window.navigator.platform === "MacIntel" && e.metaKey || e.ctrlKey) {
            key = "ctrl+" + key;
          }

          if (toolbar.shortcutKeys[key]) toolbar.shortcutKeys[key]._keysPressed(e);
        }
      }
    }]);
    return RichTextEditorSelection;
  }((0, _richTextEditorStyles.RichTextEditorStyles)(_litElement.LitElement));

  _exports.RichTextEditorSelection = RichTextEditorSelection;
  window.customElements.define(RichTextEditorSelection.tag, RichTextEditorSelection);
  window.RichTextEditorSelection = {};
  window.RichTextEditorSelection.instance = null;
  /**
   * Checks to see if there is an instance available, and if not appends one
   */

  window.RichTextEditorSelection.requestAvailability = function () {
    if (window.RichTextEditorSelection.instance == null) {
      window.RichTextEditorSelection.instance = document.createElement(RichTextEditorSelection.tag);
      document.body.appendChild(window.RichTextEditorSelection.instance);
    }

    return window.RichTextEditorSelection.instance;
  };
});