define(["exports", "../../../../lit-element/lit-element.js", "../rich-text-editor-styles.js"], function (_exports, _litElement, _richTextEditorStyles) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.RichTextEditorSelection = void 0;

  function _templateObject2_4f8bfe40019d11eb9027c17497ee62cd() {
    var data = babelHelpers.taggedTemplateLiteral(["\n        :host {\n          background-color: var(--rich-text-editor-selection-bg);\n          margin: 0;\n          padding: 0;\n          display: inline;\n        }\n        :host([hidden]) {\n          display: none;\n        }\n        :host([collapsed]):after {\n          content: '|';\n          color: var(--rich-text-editor-selection-bg);\n          background-color: transparent;\n        }\n\xA0\xA0\xA0\xA0\xA0\xA0"]);

    _templateObject2_4f8bfe40019d11eb9027c17497ee62cd = function _templateObject2_4f8bfe40019d11eb9027c17497ee62cd() {
      return data;
    };

    return data;
  }

  function _templateObject_4f8bfe40019d11eb9027c17497ee62cd() {
    var data = babelHelpers.taggedTemplateLiteral([" <slot></slot> "]);

    _templateObject_4f8bfe40019d11eb9027c17497ee62cd = function _templateObject_4f8bfe40019d11eb9027c17497ee62cd() {
      return data;
    };

    return data;
  }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  /**
   * `rich-text-editor-selection`
   * `a button for rich text editor (custom buttons can extend this)`
   *
   * @element rich-text-editor-selection
   * @demo ./demo/selection.html
   */
  var RichTextEditorSelection = /*#__PURE__*/function (_RichTextEditorStyles) {
    babelHelpers.inherits(RichTextEditorSelection, _RichTextEditorStyles);

    var _super = _createSuper(RichTextEditorSelection);

    babelHelpers.createClass(RichTextEditorSelection, [{
      key: "render",
      value: function render() {
        return (0, _litElement.html)(_templateObject_4f8bfe40019d11eb9027c17497ee62cd());
      }
    }], [{
      key: "tag",

      /**
       * Store tag name to make it easier to obtain directly.
       */
      get: function get() {
        return "rich-text-editor-selection";
      }
    }, {
      key: "styles",
      get: function get() {
        return [].concat(babelHelpers.toConsumableArray(babelHelpers.get(babelHelpers.getPrototypeOf(RichTextEditorSelection), "styles", this)), [(0, _litElement.css)(_templateObject2_4f8bfe40019d11eb9027c17497ee62cd())]);
      }
    }, {
      key: "properties",
      get: function get() {
        return {
          editor: {
            type: Object
          },
          collapsed: {
            type: Boolean,
            reflect: true,
            attribute: "collapsed"
          },
          hidden: {
            type: Boolean,
            reflect: true,
            attribute: "hidden"
          },
          observer: {
            type: Object
          },
          range: {
            type: Object
          },
          toolbar: {
            type: Object
          }
        };
      }
    }]);

    function RichTextEditorSelection() {
      var _this;

      babelHelpers.classCallCheck(this, RichTextEditorSelection);
      _this = _super.call(this);
      _this.hidden = true;
      document.addEventListener("selectionchange", function (e) {
        _this.range = _this.getRange();
      });
      document.addEventListener("select-rich-text-editor-editor", function (e) {
        _this._editorChange(e);
      });
      document.addEventListener("deselect-rich-text-editor-editor", function (e) {
        _this._editorChange(e);
      });

      _this.setAttribute("id", _this._generateUUID());

      return _this;
    }

    babelHelpers.createClass(RichTextEditorSelection, [{
      key: "updated",
      value: function updated(changedProperties) {
        var _this2 = this;

        babelHelpers.get(babelHelpers.getPrototypeOf(RichTextEditorSelection.prototype), "updated", this).call(this, changedProperties);
        changedProperties.forEach(function (oldValue, propName) {
          if (propName === "range") _this2._updateToolbar();
        });
      }
      /**
       * life cycle, element is disconnected
       */

    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        var _this3 = this;

        babelHelpers.get(babelHelpers.getPrototypeOf(RichTextEditorSelection.prototype), "disconnectedCallback", this).call(this);
        document.removeEventListener("selectionchange", function (e) {
          _this3.range = root.getRange();
        });
        document.removeEventListener("select-rich-text-editor-editor", function (e) {
          _this3._editorChange(e);
        });
        document.removeEventListener("deselect-rich-text-editor-editor", function (e) {
          _this3._editorChange(e);
        });
      }
      /**
       * expands selection to a specific ancestor or wraps selection in a default tag
       * @param {string} selector ancestor selector to find
       * @param {string} wrapTag tagName to use if ancestor cannot be found
       * @returns {object} selected node
       */

    }, {
      key: "expandSelection",
      value: function expandSelection(selector) {
        var range = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.range;
        var wrapTag = arguments.length > 2 ? arguments[2] : undefined;
        return this.selectAncestor(selector, range) || this.wrap(!!wrapTag ? document.createElement(wrapTag) : undefined);
      }
      /**
       * Normalizes selected range data.
       *
       * @returns {object} selected range
       */

    }, {
      key: "getRange",
      value: function getRange() {
        var sel = window.getSelection();

        if (sel.getRangeAt && sel.rangeCount) {
          return sel.getRangeAt(0);
        } else if (sel) {
          return sel;
        } else false;
      }
      /**
       * adds or removes hightlight
       * @param {object} contents contents to be highlighted
       * @returns {void}
       */

    }, {
      key: "addHighlight",
      value: function addHighlight() {
        if (!this.hidden) return;
        this.hidden = !this.range || this.range.collapsed;

        if (!this.hidden) {
          this.range.surroundContents(this);
          this.normalize();
          this.innerHTML = this.innerHTML.trim();
          this.range.selectNodeContents(this);
          this.dispatchEvent(new CustomEvent("highlight", {
            detail: this
          }));
          this.hidden = false;
        }
      }
      /**
       * gets contents of selected range
       * @returns {object} range contents
       */

    }, {
      key: "getRangeContents",
      value: function getRangeContents() {
        return this.range ? this.range.cloneContents() : null;
      }
      /**
       * searches for a closest ancestor by tagname,
       * expands selection to matching ancestor,
       * and returns ancestor, or returns null if not found
       * @param {string} tag tag to expand selection to
       * @returns {object} selected node
       */

    }, {
      key: "getAncestor",
      value: function getAncestor(selector) {
        var range = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.range;

        var wrapper,
            tags = selector.toLowerCase().split(","),
            getMatchingTag = function getMatchingTag(ancestor) {
          if (!!ancestor && !!ancestor.tagName && (!selector || tags.includes(ancestor.tagName.toLowerCase()))) {
            return ancestor;
          } else if (!!ancestor && !!ancestor.parentNode && ancestor.parentNode.childNodes.length === 1) {
            return getMatchingTag(ancestor.parentNode);
          } else {
            return undefined;
          }
        }; //try to find an ancestor that matches tag


        if (range) {
          var ancestor = range.commonAncestorContainer;
          wrapper = getMatchingTag(ancestor);
        }

        return wrapper;
      }
      /**
       * searches for a closest ancestor by tagname,
       * expands selection to matching ancestor,
       * and returns ancestor, or returns null if not found
       * @param {string} tag tag to expand selection to
       * @returns {object} selected node
       */

    }, {
      key: "selectAncestor",
      value: function selectAncestor(selector) {
        var range = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.range;
        var wrapper = this.getAncestor(selector, range);
        if (wrapper) range.selectNode(wrapper);
        return wrapper;
      }
      /**
       * sets selection range to specified node
       * @param {object} node node to select
       * @returns {void}
       */

    }, {
      key: "selectNode",
      value: function selectNode() {
        var node = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

        if (node) {
          if (!this.range) {
            var sel = window.getSelection();
            this.range = document.createRange();
            sel.removeAllRanges();
            sel.addRange(this.range);
          }

          this.range.selectNode(node);
        }

        return this.range;
      }
      /**
       * sets selection range to specified node's contents
       * @param {object} node node to select
       * @returns {void}
       */

    }, {
      key: "selectNodeContents",
      value: function selectNodeContents() {
        var node = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

        if (node) {
          if (!this.range) {
            var sel = window.getSelection();
            this.range = document.createRange();
            sel.removeAllRanges();
            sel.addRange(this.range);
          }

          this.range.selectNodeContents(node);
        }
      }
      /**
       * selects a range
       *
       * @param {object} range
       * @memberof RichTextEditorSelection
       */

    }, {
      key: "selectRange",
      value: function selectRange(range) {
        if (range) {
          var sel = window.getSelection();
          sel.removeAllRanges();
          sel.addRange(range);
        }
      }
      /**
       * collapses range
       *
       * @memberof RichTextEditorSelection
       */

    }, {
      key: "deselectRange",
      value: function deselectRange() {
        var sel = this.getRange();
        if (!sel.isCollapsed) sel.collapse();
      }
      /**
       * removes highlight from range
       *
       * @memberof RichTextEditorSelection
       */

    }, {
      key: "removeHighlight",
      value: function removeHighlight() {
        var _this4 = this;

        if (this.hidden) return;
        this.normalize();
        var children = this.childNodes;

        if (children.length > 0) {
          children.forEach(function (child, i) {
            _this4.parentNode.insertBefore(child, _this4);

            if (i === 0) _this4.range.setStart(child, 0);

            _this4.range.setEnd(child, 0);
          });
        } else if (this.previousSibling) {
          this.range.selectNode(this.previousSibling);
          this.range.collapse();
        } else if (this.nextSibling) {
          this.range.selectNode(this.nextSibling);
          this.range.collapse(true);
        } else if (this.parentNode) {
          this.range.selectNode(this.c);
          this.range.collapse(true);
        }

        this.hidden = true;
      }
      /**
       * gets range contents in specified wrapper
       * @param {object} wrapper a node to wrap range contents in
       * @returns {object} range which oncludes wrapper and wrapped contents
       */

    }, {
      key: "wrap",
      value: function wrap(wrapper) {
        wrapper = wrapper || document.createElement("span");
        this.range.surroundContents(wrapper);
        return wrapper;
      }
      /**
       * Updates selected range based on toolbar and editor
       * @param {event} e editor change event
       * @param {deselect} if editor is being deselected
       * @returns {void}
       */

    }, {
      key: "_editorChange",
      value: function _editorChange(e) {
        var deselect = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var root = this,
            editorChange = root.editor !== e.detail.editor,
            toolbarChange = root.toolbar !== e.detail.toolbar;

        if (deselect || editorChange || toolbarChange) {
          var sel = window.getSelection();
          sel.removeAllRanges();
          root.editor = e.detail.editor;
          root.toolbar = e.detail.toolbar;
          if (root.observer) root.observer.disconnect();

          if (!deselect && e.detail.editor) {
            root.observer = new MutationObserver(function (evt) {
              root.range = root.getRange();
            });
            root.observer.observe(e.detail.editor, {
              attributes: false,
              childList: true,
              subtree: true,
              characterData: false
            });
          }
        }
      }
      /**
       * Generate a UUID
       * @returns {string} unique id
       */

    }, {
      key: "_generateUUID",
      value: function _generateUUID() {
        var hex = Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
        return "rte-" + "ss-s-s-s-sss".replace(/s/g, hex);
      }
      /**
       * Updates toolbar
       */

    }, {
      key: "_updateToolbar",
      value: function _updateToolbar() {
        if (this.toolbar) this.toolbar.range = this.range;
      }
    }]);
    return RichTextEditorSelection;
  }((0, _richTextEditorStyles.RichTextEditorStyles)(_litElement.LitElement));

  _exports.RichTextEditorSelection = RichTextEditorSelection;
  window.customElements.define(RichTextEditorSelection.tag, RichTextEditorSelection);
  window.RichTextEditorSelection = {};
  window.RichTextEditorSelection.instance = null;
  /**
   * Checks to see if there is an instance available, and if not appends one
   */

  window.RichTextEditorSelection.requestAvailability = function () {
    if (window.RichTextEditorSelection.instance == null) {
      window.RichTextEditorSelection.instance = new RichTextEditorSelection();
      document.body.appendChild(window.RichTextEditorSelection.instance);
    }

    return window.RichTextEditorSelection.instance;
  };
});