define(["exports", "../../../../@polymer/polymer/polymer-element.js", "./rich-text-editor-button.js", "../../../simple-tooltip/simple-tooltip.js", "../../../../@polymer/iron-icons/iron-icons.js", "../singletons/rich-text-editor-selection.js", "../singletons/rich-text-editor-prompt.js", "./rich-text-editor-button-styles.js"], function (_exports, _polymerElement, _richTextEditorButton, _simpleTooltip, _ironIcons, _richTextEditorSelection, _richTextEditorPrompt, _richTextEditorButtonStyles) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.RichTextEditorPromptButton = void 0;

  /**
   * Copyright 2019 Penn State University
   * @license Apache-2.0, see License.md for full text.
   */

  /**
   * `rich-text-editor-prompt-button`
   * `a button that prompts for more information for rich text editor (custom buttons can extend this)`
   *
   * @microcopy - language worth noting:
   *  -
   *
  
   * @polymer
   */
  var RichTextEditorPromptButton =
  /*#__PURE__*/
  function (_RichTextEditorButton) {
    babelHelpers.inherits(RichTextEditorPromptButton, _RichTextEditorButton);

    function RichTextEditorPromptButton() {
      babelHelpers.classCallCheck(this, RichTextEditorPromptButton);
      return babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(RichTextEditorPromptButton).call(this));
    } // properties available to the custom element for data binding


    babelHelpers.createClass(RichTextEditorPromptButton, [{
      key: "ready",

      /**
       * life cycle, element is ready
       */
      value: function ready() {
        babelHelpers.get(babelHelpers.getPrototypeOf(RichTextEditorPromptButton.prototype), "ready", this).call(this);
        var root = this;
        this.__prompt = window.RichTextEditorPrompt.requestAvailability();
        this.__selection = window.RichTextEditorSelection.requestAvailability();
      }
      /**
       * Handles button tap
       * @param {event} e the button tap event
       */

    }, {
      key: "_buttonTap",
      value: function _buttonTap(e) {
        e.preventDefault();
        this.selectRange();
        this.open();
      }
      /**
       * cleans a field value if needed
       * @param {string} prop field property name
       * @returns {object} val the cleaned property value
       */

    }, {
      key: "getCleanValue",
      value: function getCleanValue(prop) {
        var val = this.value[prop];
        if (val && typeof val === "string") val = val.replace(/[\s\n\t]+/g, " ").trim();
        return val;
      }
      /**
       * updates the insertion based on fields
       */

    }, {
      key: "cancel",
      value: function cancel() {
        this.value = this.__oldValue;
        this.confirm();
      }
      /**
       * updates the insertion based on fields
       */

    }, {
      key: "confirm",
      value: function confirm() {
        this.updateSelection();
        this.deselect();
      }
      /**
       * deselects the text
       */

    }, {
      key: "deselect",
      value: function deselect() {
        this.__prompt.clearTarget("");

        this.__selection.normalize();

        this.__selection.parentNode.insertBefore(this.__selectionContents, this.__selection);

        this.__selection.range.selectNode(this.__selectionContents);

        this.__selection.range.collapse();

        this.__selection.hidden = true;
      }
      /**
       * Handles editor change
       * @param {string} newVal the new editor's id
       * @param {string} oldVal the old editor's id
       * @returns {void}
       */

    }, {
      key: "_editorChanged",
      value: function _editorChanged(newVal, oldVal) {
        var root = this,
            newEditor = newVal ? document.getElementById(newVal) : null,
            oldEditor = oldVal ? document.getElementById(oldVal) : null;
        if (newEditor) newEditor.addEventListener("click", function (e) {
          root._editInlineWidget(newEditor, e);
        }, true);
        if (oldEditor) oldEditor.removeEventListener("click", function (e) {
          root._editInlineWidget(oldEditor, e);
        }, true);
        babelHelpers.get(babelHelpers.getPrototypeOf(RichTextEditorPromptButton.prototype), "_editorChanged", this).call(this, newVal, oldVal);
      }
      /**
       *
       * @param {object} editor the active editor
       * @param {event} e the edit event
       * @returns {boolean} whether to prevent the default behavior for an inline widget
       */

    }, {
      key: "_editInlineWidget",
      value: function _editInlineWidget(editor, e) {
        if (editor.getAttribute("contenteditable") && this.inlineWidget && e.target.tagName && e.target.tagName.toLowerCase() === this.tag) {
          e.stopPropagation();
          e.preventDefault();
          this.selectWidget(e.target);
          this.open();
          return false;
        } else {
          return true;
        }
      }
    }, {
      key: "selectWidget",
      value: function selectWidget(widget) {
        this.__selection.selectNode(widget);

        this.__selectionContents = widget;
      }
    }, {
      key: "selectRange",
      value: function selectRange() {
        this.__selectionContents = this.__selection.expandSelection(this.tag);
      }
      /**
       * Handles selecting text and opening prompt
       */

    }, {
      key: "open",
      value: function open() {
        this.__selection.addHighlight();

        this.updatePrompt();

        this.__prompt.setTarget(this);

        this.dispatchEvent(new CustomEvent("select", {
          detail: this
        }));
      }
      /**
       * updates prompt fields with selected range data
       */

    }, {
      key: "updatePrompt",
      value: function updatePrompt() {
        var _this = this;

        this.__oldValue = this.value;
        var el = this.__selectionContents;
        this.__fields = [];
        el.normalize();
        el.innerHTML.trim();
        this.fields.forEach(function (field) {
          _this.__fields.push(field);

          if (field.property && field.property !== "") {
            _this.value[field.property] = el ? el.getAttribute(field.property) : null;
          } else if (field.slot && field.slot !== "") {
            _this.value[field.slot] = el & el.querySelector(field.slot) ? el.querySelector(field.slot).innerHTML.replace(/[\s\n\t]+/g, " ").trim() : null;
          } else {
            _this.value[""] = el ? el.innerHTML.replace(/[\s\n\t]+/g, " ").trim() : "";
            if (!_this.__slotInputMethod) _this.__slotInputMethod = field.inputMethod;

            if (el.childNodes.length === 1 && el.childNodes[0].nodeType !== Node.TEXT_NODE || el.childNodes.length > 1) {
              field.hidden = !_this.editableSelection;
              field.inputMethod = "code-editor";
            } else {
              field.inputMethod = _this.__slotInputMethod;
              field.hidden = false;
            }
          }
        });
      }
      /**
       * updates the insertion based on fields
       */

    }, {
      key: "updateSelection",
      value: function updateSelection() {
        var _this2 = this;

        this.__selection.innerHTML = "";
        var selection = document.createTextNode(this.getCleanValue(""));

        if (this._getTagNeeded(this.value)) {
          selection = document.createElement(this.tag);
          this.fields.forEach(function (field) {
            if (field.property) {
              selection.setAttribute(field.property, _this2.getCleanValue(field.property));
            } else if (field.slot && field.slot !== "") {
              var slot = _this2.getCleanValue(field.slot);

              selection.innerHTML += "<span slot=\"".concat(field.slot, "\">").concat(slot, "</slot>");
            } else {
              selection.innerHTML += "".concat(_this2.getCleanValue(""));
            }
          });
        } else {
          selection.innerHTML += "".concat(this.getCleanValue(""));
        }

        this.__selectionContents = selection;
        if (selection) this.__selection.appendChild(selection);
      }
      /**
       * determines if the tag is needed for the element
       * @param {object} value the prompt values
       * @returns {boolean} if the tag is needed for the element
       */

    }, {
      key: "_getTagNeeded",
      value: function _getTagNeeded(value) {
        return value && this.getCleanValue("") && this.getCleanValue("") !== "";
      }
    }], [{
      key: "properties",
      get: function get() {
        return {
          /**
           * if the selection is more than just a single text node, allow edits via code-editor?
           */
          editableSelection: {
            type: Boolean,
            value: false
          },

          /**
           * fields for the prompt popover.
           */
          fields: {
            type: Array,
            value: [{
              property: "",
              title: "Text",
              description: "The inner text",
              inputMethod: "textfield"
            }]
          },

          /**
           * is the element a custom inline widget element?
           */
          inlineWidget: {
            name: "inlineWidget",
            type: Boolean,
            value: false
          },

          /**
           * the tag that will wrap the selected range
           */
          tag: {
            name: "tag",
            type: String,
            value: "span"
          },

          /**
           * The prefilled value of the prompt
           */
          value: {
            type: Object,
            value: {
              "": null,
              id: null
            }
          },

          /**
           * fields for the prompt popover.
           */
          __fields: {
            type: Array,
            value: []
          },

          /**
           * the contents node inside the selected range
           */
          __oldValue: {
            name: "__oldValue",
            type: Object,
            value: null
          },

          /**
           * the prompt that pops up when button is pressed
           */
          __prompt: {
            name: "__prompt",
            type: Object,
            value: null
          },

          /**
           * the highlight surrounding the selected range
           */
          __selection: {
            name: "__selection",
            type: Object,
            value: null
          },

          /**
           * the contents node inside the selected range
           */
          __selectionContents: {
            name: "__selectionContents",
            type: Object,
            value: null
          }
        };
      }
      /**
       * Store the tag name to make it easier to obtain directly.
       */

    }, {
      key: "tag",
      get: function get() {
        return "rich-text-editor-prompt-button";
      }
    }]);
    return RichTextEditorPromptButton;
  }(_richTextEditorButton.RichTextEditorButton);

  _exports.RichTextEditorPromptButton = RichTextEditorPromptButton;
  window.customElements.define(RichTextEditorPromptButton.tag, RichTextEditorPromptButton);
});