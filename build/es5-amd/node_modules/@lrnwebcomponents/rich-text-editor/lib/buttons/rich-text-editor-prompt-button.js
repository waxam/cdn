define(["exports", "../../../../lit-element/lit-element.js", "./rich-text-editor-button.js", "../singletons/rich-text-editor-selection.js", "../singletons/rich-text-editor-prompt.js"], function (_exports, _litElement, _richTextEditorButton, _richTextEditorSelection, _richTextEditorPrompt) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.RichTextEditorPromptButtonBehaviors = _exports.RichTextEditorPromptButton = void 0;

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var RichTextEditorPromptButtonBehaviors = function RichTextEditorPromptButtonBehaviors(SuperClass) {
    return /*#__PURE__*/function (_RichTextEditorButton) {
      babelHelpers.inherits(_class, _RichTextEditorButton);

      var _super = _createSuper(_class);

      babelHelpers.createClass(_class, [{
        key: "render",
        // render function for template
        value: function render() {
          return babelHelpers.get(babelHelpers.getPrototypeOf(_class.prototype), "render", this).call(this);
        } // properties available to custom element for data binding

      }], [{
        key: "tag",

        /**
         * Store tag name to make it easier to obtain directly.
         */
        get: function get() {
          return "rich-text-editor-prompt-button";
        }
      }, {
        key: "properties",
        get: function get() {
          return _objectSpread(_objectSpread({}, babelHelpers.get(babelHelpers.getPrototypeOf(_class), "properties", this)), {}, {
            /**
             * fields for prompt popover.
             */
            fields: {
              type: Array
            },

            /**
             * is element a custom inline widget element?
             */
            inlineWidget: {
              name: "inlineWidget",
              type: Boolean
            },

            /**
             * is element a custom inline widget element?
             */
            id: {
              name: "id",
              type: String,
              reflect: true,
              attribute: "id"
            },

            /**
             * tag that will wrap selected range
             */
            tag: {
              name: "tag",
              type: String
            },

            /**
             * prefilled value of prompt
             */
            value: {
              type: Object
            },

            /**
             * prompt that pops up when button is pressed
             */
            prompt: {
              name: "prompt",
              type: Object
            },

            /**
             * contents node inside selected range
             */
            __wrap: {
              name: "__wrap",
              type: Object
            },

            /**
             * contents node inside selected range
             */
            __oldValue: {
              name: "__oldValue",
              type: Object
            }
          });
        }
      }]);

      function _class() {
        var _this;

        babelHelpers.classCallCheck(this, _class);
        _this = _super.call(this);
        _this.editableSelection = false;
        _this.inlineWidget = false;
        _this.fields = [{
          property: "innerHTML",
          title: "Text",
          inputMethod: "textfield"
        }];
        _this.tag = "span";
        _this.value = {
          innerHTML: undefined
        };
        _this.prompt = window.RichTextEditorPrompt.requestAvailability();
        return _this;
      }
      /**
       * determines which command based on values passed from prompt
       * (can be overriden for custom prompt  commands)
       *
       * @readonly
       */


      babelHelpers.createClass(_class, [{
        key: "cancel",

        /**
         * override to add function to cancelled prompt
         */
        value: function cancel() {}
        /**
         * updates insertion based on fields
         */

      }, {
        key: "confirm",
        value: function confirm(val) {
          this.value = val;
          this.update();
          this.setToggled();
          this.promptCommandVal;
          this.updateSelection();
        }
        /**
         * expands selection to include this.tag
         *
         */

      }, {
        key: "expandSelection",
        value: function expandSelection() {
          var element = this.rangeQuery();
          if (element) this.highlightNode(element);
        }
        /**
         * if selection is a node, gets node innerHTML
         *
         * @returns {string}
         */

      }, {
        key: "getInnerHTML",
        value: function getInnerHTML() {
          var target = this.range && this.range.cloneContents ? this.range.cloneContents() : undefined,
              root = this.rangeElement() ? this.rangeElement() : undefined,
              temp,
              html;

          if (this.rangeIsElement()) {
            html = root ? root.innerHTML : undefined;
          } else {
            temp = document.createElement("span");
            if (target) temp.appendChild(target);
            html = temp.innerHTML;
            temp.remove();
          }

          return html;
        }
        /**
         * gets a field value (and trims it if it's a string)
         *
         * @param {string} prop field name
         * @returns {*}
         * @memberof RichTextEditorPrompt
         */

      }, {
        key: "getPropValue",
        value: function getPropValue(prop) {
          var val = !!this.value ? this.value : false,
              rawVal = !val || !val[prop] ? false : val[prop].trim ? val[prop].trim() : val[prop];
          return rawVal && rawVal !== "" ? rawVal : false;
        }
        /**
         * gets value for prompt based on current selection
         * (can be overriden for custom prompt field values)
         */

      }, {
        key: "getValue",
        value: function getValue() {
          return {
            innerHTML: this.getInnerHTML() || ""
          };
        }
        /**
         * Handles selecting text and opening prompt
         */

      }, {
        key: "open",
        value: function open() {
          this.expandSelection();
          this.value = this.getValue();
          this.prompt.fields = babelHelpers.toConsumableArray(this.fields);
          this.prompt.value = _objectSpread({}, this.value);
          this.dispatchEvent(new CustomEvent("rich-text-editor-prompt-open", {
            bubbles: true,
            cancelable: true,
            composed: true,
            detail: this
          }));
        }
        /**
         * sets inner HTML of selection
         *
         * @param {string} html
         */

      }, {
        key: "setInnerHTML",
        value: function setInnerHTML(html) {
          var target = this.rangeElement();

          if (target && this.rangeIsElement()) {
            target.innerHTML = html;
          } else if (this.range) {
            this.sendCommand("insertHtml", html);
          }
        }
        /**
         * updates toggled based on values passed from prompt
         * (can be overriden for custom toggled state)
         */

      }, {
        key: "setToggled",
        value: function setToggled() {
          this.toggled = !this.value;
        }
        /**
         * updates selection based on values passed from prompt
         */

      }, {
        key: "updateSelection",
        value: function updateSelection() {
          var range = this.range.cloneRange();
          this.sendCommand(this.promptCommand, this.promptCommandVal);
          this.selectRange(range);
          if (this.setsInnerHTML) this.setInnerHTML(this.getPropValue("innerHTML"));
        }
        /**
         * Handles button tap
         * @param {event} e button tap event
         */

      }, {
        key: "_buttonTap",
        value: function _buttonTap(e) {
          e.preventDefault();
          this.open();
        }
        /**
         * Handles range change
         * @param {event} e button tap event
         */

      }, {
        key: "_rangeChanged",
        value: function _rangeChanged(newVal, oldVal) {
          this.value = this.getValue();
          this.setToggled();
        }
      }, {
        key: "promptCommand",
        get: function get() {
          return this.toggledCommand && !this.toggled ? this.toggledCommand : this.command;
        }
        /**
         * determaines commandVal based on values passed from prompt
         * (can be overriden for custom prompt command values)
         */

      }, {
        key: "promptCommandVal",
        get: function get() {
          return this.commandVal;
        }
        /**
         * determaines if prompt also sets innerHTML of range
         * (can be overriden for custom prompts)
         */

      }, {
        key: "setsInnerHTML",
        get: function get() {
          var innerHTML = (this.fields || []).filter(function (field) {
            return field.property === "innerHTML";
          });
          return innerHTML && innerHTML.length > 0;
        }
      }]);
      return _class;
    }((0, _richTextEditorButton.RichTextEditorButtonBehaviors)(SuperClass));
  };
  /**
   * `rich-text-editor-prompt-button`
   * a button that prompts for more information for rich text editor (custom buttons can extend this)
   *
   * @element rich-text-editor-prompt-button
   * @demo ./demo/buttons.html
   */


  _exports.RichTextEditorPromptButtonBehaviors = RichTextEditorPromptButtonBehaviors;

  var RichTextEditorPromptButton = /*#__PURE__*/function (_RichTextEditorPrompt) {
    babelHelpers.inherits(RichTextEditorPromptButton, _RichTextEditorPrompt);

    var _super2 = _createSuper(RichTextEditorPromptButton);

    function RichTextEditorPromptButton() {
      babelHelpers.classCallCheck(this, RichTextEditorPromptButton);
      return _super2.apply(this, arguments);
    }

    return RichTextEditorPromptButton;
  }(RichTextEditorPromptButtonBehaviors(_litElement.LitElement));

  _exports.RichTextEditorPromptButton = RichTextEditorPromptButton;
  window.customElements.define(RichTextEditorPromptButton.tag, RichTextEditorPromptButton);
});