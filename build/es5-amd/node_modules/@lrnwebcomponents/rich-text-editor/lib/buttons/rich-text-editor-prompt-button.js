define(["exports", "../../../../lit-element/lit-element.js", "./rich-text-editor-button.js", "../singletons/rich-text-editor-selection.js", "../singletons/rich-text-editor-prompt.js"], function (_exports, _litElement, _richTextEditorButton, _richTextEditorSelection, _richTextEditorPrompt) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.RichTextEditorPromptButtonBehaviors = _exports.RichTextEditorPromptButton = void 0;

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var RichTextEditorPromptButtonBehaviors = function RichTextEditorPromptButtonBehaviors(SuperClass) {
    return /*#__PURE__*/function (_RichTextEditorButton) {
      babelHelpers.inherits(_class, _RichTextEditorButton);

      var _super = _createSuper(_class);

      babelHelpers.createClass(_class, [{
        key: "render",
        // render function for template
        value: function render() {
          return babelHelpers.get(babelHelpers.getPrototypeOf(_class.prototype), "render", this).call(this);
        } // properties available to the custom element for data binding

      }], [{
        key: "tag",

        /**
         * Store the tag name to make it easier to obtain directly.
         */
        get: function get() {
          return "rich-text-editor-prompt-button";
        }
      }, {
        key: "properties",
        get: function get() {
          return _objectSpread(_objectSpread({}, babelHelpers.get(babelHelpers.getPrototypeOf(_class), "properties", this)), {}, {
            /**
             * fields for the prompt popover.
             */
            fields: {
              type: Array
            },

            /**
             * is the element a custom inline widget element?
             */
            inlineWidget: {
              name: "inlineWidget",
              type: Boolean
            },

            /**
             * the tag that will wrap the selected range
             */
            tag: {
              name: "tag",
              type: String
            },

            /**
             * The prefilled value of the prompt
             */
            value: {
              type: Object
            },

            /**
             * fields for the prompt popover.
             */
            __promptFields: {
              type: Array
            },

            /**
             * the contents node inside the selected range
             */
            __oldValue: {
              name: "__oldValue",
              type: Object
            },

            /**
             * the prompt that pops up when button is pressed
             */
            __prompt: {
              name: "__prompt",
              type: Object
            },

            /**
             * the contents node inside the selected range
             */
            __selectionContents: {
              name: "__selectionContents",
              type: Object
            }
          });
        }
      }]);

      function _class() {
        var _this;

        babelHelpers.classCallCheck(this, _class);
        _this = _super.call(this);
        _this.editableSelection = false;
        _this.inlineWidget = false;
        _this.fields = [{
          slot: "",
          title: "Text",
          description: "The inner text",
          inputMethod: "textfield"
        }];
        _this.tag = "span";
        _this.value = {
          "": null,
          id: null
        };
        _this.__prompt = window.RichTextEditorPrompt.requestAvailability();
        return _this;
      }
      /**
       * Handles button tap
       * @param {event} e the button tap event
       */


      babelHelpers.createClass(_class, [{
        key: "_buttonTap",
        value: function _buttonTap(e) {
          e.preventDefault();

          var block = this._getSelectedBlock();

          this.__selection.selectRange(this.range);

          if (block) {
            this.range.selectNode(block);
          } else {
            this.__selection.wrap();
          }

          this.__selection.addHighlight();

          this.range = this.__selection.range;
          this.open();
        }
        /**
         * cancels the changes
         */

      }, {
        key: "cancel",
        value: function cancel() {
          this.__selection.removeHighlight();
        }
        /**
         * updates the insertion based on fields
         */

      }, {
        key: "confirm",
        value: function confirm() {
          this.updateSelection();

          this.__selection.removeHighlight();
        }
        /**
         * Handles editor change
         * @param {string} newVal the new editor's id
         * @param {string} oldVal the old editor's id
         * @returns {void}
         */

      }, {
        key: "_editorChanged",
        value: function _editorChanged(newVal, oldVal) {
          var _this2 = this;

          var newEditor = newVal ? document.getElementById(newVal) : null,
              oldEditor = oldVal ? document.getElementById(oldVal) : null;
          if (newEditor) newEditor.addEventListener("click", function (e) {
            return _this2._editInlineWidget(newEditor, e);
          }, true);
          if (oldEditor) oldEditor.removeEventListener("click", function (e) {
            return _this2._editInlineWidget(oldEditor, e);
          }, true);
          babelHelpers.get(babelHelpers.getPrototypeOf(_class.prototype), "_editorChanged", this).call(this, newVal, oldVal);
        }
        /**
         *
         * @param {object} editor the active editor
         * @param {event} e the edit event
         * @returns {boolean} whether to prevent the default behavior for an inline widget
         */

      }, {
        key: "_editInlineWidget",
        value: function _editInlineWidget(editor, e) {
          if (editor.getAttribute("contenteditable") && this.inlineWidget && e.target.tagName && e.target.tagName.toLowerCase() === this.tag) {
            e.stopPropagation();
            e.preventDefault();
            this.selectWidget(e.target);
            this.open();
            return false;
          } else {
            return true;
          }
        }
      }, {
        key: "selectWidget",
        value: function selectWidget(widget) {
          this.__selection.selectNode(widget);

          this.__selectionContents = widget;
        }
        /**
         * Handles selecting text and opening prompt
         */

      }, {
        key: "open",
        value: function open() {
          this.updatePrompt();

          this.__prompt.setTarget(this);
        }
        /**
         * updates prompt fields with selected range data
         */

      }, {
        key: "updatePrompt",
        value: function updatePrompt() {
          this.__selectionContents = this.__selection.firstChild;
          this.__promptFields = JSON.parse(JSON.stringify(this.fields));
        }
        /**
         * updates the insertion based on fields
         */

      }, {
        key: "updateSelection",
        value: function updateSelection() {
          this.__selectionContents = this._getSelectedBlock() || this.__selection;
          this.setRange();
          this.toggled = !this.__prompt.value;
          this.commandVal = this.__prompt.value;
          this.execCommand();
        }
      }, {
        key: "setRange",
        value: function setRange() {
          this.__selection.selectRange(this.range);
        }
      }]);
      return _class;
    }((0, _richTextEditorButton.RichTextEditorButtonBehaviors)(SuperClass));
  };
  /**
   * `rich-text-editor-prompt-button`
   * a button that prompts for more information for rich text editor (custom buttons can extend this)
   *
   * @element rich-text-editor-prompt-button
   * @demo ./demo/buttons.html
   */


  _exports.RichTextEditorPromptButtonBehaviors = RichTextEditorPromptButtonBehaviors;

  var RichTextEditorPromptButton = /*#__PURE__*/function (_RichTextEditorPrompt) {
    babelHelpers.inherits(RichTextEditorPromptButton, _RichTextEditorPrompt);

    var _super2 = _createSuper(RichTextEditorPromptButton);

    function RichTextEditorPromptButton() {
      babelHelpers.classCallCheck(this, RichTextEditorPromptButton);
      return _super2.apply(this, arguments);
    }

    return RichTextEditorPromptButton;
  }(RichTextEditorPromptButtonBehaviors(_litElement.LitElement));

  _exports.RichTextEditorPromptButton = RichTextEditorPromptButton;
  window.customElements.define(RichTextEditorPromptButton.tag, RichTextEditorPromptButton);
});