define(["exports", "../../../../@polymer/polymer/polymer-element.js", "../../../../@polymer/paper-button/paper-button.js", "../../../simple-tooltip/simple-tooltip.js", "../../../../@polymer/iron-a11y-keys/iron-a11y-keys.js", "../../../../@polymer/iron-icons/iron-icons.js", "./rich-text-editor-button-styles.js", "../singletons/rich-text-editor-selection.js"], function (_exports, _polymerElement, _paperButton, _simpleTooltip, _ironA11yKeys, _ironIcons, _richTextEditorButtonStyles, _richTextEditorSelection) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.RichTextEditorButton = void 0;

  function _templateObject_967e8bd0c96f11ea8be5e1d5fe7ec787() {
    var data = babelHelpers.taggedTemplateLiteral(["\n      <style include=\"rich-text-editor-button-styles\">\n        :host .rtebutton {\n          min-width: var(--rich-text-editor-button-min-width);\n          height: var(--rich-text-editor-button-height);\n          margin: var(--rich-text-editor-button-margin);\n          padding: var(--rich-text-editor-button-padding);\n        }\n      </style>\n      <iron-a11y-keys\n        id=\"a11y\"\n        target=\"[[__a11y]]\"\n        keys=\"enter\"\n        on-keys-pressed=\"_buttonTap\"\n      >\n      </iron-a11y-keys>\n      <paper-button\n        id=\"button\"\n        class=\"rtebutton\"\n        disabled$=\"[[disabled]]\"\n        controls$=\"[[controls]]\"\n        on-click=\"_buttonTap\"\n        tabindex=\"0\"\n        toggled$=\"[[toggled]]\"\n      >\n        <iron-icon\n          id=\"icon\"\n          aria-hidden\n          icon$=\"[[_regOrToggled(icon,toggledIcon,toggled)]]\"\n        >\n        </iron-icon>\n        <span id=\"label\" class$=\"[[labelStyle]]\">[[__label]]</span>\n      </paper-button>\n      <simple-tooltip id=\"tooltip\" for=\"button\">[[__label]]</simple-tooltip>\n    "]);

    _templateObject_967e8bd0c96f11ea8be5e1d5fe7ec787 = function _templateObject_967e8bd0c96f11ea8be5e1d5fe7ec787() {
      return data;
    };

    return data;
  }

  /**
   * `rich-text-editor-button`
   * `a button for rich text editor (custom buttons can extend this)`
   *
   * @microcopy - language worth noting:
   *  -
   *
  
   * @polymer
   */
  var RichTextEditorButton =
  /*#__PURE__*/
  function (_PolymerElement) {
    babelHelpers.inherits(RichTextEditorButton, _PolymerElement);

    function RichTextEditorButton() {
      babelHelpers.classCallCheck(this, RichTextEditorButton);
      return babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(RichTextEditorButton).apply(this, arguments));
    }

    babelHelpers.createClass(RichTextEditorButton, [{
      key: "ready",

      /**
       * life cycle, element is ready
       */
      value: function ready() {
        babelHelpers.get(babelHelpers.getPrototypeOf(RichTextEditorButton.prototype), "ready", this).call(this);
        var root = this;
        root.addEventListener("mousedown", function (e) {
          console.log("mousedown", e);
        });
        root.addEventListener("keypress", function (e) {
          e.preventDefault();
        });
      }
      /**
       * life cycle, element is afixed to the DOM
       */

    }, {
      key: "connectedCallback",
      value: function connectedCallback() {
        babelHelpers.get(babelHelpers.getPrototypeOf(RichTextEditorButton.prototype), "connectedCallback", this).call(this);
        this.__a11y = this.shadowRoot.querySelector("#button");
      }
      /**
       * life cycle, element is detatched
       */

    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        babelHelpers.get(babelHelpers.getPrototypeOf(RichTextEditorButton.prototype), "disconnectedCallback", this).call(this);
      }
      /**
       * excutes the button's command
       */

    }, {
      key: "doTextOperation",
      value: function doTextOperation() {
        var root = this,
            range = root.range;

        if (root.toggled && root.toggledCommand !== null) {
          document.execCommand(root.toggledCommand, false, root.toggledCommand || "");
        } else if (root.command !== null) {
          root.dispatchEvent(new CustomEvent(root.command + "-button", {
            bubbles: true,
            cancelable: true,
            composed: true,
            detail: root
          }));
          console.log("doTextOperation", range, root.command, false, root.commandVal || "");
          document.execCommand(root.command, false, root.commandVal || "");
          root.range = range;
        }
      }
      /**
       * Handles button tap
       */

    }, {
      key: "_buttonTap",
      value: function _buttonTap(e) {
        e.preventDefault();
        console.log("_buttonTap", e);
        this.doTextOperation();
      }
      /**
       * Handles editor change
       * @param {string} newVal the new editor's id
       * @param {string} oldVal the old editor's id
       * @returns {void}
       */

    }, {
      key: "_editorChanged",
      value: function _editorChanged(newVal, oldVal) {
        var root = this;
        root.dispatchEvent(new CustomEvent(root.command + "-button-editor-change", {
          bubbles: true,
          cancelable: true,
          composed: true,
          detail: root
        }));
      }
      /**
       * determine if the button is toggled
       *
       * @param {object} the text selected range
       * @param {string} the default command
       * @param {boolean} whether the button toggles
       * @returns {string} the label based on whether or not the button is toggled
       *
       */

    }, {
      key: "_getLabel",
      value: function _getLabel(range, command, toggles) {
        var toggled = this.command !== null && toggles ? document.queryCommandState(command) : false,
            label = this._regOrToggled(this.label, this.toggledLabel, toggled);

        return label;
      }
      /**
       * determine if the button is toggled
       *
       * @param {object} the text selected range
       * @returns {boolean} whether the button is toggled
       *
       */

    }, {
      key: "_isToggled",
      value: function _isToggled(range) {
        var toggled = this.command !== null && this.toggles ? document.queryCommandState(this.command) : false;
        /*,
        label = this._regOrToggled(this.label, this.toggledLabel, toggled);
        if (this.shadowRoot.querySelector('#label') !== undefined) this.shadowRoot.querySelector('#label').innerHTML = label;
        if (this.shadowRoot.querySelector('#tooltip') !== undefined) this.shadowRoot.querySelector('#tooltip').innerHTML = label*/

        return toggled;
      }
      /**
       * Handles keys the same way a button is handled
       * @param {event} e the  event
       */

    }, {
      key: "_keysPressed",
      value: function _keysPressed(e) {
        console.log("_keysPressed", e);
        e.preventDefault();

        this._buttonTap(e);
      }
      /**
       * updates a button value based on whether or not button is toggled
       *
       * @param {string} the value when toggled off
       * @param {string} the value when toggled on
       * @param {boolean} whether the button is toggled
       * @returns {string} the correct value based on
       * whether or not the button is toggled
       */

    }, {
      key: "_regOrToggled",
      value: function _regOrToggled(toggledOff, toggledOn, toggled) {
        return toggledOn !== null && toggled ? toggledOn : toggledOff;
      }
      /**
       * Determines if an iron icon has been named for the button.
       *
       * @param {string} the name of the icon
       * @returns {boolean} if an icon is named
       */

    }, {
      key: "_labelStyle",
      value: function _labelStyle(icon, showTextLabel) {
        return icon !== undefined && icon !== null && icon !== "" && showTextLabel === false ? "offscreen" : null;
      }
    }], [{
      key: "template",
      // render function
      get: function get() {
        return (0, _polymerElement.html)(_templateObject_967e8bd0c96f11ea8be5e1d5fe7ec787());
      } // properties available to the custom element for data binding

    }, {
      key: "properties",
      get: function get() {
        return {
          /**
           * The `id` of the `rich-text-editor` that the toolbar controls.
           */
          controls: {
            name: "controls",
            type: String,
            observer: "_editorChanged"
          },

          /**
           * The command used for document.execCommand.
           */
          command: {
            name: "command",
            type: String
          },

          /**
           * Optional parameter for the command.
           */
          commandVal: {
            name: "commandVal",
            type: Object,
            value: null,
            notify: true
          },

          /**
           * Is the button disabled? Default is false.
           */
          disabled: {
            name: "disabled",
            type: Boolean,
            value: false
          },

          /**
           * Optional iron icon name for the button.
           */
          icon: {
            name: "icon",
            type: String,
            value: null
          },

          /**
           * Label for the icon.
           */
          label: {
            name: "label",
            type: String,
            value: null
          },

          /**
           * Hide the label offscreen?
           */
          labelStyle: {
            name: "labelStyle",
            type: String,
            computed: "_labelStyle(icon,showTextLabel)",
            readOnly: true
          },

          /**
           * The active selected range, inherited from the toolbar
           */
          range: {
            name: "range",
            type: Object,
            notify: true,
            value: null
          },

          /**
           * Optional space-sperated list of keyboard shortcuts for the editor
           * to fire this button, see iron-a11y-keys for more info.
           */
          shortcutKeys: {
            name: "shortcutKeys",
            type: String,
            value: null
          },

          /**
           * Show text label even if an icon is named?
           */
          showTextLabel: {
            name: "showTextLabel",
            type: Boolean,
            value: false
          },

          /**
           * The active selected range, inherited from the toolbar
           */
          target: {
            name: "target",
            type: Object,
            value: null
          },

          /**
           * Is this button toggled?
           */
          toggled: {
            name: "toggled",
            type: Boolean,
            computed: "_isToggled(range)",
            notify: true
          },

          /**
           * The label for the button based on its toggled state
           */
          __label: {
            name: "__label",
            type: String,
            computed: "_getLabel(range,command,toggles)",
            notify: true
          },

          /**
           * The command used for document.execCommand when toggled.
           */
          toggledCommand: {
            name: "toggledCommand",
            type: String,
            value: null
          },

          /**
           * Optional parameter for the command when toggled.
           */
          toggledCommandVal: {
            name: "toggledCommandVal",
            type: Object,
            value: null
          },

          /**
           * Optional iron icon name for the button if it is toggled.
           */
          toggledIcon: {
            name: "toggledIcon",
            type: String,
            value: null
          },

          /**
           * Label for the icon, if button is toggled.
           */
          toggledLabel: {
            name: "toggledLabel",
            type: String,
            value: null
          },

          /**
           * Can this button toggle?
           */
          toggles: {
            name: "toggles",
            type: Boolean,
            value: false
          },

          /**
           * List of valid commands
           */
          validCommands: {
            name: "validCommands",
            type: Array,
            value: ["backColor", "bold", "createLink", "copy", "cut", "defaultParagraphSeparator", "delete", "fontName", "fontSize", "foreColor", "formatBlock", "forwardDelete", "insertHorizontalRule", "insertHTML", "insertImage", "insertLineBreak", "insertOrderedList", "insertParagraph", "insertText", "insertUnorderedList", "justifyCenter", "justifyFull", "justifyLeft", "justifyRight", "outdent", "paste", "redo", "selectAll", "strikethrough", "styleWithCss", "superscript", "undo", "unlink", "useCSS"],
            readOnly: true
          }
        };
      }
      /**
       * Store the tag name to make it easier to obtain directly.
       */

    }, {
      key: "tag",
      get: function get() {
        return "rich-text-editor-button";
      }
    }]);
    return RichTextEditorButton;
  }(_polymerElement.PolymerElement);

  _exports.RichTextEditorButton = RichTextEditorButton;
  window.customElements.define(RichTextEditorButton.tag, RichTextEditorButton);
});