define(["exports", "require", "../../../../lit-element/lit-element.js", "./rich-text-editor-button-styles.js", "../singletons/rich-text-editor-selection.js", "../../../simple-icon/lib/simple-icon-lite.js", "../../../simple-icon/lib/simple-icons.js", "../../../simple-icon/lib/simple-icon-button-lite.js", "../../../hax-iconset/lib/simple-hax-iconset.js"], function (_exports, _require, _litElement, _richTextEditorButtonStyles, _richTextEditorSelection, _simpleIconLite, _simpleIcons, _simpleIconButtonLite, _simpleHaxIconset) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.RichTextEditorButtonBehaviors = _exports.RichTextEditorButton = void 0;
  _require = babelHelpers.interopRequireWildcard(_require);

  function _templateObject2_e5fec530576311eba9ce094baa5ca644() {
    var data = babelHelpers.taggedTemplateLiteral(["\n          .rtebutton {\n            min-width: var(--rich-text-editor-button-min-width);\n            height: var(--rich-text-editor-button-height);\n            margin: var(--rich-text-editor-button-margin);\n            padding: var(--rich-text-editor-button-padding);\n          }\n  \xA0\xA0\xA0\xA0\xA0\xA0"]);

    _templateObject2_e5fec530576311eba9ce094baa5ca644 = function _templateObject2_e5fec530576311eba9ce094baa5ca644() {
      return data;
    };

    return data;
  }

  function _templateObject_e5fec530576311eba9ce094baa5ca644() {
    var data = babelHelpers.taggedTemplateLiteral(["\n        <button\n          id=\"button\"\n          class=\"rtebutton\"\n          ?disabled=\"", "\"\n          ?controls=\"", "\"\n          @click=\"", "\"\n          tabindex=\"0\"\n          ?toggled=\"", "\"\n        >\n          <simple-icon-lite\n            id=\"icon\"\n            aria-hidden=\"true\"\n            icon=\"", "\"\n          >\n          </simple-icon-lite>\n          <span id=\"label\" class=\"", "\"\n            >", "</span\n          >\n        </button>\n        <simple-tooltip id=\"tooltip\" for=\"button\"\n          >", "</simple-tooltip\n        >\n      "]);

    _templateObject_e5fec530576311eba9ce094baa5ca644 = function _templateObject_e5fec530576311eba9ce094baa5ca644() {
      return data;
    };

    return data;
  }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var RichTextEditorButtonBehaviors = function RichTextEditorButtonBehaviors(SuperClass) {
    return /*#__PURE__*/function (_RichTextEditorButton) {
      babelHelpers.inherits(_class, _RichTextEditorButton);

      var _super = _createSuper(_class);

      babelHelpers.createClass(_class, [{
        key: "firstUpdated",
        value: function firstUpdated(changedProperties) {
          var _this2 = this;

          if (babelHelpers.get(babelHelpers.getPrototypeOf(_class.prototype), "firstUpdated", this)) {
            babelHelpers.get(babelHelpers.getPrototypeOf(_class.prototype), "firstUpdated", this).call(this, changedProperties);
          }

          this.__a11y = this.shadowRoot.querySelector("#button");

          this.__a11y.addEventListener("keypress", function (e) {
            switch (e.key) {
              case "Enter":
                _this2._buttonTap(e);

                break;
            }
          });
        }
        /**
         * Store the tag name to make it easier to obtain directly.
         */

      }, {
        key: "render",
        value: function render() {
          return (0, _litElement.html)(_templateObject_e5fec530576311eba9ce094baa5ca644(), this.disabled, this.controls, this._buttonTap, this.isToggled, this.currentIcon, this.labelStyle, this.currentLabel, this.currentLabel);
        }
      }], [{
        key: "tag",
        get: function get() {
          return "rich-text-editor-button";
        }
      }, {
        key: "styles",
        get: function get() {
          return [].concat(babelHelpers.toConsumableArray(babelHelpers.get(babelHelpers.getPrototypeOf(_class), "styles", this)), [(0, _litElement.css)(_templateObject2_e5fec530576311eba9ce094baa5ca644())]);
        }
      }, {
        key: "properties",
        get: function get() {
          return {
            /**
             * The `id` of the `rich-text-editor` that the toolbar controls.
             */
            controls: {
              type: String
            },

            /**
             * The command used for document.execCommand.
             */
            command: {
              type: String
            },

            /**
             * Optional parameter for the command.
             */
            commandVal: {
              attribute: "command-val",
              type: Object
            },

            /**
             * Is the button disabled? Default is false.
             */
            disabled: {
              type: Boolean
            },

            /**
             * Optional iron icon name for the button.
             */
            icon: {
              type: String
            },

            /**
             * Label for the icon.
             */
            label: {
              type: String
            },

            /**
             * The active selected range, inherited from the toolbar
             */
            range: {
              type: Object
            },

            /**
             * Optional space-sperated list of keyboard shortcuts for the editor
             */
            shortcutKeys: {
              attribute: "shortcut-keys",
              type: String
            },

            /**
             * Show text label even if an icon is named?
             */
            showTextLabel: {
              attribute: "show-text-label",
              type: Boolean
            },

            /**
             * The active selected range, inherited from the toolbar
             */
            tag: {
              type: String
            },

            /**
             * The active selected range, inherited from the toolbar
             */
            target: {
              type: Object
            },

            /**
             * The command used for document.execCommand when toggled.
             */
            toggledCommand: {
              attribute: "toggled-command",
              type: String
            },

            /**
             * Optional parameter for the command when toggled.
             */
            toggledCommandVal: {
              attribute: "toggled-command-val",
              type: Object
            },

            /**
             * Optional iron icon name for the button if it is toggled.
             */
            toggledIcon: {
              attribute: "toggled-icon",
              type: String
            },

            /**
             * Label for the icon, if button is toggled.
             */
            toggledLabel: {
              attribute: "toggled-label",
              type: String
            },

            /**
             * currently selected node
             */
            selectedNode: {
              type: Object
            },

            /**
             * array of ancestors of currently selected node
             */
            selectionAncestors: {
              type: Array
            },

            /**
             * Can this button toggle?
             */
            toggles: {
              type: Boolean
            },

            /**
             * highlight surrounding selected range
             */
            __selection: {
              type: Object
            }
          };
        }
      }]);

      function _class() {
        var _this;

        babelHelpers.classCallCheck(this, _class);
        _this = _super.call(this);
        _this.__selection = window.RichTextEditorSelection.requestAvailability();
        _this.disabled = false;
        _this.showTextLabel = false;
        _this.toggles = false;
        new Promise(function (res, rej) {
          return _require.default(["../../../simple-tooltip/simple-tooltip.js"], res, rej);
        });
        return _this;
      }

      babelHelpers.createClass(_class, [{
        key: "updated",
        value: function updated(changedProperties) {
          var _this3 = this;

          babelHelpers.get(babelHelpers.getPrototypeOf(_class.prototype), "updated", this).call(this, changedProperties);
          changedProperties.forEach(function (oldValue, propName) {
            if (propName === "controls") _this3._editorChanged(_this3.controls, oldValue);
            if (propName === "range") _this3._rangeChanged(_this3.range, oldValue);
          });
        }
        /**
         * life cycle, element is detatched
         */

      }, {
        key: "disconnectedCallback",
        value: function disconnectedCallback() {
          babelHelpers.get(babelHelpers.getPrototypeOf(_class.prototype), "disconnectedCallback", this).call(this);
        }
        /**
         * gets command param for document.execCommand
         * @readonly
         */

      }, {
        key: "highlight",

        /**
         * indicates how highlight should be toggled
         * @event highlight
         * @param {boolean} [on=true] whether to turn highlight on
         */
        value: function highlight() {
          var on = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
          this.dispatchEvent(new CustomEvent("highlight", {
            bubbles: true,
            composed: true,
            cancelable: true,
            detail: on
          }));
        }
        /**
         * indicates node that should be highlighted
         * @event highlightnode
         * @param {object} node
         */

      }, {
        key: "highlightNode",
        value: function highlightNode(node) {
          this.dispatchEvent(new CustomEvent("highlightnode", {
            bubbles: true,
            composed: true,
            cancelable: true,
            detail: node
          }));
        }
        /**
         * indicates range to be set
         * @event selectrange
         * @param {object} range
         */

      }, {
        key: "selectRange",
        value: function selectRange(range) {
          this.dispatchEvent(new CustomEvent("selectrange", {
            bubbles: true,
            composed: true,
            cancelable: true,
            detail: range
          }));
        }
        /**
         * indicates range should be a given node
         * @event selectnode
         * @param {object} node
         */

      }, {
        key: "selectNode",
        value: function selectNode(node) {
          this.dispatchEvent(new CustomEvent("selectnode", {
            bubbles: true,
            composed: true,
            cancelable: true,
            detail: node
          }));
        }
        /**
         * indicates range should be the contents of a given node
         * @event selectnodeccontents
         * @param {object} node
         */

      }, {
        key: "selectNodeContents",
        value: function selectNodeContents(node) {
          this.dispatchEvent(new CustomEvent("selectnodeccontents", {
            bubbles: true,
            composed: true,
            cancelable: true,
            detail: node
          }));
        }
        /**
         * indicates range should be wrapped in given element
         * @event wrapselection
         * @param {object} element html element
         */

      }, {
        key: "wrapSelection",
        value: function wrapSelection(element) {
          this.dispatchEvent(new CustomEvent("wrapselection", {
            bubbles: true,
            composed: true,
            cancelable: true,
            detail: element
          }));
        }
        /**
         * gets node where range starts
         *
         * @returns node
         */

      }, {
        key: "startNode",
        value: function startNode() {
          var startContainer = !this.range ? undefined : this.range.startContainer,
              startOffset = !this.range ? undefined : this.range.startOffset;
          return !startContainer ? undefined : startContainer.children ? startContainer.children[startOffset - 1] : startContainer.childNodes ? startContainer.childNodes[startOffset - 1] : undefined;
        }
        /**
         * gets closest element to range
         *
         * @returns node
         */

      }, {
        key: "rangeElement",
        value: function rangeElement() {
          return this.rangeIsElement() ? this.startNode() : this.rangeParent();
        }
        /**
         * determines if selection is a element node
         *
         * @returns node
         */

      }, {
        key: "rangeIsElement",
        value: function rangeIsElement() {
          var startContainer = !this.range ? undefined : this.range.startContainer,
              startOffset = !this.range ? undefined : this.range.startOffset,
              endContainer = !this.range ? undefined : this.range.endContainer,
              endOffset = !this.range ? undefined : this.range.endOffset;
          return startContainer === endContainer && endOffset - startOffset === 1;
        }
        /**
         * gets parent element of range
         *
         * @returns node
         */

      }, {
        key: "rangeParent",
        value: function rangeParent() {
          var common = !this.range ? undefined : this.range.commonAncestorContainer;
          return !common ? undefined : common.nodeType == 1 ? common : common.parentElement;
        }
        /**
         * gets closest node to range that matches selectors
         *
         * @param {string} [selectors=this.blockSelectors || this.tag]
         * @returns node
         */

      }, {
        key: "rangeQuery",
        value: function rangeQuery() {
          var selectors = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.blockSelectors || this.tag;
          selectors = selectors.toLowerCase().replace(/\s*/g, "");
          var start = this.rangeElement(),
              startTag = !start || !start.tagName ? undefined : start.tagName.toLowerCase(),
              tags = selectors.split(",");
          return !start ? undefined : startTag && tags.includes(startTag) ? start : start.closest(selectors);
        }
        /**
         * sends a command to the selection manager
         *
         * @param {string} [command=this.operationCommand]
         * @param {string} [commandVal=this.operationCommandVal]
         */

      }, {
        key: "sendCommand",
        value: function sendCommand() {
          var command = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.operationCommand;
          var commandVal = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.operationCommandVal;
          this.dispatchEvent(new CustomEvent("command", {
            bubbles: true,
            cancelable: true,
            composed: true,
            detail: {
              command: command,
              commandVal: commandVal,
              range: this.range
            }
          }));
        }
        /**
         * expands range to selection's parent block
         */

      }, {
        key: "setRange",
        value: function setRange() {
          /* if command is formatBlock expand selection to entire block */
          var block = this.rangeQuery();
          if (block) this.selectNode(block);
        }
        /**
         * Handles button tap
         */

      }, {
        key: "_buttonTap",
        value: function _buttonTap(e) {
          console.log("_buttonTap", this.range);
          e.preventDefault();
          this.sendCommand();
        }
        /**
         * handles range change
         *
         * @param {string} newVal new editor id
         * @param {string} oldVal old editor id
         */

      }, {
        key: "_editorChanged",
        value: function _editorChanged(newValue, oldValue) {}
        /**
         * gets appplicable selection
         * @returns {object}
         */

      }, {
        key: "_getSelection",
        value: function _getSelection() {
          return this.command === "formatBlock" ? this.rangeQuery() : this._getSelectedHtml();
        }
        /**
         * gets selected html
         * @returns {string}
         */

      }, {
        key: "_getSelectedHtml",
        value: function _getSelectedHtml() {
          if (this.range) {
            var div = document.createElement("div"),
                contents = this.range.cloneContents(),
                val;
            div.appendChild(contents);
            val = div.innerHTML;
            div.remove();
            return val ? val.trim() : undefined;
          }

          return undefined;
        }
        /**
         * get selection's parent block
         *
         * @returns
         */

      }, {
        key: "_getSelectedTag",
        value: function _getSelectedTag() {
          var block = this.rangeQuery(),
              tag = !!block && !!block.tagName ? block.tagName.toLowerCase() : false;
          return tag;
        }
        /**
         * gets appplicable selection
         * @returns {object}
         */

      }, {
        key: "_getSelectionType",
        value: function _getSelectionType() {
          return this.command === "formatBlock" ? this._getSelectedTag() : this._getSelectedHtml();
        }
        /**
         * Handles keys the same way a button is handled
         * @param {event} e the  event
         */

      }, {
        key: "_keysPressed",
        value: function _keysPressed(e) {
          e.preventDefault();

          this._buttonTap(e);
        }
        /**
         * handles range change
         *
         * @param {object} newVal new range
         * @param {object} oldVal old range
         */

      }, {
        key: "_rangeChanged",
        value: function _rangeChanged(newVal, oldVal) {}
        /**
         * updates a button value based on whether or not button is toggled
         *
         * @param {string} the value when toggled off
         * @param {string} the value when toggled on
         * @param {boolean} whether the button is toggled
         * @returns {string} the correct value based on
         * whether or not the button is toggled
         */

      }, {
        key: "_regOrToggled",
        value: function _regOrToggled(toggledOff, toggledOn, toggled) {
          return !!toggledOn && toggled ? toggledOn : toggledOff;
        }
      }, {
        key: "blockSelectors",
        get: function get() {
          return "p,h1,h2,h3,h4,h5,h6,div,address,blockquote,pre";
        }
        /**
         * current label based on toggled state
         *
         * @readonly
         * @memberof RichTextEditorButton
         */

      }, {
        key: "currentLabel",
        get: function get() {
          return this._regOrToggled(this.label, this.toggledLabel, this.isToggled);
        }
        /**
         * current icon based on toggled state
         *
         * @readonly
         * @memberof RichTextEditorButton
         */

      }, {
        key: "currentIcon",
        get: function get() {
          return this._regOrToggled(this.icon, this.toggledIcon, this.isToggled);
        }
        /**
         * label is offscreen (screenreader-only)
         *
         * @readonly
         * @memberof RichTextEditorButton
         */

      }, {
        key: "labelStyle",
        get: function get() {
          return !!this.icon && this.icon !== "" && this.showTextLabel === false ? "offscreen" : null;
        }
        /**
         * whether button is toggled
         *
         * @readonly
         * @memberof RichTextEditorButton
         */

      }, {
        key: "isToggled",
        get: function get() {
          var command = !!this.range && !!this.command ? document.queryCommandState(this.command) : false,

          /* workaround because queryCommandState("underline") returns true on links */
          block = this.command === "underline" ? !!this.rangeQuery("u") : command;
          return this.toggles && !!block ? true : false;
        }
        /**
         * gets valid commands list
         *
         * @readonly
         * @memberof RichTextEditorButton
         */

      }, {
        key: "validCommands",
        get: function get() {
          return ["backColor", "bold", "createLink", "copy", "cut", "defaultParagraphSeparator", "delete", "fontName", "fontSize", "foreColor", "formatBlock", "forwardDelete", "insertHorizontalRule", "insertHTML", "insertImage", "insertLineBreak", "insertOrderedList", "insertParagraph", "insertText", "insertUnorderedList", "justifyCenter", "justifyFull", "justifyLeft", "justifyRight", "outdent", "paste", "redo", "selectAll", "strikethrough", "styleWithCss", "superscript", "undo", "unlink", "useCSS"];
        }
      }, {
        key: "operationCommand",
        get: function get() {
          return this.isToggled && !!this.toggledCommand ? this.toggledCommand : this.command;
        }
        /**
         * gets value param for document.execCommand
         * @readonly
         */

      }, {
        key: "operationCommandVal",
        get: function get() {
          return this.isToggled && !!this.toggledCommand ? this.toggledCommandVal || "" : this.commandVal;
        }
      }]);
      return _class;
    }((0, _richTextEditorButtonStyles.RichTextEditorButtonStyles)(SuperClass));
  };
  /**
   * `rich-text-editor-button`
   * a button for rich text editor (custom buttons can extend this)
   *
   * @element rich-text-editor-button
   * @demo ./demo/buttons.html
   */


  _exports.RichTextEditorButtonBehaviors = RichTextEditorButtonBehaviors;

  var RichTextEditorButton = /*#__PURE__*/function (_RichTextEditorButton2) {
    babelHelpers.inherits(RichTextEditorButton, _RichTextEditorButton2);

    var _super2 = _createSuper(RichTextEditorButton);

    function RichTextEditorButton() {
      babelHelpers.classCallCheck(this, RichTextEditorButton);
      return _super2.apply(this, arguments);
    }

    return RichTextEditorButton;
  }(RichTextEditorButtonBehaviors(_litElement.LitElement));

  _exports.RichTextEditorButton = RichTextEditorButton;
  window.customElements.define(RichTextEditorButton.tag, RichTextEditorButton);
});