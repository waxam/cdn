var gulp = require("gulp");

var fs = require("fs");

var path = require("path");

var _ = require("lodash");

var rename = require("gulp-rename");

var replace = require("gulp-replace");

var stripCssComments = require("strip-css-comments");

var decomment = require("decomment");

var sourcemaps = require("gulp-sourcemaps");

var packageJson = require("./package.json"); // merge all the src files together


gulp.task("merge", function () {
  return gulp.src("./src/" + packageJson.wcfactory.elementName + ".js").pipe(replace(/\/\* REQUIRED FOR TOOLING DO NOT TOUCH \*\//g, function (classStatement, character, jsFile) {
    // pull these off the package wcfactory files area
    var html = fs.readFileSync(path.join("./", packageJson.wcfactory.files.html)).toString().trim();
    html = decomment(html);
    var haxString = "";

    if (packageJson.wcfactory.useHAX) {
      var HAXProps = fs.readFileSync(path.join("./", packageJson.wcfactory.files.hax));
      haxString = "\n  // haxProperty definition\n  static get haxProperties() {\n    return ".concat(HAXProps, ";\n  }");
    }

    var rawprops = "{}";
    rawprops = fs.readFileSync(path.join("./", packageJson.wcfactory.files.properties));
    var props = "".concat(rawprops),
        comma = props.replace(/\/\*[\s\S]*?\*\//g, "").replace(/\/\/.*/g, "").replace(/[\{\s\n\}]/g, "");
    props = props.replace(/\"type\": \"(\w+)\"/g, '"type": $1'), superprops = comma === "" ? "...super.properties" : "...super.properties,";
    props = props.replace(/\{([\s\n]*)/, "{$1$1".concat(superprops, "$1$1"));
    var cssResult = "";

    if (packageJson.wcfactory.useSass && packageJson.wcfactory.files.scss) {
      var sass = require("node-sass");

      cssResult += sass.renderSync({
        file: path.join("./", packageJson.wcfactory.files.scss)
      }).css;
    } else if (packageJson.wcfactory.files.css) {
      cssResult += fs.readFileSync(path.join("./", packageJson.wcfactory.files.css));
    }

    var styleRegex = /\/\*[\s]*LIST SHARED STYLES BELOW[\s]*((?:(?:\w+)[\s,]*)*)\*\//g,
        styleArray = cssResult.match(styleRegex) && cssResult.match(styleRegex).length > 0 ? cssResult.match(styleRegex)[0].replace(styleRegex, "$1").match(/(\w+)[\s,]*/g) : [];
    sharedStyles = styleArray && styleArray.length > 0 ? styleArray.map(function (style) {
      return style.replace(/(\w+)[\s,]*/g, "\n        $1");
    }) : "";
    cssResult = stripCssComments(cssResult).trim();
    var litResult = packageJson.wcfactory.customElementClass !== "LitElement" ? "" : "\n  //styles function\n  static get styles() {\n    return  [".concat(sharedStyles ? "".concat(sharedStyles, ",") : "", "\n      css`\n").concat(cssResult, "\n      `\n    ];\n  }"),
        styleResult = packageJson.wcfactory.customElementClass !== "LitElement" ? "<style>\n".concat(cssResult, "\n        </style>") : "";
    return "".concat(litResult, "\n  // render function\n  static get template() {\n    return html`\n").concat(styleResult, "\n").concat(html, "`;\n  }\n").concat(haxString, "\n  // properties available to the custom element for data binding\n    static get properties() {\n    return ").concat(props, ";\n  }");
  })).pipe(gulp.dest("./"));
}); // run polymer analyze to generate documentation

gulp.task("analyze", function () {
  var exec = require("child_process").exec;

  return exec("polymer analyze --input demo/index.html > analysis.json", function (error, stdout, stderr) {
    if (error !== null) {
      console.log("exec error: " + error);
    }
  });
}); // copy from the built locations pulling them together

gulp.task("compile", function () {
  // copy outputs
  gulp.src("./" + packageJson.wcfactory.elementName + ".js").pipe(rename({
    suffix: ".es6"
  })).pipe(gulp.dest("./"));
  return gulp.src("./" + packageJson.wcfactory.elementName + ".js").pipe(replace(/^(import .*?)(['"]\.\.\/(?!\.\.\/).*)(\.js['"];)$/gm, "$1$2.umd$3")).pipe(rename({
    suffix: ".umd"
  })).pipe(gulp.dest("./"));
});
gulp.task("watch", function () {
  return gulp.watch("./src/*", gulp.series("merge", "analyze"));
}); // shift build files around a bit and build source maps

gulp.task("sourcemaps", function () {
  return gulp.src("./" + packageJson.wcfactory.elementName + ".es6.js").pipe(sourcemaps.init()).pipe(sourcemaps.write("./"));
});
gulp.task("dev", gulp.series("merge", "analyze", "watch"));
gulp.task("default", gulp.series("merge", "analyze", "compile", "sourcemaps"));