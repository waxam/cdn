define(["exports"], function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.PerformanceDetect = _exports.DeviceDetails = void 0;

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  // register globally so we can make sure there is only one
  window.PerformanceDetectManager = window.PerformanceDetectManager || {}; // request if this exists. This helps invoke the element existing in the dom
  // as well as that there is only one of them. That way we can ensure everything
  // is rendered through the same modal

  window.PerformanceDetectManager.requestAvailability = function () {
    if (!window.PerformanceDetectManager.instance) {
      window.PerformanceDetectManager.instance = document.createElement("performance-detect");
      document.body.appendChild(window.PerformanceDetectManager.instance);
    }

    return window.PerformanceDetectManager.instance;
  };

  var DeviceDetails = window.PerformanceDetectManager.requestAvailability();
  _exports.DeviceDetails = DeviceDetails;

  var PerformanceDetect = /*#__PURE__*/function (_HTMLElement) {
    babelHelpers.inherits(PerformanceDetect, _HTMLElement);

    var _super = _createSuper(PerformanceDetect);

    function PerformanceDetect() {
      var _this;

      babelHelpers.classCallCheck(this, PerformanceDetect);
      _this = _super.call(this);
      _this.details = _this.updateDetails();
      return _this;
    }

    babelHelpers.createClass(PerformanceDetect, [{
      key: "badDevice",
      value: // test device for ANY poor setting
      function () {
        var _badDevice = babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
          var _i, _Object$entries, _Object$entries$_i, key, value;

          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _i = 0;
                  _context.t0 = Object;
                  _context.next = 4;
                  return this.details;

                case 4:
                  _context.t1 = _context.sent;
                  _Object$entries = _context.t0.entries.call(_context.t0, _context.t1);

                case 6:
                  if (!(_i < _Object$entries.length)) {
                    _context.next = 13;
                    break;
                  }

                  _Object$entries$_i = babelHelpers.slicedToArray(_Object$entries[_i], 2), key = _Object$entries$_i[0], value = _Object$entries$_i[1];

                  if (!value) {
                    _context.next = 10;
                    break;
                  }

                  return _context.abrupt("return", true);

                case 10:
                  _i++;
                  _context.next = 6;
                  break;

                case 13:
                  return _context.abrupt("return", false);

                case 14:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));

        function badDevice() {
          return _badDevice.apply(this, arguments);
        }

        return badDevice;
      }() // return any details

    }, {
      key: "getDetails",
      value: function getDetails() {
        var detail = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

        switch (detail) {
          case "memory":
            return this.details.lowMemory;
            break;

          case "processor":
            return this.details.lowProcessor;
            break;

          case "battery":
            return this.details.lowBattery;
            break;

          case "connection":
            return this.details.poorConnection;
            break;

          case "data":
            return this.details.dataSaver;
            break;
        }

        return this.details;
      }
    }, {
      key: "updateDetails",
      value: function () {
        var _updateDetails = babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
          var details;
          return regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  details = {
                    lowMemory: false,
                    lowProcessor: false,
                    lowBattery: false,
                    poorConnection: false,
                    dataSaver: false
                  };

                  if (navigator) {
                    // if less than a gig we know its bad
                    if (navigator.deviceMemory && navigator.deviceMemory < 1) {
                      details.lowMemory = true;
                    } // even phones have multi-core processors so another sign


                    if (navigator.hardwareConcurrency && navigator.hardwareConcurrency < 2) {
                      details.lowProcessor = true;
                    } // some platforms support getting the battery status


                    if (navigator.getBattery) {
                      navigator.getBattery().then(function (battery) {
                        // if we are not charging AND we have under 25% be kind
                        if (!battery.charging && battery.level < 0.25) {
                          details.lowBattery = true;
                        }
                      });
                    } // some things report the "type" of internet connection speed
                    // for terrible connections lets save frustration


                    if (navigator.connection && navigator.connection.effectiveType && ["slow-2g", "2g", "3g"].includes(navigator.connection.effectiveType)) {
                      details.poorConnection = true;
                    } // see if they said "hey, save me data"


                    if (navigator.connection && navigator.connection.saveData) {
                      details.dataSaver = true;
                    }
                  }

                  return _context2.abrupt("return", details);

                case 3:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2);
        }));

        function updateDetails() {
          return _updateDetails.apply(this, arguments);
        }

        return updateDetails;
      }()
    }], [{
      key: "tag",
      get: function get() {
        return "performance-detect";
      }
    }]);
    return PerformanceDetect;
  }( /*#__PURE__*/babelHelpers.wrapNativeSuper(HTMLElement));

  _exports.PerformanceDetect = PerformanceDetect;
  customElements.define(PerformanceDetect.tag, PerformanceDetect);
});