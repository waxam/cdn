define(["exports", "require", "../../@polymer/polymer/polymer-element.js", "../../@polymer/polymer/lib/utils/render-status.js", "../../@polymer/polymer/lib/legacy/polymer.dom.js", "../hax-body-behaviors/lib/HAXWiring.js", "../../@polymer/iron-a11y-keys/iron-a11y-keys.js", "../responsive-utility/responsive-utility.js", "../simple-colors/simple-colors.js"], function (_exports, _require, _polymerElement, _renderStatus, _polymerDom, _HAXWiring, _ironA11yKeys, _responsiveUtility, _simpleColors) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.GridPlate = void 0;
  _require = babelHelpers.interopRequireWildcard(_require);

  function _templateObject_10df0990b49511e9bfd4f79a8a57e0f7() {
    var data = babelHelpers.taggedTemplateLiteral(["\n      <style>\n        :host {\n          display: block;\n          --grid-plate-row-margin: 0px;\n          --grid-plate-row-padding: 0px;\n          --grid-plate-item-margin: 15px;\n          --grid-plate-editable-border-color: #bbbbbb;\n          --grid-plate-active-border-color: #000000;\n          --grid-plate-col-transition: all 0.2s ease-in-out;\n        }\n        :host .row {\n          width: 100%;\n          display: flex;\n          flex-wrap: wrap;\n          justify-content: space-between;\n          align-items: stretch;\n          margin: var(--grid-plate-row-margin);\n          padding: var(--grid-plate-row-padding);\n        }\n        :host .column {\n          width: 100%;\n          flex: 0 0 auto;\n          transition: var(--grid-plate-col-transition);\n        }\n        :host([edit-mode]) .column {\n          min-height: 150px;\n        }\n        :host([edit-mode]) .column {\n          outline: 1px dotted var(--grid-plate-editable-border-color);\n        }\n        :host .column[style=\"min-height: unset\"] {\n          display: none;\n        }\n        :host([edit-mode]) .column[style=\"min-height: unset\"]:not(:empty) {\n          display: block;\n          outline: 1px solid red;\n          width: 20%;\n          margin-top: var(--grid-plate-item-margin);\n        }\n        :host([edit-mode])\n          .column[style=\"min-height: unset\"]:not(:empty):before {\n          content: \"Layout hides this column (\" attr(id) \")\";\n          color: red;\n          margin: var(--grid-plate-item-margin);\n          padding: 15px 0;\n          min-height: 150px;\n        }\n        :host .column ::slotted(*) {\n          margin: var(--grid-plate-item-margin);\n          padding: var(--grid-plate-item-margin);\n          transition: var(--grid-plate-col-transition);\n        }\n        :host([edit-mode]) .column ::slotted(img) {\n          display: block;\n          width: calc(100% - 32px - var(--grid-plate-item-margin));\n        }\n        :host([edit-mode]) .column ::slotted(.mover) {\n          outline: 2px dashed var(--grid-plate-editable-border-color);\n          outline-offset: 4px;\n        }\n        :host([edit-mode]) .column.mover {\n          outline: 2px dashed var(--grid-plate-editable-border-color);\n          outline-offset: 0px;\n        }\n        :host([edit-mode]) .column ::slotted(.active-item) {\n          outline: 2px dashed var(--grid-plate-active-border-color);\n          background-color: var(--simple-colors-default-theme-yellow-1);\n          outline-offset: 4px;\n        }\n        :host([edit-mode]) .column ::slotted(*:focus),\n        :host([edit-mode]) .column ::slotted(*:hover),\n        :host([edit-mode]) .column ::slotted(*:active) {\n          cursor: move;\n          background-color: var(--simple-colors-default-theme-yellow-3);\n        }\n        :host([edit-mode]) .column ::slotted(.mover) {\n          background-color: var(--simple-colors-default-theme-orange-1);\n          padding: 16px;\n        }\n        :host([edit-mode]) .column ::slotted([data-draggable].mover:hover) {\n          background-color: var(--simple-colors-default-theme-yellow-2);\n        }\n        :host([edit-mode]) .column.mover {\n          content: \"Double click to create a paragraph here\";\n          background-color: var(--simple-colors-default-theme-orange-1);\n        }\n        :host([edit-mode]) .column.mover:hover {\n          background-color: var(--simple-colors-default-theme-yellow-1);\n        }\n        :host([edit-mode]) .column ::slotted(.hovered) {\n          background-color: var(\n            --simple-colors-default-theme-orange-3\n          ) !important;\n          outline: dashed 4px var(--grid-plate-active-border-color);\n        }\n        :host([edit-mode]) .column.hovered {\n          background-color: var(\n            --simple-colors-default-theme-orange-3\n          ) !important;\n        }\n        paper-icon-button {\n          display: none;\n          position: absolute;\n          margin: 0;\n          padding: 0;\n          outline: none;\n          width: 20px;\n          height: 20px;\n          color: black;\n          background-color: #eeeeee;\n          border-radius: 50%;\n          box-sizing: content-box !important;\n          z-index: 1;\n          min-width: unset;\n        }\n\n        paper-icon-button[disabled] {\n          color: #aaa;\n          background-color: #ddd;\n        }\n        paper-icon-button[disabled]:focus,\n        paper-icon-button[disabled]:hover {\n          cursor: not-allowed;\n        }\n        paper-icon-button.active {\n          display: block;\n        }\n\n        .button-holding-pen {\n          position: relative;\n        }\n      </style>\n      <div class=\"button-holding-pen\">\n        <paper-icon-button\n          icon=\"icons:arrow-upward\"\n          title=\"move item up\"\n          id=\"up\"\n          on-click=\"moveActiveElement\"\n        >\n        </paper-icon-button>\n        <paper-icon-button\n          icon=\"icons:arrow-forward\"\n          title=\"move item right\"\n          id=\"right\"\n          on-click=\"moveActiveElement\"\n        >\n        </paper-icon-button>\n        <paper-icon-button\n          icon=\"icons:arrow-downward\"\n          title=\"move item down\"\n          id=\"down\"\n          on-click=\"moveActiveElement\"\n        >\n        </paper-icon-button>\n        <paper-icon-button\n          icon=\"icons:arrow-back\"\n          title=\"move item left\"\n          id=\"left\"\n          on-click=\"moveActiveElement\"\n        >\n        </paper-icon-button>\n      </div>\n      <div class=\"row\">\n        <div\n          class=\"column\"\n          id=\"col1\"\n          style$=\"[[_getColumnWidth(0,columnWidths)]]\"\n        >\n          <slot name=\"col-1\"></slot>\n        </div>\n        <div\n          class=\"column\"\n          id=\"col2\"\n          style$=\"[[_getColumnWidth(1,columnWidths)]]\"\n        >\n          <slot name=\"col-2\"></slot>\n        </div>\n        <div\n          class=\"column\"\n          id=\"col3\"\n          style$=\"[[_getColumnWidth(2,columnWidths)]]\"\n        >\n          <slot name=\"col-3\"></slot>\n        </div>\n        <div\n          class=\"column\"\n          id=\"col4\"\n          style$=\"[[_getColumnWidth(3,columnWidths)]]\"\n        >\n          <slot name=\"col-4\"></slot>\n        </div>\n        <div\n          class=\"column\"\n          id=\"col5\"\n          style$=\"[[_getColumnWidth(4,columnWidths)]]\"\n        >\n          <slot name=\"col-5\"></slot>\n        </div>\n        <div\n          class=\"column\"\n          id=\"col6\"\n          style$=\"[[_getColumnWidth(5,columnWidths)]]\"\n        >\n          <slot name=\"col-6\"></slot>\n        </div>\n      </div>\n      <iron-a11y-keys\n        target=\"[[activeItem]]\"\n        keys=\"enter\"\n        on-keys-pressed=\"setActiveElement\"\n      ></iron-a11y-keys>\n      <iron-a11y-keys\n        target=\"[[activeItem]]\"\n        keys=\"esc\"\n        on-keys-pressed=\"cancelActive\"\n      ></iron-a11y-keys>\n    "]);

    _templateObject_10df0990b49511e9bfd4f79a8a57e0f7 = function _templateObject_10df0990b49511e9bfd4f79a8a57e0f7() {
      return data;
    };

    return data;
  }

  // need to make this an object so that HAX can listen for it correctly
  var GridPlateLayoutOptions = function GridPlateLayoutOptions() {
    babelHelpers.classCallCheck(this, GridPlateLayoutOptions);
    this.layouts = {
      "1": {
        columnLayout: "1: full width",
        xs: ["100%"],
        sm: ["100%"],
        md: ["100%"],
        lg: ["100%"],
        xl: ["100%"]
      },
      "1-1": {
        columnLayout: "2: equal width",
        xs: ["100%", "100%"],
        sm: ["50%", "50%"],
        md: ["50%", "50%"],
        lg: ["50%", "50%"],
        xl: ["50%", "50%"]
      },
      "2-1": {
        columnLayout: "2: wide & narrow",
        xs: ["100%", "100%"],
        sm: ["50%", "50%"],
        md: ["66.6666667%", "33.3333337%"],
        lg: ["66.6666667%", "33.3333337%"],
        xl: ["66.6666667%", "33.3333337%"]
      },
      "1-2": {
        columnLayout: "2: narrow & wide",
        xs: ["100%", "100%"],
        sm: ["50%", "50%"],
        md: ["33.3333333%", "66.6666667%"],
        lg: ["33.3333333%", "66.6666667%"],
        xl: ["33.3333333%", "66.6666667%"]
      },
      "3-1": {
        columnLayout: "2: wider & narrower",
        xs: ["100%", "100%"],
        sm: ["50%", "50%"],
        md: ["75%", "25%"],
        lg: ["75%", "25%"],
        xl: ["75%", "25%"]
      },
      "1-3": {
        columnLayout: "2: narrower & wider",
        xs: ["100%", "100%"],
        sm: ["50%", "50%"],
        md: ["25%", "75%"],
        lg: ["25%", "75%"],
        xl: ["25%", "75%"]
      },
      "1-1-1": {
        columnLayout: "3: equal width",
        xs: ["100%", "100%", "100%"],
        sm: ["100%", "100%", "100%"],
        md: ["33.3333333%", "33.3333333%", "33.3333333%"],
        lg: ["33.3333333%", "33.3333333%", "33.3333333%"],
        xl: ["33.3333333%", "33.3333333%", "33.3333333%"]
      },
      "2-1-1": {
        columnLayout: "3: wide, narrow, and narrow",
        xs: ["100%", "100%", "100%"],
        sm: ["100%", "50%", "50%"],
        md: ["50%", "25%", "25%"],
        lg: ["50%", "25%", "25%"],
        xl: ["50%", "25%", "25%"]
      },
      "1-2-1": {
        columnLayout: "3: narrow, wide, and narrow",
        xs: ["100%", "100%", "100%"],
        sm: ["100%", "100%", "100%"],
        md: ["25%", "50%", "25%"],
        lg: ["25%", "50%", "25%"],
        xl: ["25%", "50%", "25%"]
      },
      "1-1-2": {
        columnLayout: "3: narrow, narrow, and wide",
        xs: ["100%", "100%", "100%"],
        sm: ["50%", "50%", "100%"],
        md: ["25%", "25%", "50%"],
        lg: ["25%", "25%", "50%"],
        xl: ["25%", "25%", "50%"]
      },
      "1-1-1-1": {
        columnLayout: "4: equal width",
        xs: ["100%", "100%", "100%", "100%"],
        sm: ["50%", "50%", "50%", "50%"],
        md: ["25%", "25%", "25%", "25%"],
        lg: ["25%", "25%", "25%", "25%"],
        xl: ["25%", "25%", "25%", "25%"]
      },
      "1-1-1-1-1": {
        columnLayout: "5: equal width",
        xs: ["100%", "100%", "100%", "100%", "100%"],
        sm: ["50%", "50%", "50%", "50%", "50%"],
        md: ["20%", "20%", "20%", "20%", "20%"],
        lg: ["20%", "20%", "20%", "20%", "20%"],
        xl: ["20%", "20%", "20%", "20%", "20%"]
      },
      "1-1-1-1-1-1": {
        columnLayout: "6: equal width",
        xs: ["100%", "100%", "100%", "100%", "100%", "100%"],
        sm: ["50%", "50%", "50%", "50%", "50%", "50%"],
        md: ["33.3333333%", "33.3333333%", "33.3333333%", "33.3333333%", "33.3333333%", "33.3333333%"],
        lg: ["16.6666667%", "16.6666667%", "16.6666667%", "16.6666667%", "16.6666667%", "16.6666667%"],
        xl: ["16.6666667%", "16.6666667%", "16.6666667%", "16.6666667%", "16.6666667%", "16.6666667%"]
      }
    };
    this.options = {};
    var layoutFlip = Object.keys(this.layouts); //loop through all the supplied layouts to get the HAX layout options & descriptions

    for (var i = 0; i < layoutFlip.length; i++) {
      this.options[layoutFlip[i]] = this.layouts[layoutFlip[i]].columnLayout;
    }
  };
  /**
   * `grid-plate`
   * `A grid plate based on a layout that manipulates it.`
   * @demo demo/index.html
   */


  var GridPlate =
  /*#__PURE__*/
  function (_PolymerElement) {
    babelHelpers.inherits(GridPlate, _PolymerElement);

    function GridPlate() {
      var _this;

      babelHelpers.classCallCheck(this, GridPlate);
      _this = babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(GridPlate).call(this));
      window.SimpleColorsStyles.requestAvailability();
      new Promise(function (res, rej) {
        return _require.default(["../../@polymer/paper-icon-button/paper-icon-button.js"], res, rej);
      });
      new Promise(function (res, rej) {
        return _require.default(["../../@polymer/iron-icons/iron-icons.js"], res, rej);
      });
      return _this;
    }

    babelHelpers.createClass(GridPlate, [{
      key: "connectedCallback",

      /**
       * life cycle
       */
      value: function connectedCallback() {
        babelHelpers.get(babelHelpers.getPrototypeOf(GridPlate.prototype), "connectedCallback", this).call(this);
        (0, _renderStatus.afterNextRender)(this, function () {
          for (var j = 1; j <= this.columns; j++) {
            if (this.shadowRoot.querySelector("#col" + j) !== undefined) {
              var col = this.shadowRoot.querySelector("#col" + j);
              col.addEventListener("drop", this.dropEvent.bind(this));
              col.addEventListener("dblclick", this.dblclick.bind(this));
              col.addEventListener("dragstart", this.dragStart.bind(this));
              col.addEventListener("dragenter", this.dragEnter.bind(this));
              col.addEventListener("dragleave", this.dragLeave.bind(this));
              col.addEventListener("dragend", this.dragEnd.bind(this));
              col.addEventListener("dragover", function (e) {
                e.preventDefault();
              });
              col.setAttribute("data-draggable", true);
            }
          }

          this.addEventListener("focusin", this._focusIn.bind(this)); // listen for HAX if it's around

          window.addEventListener("hax-store-property-updated", this._haxStorePropertyUpdated.bind(this)); // listen for HAX insert events if it exists

          window.addEventListener("hax-insert-content", this.haxInsertContent.bind(this)); // Establish hax property binding

          this.HAXWiring = new _HAXWiring.HAXWiring();
          this.HAXWiring.setup(GridPlate.haxProperties, GridPlate.tag, this);
        });
        window.ResponsiveUtility.requestAvailability();
        window.dispatchEvent(new CustomEvent("responsive-element", {
          detail: {
            element: this,
            attribute: "responsive-size",
            relativeToParent: false,
            sm: this.breakpointSm,
            md: this.breakpointMd,
            lg: this.breakpointLg,
            xl: this.breakpointXl
          }
        }));
      }
      /**
       * life cycle
       */

    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        for (var j = 1; j <= this.columns; j++) {
          if (this.shadowRoot.querySelector("#col" + j) !== undefined) {
            var col = this.shadowRoot.querySelector("#col" + j);
            col.removeEventListener("drop", this.dropEvent.bind(this));
            col.removeEventListener("dblclick", this.dblclick.bind(this));
            col.removeEventListener("dragstart", this.dragStart.bind(this));
            col.removeEventListener("dragenter", this.dragEnter.bind(this));
            col.removeEventListener("dragleave", this.dragLeave.bind(this));
            col.removeEventListener("dragend", this.dragEnd.bind(this));
            col.removeEventListener("dragover", function (e) {
              e.preventDefault();
            });
            col.removeAttribute("data-draggable");
          }
        }

        this.removeEventListener("focusin", this._focusIn.bind(this)); // listen for HAX if it's around

        window.removeEventListener("hax-store-property-updated", this._haxStorePropertyUpdated.bind(this)); // listen for HAX insert events if it exists

        window.removeEventListener("hax-insert-content", this.haxInsertContent.bind(this));
        babelHelpers.get(babelHelpers.getPrototypeOf(GridPlate.prototype), "disconnectedCallback", this).call(this);
      }
    }, {
      key: "preProcessHaxInsertContent",

      /**
       * Implements preProcessHaxInsertContent to clean up output on save
       */
      value: function preProcessHaxInsertContent(detail) {
        // ensure this is wiped to avoid issues in building
        delete detail.properties.activeItem;
        return detail;
      }
    }, {
      key: "_droppableChanged",
      value: function _droppableChanged(newValue) {
        if (newValue) {
          this.editMode = true;
        }
      }
      /**
       * Cancel active element
       */

    }, {
      key: "cancelActive",
      value: function cancelActive(e) {
        this.activeItem = null;
      }
      /**
       * Determines if the item can move a set number of slots.
       *
       * @param {object} the item
       * @param {number} -1 for left or +1 for right
       * @returns {boolean} if the item can move a set number of slots
       */

    }, {
      key: "canMoveSlot",
      value: function canMoveSlot(item, before) {
        var dir = before ? -1 : 1,
            max = this.shadowRoot.querySelectorAll(".column").length,
            col = item.getAttribute("slot").split("-"),
            dest = parseInt(col[1]) + dir;
        return dest >= 1 && dest <= max;
      }
    }, {
      key: "layoutChanged",
      value: function layoutChanged(newValue, oldValue) {
        var _this2 = this;

        if (newValue && babelHelpers.typeof(oldValue) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
          // ensure we apply things correctly
          if (this.editMode) {
            this.editMode = false;
            setTimeout(function () {
              _this2.editMode = true;
            }, 100);
          }
        }
      }
      /**
       * Moves an item a set number of slots.
       *
       * @param {object} the item
       * @param {number} -1 for left or +1 for right
       */

    }, {
      key: "moveSlot",
      value: function moveSlot(item, before) {
        var dir = before ? -1 : 1,
            col = item.getAttribute("slot").split("-"),
            dest = parseInt(col[1]) + dir;
        item.setAttribute("slot", "col-" + dest);
      }
      /**
       * Determines if the item can move a set number of slots.
       *
       * @param {object} the item
       * @param {boolean} move item before previous? (false for move item after next)
       * @returns {boolean} if the item can move a set number of slots
       */

    }, {
      key: "canMoveOrder",
      value: function canMoveOrder(item, before) {
        var nodes = this.shadowRoot.querySelector('slot[name="' + item.getAttribute("slot") + '"').assignedNodes({
          flatten: true
        });
        var target = null,
            position = 0;

        for (var i in nodes) {
          if (item === nodes[i]) {
            position = i;
          }
        }

        if (before && parseInt(position) - 1 >= 0) {
          target = nodes[parseInt(position) - 1];
        } else if (!before && parseInt(position) + 1 <= nodes.length - 1) {
          target = nodes[parseInt(position) + 1];
        }

        return target !== null && babelHelpers.typeof(target) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined));
      }
      /**
       * Moves an item's order within a slot.
       *
       * @param {object} the item
       * @param {boolean} move item before previous? (false for move item after next)
       */

    }, {
      key: "moveOrder",
      value: function moveOrder(item) {
        var before = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        var nodes = this.shadowRoot.querySelector('slot[name="' + item.getAttribute("slot") + '"').assignedNodes({
          flatten: true
        });
        var target = null,
            position = 0;

        for (var i in nodes) {
          if (item === nodes[i]) {
            position = i;
          }
        }

        if (before) {
          target = nodes[parseInt(position) - 1];
          (0, _polymerDom.dom)(this).insertBefore(this.activeItem, target);
        } else {
          target = nodes[parseInt(position) + 1];
          (0, _polymerDom.dom)(this).insertBefore(target, this.activeItem);
        }
      }
      /**
       * Move the active element based on which button got pressed.
       */

    }, {
      key: "moveActiveElement",
      value: function moveActiveElement(e) {
        var _this3 = this;

        var normalizedEvent = (0, _polymerDom.dom)(e);
        var local = normalizedEvent.localTarget; // see if this was an up down left or right movement

        switch (local.id) {
          case "up":
            this.moveOrder(this.activeItem, true);
            break;

          case "down":
            this.moveOrder(this.activeItem, false);
            break;

          case "left":
            this.moveSlot(this.activeItem, true);
            break;

          case "right":
            this.moveSlot(this.activeItem, false);
            break;
        } // ensure arrows are correctly positioned after the move


        setTimeout(function () {
          if (_this3.activeItem && typeof _this3.activeItem.focus === "function") {
            _this3.positionArrows(_this3.activeItem);

            _this3.activeItem.focus();
          }
        }, 100);
      }
      /**
       * Notice changes to what's active and ensure UX associated w/ it is visble
       */

    }, {
      key: "_activeItemChanged",
      value: function _activeItemChanged(newValue, oldValue) {
        if (babelHelpers.typeof(newValue) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && newValue != null) {
          // position arrows
          newValue.classList.add("active-item");
          this.positionArrows(newValue);
        } else if (newValue == null) {
          this.positionArrows(newValue);
        } // if we had a previous value then remove the active item class


        if (babelHelpers.typeof(oldValue) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && oldValue != null) {
          oldValue.classList.remove("active-item");
          oldValue.blur();
        }
      }
      /**
       * Set the target element to active
       */

    }, {
      key: "setActiveElement",
      value: function setActiveElement(e) {
        // support HAX text operations should take priority
        if (window.HaxStore && window.HaxStore.instance && window.HaxStore.instance.isTextElement(this.activeItem)) {
          return true;
        }

        this.shadowRoot.querySelector("#right").focus();
      }
      /**
       * gets the column widths based on selected layout and current responsive width
       *
       * @param {string} a string that describes the current responsive width
       * @param {string} the name of selected layout
       * @param {object} predefined layouts of column sizes and various responsive widths
       * @param {boolean} disable responsive sizing?
       * @returns {object} an object with a layout's column sizes at the current responsive width
       */

    }, {
      key: "_getColumnWidths",
      value: function _getColumnWidths() {
        var responsiveSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "sm";
        var layout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "1-1";
        var layouts = arguments.length > 2 ? arguments[2] : undefined;
        var disableResponsive = arguments.length > 3 ? arguments[3] : undefined;

        if (layouts) {
          var newl = layouts[layout],
              //how old layout names map to the new ones
          oldLayouts = {
            "12": "1",
            "8/4": "2-1",
            "6/6": "1-1",
            "4/8": "1-2",
            "4/4/4": "1-1-1",
            "3/3/3/3": "1-1-1-1"
          },
              size = disableResponsive !== false ? "xl" : responsiveSize;
          var oldl = oldLayouts[layout];

          if (newl !== undefined && newl[size] !== undefined) {
            //return the layout
            return layouts[layout][size];
          } else if (layouts[oldl] !== undefined && layouts[oldl][size] !== undefined) {
            //return new layout that maps to old one
            return layouts[oldl][size];
          } else if (babelHelpers.typeof(layouts["1-1"]) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
            //return 2-column layout
            return layouts["1-1"][size];
          }
        }
      }
      /**
       * gets a given column's current width based on layout and current responsive width
       *
       * @param {number} the index of the column
       * @param {object} an object with a layout's column sizes at the current responsive width
       * @returns {string} a given column's current width based on layout and current responsive width
       */

    }, {
      key: "_getColumnWidth",
      value: function _getColumnWidth(column, columnWidths) {
        return columnWidths !== undefined && columnWidths[column] !== undefined ? "width:" + columnWidths[column] : "min-height: unset";
      }
      /**
       * gets a given column's current width based on layout and current responsive width
       *
       * @param {string} the name of selected layout
       * @returns {number} the number of columns in this layout
       */

    }, {
      key: "_getColumns",
      value: function _getColumns(columnWidths) {
        return columnWidths.length;
      }
      /**
       * Focus / tab / click event normalization
       */

    }, {
      key: "_focusIn",
      value: function _focusIn(e) {
        if (this.editMode) {
          var normalizedEvent = (0, _polymerDom.dom)(e);
          var local = normalizedEvent.localTarget; // only activate if we touch something that's in the slot of the grid plate

          if ((0, _polymerDom.dom)(local).parentNode === this) {
            this.activeItem = local;
          }
        }
      }
      /**
       * Position the arrows to change directions around something
       */

    }, {
      key: "positionArrows",
      value: function positionArrows(item) {
        if (item == null) {
          this.shadowRoot.querySelector("#up").classList.remove("active");
          this.shadowRoot.querySelector("#down").classList.remove("active");
          this.shadowRoot.querySelector("#left").classList.remove("active");
          this.shadowRoot.querySelector("#right").classList.remove("active");
        } else {
          this.shadowRoot.querySelector("#up").classList.add("active");
          this.shadowRoot.querySelector("#down").classList.add("active");
          this.shadowRoot.querySelector("#left").classList.add("active");
          this.shadowRoot.querySelector("#right").classList.add("active"); // ensure we disable invalid options contextually
          // test for an element above us

          this.shadowRoot.querySelector("#up").disabled = !this.canMoveOrder(item, true); // test for an element below us

          this.shadowRoot.querySelector("#down").disabled = !this.canMoveOrder(item, false); // test for a column to the left of us

          this.shadowRoot.querySelector("#left").disabled = !this.canMoveSlot(item, true); // test for a column to the right of us

          this.shadowRoot.querySelector("#right").disabled = !this.canMoveSlot(item, false); // get coordinates of the page and active element

          var bodyRect = this.getBoundingClientRect();
          var elemRect = item.getBoundingClientRect();
          var topOffset = elemRect.top - bodyRect.top;
          var leftOffset = elemRect.left - bodyRect.left; // set the arrows to position correctly at all 4 sides

          this.shadowRoot.querySelector("#up").style.top = topOffset - 20 + "px";
          this.shadowRoot.querySelector("#down").style.top = topOffset + elemRect.height + "px";
          this.shadowRoot.querySelector("#left").style.top = topOffset + elemRect.height / 2 + "px";
          this.shadowRoot.querySelector("#right").style.top = topOffset + elemRect.height / 2 + "px";
          this.shadowRoot.querySelector("#up").style.left = leftOffset + elemRect.width / 2 - 10 + "px";
          this.shadowRoot.querySelector("#down").style.left = leftOffset + elemRect.width / 2 - 10 + "px";
          this.shadowRoot.querySelector("#left").style.left = leftOffset - 20 + "px";
          this.shadowRoot.querySelector("#right").style.left = leftOffset + elemRect.width + "px";
        }
      }
      /**
       * Notice edit state has changed
       */

    }, {
      key: "_editModeChanged",
      value: function _editModeChanged(newValue, oldValue) {
        // flipping from false to true
        var children = (0, _polymerDom.dom)(this).getEffectiveChildNodes();

        if (babelHelpers.typeof(children) === "object") {
          if (newValue && !oldValue) {
            // walk the children and apply the draggable state needed
            for (var i in children) {
              if (babelHelpers.typeof(children[i].tagName) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
                children[i].addEventListener("drop", this.dropEvent.bind(this));
                children[i].addEventListener("dragenter", this.dragEnter.bind(this));
                children[i].addEventListener("dragleave", this.dragLeave.bind(this));
                children[i].addEventListener("dragstart", this.dragStart.bind(this));
                children[i].addEventListener("dragend", this.dragEnd.bind(this));
                children[i].addEventListener("dragover", function (e) {
                  e.preventDefault();
                });
                children[i].setAttribute("draggable", true);
                children[i].setAttribute("data-draggable", true); // ensure they can be focused

                children[i].setAttribute("tabindex", 0);
              }
            }
          } // flipping from true to false
          else if (!newValue && oldValue) {
              // unset active to clean up state
              this.activeItem = null; // walk the children and remove the draggable state needed

              for (var i in children) {
                if (babelHelpers.typeof(children[i].tagName) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
                  children[i].removeEventListener("drop", this.dropEvent.bind(this));
                  children[i].removeEventListener("dragstart", this.dragStart.bind(this));
                  children[i].removeEventListener("dragenter", this.dragEnter.bind(this));
                  children[i].removeEventListener("dragleave", this.dragLeave.bind(this));
                  children[i].removeEventListener("dragend", this.dragEnd.bind(this));
                  children[i].removeEventListener("dragover", function (e) {
                    e.preventDefault();
                  });
                  children[i].removeAttribute("draggable");
                  children[i].removeAttribute("data-draggable");
                  children[i].removeAttribute("tabindex");
                }
              }
            }
        }
      }
      /**
       * Enter an element, meaning we've over it while dragging
       */

    }, {
      key: "dragEnter",
      value: function dragEnter(e) {
        if (this.editMode) {
          e.preventDefault();
          e.target.classList.add("hovered");
        }
      }
      /**
       * Leaving an element while dragging.
       */

    }, {
      key: "dragLeave",
      value: function dragLeave(e) {
        if (this.editMode) {
          e.target.classList.remove("hovered");
        }
      }
      /**
       * On double check, fire an event for HAX to insert a paragraph.
       * If they aren't using HAX then it won't do anything
       */

    }, {
      key: "dblclick",
      value: function dblclick(e) {
        if (this.editMode && e.target.id) {
          var detail = {};
          detail.properties = {
            slot: e.target.id.replace("col", "col-")
          };
          this.dispatchEvent(new CustomEvent("grid-plate-add-item", {
            bubbles: true,
            cancelable: true,
            composed: true,
            detail: detail
          }));
        }
      }
      /**
       * Drop an item onto another
       */

    }, {
      key: "dropEvent",
      value: function dropEvent(e) {
        var _this4 = this;

        if (this.editMode) {
          var normalizedEvent = (0, _polymerDom.dom)(e);
          var local = normalizedEvent.localTarget; // if we have a slot on what we dropped into then we need to mirror that item
          // and place ourselves below it in the DOM

          if (babelHelpers.typeof(this.activeItem) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && this.activeItem !== null && babelHelpers.typeof(local) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && local.getAttribute("slot") != null && this.activeItem !== local) {
            this.activeItem.setAttribute("slot", local.getAttribute("slot"));
            (0, _polymerDom.dom)(this).insertBefore(this.activeItem, local); // ensure that if we caught this event we process it

            e.preventDefault();
            e.stopPropagation();
          } // special case for dropping on an empty column or between items
          // which could involve a miss on the column
          else if (local.tagName === "DIV" && local.classList.contains("column")) {
              var col = local.id.replace("col", "");
              this.activeItem.setAttribute("slot", "col-" + col);
              (0, _polymerDom.dom)(this).appendChild(this.activeItem); // ensure that if we caught this event we process it

              e.preventDefault();
              e.stopPropagation();
            }

          var children = (0, _polymerDom.dom)(this).children; // walk the children and apply the draggable state needed

          for (var i in children) {
            if (babelHelpers.typeof(children[i].classList) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
              children[i].classList.remove("mover");
            }
          }

          for (var j = 1; j <= this.columns; j++) {
            if (this.shadowRoot.querySelector("#col" + j) !== undefined) {
              this.shadowRoot.querySelector("#col" + j).classList.remove("mover");
            }
          } // position arrows / set focus in case the DOM got updated above


          setTimeout(function () {
            if (_this4.activeItem && typeof _this4.activeItem.focus === "function") {
              _this4.positionArrows(_this4.activeItem);

              _this4.activeItem.focus();
            }
          }, 100);
        }
      }
      /**
       * Start a drag event, this is an element being dragged
       */

    }, {
      key: "dragStart",
      value: function dragStart(e) {
        if (this.editMode) {
          var children = (0, _polymerDom.dom)(this).children; // walk the children and apply the draggable state needed

          for (var i in children) {
            if (babelHelpers.typeof(children[i].classList) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
              children[i].classList.add("mover");
            }
          }

          for (var j = 1; j <= this.columns; j++) {
            if (this.shadowRoot.querySelector("#col" + j) !== undefined) {
              this.shadowRoot.querySelector("#col" + j).classList.add("mover");
            }
          }
        }
      }
      /**
       * When we end dragging ensure we remove the mover class.
       */

    }, {
      key: "dragEnd",
      value: function dragEnd(e) {
        if (this.editMode) {
          var children = (0, _polymerDom.dom)(this).children; // walk the children and apply the draggable state needed

          for (var i in children) {
            if (babelHelpers.typeof(children[i].classList) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
              children[i].classList.remove("mover", "hovered");
            }
          }

          for (var j = 1; j <= this.columns; j++) {
            if (this.shadowRoot.querySelector("#col" + j) !== undefined) {
              this.shadowRoot.querySelector("#col" + j).classList.remove("mover", "hovered");
            }
          }
        }
      }
      /**
       * Insert event noticed by HAX
       */

    }, {
      key: "haxInsertContent",
      value: function haxInsertContent(e) {
        var _this5 = this;

        // see if WE are the thing that's active when insert was fired
        if (this === window.HaxStore.instance.activeContainerNode) {
          // trick events into rebinding since this event is only possible
          // when we are in an edit state
          this.editMode = false; // delay and then set it back, re-applying all events

          setTimeout(function () {
            _this5.editMode = true;

            if (_this5.activeItem && typeof _this5.activeItem.focus === "function") {
              _this5.positionArrows(_this5.activeItem);

              _this5.activeItem.focus();
            }
          }, 100);
        }
      }
      /**
       * Store updated, sync.
       */

    }, {
      key: "_haxStorePropertyUpdated",
      value: function _haxStorePropertyUpdated(e) {
        if (e.detail && babelHelpers.typeof(e.detail.value) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined)) && e.detail.property) {
          if (babelHelpers.typeof(e.detail.value) === "object") {
            this.set(e.detail.property, null);
          }

          if (e.detail.property === "editMode" && this.ignoreHax) {// do nothing, we were told to ignore hax
          } else {
            this.set(e.detail.property, e.detail.value);
          }
        }
      }
    }], [{
      key: "template",
      get: function get() {
        return (0, _polymerElement.html)(_templateObject_10df0990b49511e9bfd4f79a8a57e0f7());
      }
    }, {
      key: "tag",
      get: function get() {
        return "grid-plate";
      }
    }, {
      key: "haxProperties",
      get: function get() {
        return {
          canScale: true,
          canPosition: true,
          canEditSource: false,
          settings: {
            quick: [],
            configure: [{
              property: "layout",
              title: "Column Layout",
              description: "Style to present these items (may change for small screens)",
              inputMethod: "select",
              options: new GridPlateLayoutOptions().options
            }],
            advanced: [{
              property: "breakpointSm",
              title: "Small Breakpoint",
              description: "Anything less than this number (in pixels) will render with the smallest version of this layout",
              inputMethod: "textfield",
              validationType: "number"
            }, {
              property: "breakpointMd",
              title: "Medium Breakpoint",
              description: "Anything less than this number (in pixels) will render with the small version of this layout",
              inputMethod: "textfield",
              validationType: "number"
            }, {
              property: "breakpointLg",
              title: "Large Breakpoint",
              description: "Anything less than this number (in pixels) will render with the medium version of this layout.",
              inputMethod: "textfield",
              validationType: "number"
            }, {
              property: "breakpointXl",
              title: "Extra-Large Breakpoint",
              description: "Anything less than this number (in pixels) will render with the large version of this layout. Anything greater than or equal to this number will display with the maximum number of columns for this layout.",
              inputMethod: "textfield",
              validationType: "number"
            }]
          },
          saveOptions: {
            unsetAttributes: ["active-item", "edit-mode", "layouts", "columns", "options"]
          }
        };
      }
    }, {
      key: "properties",
      get: function get() {
        return {
          droppable: {
            type: Boolean,
            value: false,
            reflectToAttribute: true,
            observer: "_droppableChanged"
          },
          ignoreHax: {
            type: Boolean,
            value: false
          },

          /**
           * Custom small breakpoint for the layouts; only updated on attached
           */
          breakpointSm: {
            type: Number,
            value: 900
          },

          /**
           * Custom medium breakpoint for the layouts; only updated on attached
           */
          breakpointMd: {
            type: Number,
            value: 1200
          },

          /**
           * Custom large breakpoint for the layouts; only updated on attached
           */
          breakpointLg: {
            type: Number,
            value: 1500
          },

          /**
           * Custom extra-large breakpoint for the layouts; only updated on attached
           */
          breakpointXl: {
            type: Number,
            value: 1800
          },

          /**
           * number of columns at this layout / responsive size
           */
          columns: {
            type: Number,
            value: 6,
            reflectToAttribute: true
          },

          /**
           * disables responsive layouts for HAX preview
           */
          disableResponsive: {
            type: Boolean,
            value: false,
            notify: true
          },

          /**
           * If the grid plate is in a state where its items
           * can be modified as far as order or column placement.
           */
          editMode: {
            reflectToAttribute: true,
            type: Boolean,
            value: false,
            observer: "_editModeChanged"
          },

          /**
           * an object with a layout's column sizes
           * at the current responsive width
           */
          layout: {
            type: String,
            value: "1-1",
            observer: "layoutChanged",
            reflectToAttribute: true
          },

          /**
           * Predefined layouts of column sizes and various responsive widths. 
           * For example:```
          {
          "1-1-1-1": {                         //the name of the layout
          "xs": ["100%","100%","100%","100%] //the responsive width of each column when the grid is extra small
          "sm": ["50%","50%","50%","50%"]    //the responsive width of each column when the grid is small
          "md": ["50%","50%","50%","50%"]    //the responsive width of each column when the grid is medium
          "lg": ["25%","25%","25%","25%"]    //the responsive width of each column when the grid is large
          "xl": ["25%","25%","25%","25%"]    //the responsive width of each column when the grid is extra large
          },
          {...}
          }```
          */
          layouts: {
            type: Object,
            readOnly: true,
            value: new GridPlateLayoutOptions().layouts
          },

          /**
           * Responsive size as `xs`, `sm`, `md`, `lg`, or `xl`
           */
          responsiveSize: {
            type: String,
            value: "xs",
            reflectToAttribute: true
          },

          /**
           * Track active item
           */
          activeItem: {
            type: Object,
            observer: "_activeItemChanged"
          },

          /**
           * name of selected layout
           */
          columnWidths: {
            type: String,
            computed: "_getColumnWidths(responsiveSize,layout,layouts,disableResponsive)"
          }
        };
      }
    }]);
    return GridPlate;
  }(_polymerElement.PolymerElement);

  _exports.GridPlate = GridPlate;
  window.customElements.define(GridPlate.tag, GridPlate);
});