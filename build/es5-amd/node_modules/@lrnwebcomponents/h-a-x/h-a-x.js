define(["exports", "require", "../hax-body/lib/hax-store.js"], function (_exports, _require, _haxStore) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.HAX = void 0;
  _require = babelHelpers.interopRequireWildcard(_require);

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  /**
   * `h-a-x`
   * @element h-a-x
   * `Single tag to transform authoring`
   *
   * @microcopy - language worth noting:
   *  - HAX - Headless Authoring eXperience
   *  - Body - the editable area that can be worked on and gets saved as a string / blob
   *
  
   * @demo demo/index.html
   */
  var HAX =
  /*#__PURE__*/
  function (_HTMLElement) {
    babelHelpers.inherits(HAX, _HTMLElement);
    babelHelpers.createClass(HAX, [{
      key: "html",
      // render function
      get: function get() {
        return "\n    <style>\n    :host {\n      display: block;\n      font-size: var(--haxcms-base-styles-body-font-size);\n      font-family: var(--haxcms-base-styles-body-font-family);\n      line-height: var(--haxcms-base-styles-body-line-height);\n      letter-spacing: var(--haxcms-base-styles-body-letter-spacing);\n    }\n\n    :host([hidden]) {\n      display: none;\n    }\n\n    hax-body {\n      font-size: var(--haxcms-base-styles-body-font-size);\n      font-family: var(--haxcms-base-styles-body-font-family);\n      line-height: var(--haxcms-base-styles-body-line-height);\n      letter-spacing: var(--haxcms-base-styles-body-letter-spacing);\n    }\n\n    h1 {\n      font-size: var(--hax-base-styles-h1-font-size);\n      line-height: var(--hax-base-styles-h1-line-height);\n    }\n\n    h2 {\n      font-size: var(--hax-base-styles-h2-font-size);\n    }\n\n    h3 {\n      font-size: var(--hax-base-styles-h3-font-size);\n    }\n\n    h4 {\n      font-size: var(--hax-base-styles-h4-font-size);\n    }\n\n    h5 {\n      font-size: var(--hax-base-styles-h5-font-size);  \n    }\n\n    h6 {\n      font-size: var(--hax-base-styles-h6-font-size);\n    }\n\n    p {\n      min-height: var(--hax-base-styles-p-min-height);\n      font-size: var(--hax-base-styles-p-font-size);\n      line-height: var(--hax-base-styles-p-line-height);\n      letter-spacing: var(--hax-base-styles-p-letter-spacing);\n    }\n\n    a,\n    a:-webkit-any-link {\n      font-size: var(--hax-base-styles-a-font-size,var(--hax-base-styles-p-font-size));\n    }\n\n    ol,\n    ul\n    ol li,\n    ul li {\n      line-height: var(--hax-base-styles-list-line-height,var(--hax-base-styles-p-line-height));\n      font-size: var(--hax-base-styles-list-font-size,var(--hax-base-styles-p-font-size));\n    }\n\n    ul ul,\n    ul ol,\n    ol ul,\n    ol ol {\n      padding-bottom: unset;\n    }\n    </style>\n    <hax-body>\n        <slot></slot>\n    </hax-body>";
      }
      /**
       * Store the tag name to make it easier to obtain directly.
       * @notice function name must be here for tooling to operate correctly
       */

    }], [{
      key: "tag",
      get: function get() {
        return "h-a-x";
      }
      /**
       * HTMLElement
       */

    }]);

    function HAX() {
      var _this;

      var delayRender = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      babelHelpers.classCallCheck(this, HAX);
      _this = babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(HAX).call(this));
      _this.__rendered = false; // set tag for later use

      _this.tag = HAX.tag;
      _this.template = document.createElement("template");

      _this.attachShadow({
        mode: "open"
      }); // if we shouldn't delay rendering


      if (!delayRender) {
        _this.render();
      }

      window.addEventListener("hax-store-ready", _this.storeReady.bind(babelHelpers.assertThisInitialized(_this)));
      window.addEventListener("hax-store-app-store-loaded", _this.appStoreReady.bind(babelHelpers.assertThisInitialized(_this))); // dynamically import definitions for all needed tags

      new Promise(function (res, rej) {
        return _require.default(["./lib/h-a-x-dependencies.js"], res, rej);
      });
      return _this;
    }
    /**
     * life cycle, element is afixed to the DOM
     */


    babelHelpers.createClass(HAX, [{
      key: "connectedCallback",
      value: function connectedCallback() {
        if (babelHelpers.get(babelHelpers.getPrototypeOf(HAX.prototype), "connectedCallback", this)) {
          babelHelpers.get(babelHelpers.getPrototypeOf(HAX.prototype), "connectedCallback", this).call(this);
        } // this ensures it's only applied once


        if (!this.__HAXApplied && !window.__HAXApplied) {
          window.__HAXApplied = this.__HAXApplied = this.applyHAX();
        }
      }
      /**
       * Store is ready, now we can pass along the app store definition
       * which HAX will react to an load the data it finds.
       */

    }, {
      key: "storeReady",
      value: function storeReady(e) {
        var _this2 = this;

        if (e.detail) {
          setTimeout(function () {
            try {
              var appStore = _objectSpread({}, JSON.parse(_this2.getAttribute("app-store")));

              if (babelHelpers.typeof(appStore) === "object") {
                window.HaxStore.instance.appStore = appStore;
              }
            } catch (e) {
              console.log(e);
            }

            if (_this2.hidePanelOps === "hide-panel-ops") {
              _this2.hidePanelOps = true;
            }

            window.HaxStore.instance.haxTray.hidePanelOps = _this2.hidePanelOps;
            window.HaxStore.instance.haxTray.offsetMargin = _this2.offsetMargin;
            window.HaxStore.instance.haxTray.elementAlign = _this2.elementAlign;
          }, 0);
        }
      }
      /**
       * Appstore has been loaded, NOW we can safely do an import
       */

    }, {
      key: "appStoreReady",
      value: function appStoreReady(e) {
        if (e.detail) {
          // import into the active body if there's content
          // obtain the nodes that have been assigned to the slot of our element
          if (this.shadowRoot.querySelector("slot")) {
            var nodes = this.shadowRoot.querySelector("slot").assignedNodes();
            var body = ""; // loop the nodes and if it has an outerHTML attribute, append as string

            for (var i in nodes) {
              if (babelHelpers.typeof(nodes[i].outerHTML) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
                body += nodes[i].outerHTML;
              }
            }

            window.HaxStore.instance.activeHaxBody.importContent(body);
          }
        }
      }
    }, {
      key: "render",
      value: function render() {
        this.__rendered = true;
        this.shadowRoot.innerHTML = null;
        this.template.innerHTML = this.html;
        this.shadowRoot.appendChild(this.template.content.cloneNode(true));
      }
      /**
       * Apply tags to the screen to establish HAX
       */

    }, {
      key: "applyHAX",
      value: function applyHAX() {
        // store needs to come before anyone else, use it's availability request mechanism
        window.HaxStore.requestAvailability(); // now everyone else

        var tray = document.createElement("hax-tray");
        tray.hidePanelOps = this.hidePanelOps;
        tray.elementAlign = this.elementAlign;
        document.body.appendChild(tray);
        document.body.appendChild(document.createElement("hax-app-picker"));
        document.body.appendChild(document.createElement("hax-preferences-dialog"));
        document.body.appendChild(document.createElement("hax-export-dialog"));
        document.body.appendChild(document.createElement("hax-map"));
        document.body.appendChild(document.createElement("hax-autoloader"));
        return true;
      }
    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        window.removeEventListener("hax-store-ready", this.storeReady.bind(this));
        window.removeEventListener("hax-store-ready", this.appStoreReady.bind(this));

        if (babelHelpers.get(babelHelpers.getPrototypeOf(HAX.prototype), "disconnectedCallback", this)) {
          babelHelpers.get(babelHelpers.getPrototypeOf(HAX.prototype), "disconnectedCallback", this).call(this);
        }
      }
    }, {
      key: "attributeChangedCallback",
      value: function attributeChangedCallback(attr, oldValue, newValue) {}
    }, {
      key: "elementAlign",
      get: function get() {
        return this.getAttribute("element-align");
      },
      set: function set(newValue) {
        if (this.__rendered) {
          this.setAttribute("element-align", newValue); // bind to the hax store global on change

          window.HaxStore.instance.haxTray.elementAlign = newValue;
        }
      }
    }, {
      key: "offsetMargin",
      get: function get() {
        return this.getAttribute("offset-margin");
      },
      set: function set(newValue) {
        this.setAttribute("offset-margin", newValue);

        if (this.__rendered) {
          // bind to the hax store global on change
          window.HaxStore.instance.haxTray.offsetMargin = newValue;
        }
      }
    }, {
      key: "hidePanelOps",
      get: function get() {
        return this.getAttribute("hide-panel-ops");
      },
      set: function set(newValue) {
        if (newValue) {
          this.setAttribute("hide-panel-ops", "hide-panel-ops");

          if (this.__rendered) {
            // bind to the hax store global on change
            window.HaxStore.instance.haxTray.hidePanelOps = newValue;
          }
        }
      }
    }, {
      key: "appStore",
      get: function get() {
        return this.getAttribute("app-store");
      },
      set: function set(newValue) {
        console.log(newValue);
        this.setAttribute("app-store", newValue);

        if (this.__rendered) {
          // bind to the hax store global on change
          window.HaxStore.instance.appStore = _objectSpread({}, JSON.parse(this.getAttribute("app-store")));
        }
      }
    }], [{
      key: "observedAttributes",
      get: function get() {
        return ["element-align", "offset-margin", "app-store", "hide-panel-ops"];
      }
    }]);
    return HAX;
  }(babelHelpers.wrapNativeSuper(HTMLElement));

  _exports.HAX = HAX;
  window.customElements.define("h-a-x", HAX);
});