define(["exports", "require", "../hax-body/lib/hax-store.js"], function (_exports, _require, _haxStore) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.HAX = void 0;
  _require = babelHelpers.interopRequireWildcard(_require);

  /**
   * Copyright 2018 The Pennsylvania State University
   * @license Apache-2.0, see License.md for full text.
   */

  /**
   * `h-a-x`
   * `Single tag to transform authoring`
   *
   * @microcopy - language worth noting:
   *  - HAX - Headless Authoring eXperience
   *  - Body - the editable area that can be worked on and gets saved as a string / blob
   *
   * @customElement
   * @demo demo/index.html
   */
  var HAX =
  /*#__PURE__*/
  function (_HTMLElement) {
    babelHelpers.inherits(HAX, _HTMLElement);
    babelHelpers.createClass(HAX, [{
      key: "html",
      // render function
      get: function get() {
        return "\n<style>:host {\n  display: block;\n}\n\n:host([hidden]) {\n  display: none;\n}\n</style>\n<hax-body>\n    <slot></slot>\n</hax-body>";
      } // properties available to the custom element for data binding

    }], [{
      key: "properties",
      get: function get() {
        var props = {
          "appStore": {
            "name": "appStore",
            "type": String,
            "value": ""
          }
        };

        if (babelHelpers.get(babelHelpers.getPrototypeOf(HAX), "properties", this)) {
          props = Object.assign(props, babelHelpers.get(babelHelpers.getPrototypeOf(HAX), "properties", this));
        }

        return props;
      }
      /**
       * Store the tag name to make it easier to obtain directly.
       * @notice function name must be here for tooling to operate correctly
       */

    }, {
      key: "tag",
      get: function get() {
        return "h-a-x";
      }
      /**
       * life cycle
       */

    }]);

    function HAX() {
      var _this;

      var delayRender = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      babelHelpers.classCallCheck(this, HAX);
      _this = babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(HAX).call(this)); // set tag for later use

      _this.tag = HAX.tag; // map our imported properties json to real props on the element
      // @notice static getter of properties is built via tooling
      // to edit modify src/HAX-properties.json

      var obj = HAX.properties;

      for (var p in obj) {
        if (obj.hasOwnProperty(p)) {
          if (_this.hasAttribute(p)) {
            _this[p] = _this.getAttribute(p);
          } else {
            _this.setAttribute(p, obj[p].value);

            _this[p] = obj[p].value;
          }
        }
      }

      _this.template = document.createElement("template");

      _this.attachShadow({
        mode: "open"
      }); // if we shouldn't delay rendering


      if (!delayRender) {
        _this.render();
      }

      window.addEventListener("hax-store-ready", _this.storeReady.bind(babelHelpers.assertThisInitialized(_this)));
      window.addEventListener("hax-store-app-store-loaded", _this.appStoreReady.bind(babelHelpers.assertThisInitialized(_this))); // dynamically import definitions for all needed tags

      new Promise(function (res, rej) {
        return _require.default(["../hax-body/hax-body.js"], res, rej);
      });
      new Promise(function (res, rej) {
        return _require.default(["../hax-body/lib/hax-panel.js"], res, rej);
      });
      new Promise(function (res, rej) {
        return _require.default(["../hax-body/lib/hax-autoloader.js"], res, rej);
      });
      new Promise(function (res, rej) {
        return _require.default(["../hax-body/lib/hax-app.js"], res, rej);
      });
      new Promise(function (res, rej) {
        return _require.default(["../hax-body/lib/hax-manager.js"], res, rej);
      });
      new Promise(function (res, rej) {
        return _require.default(["../hax-body/lib/hax-app-picker.js"], res, rej);
      });
      new Promise(function (res, rej) {
        return _require.default(["../hax-body/lib/hax-toolbar.js"], res, rej);
      });
      new Promise(function (res, rej) {
        return _require.default(["../hax-body/lib/hax-preferences-dialog.js"], res, rej);
      });
      new Promise(function (res, rej) {
        return _require.default(["../hax-body/lib/hax-stax-picker.js"], res, rej);
      });
      new Promise(function (res, rej) {
        return _require.default(["../hax-body/lib/hax-blox-picker.js"], res, rej);
      });
      new Promise(function (res, rej) {
        return _require.default(["../../@polymer/iron-icons/iron-icons.js"], res, rej);
      });
      new Promise(function (res, rej) {
        return _require.default(["../../@polymer/iron-icons/editor-icons.js"], res, rej);
      });
      new Promise(function (res, rej) {
        return _require.default(["../../@polymer/iron-icons/device-icons.js"], res, rej);
      });
      new Promise(function (res, rej) {
        return _require.default(["../../@polymer/iron-icons/hardware-icons.js"], res, rej);
      });
      new Promise(function (res, rej) {
        return _require.default(["../../@polymer/iron-icons/communication-icons.js"], res, rej);
      });
      new Promise(function (res, rej) {
        return _require.default(["../lrn-icons/lrn-icons.js"], res, rej);
      });
      new Promise(function (res, rej) {
        return _require.default(["../../@polymer/iron-icons/social-icons.js"], res, rej);
      });
      new Promise(function (res, rej) {
        return _require.default(["../../@polymer/iron-icons/av-icons.js"], res, rej);
      });
      new Promise(function (res, rej) {
        return _require.default(["../../@polymer/iron-icons/places-icons.js"], res, rej);
      });
      new Promise(function (res, rej) {
        return _require.default(["../../@polymer/iron-icons/maps-icons.js"], res, rej);
      });
      new Promise(function (res, rej) {
        return _require.default(["../../@polymer/iron-image/iron-image.js"], res, rej);
      });
      new Promise(function (res, rej) {
        return _require.default(["../hax-iconset/hax-iconset.js"], res, rej);
      });
      new Promise(function (res, rej) {
        return _require.default(["../hax-body/lib/hax-export-dialog.js"], res, rej);
      });
      return _this;
    }
    /**
     * life cycle, element is afixed to the DOM
     */


    babelHelpers.createClass(HAX, [{
      key: "connectedCallback",
      value: function connectedCallback() {
        if (babelHelpers.get(babelHelpers.getPrototypeOf(HAX.prototype), "connectedCallback", this)) {
          babelHelpers.get(babelHelpers.getPrototypeOf(HAX.prototype), "connectedCallback", this).call(this);
        } // this ensures it's only applied once


        if (!this.__HAXApplied && !window.__HAXApplied) {
          window.__HAXApplied = this.__HAXApplied = this.applyHAX();
        }
      }
      /**
       * Store is ready, now we can pass along the app store definition
       * which HAX will react to an load the data it finds.
       */

    }, {
      key: "storeReady",
      value: function storeReady(e) {
        if (e.detail) {
          window.HaxStore.instance.appStore = JSON.parse(this.getAttribute("app-store"));
        }
      }
      /**
       * Appstore has been loaded, NOW we can safely do an import
       */

    }, {
      key: "appStoreReady",
      value: function appStoreReady(e) {
        if (e.detail) {
          // import into the active body if there's content
          // obtain the nodes that have been assigned to the slot of our element
          if (this.shadowRoot.querySelector("slot")) {
            var nodes = this.shadowRoot.querySelector("slot").assignedNodes();
            var body = ""; // loop the nodes and if it has an outerHTML attribute, append as string

            for (var i in nodes) {
              if (babelHelpers.typeof(nodes[i].outerHTML) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
                body += nodes[i].outerHTML;
              }
            }

            window.HaxStore.instance.activeHaxBody.importContent(body);
          }
        }
      }
    }, {
      key: "render",
      value: function render() {
        if (!this.__rendered) {
          this.__rendered = true;
          this.shadowRoot.innerHTML = null;
          this.template.innerHTML = this.html;
          this.shadowRoot.appendChild(this.template.content.cloneNode(true));
        }
      }
      /**
       * Apply tags to the screen to establish HAX
       */

    }, {
      key: "applyHAX",
      value: function applyHAX() {
        // store needs to come before anyone else, use it's availability request mechanism
        window.HaxStore.requestAvailability(); // now everyone else

        var panel = document.createElement("hax-panel");
        panel.hidePanelOps = this.hidePanelOps;
        document.body.appendChild(panel);
        document.body.appendChild(document.createElement("hax-manager"));
        document.body.appendChild(document.createElement("hax-app-picker"));
        document.body.appendChild(document.createElement("hax-stax-picker"));
        document.body.appendChild(document.createElement("hax-blox-picker"));
        document.body.appendChild(document.createElement("hax-preferences-dialog"));
        document.body.appendChild(document.createElement("hax-export-dialog"));
        document.body.appendChild(document.createElement("hax-autoloader"));
        return true;
      }
    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        window.removeEventListener("hax-store-ready", this.storeReady.bind(this));
        window.removeEventListener("hax-store-ready", this.appStoreReady.bind(this));

        if (babelHelpers.get(babelHelpers.getPrototypeOf(HAX.prototype), "disconnectedCallback", this)) {
          babelHelpers.get(babelHelpers.getPrototypeOf(HAX.prototype), "disconnectedCallback", this).call(this);
        }
      }
    }, {
      key: "attributeChangedCallback",
      value: function attributeChangedCallback(attr, oldValue, newValue) {}
    }, {
      key: "hidePanelOps",
      get: function get() {
        return this.getAttribute("hide-panel-ops");
      },
      set: function set(newValue) {
        if (newValue) {
          this.setAttribute("hide-panel-ops", "hide-panel-ops");
        }
      }
    }, {
      key: "appStore",
      get: function get() {
        return this.getAttribute("app-store");
      },
      set: function set(newValue) {
        if (this.__rendered) {
          this.setAttribute("app-store", newValue); // bind to the hax store global on change

          window.HaxStore.instance.appStore = JSON.parse(this.getAttribute("app-store"));
        }
      }
    }], [{
      key: "observedAttributes",
      get: function get() {
        return ["app-store", "hide-panel-ops"];
      }
    }]);
    return HAX;
  }(babelHelpers.wrapNativeSuper(HTMLElement));

  _exports.HAX = HAX;
  window.customElements.define("h-a-x", HAX);
});