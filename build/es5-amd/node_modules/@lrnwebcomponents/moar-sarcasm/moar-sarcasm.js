define(["exports"], function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.MoarSarcasm = void 0;

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  /**
   * Copyright 2020 The Pennsylvania State University
   * @license Apache-2.0, see License.md for full text.
   */

  /**
   * `moar-sarcasm`
   * `Provide a laugh and a good example of VanillaJS for demos`
   * @demo demo/index.html
   * @element moar-sarcasm
   */
  var MoarSarcasm = /*#__PURE__*/function (_HTMLElement) {
    babelHelpers.inherits(MoarSarcasm, _HTMLElement);

    var _super = _createSuper(MoarSarcasm);

    /**
     * object life cycle
     */
    function MoarSarcasm() {
      var _this;

      babelHelpers.classCallCheck(this, MoarSarcasm);
      _this = _super.call(this);
      _this.a11y = "the following is sarcastic "; // create a template element for processing shadowRoot

      _this.template = document.createElement("template"); // create a shadowRoot

      _this.attachShadow({
        mode: "open"
      });

      _this.render();

      _this.observer = new MutationObserver(function (mutations) {
        mutations.forEach(function (mutation) {
          _this.say = _this.innerText;
        });
      });

      _this.observer.observe(babelHelpers.assertThisInitialized(_this), {
        characterData: true,
        attributes: false,
        childList: false,
        subtree: true
      });

      return _this;
    } // render HTML


    babelHelpers.createClass(MoarSarcasm, [{
      key: "html",
      get: function get() {
        return "\n      <style>\n        :host {\n          display: inline-block;\n        }\n        span {\n          font-style: italic;\n        }\n        .letter:nth-child(odd) {\n          text-transform: uppercase;\n        }\n        .letter:nth-child(even) {\n          text-transform: lowercase;\n        }\n        .slot {\n          position: absolute!important;\n          width: 1px!important;\n          height: 1px!important;\n          padding: 0!important;\n          margin: -1px!important;\n          overflow: hidden!important;\n          clip: rect(0,0,0,0)!important;\n          white-space: nowrap!important;\n          border: 0!important;\n        }\n      </style>\n      <span class=\"sarcastic\" aria-hidden=\"true\"></span>\n      <span class=\"slot\">".concat(this.a11y, "<slot></slot></span>\n    ");
      }
      /**
       * life cycle, element is afixed to the DOM
       */

    }, {
      key: "connectedCallback",
      value: function connectedCallback() {
        if (window.ShadyCSS) {
          window.ShadyCSS.styleElement(this);
        }

        this.say = this.innerText;
      }
      /**
       * Render / rerender the shadowRoot
       */

    }, {
      key: "render",
      value: function render() {
        this.shadowRoot.innerHTML = null;
        this.template.innerHTML = this.html;

        if (window.ShadyCSS) {
          window.ShadyCSS.prepareTemplate(this.template, this.tag);
        }

        this.shadowRoot.appendChild(this.template.content.cloneNode(true));
      }
      /**
       * Process the text in question
       */

    }, {
      key: "processText",
      value: function processText(text) {
        // empty whats there
        this.shadowRoot.querySelector(".sarcastic").innerHTML = ""; // loop through text to process and convert to span tags

        for (var i = 0; i < text.length; i++) {
          var tag = document.createElement("span");

          if (text.charAt(i).match(/[a-z]/i)) {
            tag.classList.add("letter");
            tag.innerText = text.charAt(i);
          } else {
            tag = document.createTextNode(text.charAt(i));
          }

          this.shadowRoot.querySelector(".sarcastic").appendChild(tag);
        }
      }
      /**
       * attributes to notice changes to
       */

    }, {
      key: "say",
      get: function get() {
        return this.getAttribute("say");
      },
      set: function set(val) {
        this.setAttribute("say", val);
      }
    }, {
      key: "a11y",
      get: function get() {
        return this.getAttribute("a11y");
      }
      /**
       * callback when any observed attribute changes
       */
      ,
      set: function set(val) {
        this.setAttribute("a11y", val);
      }
    }, {
      key: "attributeChangedCallback",
      value: function attributeChangedCallback(attr, oldValue, newValue) {
        if (newValue) {
          switch (attr) {
            case "say":
              this.processText(newValue);
              break;

            case "a11y":
              this.render();
              break;
          }
        }
      }
    }], [{
      key: "tag",
      get:
      /**
       * This is a convention, not the standard
       */
      function get() {
        return "moar-sarcasm";
      }
    }, {
      key: "observedAttributes",
      get: function get() {
        return ["say", "a11y"];
      }
    }]);
    return MoarSarcasm;
  }( /*#__PURE__*/babelHelpers.wrapNativeSuper(HTMLElement));

  _exports.MoarSarcasm = MoarSarcasm;
  customElements.define(MoarSarcasm.tag, MoarSarcasm);
});