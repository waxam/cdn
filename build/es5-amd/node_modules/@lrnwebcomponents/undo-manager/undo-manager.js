define(["exports", "meta", "../../lit-element/lit-element.js", "../es-global-bridge/es-global-bridge.js"], function (_exports, meta, _litElement, _esGlobalBridge) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.UndoManagerCommand = _exports.UndoManager = void 0;
  meta = babelHelpers.interopRequireWildcard(meta);

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  function _templateObject_8c7ee260c96f11ea8be5e1d5fe7ec787() {
    var data = babelHelpers.taggedTemplateLiteral(["\n      <slot></slot>\n    "]);

    _templateObject_8c7ee260c96f11ea8be5e1d5fe7ec787 = function _templateObject_8c7ee260c96f11ea8be5e1d5fe7ec787() {
      return data;
    };

    return data;
  }

  /**
   * `undo-manager`
   * `an undo history manager element`
   *  This brings ideas from https://addyosmani.com/blog/mutation-observers/
   *  back to life and this time as LitElement + with the web drastically
   *  moved forward vs when this was originally published (2014).
   *
   * @litelement
   * @demo demo/index.html
   * @element undo-manager
   */
  var UndoManager =
  /*#__PURE__*/
  function (_LitElement) {
    babelHelpers.inherits(UndoManager, _LitElement);
    babelHelpers.createClass(UndoManager, [{
      key: "render",

      /**
       * LitElement render
       */
      value: function render() {
        return (0, _litElement.html)(_templateObject_8c7ee260c96f11ea8be5e1d5fe7ec787());
      }
      /**
       * LitElement / popular convention
       */

    }], [{
      key: "tag",

      /**
       * Convention
       */
      get: function get() {
        return "undo-manager";
      }
    }, {
      key: "properties",
      get: function get() {
        return _objectSpread({}, babelHelpers.get(babelHelpers.getPrototypeOf(UndoManager), "properties", this), {
          /**
           * If we can currently undo based on stack position
           */
          canUndo: {
            type: Boolean,
            attribute: "can-undo"
          },

          /**
           * If we can currently redo based on stack position
           */
          canRedo: {
            type: Boolean,
            attribute: "can-redo"
          },

          /**
           * If we're "dirty" meaning stackPosition and savePosition out of sync
           */
          isDirty: {
            type: Boolean,
            attribute: "is-dirty"
          },

          /**
           * Allow for targetting OTHER elements w/ this behavior
           */
          target: {
            type: Object
          }
        });
      }
      /**
       * HTMLElement
       */

    }]);

    function UndoManager() {
      var _this;

      babelHelpers.classCallCheck(this, UndoManager);
      _this = babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(UndoManager).call(this));
      _this.blocked = false;
      _this.observer = null;

      var basePath = _this.pathFromUrl(decodeURIComponent(meta.url));

      var location = "".concat(basePath, "../../undo.js/undo.js");
      window.addEventListener("es-bridge-undojs-loaded", _this._undoLoaded.bind(babelHelpers.assertThisInitialized(_this)));
      window.ESGlobalBridge.requestAvailability();
      window.ESGlobalBridge.instance.load("undojs", location);
      return _this;
    }
    /**
     * Simple path resolution from URL
     */


    babelHelpers.createClass(UndoManager, [{
      key: "pathFromUrl",
      value: function pathFromUrl(url) {
        return url.substring(0, url.lastIndexOf("/") + 1);
      }
      /**
       * undo.js has loaded, now add the stack in
       */

    }, {
      key: "_undoLoaded",
      value: function _undoLoaded(e) {
        var _this2 = this;

        this.stack = new Undo.Stack(); // simple hook into being notified of changes to the object

        this.stack.changed = function (e) {
          _this2.canRedo = _this2.stack.canRedo();
          _this2.canUndo = _this2.stack.canUndo();
          _this2.isDirty = _this2.stack.dirty();
        }; // execute once just to get these values


        this.stack.changed(); // remove listener, we're loaded

        window.removeEventListener("undo-js-loaded", this._undoLoaded.bind(this));
      }
      /**
       * HTMLElement
       */

    }, {
      key: "connectedCallback",
      value: function connectedCallback() {
        var _this3 = this;

        // watch for changes to the element itself
        this.observer = new MutationObserver(function (mutations) {
          // ensure this was not a change record to perform undo/redo itself!
          setTimeout(function () {
            if (_this3.blocked) {
              _this3.blocked = false;
              return;
            } // compare light dom children to previous value


            var newValue = _this3.innerHTML;

            if (_this3.stack && newValue != _this3.startValue) {
              // push an "edit comand"
              _this3.stack.execute(new UndoManagerCommand(_this3, _this3.startValue, newValue));

              _this3.startValue = newValue;
            }
          }, 50);
        }); // watch attributes, children and the subtree for changes

        this.observer.observe(this, {
          attributes: true,
          childList: true,
          subtree: true
        });
        babelHelpers.get(babelHelpers.getPrototypeOf(UndoManager.prototype), "connectedCallback", this).call(this);
      }
      /**
       * HTMLElement
       */

    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        this.observer.disconnect();
        babelHelpers.get(babelHelpers.getPrototypeOf(UndoManager.prototype), "disconnectedCallback", this).call(this);
      }
      /**
       * LitElement ready
       */

    }, {
      key: "firstUpdated",
      value: function firstUpdated(changedProperties) {
        if (babelHelpers.get(babelHelpers.getPrototypeOf(UndoManager.prototype), "firstUpdated", this)) {
          babelHelpers.get(babelHelpers.getPrototypeOf(UndoManager.prototype), "firstUpdated", this).call(this, changedProperties);
        } // ready to go, take a snapshot of our light dom children as text


        this.startValue = this.innerHTML;
      }
      /**
       * updated / notice property changes
       */

    }, {
      key: "updated",
      value: function updated(changedProperties) {
        var _this4 = this;

        if (babelHelpers.get(babelHelpers.getPrototypeOf(UndoManager.prototype), "updated", this)) {
          babelHelpers.get(babelHelpers.getPrototypeOf(UndoManager.prototype), "updated", this).call(this, changedProperties);
        }

        changedProperties.forEach(function (oldValue, propName) {
          if (propName == "canUndo") {
            // notify
            _this4.dispatchEvent(new CustomEvent("can-undo-changed", {
              detail: {
                value: _this4[propName]
              }
            }));
          }

          if (propName == "canRedo") {
            // notify
            _this4.dispatchEvent(new CustomEvent("can-redo-changed", {
              detail: {
                value: _this4[propName]
              }
            }));
          }

          if (propName == "isDirty") {
            // notify
            _this4.dispatchEvent(new CustomEvent("is-dirty-changed", {
              detail: {
                value: _this4[propName]
              }
            }));
          }
        });
      } // execute an undo

    }, {
      key: "undo",
      value: function undo() {
        return this.stack.undo();
      } // execute a redo

    }, {
      key: "redo",
      value: function redo() {
        return this.stack.redo();
      } // return a list of the command stack

    }, {
      key: "commands",
      value: function commands() {
        return this.stack.commands;
      } // return current stackPosition index

    }, {
      key: "stackPosition",
      value: function stackPosition() {
        return this.stack.stackPosition;
      } // return save index as a reference point

    }, {
      key: "savePosition",
      value: function savePosition() {
        return this.stack.savePosition;
      }
      /**
       * Set a save position to check against at a later point in time
       */

    }, {
      key: "save",
      value: function save() {
        this.stack.save();
      }
    }]);
    return UndoManager;
  }(_litElement.LitElement);

  _exports.UndoManager = UndoManager;
  customElements.define("undo-manager", UndoManager);
  /**
   * UndoManagerCommand, simple command scaffold to bridge undo.js with element
   */

  var UndoManagerCommand =
  /*#__PURE__*/
  function () {
    function UndoManagerCommand(el, oldValue, newValue) {
      babelHelpers.classCallCheck(this, UndoManagerCommand);
      // refernece to us
      this.el = el;
      this.oldValue = oldValue;
      this.newValue = newValue;
    } // required for undo.js though we don't use


    babelHelpers.createClass(UndoManagerCommand, [{
      key: "execute",
      value: function execute() {} // perform a "undo"

    }, {
      key: "undo",
      value: function undo() {
        this.el.blocked = true;
        this.el.innerHTML = this.oldValue;
      } // perform a "redo"

    }, {
      key: "redo",
      value: function redo() {
        this.el.blocked = true;
        this.el.innerHTML = this.newValue;
      }
    }]);
    return UndoManagerCommand;
  }();

  _exports.UndoManagerCommand = UndoManagerCommand;
});