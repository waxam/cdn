define(["exports"],function(_exports){"use strict";Object.defineProperty(_exports,"__esModule",{value:!0});_exports.dashToCamelCase=dashToCamelCase;_exports.camelCaseToDash=camelCaseToDash;_exports.encapScript=encapScript;_exports.findTagsInHTML=findTagsInHTML;_exports.wipeSlot=wipeSlot;_exports.generateResourceID=generateResourceID;_exports.stripMSWord=stripMSWord;_exports.varExists=varExists;_exports.varGet=varGet;_exports.objectValFromStringPos=objectValFromStringPos;_exports.getRange=getRange;_exports.internalGetShadowSelection=internalGetShadowSelection;_exports.winEventsElement=void 0;/**
 * A collection of utility functions exported for convenience
 */ /**
 * Convert dash case to camel case
 */function dashToCamelCase(key){return key.toLowerCase().replace(/-(.)/g,function(match,group1){return group1.toUpperCase()})}/**
 * Conver camel case to dash case
 */function camelCaseToDash(key){return key.replace(/([A-Z])/g,function(g){return"-".concat(g[0].toLowerCase())})}/**
 * Encapsulate script types in an HTML blob
 */function encapScript(html){// ensure this is a string to then do replacements on, rare but possible w/ null
if(html&&"function"===typeof html.replace){html=html.replace(/<script[\s\S]*?>/gi,"&lt;script&gt;");html=html.replace(/<\/script>/gi,"&lt;/script&gt;");// ensure that HAX tags aren't leaking in here
html=html.replace(/<hax[\s\S]*?>/gi,"");html=html.replace(/<\/hax[\s\S]*?>/gi,"");html=html.replace(/<h-a-x[\s\S]*?>/gi,"");html=html.replace(/<\/h-a-x*?>/gi,"");html=html.replace(/<style[\s\S]*?>/gi,"&lt;style&gt;");html=html.replace(/<\/style>/gi,"&lt;/style&gt;");// special case, it's inside a template tag
html=html.replace(/<template[\s\S]*?>[\s\S]*?&lt;script[\s\S]*?&gt;[\s\S]*?&lt;\/script&gt;/gi,function(match,contents,offset,input_string){match=match.replace("&lt;script&gt;","<script>");match=match.replace("&lt;/script&gt;","</script>");match=match.replace("&lt;style&gt;","<style>");match=match.replace("&lt;/style&gt;","</style>");return match})}return html}/**
 * Find custom elements in HTML
 */function findTagsInHTML(html){var tags={},tag="",matches=html.match(/<\/([a-z,0-9]*?)-(\S*?)>/g);for(var i in matches){tag=matches[i].replace("</","").replace(">","");tags[tag]=tag}return tags}/**
 * Wipe slotted content
 */function wipeSlot(element){var slot=1<arguments.length&&arguments[1]!==void 0?arguments[1]:"*";// 100% clean slate
if("*"===slot){while(null!==element.firstChild){element.removeChild(element.firstChild)}}else{for(var i in element.childNodes){// test for element nodes to be safe
if(babelHelpers.typeof(element.childNodes[i])!==("undefined"===typeof void 0?"undefined":babelHelpers.typeof(void 0))&&element.childNodes[i].slot===slot){element.removeChild(element.childNodes[i])}}}}/**
 * Generate a uinque ID
 */function generateResourceID(){var base=0<arguments.length&&arguments[0]!==void 0?arguments[0]:"#";function idPart(){return Math.floor(65536*(1+Math.random())).toString(16).substring(1)}return base+idPart()+idPart()+"-"+idPart()+"-"+idPart()+"-"+idPart()+"-"+idPart()+idPart()+idPart()}/**
 * Strip word BS
 */function stripMSWord(input){// 1. remove line breaks / Mso classes right off the bat
var output=input.split("\n\r").join("\n").split("\r").join("\n").split("\n\n").join("\n").split("\n\n").join("\n").split("\n\n").join("\n").split("\n").join(" ").replace(/( class=(")?Mso[a-zA-Z]+(")?)/g,"");// 2. strip Word generated HTML comments
output=output.replace(/<\!--(\s|.)*?-->/gim,"");output=output.replace(/<\!(\s|.)*?>/gim,"");// 3. remove tags leave content if any
output=output.replace(/<(\/)*(meta|link|html|head|body|span|font|br|\\\\?xml:|xml|st1:|o:|w:|m:|v:)(\s|.)*?>/gim,"");// 4. Remove everything in between and including tags '<style(.)style(.)>'
var badTags=["style","script","applet","embed","noframes","noscript"];for(var i in badTags){var tagStripper=new RegExp("<"+badTags[i]+"(s|.)*?"+badTags[i]+"(.*?)>","gim");output=output.replace(tagStripper,"")}// 5. remove attributes ' style="..."', align, start
output=output.replace(/ style='(\s|.)*?'/gim,"");output=output.replace(/ align=.*? /g,"");output=output.replace(/ start='.*?'/g,"");// 6. some HAX specific things in case this was moving content around
// these are universally true tho so fine to have here
output=output.replace(/ style="(\s|.)*?"/gim,"");output=output.replace(/ data-editable="(\s|.)*?"/gim,"");output=output.replace(/ data-hax-ray="(\s|.)*?"/gim,"");output=output.replace(/ class=""/gim,"");output=output.replace(/ class="hax-active"/gim,"");output=output.replace(/ contenteditable="(\s|.)*?"/gim,"");// 7. clean out empty paragraphs and endlines that cause weird spacing
output=output.replace(/&nbsp;/gm," ");// start of double, do it twice for nesting
output=output.replace(/<p><p>/gm,"<p>");output=output.replace(/<p><p>/gm,"<p>");// double, do it twice for nesting
output=output.replace(/<\/p><\/p>/gm,"</p>");output=output.replace(/<\/p><\/p>/gm,"</p>");// empty with lots of space
output=output.replace(/<p>(\s*)<\/p>/gm," ");// empty p / more or less empty
output=output.replace(/<p><\/p>/gm,"");output=output.replace(/<p>&nbsp;<\/p>/gm," ");// br somehow getting through here
output=output.replace(/<p><br\/><\/p>/gm,"");output=output.replace(/<p><br><\/p>/gm,"");// whitespace in reverse of the top case now that we've cleaned it up
output=output.replace(/<\/p>(\s*)<p>/gm,"</p><p>");// wow do I hate contenteditable and the dom....
// bold and italic are treated as if they are block elements in a paste scenario
// 8. check for empty bad tags
for(var i in badTags){var emptyTagRemove=new RegExp("<"+badTags[i]+"></"+badTags[i]+">","gi");output=output.replace(emptyTagRemove,"")}output=output.trim();return output}/**
 * Test if a variable along a given object path exists
 */function varExists(obj,path){var g=objectValFromStringPos(obj,path,"__failedToFind__");if("__failedToFind__"!=g){return!0}return!1}/**
 * Return an object path or fallback value if not set
 */function varGet(obj,path){var fallback=2<arguments.length&&arguments[2]!==void 0?arguments[2]:"";return objectValFromStringPos(obj,path,fallback)}// helper to use strings for index in Objects
function objectValFromStringPos(o,s){var r=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;s=s.replace(/\[(\w+)\]/g,".$1");// convert indexes to properties
s=s.replace(/^\./,"");// strip a leading dot
for(var a=s.split("."),i=0,n=a.length,k;i<n;++i){k=a[i];if(o){if(k in o){o=o[k]}else{return r}}else{return r}}return o}/**
 * Manage window based events in a consistent and simple manner
 */var winEventsElement=function winEventsElement(SuperClass){return(/*#__PURE__*/function(_SuperClass){babelHelpers.inherits(_class,_SuperClass);function _class(){babelHelpers.classCallCheck(this,_class);return babelHelpers.possibleConstructorReturn(this,babelHelpers.getPrototypeOf(_class).apply(this,arguments))}babelHelpers.createClass(_class,[{key:"__applyWinEvents",value:function __applyWinEvents(status){if(this.__winEvents){for(var eName in this.__winEvents){window["".concat(status?"add":"remove","EventListener")](eName,this[this.__winEvents[eName]].bind(this))}}}/**
     * HTMLElement connected element
     */},{key:"connectedCallback",value:function connectedCallback(){if(babelHelpers.get(babelHelpers.getPrototypeOf(_class.prototype),"connectedCallback",this)){babelHelpers.get(babelHelpers.getPrototypeOf(_class.prototype),"connectedCallback",this).call(this)}this.__applyWinEvents(!0)}/**
     * HTML Element disconnected element
     */},{key:"disconnectedCallback",value:function disconnectedCallback(){this.__applyWinEvents(!1);if(babelHelpers.get(babelHelpers.getPrototypeOf(_class.prototype),"disconnectedCallback",this)){babelHelpers.get(babelHelpers.getPrototypeOf(_class.prototype),"disconnectedCallback",this).call(this)}}}]);return _class}(SuperClass))};_exports.winEventsElement=winEventsElement;/**
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */var debug=!1,validNodeTypes=[Node.ELEMENT_NODE,Node.TEXT_NODE,Node.DOCUMENT_FRAGMENT_NODE];function isValidNode(node){return validNodeTypes.includes(node.nodeType)}function findNode(s,parentNode,isLeft){var nodes=parentNode.childNodes||parentNode.children;if(!nodes){return parentNode;// found it, probably text
}for(var i=0;i<nodes.length;++i){var j=isLeft?i:nodes.length-1-i,childNode=nodes[j];if(!isValidNode(childNode)){continue}debug;if(s.containsNode(childNode,!0)){if(s.containsNode(childNode,!1)){debug;return childNode}debug;return findNode(s,childNode,isLeft)}debug}return parentNode}/**
 * @param {function(!Event)} fn to add to selectionchange internals
 */var addInternalListener=function(){var testNode=document.createElement("div"),testRoot=testNode.attachShadow({mode:"open"});if(testRoot.getSelection){// getSelection really exists, why are you using us?
document.addEventListener("selectionchange",function(ev){document.dispatchEvent(new CustomEvent("-shadow-selectionchange"))});return function(){}}var withinInternals=!1,handlers=[];document.addEventListener("selectionchange",function(ev){if(withinInternals){return}document.dispatchEvent(new CustomEvent("-shadow-selectionchange"));withinInternals=!0;window.setTimeout(function(){withinInternals=!1},0);handlers.forEach(function(fn){return fn(ev)})});return function(fn){return handlers.push(fn)}}(),wasCaret=!1,resolveTask=null;addInternalListener(function(ev){var s=window.getSelection();if("Caret"===s.type){wasCaret=!0}else if(wasCaret&&!resolveTask){resolveTask=Promise.resolve(!0).then(function(){wasCaret=!1;resolveTask=null})}});/**
 * @param {!Selection} s the window selection to use
 * @param {!Node} node the node to walk from
 * @param {boolean} walkForward should this walk in natural direction
 * @return {boolean} whether the selection contains the following node (even partially)
 */function containsNextElement(s,node,walkForward){var start=node;while(node=walkFromNode(node,walkForward)){// walking (left) can contain our own parent, which we don't want
if(!node.contains(start)){break}}if(!node){return!1}// we look for Element as .containsNode says true for _every_ text node, and we only care about
// elements themselves
return babelHelpers.instanceof(node,Element)&&s.containsNode(node,!0)}/**
 * @param {!Selection} s the window selection to use
 * @param {!Node} leftNode the left node
 * @param {!Node} rightNode the right node
 * @return {boolean|undefined} whether this has natural direction
 */function getSelectionDirection(s,leftNode,rightNode){if("Range"!==s.type){return void 0;// no direction
}var measure=function measure(){return s.toString().length},initialSize=measure();debug;if(1===initialSize&&wasCaret&&leftNode===rightNode){// nb. We need to reset a single selection as Safari _always_ tells us the cursor was dragged
// left to right (maybe RTL on those devices).
// To be fair, Chrome has the same bug.
debug;s.extend(leftNode,0);s.collapseToEnd();return void 0}var updatedSize;// Try extending forward and seeing what happens.
s.modify("extend","forward","character");updatedSize=measure();debug;if(updatedSize>initialSize||containsNextElement(s,rightNode,!0)){debug;s.modify("extend","backward","character");return!0}else if(updatedSize<initialSize||!s.containsNode(leftNode)){debug;s.modify("extend","backward","character");return!1}// Maybe we were at the end of something. Extend backwards.
// TODO(samthor): We seem to be able to get away without the 'backwards' case.
s.modify("extend","backward","character");updatedSize=measure();debug;if(updatedSize>initialSize||containsNextElement(s,leftNode,!1)){debug;s.modify("extend","forward","character");return!1}else if(updatedSize<initialSize||!s.containsNode(rightNode)){debug;s.modify("extend","forward","character");return!0}// This is likely a select-all.
return void 0}/**
 * Returns the next valid node (element or text). This is needed as Safari doesn't support
 * TreeWalker inside Shadow DOM. Don't escape shadow roots.
 *
 * @param {!Node} node to start from
 * @param {boolean} walkForward should this walk in natural direction
 * @return {Node} node found, if any
 */function walkFromNode(node,walkForward){if(!walkForward){return node.previousSibling||node.parentNode||null}while(node){if(node.nextSibling){return node.nextSibling}node=node.parentNode}return null}/**
 * @param {!Node} node to start from
 * @param {boolean} isLeft is this a left node
 * @param {string} s expected string
 * @return {?{node: !Node, offset: number}}
 */function walkTextFromNode(node,isLeft,s){for(;node;node=walkFromNode(node,isLeft)){if(node.nodeType!==Node.TEXT_NODE){continue}var t=node.textContent;if(isLeft){if(s.length<t.length){return{node:node,offset:s.length}}var prefix=s.substr(0,t.length);if(prefix!==t){console.debug("unexpected string prefix",prefix,"expected",t)}s=s.substr(t.length)}else{if(s.length<t.length){return{node:node,offset:t.length-s.length}}var suffix=s.substr(s.length-t.length);if(suffix!==t){console.debug("unexpected string suffix",suffix,"expected",t)}s=s.substr(0,s.length-t.length)}}return null;// too far
}/**
 * @param {!Node} node
 * @return {number} count of initial space
 */function initialSpace(node){if(node.nodeType!==Node.TEXT_NODE){return 0}return /^\s*/.exec(node.textContent)[0].length}/**
 * @param {!Node} node
 * @return {number} count of ignored trailing space
 */function ignoredTrailingSpace(node){if(node.nodeType!==Node.TEXT_NODE){return 0}var trailingSpaceCount=/\s*$/.exec(node.textContent)[0].length;if(!trailingSpaceCount){return 0}return trailingSpaceCount-1;// always allow single last
}var cachedRange=new Map;function getRange(root){if(root.getSelection){var s=root.getSelection();return s.rangeCount?s.getRangeAt(0):null}var thisFrame=cachedRange.get(root);if(thisFrame){return thisFrame}var initialText=window.getSelection().toString(),result=internalGetShadowSelection(root),rs=result.range&&result.range.toString()||null;if(null!==rs&&rs!==initialText){// TODO: sometimes triggers on single-char hack etc
if(rs.replace(/\s/g,"")!==initialText.replace(/\s/g,"")){// nb. selection eats initial/ending space, range does not: if whitespace is the only
// difference, then ignore
console.warn("invalid range, initial text:",initialText);console.warn("vs",rs,result.mode,result.range)}}cachedRange.set(root,result.range);window.setTimeout(function(){cachedRange.delete(root)},0);debug;return result.range}var fakeSelectionNode=document.createTextNode("");function internalGetShadowSelection(root){var range=document.createRange(),s=window.getSelection();if(!s.containsNode(root.host,!0)){return{range:null,mode:"none"}}// TODO: inserting fake nodes isn't ideal, but containsNode doesn't work on nearby adjacent
// text nodes (in fact it returns true for all text nodes on the page?!).
// insert a fake 'before' node to see if it's selected
root.insertBefore(fakeSelectionNode,root.childNodes[0]);var includesBeforeRoot=s.containsNode(fakeSelectionNode);fakeSelectionNode.remove();if(includesBeforeRoot){return{range:null,mode:"outside-before"}}// insert a fake 'after' node to see if it's selected
root.appendChild(fakeSelectionNode);var includesAfterRoot=s.containsNode(fakeSelectionNode);fakeSelectionNode.remove();if(includesAfterRoot){return{range:null,mode:"outside-after"}}var measure=function measure(){return s.toString().length},initialSelectionContent=s.toString();if(!("Caret"===s.type||"Range"===s.type)){throw new TypeError("unexpected type: "+s.type)}var initialCaret="Caret"===s.type,leftNode=findNode(s,root,!0),rightNode,isNaturalDirection=void 0;if("Range"===s.type){rightNode=findNode(s,root,!1);// get right node here _before_ getSelectionDirection
isNaturalDirection=getSelectionDirection(s,leftNode,rightNode);// isNaturalDirection means "going right"
}if("Caret"===s.type){// we might transition to being a caret, so don't check initial value
s.extend(leftNode,0);var at=measure();s.collapseToEnd();range.setStart(leftNode,at);range.setEnd(leftNode,at);return{range:range,mode:"caret"}}else if(isNaturalDirection===void 0){if("Range"!==s.type){throw new TypeError("unexpected type: "+s.type)}// This occurs when we can't move because we can't extend left or right to measure the
// direction we're moving in. Good news though: we don't need to _change_ the selection
// to measure it, so just return immediately.
range.setStart(leftNode,0);range.setEnd(rightNode,rightNode.length);return{range:range,mode:"all"}}var size=measure(),offsetLeft,offsetRight,validRightLength=rightNode.length-ignoredTrailingSpace(rightNode);if(isNaturalDirection){// walk in the opposite direction first
s.extend(leftNode,0);offsetLeft=measure()+initialSpace(leftNode);// measure doesn't include initial space
// then in our actual direction
s.extend(rightNode,validRightLength);offsetRight=validRightLength-(measure()-size);// then revert to the original position
s.extend(rightNode,offsetRight)}else{// walk in the opposite direction first
s.extend(rightNode,validRightLength);offsetRight=validRightLength-measure();// then in our actual direction
s.extend(leftNode,0);offsetLeft=measure()-size+initialSpace(leftNode);// doesn't include initial space
// then revert to the original position
s.extend(leftNode,offsetLeft)}if(debug){if(leftNode===rightNode){console.info("got string",leftNode.textContent.substr(offsetLeft,offsetRight-offsetLeft))}else{console.info(">>> string",leftNode.textContent.substr(offsetLeft));console.info("<<< string",rightNode.textContent.substr(0,offsetRight))}}range.setStart(leftNode,offsetLeft);range.setEnd(rightNode,offsetRight);return{mode:isNaturalDirection?"right":"left",range:range}}});