define(["exports", "require", "../../lit-element/lit-element.js"], function (_exports, _require, _litElement) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.createSWC = createSWC;
  _require = babelHelpers.interopRequireWildcard(_require);

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  function _templateObject_8c237bf0c96f11ea8be5e1d5fe7ec787() {
    var data = babelHelpers.taggedTemplateLiteral(["\n          /* this style helps ease FOUC w/ dynamic imports */\n          :host *:not(:defined) {\n            display: none;\n          }\n        "]);

    _templateObject_8c237bf0c96f11ea8be5e1d5fe7ec787 = function _templateObject_8c237bf0c96f11ea8be5e1d5fe7ec787() {
      return data;
    };

    return data;
  }

  /**
   * `simple-wc`
   * `A simple web component wrapper to simplify consistent patterns of element creation`
   * @demo demo/index.html
   * @element simple-wc
   */
  function camelCaseToDash(key) {
    return key.replace(/([A-Z])/g, function (g) {
      return "-".concat(g[0].toLowerCase());
    });
  }

  function createSWC(swc) {
    var MyComponent =
    /*#__PURE__*/
    function (_LitElement) {
      babelHelpers.inherits(SWC, _LitElement);

      /**
       * HTMLElement
       */
      function SWC() {
        var _this;

        babelHelpers.classCallCheck(this, SWC);
        _this = babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(SWC).call(this));

        for (var key in swc.callbacks) {
          _this[key] = swc.callbacks[key];
        } // internal var to access everywhere
        // set the values from defaults


        for (var _key in swc.data.values) {
          _this[_key] = swc.data.values[_key];
        } // dynamically import depedencies


        setTimeout(function () {
          swc.deps.map(function (i) {
            new Promise(function (res, rej) {
              return _require.default(["../../".concat(i)], res, rej);
            });
          });
        }, 0);
        return _this;
      }

      babelHelpers.createClass(SWC, [{
        key: "render",

        /**
         * LitElement render function
         */
        value: function render() {
          return swc.html(this, _litElement.html);
        }
        /**
         * LitElement style rendering
         */

      }, {
        key: "updated",

        /**
         * Updated attribute / property callback
         */
        value: function updated(changedProperties) {
          var _this2 = this;

          if (babelHelpers.get(babelHelpers.getPrototypeOf(SWC.prototype), "updated", this)) {
            babelHelpers.get(babelHelpers.getPrototypeOf(SWC.prototype), "updated", this).call(this, changedProperties);
          }

          changedProperties.forEach(function (old, name) {
            if (swc.data.observe) {
              swc.data.observe.forEach(function (value, key) {
                // we have something we are observing
                if (value[0].includes(name)) {
                  var result; // theres 1 value so pass new and old vlaue

                  if (value[0].length === 1) {
                    result = swc.callbacks[value[1]](_this2[value[0][0]], old);
                  } else {
                    var _swc$callbacks;

                    // pass in all the current values looking off of this
                    var valueMap = [];
                    value[0].map(function (val) {
                      valueMap.push(_this2[val]);
                    }); // spread the value map so we get the values populated as args correctly

                    result = (_swc$callbacks = swc.callbacks)[value[1]].apply(_swc$callbacks, valueMap);
                  } // set the result to this value while also spreading
                  // array values to propagate data binding
                  // this only happens if we have a 3rd value which is what we are
                  // storing the result in otherwise the result is not used


                  if (value.length == 3) {
                    _this2[value[2]] = Array.isArray(result) ? babelHelpers.toConsumableArray(result) : result;
                  }
                }
              });
            } // notify changes


            if (swc.data.notify && swc.data.notify.includes(name)) {
              // notify
              _this2.dispatchEvent(new CustomEvent("".concat(camelCaseToDash(name), "-changed"), {
                detail: {
                  value: _this2[name]
                }
              }));
            }
          });
        }
        /**
         * Window events add and remove
         * @param {String} status
         */

      }, {
        key: "__applyWinEvents",
        value: function __applyWinEvents(status) {
          if (swc.events && swc.events.window) {
            for (var eName in swc.events.window) {
              window["".concat(status ? "add" : "remove", "EventListener")](eName, swc.callbacks[swc.events.window[eName]].bind(this));
            }
          }
        }
        /**
         * LitElement shadow dom ready
         */

      }, {
        key: "firstUpdated",
        value: function firstUpdated() {
          if (swc.events && swc.events.shadow) {
            for (var target in swc.events.shadow) {
              for (var eName in swc.events.shadow[target]) {
                this.shadowRoot.querySelector(target).addEventListener(eName, swc.callbacks[swc.events.shadow[target][eName]].bind(this));
              }
            }
          }
        }
        /**
         * HTMLElement connected element
         */

      }, {
        key: "connectedCallback",
        value: function connectedCallback() {
          if (babelHelpers.get(babelHelpers.getPrototypeOf(SWC.prototype), "connectedCallback", this)) {
            babelHelpers.get(babelHelpers.getPrototypeOf(SWC.prototype), "connectedCallback", this).call(this);
          }

          this.__applyWinEvents(true);
        }
        /**
         * HTMLElement disconnected element
         */

      }, {
        key: "disconnectedCallback",
        value: function disconnectedCallback() {
          this.__applyWinEvents(false);

          if (babelHelpers.get(babelHelpers.getPrototypeOf(SWC.prototype), "disconnectedCallback", this)) {
            babelHelpers.get(babelHelpers.getPrototypeOf(SWC.prototype), "disconnectedCallback", this).call(this);
          }
        }
        /**
         * return HAX Schema for wiring to HAX
         * @todo build this on the fly from swc
         */

      }, {
        key: "haxProperties",
        value: function haxProperties() {
          return {};
        }
      }], [{
        key: "tag",
        get: function get() {
          return swc.name;
        }
      }, {
        key: "styles",
        get: function get() {
          return [(0, _litElement.css)(_templateObject_8c237bf0c96f11ea8be5e1d5fe7ec787()), swc.css(this, _litElement.css)];
        }
        /**
         * LitElement / popular convention
         */

      }, {
        key: "properties",
        get: function get() {
          var props = {};

          for (var key in swc.data.values) {
            // set type
            props[key] = {
              type: babelHelpers.typeof(swc.data.values[key])
            };
            props[key].type = props[key].type.charAt(0).toUpperCase() + props[key].type.slice(1); // convert camel to attr name IF it doesnt match

            var attr = camelCaseToDash(key);

            if (attr !== key) {
              props[key].attribute = attr;
            } // LitElement syntax


            if (swc.data.reflect && swc.data.reflect.includes(key)) {
              props[key].reflect = true;
            }
          }

          return _objectSpread({}, babelHelpers.get(babelHelpers.getPrototypeOf(SWC), "properties", this), {}, props);
        }
      }]);
      return SWC;
    }(_litElement.LitElement);

    customElements.define(MyComponent.tag, MyComponent);
    return MyComponent;
  }
});