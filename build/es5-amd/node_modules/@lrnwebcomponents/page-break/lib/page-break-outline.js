define(["exports", "./page-break-manager.js", "../../utils/utils.js"], function (_exports, _pageBreakManager, _utils) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.PageBreakOutline = void 0;

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var PageBreakOutline = /*#__PURE__*/function (_HTMLElement) {
    babelHelpers.inherits(PageBreakOutline, _HTMLElement);

    var _super = _createSuper(PageBreakOutline);

    function PageBreakOutline() {
      var _this;

      babelHelpers.classCallCheck(this, PageBreakOutline);
      _this = _super.call(this);
      _this.target = null;
      _this.selector = null;
      _this.div = document.createElement("div");

      _this.appendChild(_this.div);

      _this.basePath = "";

      _this.addEventListener("click", _this.clickHandler.bind(babelHelpers.assertThisInitialized(_this)));

      return _this;
    }

    babelHelpers.createClass(PageBreakOutline, [{
      key: "attributeChangedCallback",
      value: function attributeChangedCallback(name, oldValue, newValue) {
        if (name === "base-path" && newValue) {
          this.basePath = newValue;
        }

        if (name === "selector" && newValue) {
          this.selector = newValue;
          this.target = document.querySelector(this.selector);
          this.render(this.div);
        }
      }
    }, {
      key: "connectedCallback",
      value: function connectedCallback() {
        var _this2 = this;

        setTimeout(function () {
          window.addEventListener("page-break-change", _this2.rerender.bind(_this2));
        }, 0); // render on initial paint

        this.render(this.div);
      }
    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        window.removeEventListener("page-break-change", this.rerender.bind(this));
      }
    }, {
      key: "clickHandler",
      value: function clickHandler(e) {
        var target = (0, _utils.normalizeEventPath)(e)[0];

        if (target.tagName === "A") {
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation();

          for (var i = 0; i < _pageBreakManager.pageBreakManager.breaks.length; i++) {
            if (_pageBreakManager.pageBreakManager.breaks[i].path === target.getAttribute("href")) {
              _pageBreakManager.pageBreakManager.breaks[i].scrollIntoView({
                behavior: "smooth",
                block: "start",
                inline: "nearest"
              });

              break;
            }
          }
        }
      } // oh.. you are a clever boy aren't you
      // well.. someone is clever, I'm just good at repurposing
      // source: https://ianopolous.github.io/javascript/innerHTML
      // this will check that we have a parentNode to avoid
      // really early calls for changes in our page break hierarchy
      // and then as long as we do have a parent, we can perform the replacement

    }, {
      key: "rerender",
      value: function rerender() {
        var _this3 = this;

        // very simple debounce
        if (!this.__lock) {
          this.__lock = true;
          setTimeout(function () {
            var tmp = _this3.div.cloneNode(false);

            _this3.render(tmp);

            _this3.replaceChild(tmp, _this3.div);

            _this3.div = tmp;
            _this3.__lock = false;
          }, 0);
        }
      } // render a new mini outline of links based on discovering headings within a target

    }, {
      key: "render",
      value: function render(container) {
        if (this.target && this.target.children && this.target.children.length > 0) {
          // wipe inner
          var html = "<ul>" + "\n";
          var parents = []; // loop children

          var kids = this.target.querySelectorAll("page-break");

          for (var i = 0; i < kids.length; i++) {
            var el = kids[i]; // see if our parent is the active parent

            if (parents.length > 0) {
              if (el.parent && parents.indexOf(el.parent) !== -1) {
                while (parents.indexOf(el.parent) !== -1) {
                  html += "</ul></li>" + "\n";
                  parents.shift();
                }
              } // missing parent in the hierarchy
              else if (el.parent && parents.indexOf(el.parent) === -1) {// do nothing; something messed up so let's act like it
                  // didn't happen and just render as we have been
                } else {
                  // no parent, shift all the way down to nothing
                  while (parents.length > 0) {
                    html += "</ul></li>" + "\n";
                    parents.shift();
                  } // ALLLL the way to 0


                  html += "</ul></li>" + "\n";
                }
            }

            var depth = 0;

            if (i !== 0 && el.parent && this.target.querySelector("page-break[path=\"".concat(el.parent, "\"]"))) {
              depth = this.target.querySelector("page-break[path=\"".concat(el.parent, "\"]")).depth + 1;
            }

            html += "<li>" + "\n" + "<a href=\"".concat(this.basePath + el.path, "\" data-path=\"").concat(el.path, "\" data-parent=\"").concat(el.parent, "\" data-depth=\"").concat(depth, "\">").concat(el.title, "</a>") + "\n"; // set back into the element how deep it is; weird I know but the element doesn't
            // know this, the tree builder would though

            el.depth = depth; // see if WE have children

            if (i != kids.length && kids[i + 1] && kids[i + 1].parent === el.path) {
              html += "<ul>" + "\n";

              if (el.parent) {
                parents.unshift(el.parent);
              }
            } else {
              html += "</li>" + "\n";
            }
          }

          html += "</ul>" + "\n";
          container.innerHTML = html;
        }
      }
    }], [{
      key: "tag",
      get: function get() {
        return "page-break-outline";
      }
    }, {
      key: "observedAttributes",
      get: function get() {
        return ["selector", "base-path"];
      }
    }]);
    return PageBreakOutline;
  }( /*#__PURE__*/babelHelpers.wrapNativeSuper(HTMLElement));

  _exports.PageBreakOutline = PageBreakOutline;
  customElements.define(PageBreakOutline.tag, PageBreakOutline);
});