define(["exports", "meta", "../../lit/index.js", "../schema-behaviors/schema-behaviors.js", "../intersection-element/lib/IntersectionObserverMixin.js", "../i18n-manager/lib/I18NMixin.js", "../simple-icon/lib/simple-icon-button-lite.js", "../simple-icon/lib/simple-icons.js", "../simple-icon/lib/simple-iconset.js", "./lib/page-break-manager.js"], function (_exports, meta, _index, _schemaBehaviors, _IntersectionObserverMixin, _I18NMixin, _simpleIconButtonLite, _simpleIcons, _simpleIconset, _pageBreakManager) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.PageBreak = void 0;
  meta = _interopRequireWildcard(meta);

  var _templateObject_e75babe0ce4611ecb13bcf602138080f, _templateObject2_e75babe0ce4611ecb13bcf602138080f, _templateObject3_e75babe0ce4611ecb13bcf602138080f;

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || babelHelpers.typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  /**
   * `page-break`
   * `a visual break but also helps manage hierarchy`
   *
   * @demo demo/index.html
   * @element page-break
   */
  var PageBreak = /*#__PURE__*/function (_IntersectionObserver) {
    babelHelpers.inherits(PageBreak, _IntersectionObserver);

    var _super = _createSuper(PageBreak);

    function PageBreak() {
      var _this;

      babelHelpers.classCallCheck(this, PageBreak);
      _this = _super.call(this);
      _this.status = "";
      _this.t = {
        newPage: "New page",
        pageBreak: "Page break",
        pageDetails: "Page details",
        clickToUnlock: "Click to unlock",
        noParent: "No parent",
        toggleLock: "Toggle lock",
        togglePublished: "Toggle published"
      };

      _this.registerLocalization({
        context: babelHelpers.assertThisInitialized(_this),
        localesPath: new URL("./locales", meta.url).href,
        locales: ["es"]
      });

      _this.title = _this.t.newPage;
      _this.slug = "";
      _this.published = false;
      _this.target = null;
      _this.locked = false;
      _this.order = null;
      _this.depth = 0;
      _this.itemId = null;
      _this._haxState = false;
      _this.IORemoveOnVisible = false;
      _this.IODelay = 250;
      _this.remoteHeadingobserver = new MutationObserver(function () {
        // lock ensures that title update, then updating hte innerText
        // doesn't generate another mutation record
        if (_this.title != _this.target.innerText) {
          _this.__moUpdate = true;
          _this.title = _this.target.innerText;
        }
      }); // default break type for the vast majority of situations

      _this.breakType = "node";
      return _this;
    }

    babelHelpers.createClass(PageBreak, [{
      key: "connectedCallback",
      value: function connectedCallback() {
        var _this2 = this;

        babelHelpers.get(babelHelpers.getPrototypeOf(PageBreak.prototype), "connectedCallback", this).call(this);

        if (this.breakType === "node") {
          if (this.nextElementSibling && this.nextElementSibling.tagName && ["H1", "H2", "H3", "H4", "H5", "H6"].includes(this.nextElementSibling.tagName)) {
            this.title = this.nextElementSibling.innerText;
            this.target = this.nextElementSibling;
            this.setupTargetData(this.target);
          } else {
            // we are going to inject a title element possibly so pause
            // to make sure there wasn't some timing in rendering before
            // we accidentally inject an element
            setTimeout(function () {
              if (_this2.target === null) {
                if (_this2.nextElementSibling && _this2.nextElementSibling.tagName && ["H1", "H2", "H3", "H4", "H5", "H6"].includes(_this2.nextElementSibling.tagName)) {
                  _this2.title = _this2.nextElementSibling.innerText;
                  _this2.target = _this2.nextElementSibling;

                  _this2.setupTargetData(_this2.target);
                } else {
                  var tagName = _this2.depth === 0 ? "h2" : "h".concat(_this2.depth + 2);
                  var newH = document.createElement(tagName);
                  newH.setAttribute("data-original-level", "H2");
                  newH.innerText = _this2.title;

                  _this2.parentNode.insertBefore(newH, _this2.nextElementSibling); // account for HAX which might mess w/ the tag on insert


                  setTimeout(function () {
                    _this2.setupTargetData(_this2.nextElementSibling);
                  }, 100);
                }
              }
            }, 0);
          }
        }

        window.dispatchEvent(new CustomEvent("page-break-registration", {
          composed: true,
          bubbles: true,
          cancelable: true,
          detail: {
            value: this,
            action: "add"
          }
        }));
        window.dispatchEvent(new CustomEvent("page-break-change", {
          composed: true,
          bubbles: true,
          cancelable: true,
          detail: {
            value: this
          }
        }));
      }
    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        window.dispatchEvent(new CustomEvent("page-break-registration", {
          detail: {
            value: this,
            action: "remove"
          }
        }));
        window.dispatchEvent(new CustomEvent("page-break-change", {
          composed: true,
          bubbles: true,
          cancelable: true,
          detail: {
            value: this
          }
        }));
        this.remoteHeadingobserver.disconnect();
        babelHelpers.get(babelHelpers.getPrototypeOf(PageBreak.prototype), "disconnectedCallback", this).call(this);
      } // setup the target data

    }, {
      key: "setupTargetData",
      value: function setupTargetData(newTarget) {
        if (this.target) {
          this.remoteHeadingobserver.disconnect();
        }

        this.target = newTarget; // add a backdoor for hax to have a hook into this

        this._haxSibling = this; // @todo need to add some kind of "if this gets deleted let me know"
        // or a hook that basically blocks this being deleted because it
        // is under control of the page-break tag

        this.remoteHeadingobserver.observe(this.target, {
          characterData: true,
          childList: true,
          subtree: true
        });
      }
    }, {
      key: "updated",
      value: function updated(changedProperties) {
        var _this3 = this;

        if (babelHelpers.get(babelHelpers.getPrototypeOf(PageBreak.prototype), "updated", this)) {
          babelHelpers.get(babelHelpers.getPrototypeOf(PageBreak.prototype), "updated", this).call(this, changedProperties);
        }

        changedProperties.forEach(function (oldValue, propName) {
          if (propName === "schemaResourceID" && _this3.itemId == null && oldValue !== undefined) {
            _this3.itemId = _this3.schemaResourceID.replace("#", "item-");
          } // when visible, "click" the thing so that it's activated


          if (propName === "elementVisible" && _this3.elementVisible && _this3.itemId && _this3.shadowRoot) {
            setTimeout(function () {
              _pageBreakManager.pageBreakManager.updateVisibleAsActive();
            }, 0);
          } // replicate locked aross elements between here and next page break


          if (_this3.locked && propName === "locked") {
            _pageBreakManager.pageBreakManager.elementsBetween(_this3).forEach(function (el) {
              el.setAttribute("data-hax-lock", "data-hax-lock");
            });
          } // was true, not locked
          else if (!_this3.locked && propName === "locked" && oldValue) {
              _pageBreakManager.pageBreakManager.elementsBetween(_this3).forEach(function (el) {
                el.removeAttribute("data-hax-lock");
              });
            } // update CE menu when these change if it is around


          if (_this3._ceMenu && ["locked", "parent", "published"].includes(propName)) {
            _this3._updateHAXCEMenu();
          } // fire event for reaction so we can update sgtate elsewhere


          if (["title", "parent", "slug"].includes(propName)) {
            window.dispatchEvent(new CustomEvent("page-break-change", {
              composed: true,
              bubbles: true,
              cancelable: true,
              detail: {
                value: _this3
              }
            }));
          } // while the most common, only do these when we have a target


          if (_this3.breakType === "node" && _this3.target) {
            if (propName === "title" && _this3[propName]) {
              // change title text to match title if updated but delay
              // to avoid input spamming as this could generate a lot of change records
              // but don't just set it as it would generate another change record
              if (_this3.__moUpdate) {
                // skips the update of innerText to match
                _this3.__moUpdate = false;
              } else if (_this3.title != _this3.target.innerText) {
                _this3.target.innerText = _this3.title;
              }
            } // the magic a11y rewriter


            if (!_this3._haxState && propName === "depth" && _this3.depth >= 0) {
              _pageBreakManager.pageBreakManager.elementsBetween(_this3, "page-break", "h1,h2,h3,h4,h5,h6").forEach(function (el) {
                var tagNumber = (el.getAttribute("data-original-level") ? new Number(el.getAttribute("data-original-level").replace("H", "")) : new Number(el.tagName.replace("H", ""))) + _this3.depth;
                tagNumber = tagNumber > 6 ? 6 : tagNumber;
                var newH = document.createElement("h".concat(tagNumber));
                newH.setAttribute("data-original-level", el.tagName);

                for (var i = 0, l = el.attributes.length; i < l; ++i) {
                  newH.setAttribute(el.attributes.item(i).nodeName, el.attributes.item(i).nodeValue);
                }

                newH.innerHTML = el.innerHTML;

                _this3.setupTargetData(newH);

                el.parentNode.replaceChild(newH, el);
              });
            } // hax state is a special case bc we want to edit in whats saved
            // not what's interpretted


            if (propName === "_haxState" && oldValue !== undefined) {
              if (_this3._haxState) {
                _pageBreakManager.pageBreakManager.elementsBetween(_this3, "page-break", "h1,h2,h3,h4,h5,h6").forEach(function (el) {
                  if (el.getAttribute("data-original-level")) {
                    var tagNumber = new Number(el.getAttribute("data-original-level").replace("H", ""));
                    var newH = document.createElement("h".concat(tagNumber));

                    for (var i = 0, l = el.attributes.length; i < l; ++i) {
                      newH.setAttribute(el.attributes.item(i).nodeName, el.attributes.item(i).nodeValue);
                    }

                    newH.innerHTML = el.innerHTML;
                    el.parentNode.replaceChild(newH, el);

                    _this3.setupTargetData(newH);
                  }
                });
              } else {
                _pageBreakManager.pageBreakManager.elementsBetween(_this3, "page-break", "h1,h2,h3,h4,h5,h6").forEach(function (el) {
                  var tagNumber = (el.getAttribute("data-original-level") ? new Number(el.getAttribute("data-original-level").replace("H", "")) : new Number(el.tagName.replace("H", ""))) + _this3.depth;
                  tagNumber = tagNumber > 6 ? 6 : tagNumber;
                  var newH = document.createElement("h".concat(tagNumber));
                  newH.setAttribute("data-original-level", el.tagName);

                  for (var i = 0, l = el.attributes.length; i < l; ++i) {
                    newH.setAttribute(el.attributes.item(i).nodeName, el.attributes.item(i).nodeValue);
                  }

                  newH.innerHTML = el.innerHTML;
                  el.parentNode.replaceChild(newH, el);

                  _this3.setupTargetData(newH);
                });
              }
            }
          } // allow for haxcms page style association to allow users to edit the
          // current page's details


          if (propName === "breakType" || propName === "t") {
            var iconPath;

            if (_this3[propName] === "node") {
              iconPath = _simpleIconset.SimpleIconsetStore.getIcon("editor:format-page-break");
              _this3.shadowRoot.querySelector("style").innerHTML = "\n          :host([data-hax-ray]:hover) .mid::before {\n            content: \"".concat(_this3.t.pageBreak, "\";\n          }");
            } else {
              iconPath = _simpleIconset.SimpleIconsetStore.getIcon("hax:page-details");
              _this3.shadowRoot.querySelector("style").innerHTML = "\n          :host([data-hax-ray]:hover) .mid::before {\n            content: \"".concat(_this3.t.pageDetails, "\";\n          }");
            } // set background of the tag itself to the icon based on mode


            _this3.style.backgroundImage = "url(\"".concat(iconPath, "\")");
          }
        });
      }
    }, {
      key: "firstUpdated",
      value: function firstUpdated(changedProperties) {
        if (babelHelpers.get(babelHelpers.getPrototypeOf(PageBreak.prototype), "firstUpdated", this)) {
          babelHelpers.get(babelHelpers.getPrototypeOf(PageBreak.prototype), "firstUpdated", this).call(this, changedProperties);
        } // align schema ID w/ the ID from itemId on load


        if (this.itemId != null) {
          this.schemaResourceID = this.itemId;
        }
      }
    }, {
      key: "render",
      value: function render() {
        return (0, _index.html)(_templateObject_e75babe0ce4611ecb13bcf602138080f || (_templateObject_e75babe0ce4611ecb13bcf602138080f = babelHelpers.taggedTemplateLiteral(["\n      <style></style>\n      <a .href=\"", "\" .name=\"#", "\" class=\"sr-only\"\n        >", "</a\n      >\n      <hr class=\"mid\" />\n      ", "\n    "])), this.slug, this.itemId, this.title, this.locked ? (0, _index.html)(_templateObject2_e75babe0ce4611ecb13bcf602138080f || (_templateObject2_e75babe0ce4611ecb13bcf602138080f = babelHelpers.taggedTemplateLiteral(["<simple-icon-button-lite\n            @click=\"", "\"\n            icon=\"icons:lock\"\n            title=\"", "\"\n          ></simple-icon-button-lite>"])), this.haxClickLockInPage, this.t.clickToUnlock) : "");
      }
      /**
       * haxProperties integration via file reference
       */

    }, {
      key: "haxHooks",
      value:
      /**
       * haxHooks
       */
      function haxHooks() {
        return {
          editModeChanged: "haxeditModeChanged",
          inlineContextMenu: "haxinlineContextMenu",
          activeElementChanged: "haxactiveElementChanged",
          setupActiveElementForm: "haxsetupActiveElementForm",
          preProcessInsertContent: "haxpreProcessInsertContent",
          trayDragNDropToNode: "haxtrayDragNDropToNode"
        };
      }
      /**
       * on insert, test for other page-break tags via manager to see
       * if we're able to steal sane defaults from there
       */

    }, {
      key: "haxpreProcessInsertContent",
      value: function () {
        var _haxpreProcessInsertContent = babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(details, activeNode) {
          var testNode, closestPB;
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  // look up the current page breaks from manager
                  // if a haxcms one exists then use that for defaults
                  // if activeNode would have us be at a different page-break, use this
                  // as the target for drawing the following settings:
                  // for parent (same parent), order (+1 from it), published (mirror), locked (mirror)
                  // this ensures we look at the level just below the body container level
                  testNode = activeNode;

                  if (!(testNode && testNode.parentNode)) {
                    _context.next = 7;
                    break;
                  }

                  while (testNode.parentNode.tagName !== "HAX-BODY") {
                    testNode = testNode.parentNode;
                  }

                  _context.next = 5;
                  return _pageBreakManager.pageBreakManager.associatedPageBreak(testNode);

                case 5:
                  closestPB = _context.sent;

                  if (closestPB) {
                    details.properties.parent = closestPB.parent;
                    details.properties.order = closestPB.order + 1;
                    details.properties.published = closestPB.published;
                    details.properties.locked = closestPB.locked;
                  }

                case 7:
                  return _context.abrupt("return", details);

                case 8:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));

        function haxpreProcessInsertContent(_x, _x2) {
          return _haxpreProcessInsertContent.apply(this, arguments);
        }

        return haxpreProcessInsertContent;
      }()
      /**
       * Same as the above hook in capability however because of the interim state
       * of a drag event, we need a specialized hook that is for when the new
       * element has been dropped into the page
       */

    }, {
      key: "haxtrayDragNDropToNode",
      value: function () {
        var _haxtrayDragNDropToNode = babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(activeNode) {
          var testNode, closestPB;
          return regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  // look up the current page breaks from manager
                  // if a haxcms one exists then use that for defaults
                  // if activeNode would have us be at a different page-break, use this
                  // as the target for drawing the following settings:
                  // for parent (same parent), order (+1 from it), published (mirror), locked (mirror)
                  // this ensures we look at the level just below the body container level
                  testNode = activeNode;

                  while (testNode.parentNode.tagName !== "HAX-BODY") {
                    testNode = testNode.parentNode;
                  }

                  _context2.next = 4;
                  return _pageBreakManager.pageBreakManager.associatedPageBreak(testNode);

                case 4:
                  closestPB = _context2.sent;

                  if (closestPB) {
                    activeNode.parent = closestPB.parent;
                    activeNode.order = closestPB.order + 1;
                    activeNode.published = closestPB.published;
                    activeNode.locked = closestPB.locked;
                  }

                case 6:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2);
        }));

        function haxtrayDragNDropToNode(_x3) {
          return _haxtrayDragNDropToNode.apply(this, arguments);
        }

        return haxtrayDragNDropToNode;
      }()
      /**
       * Allow for dynamic setting of the parent field if we have the store around
       * with values to do so
       */

    }, {
      key: "haxsetupActiveElementForm",
      value: function haxsetupActiveElementForm(props) {
        var _this4 = this;

        if (window.HAXCMS) {
          var itemManifest = window.HAXCMS.requestAvailability().store.getManifestItems(true); // default to null parent as the whole site

          var items = [{
            text: "-- ".concat(this.t.noParent, " --"),
            value: null
          }];
          itemManifest.forEach(function (el) {
            if (el.id != _this4.itemId) {
              (function () {
                // calculate -- depth so it looks like a tree
                var itemBuilder = el; // walk back through parent tree

                var distance = "- ";

                while (itemBuilder && itemBuilder.parent != null) {
                  itemBuilder = itemManifest.find(function (i) {
                    return i.id == itemBuilder.parent;
                  }); // double check structure is sound

                  if (itemBuilder) {
                    distance = "--" + distance;
                  }
                }

                items.push({
                  text: distance + el.title,
                  value: el.id
                });
              })();
            }
          });
          props.settings.configure.forEach(function (attr, index) {
            if (attr.property === "parent") {
              props.settings.configure[index].inputMethod = "select";
              props.settings.configure[index].itemsList = items;
            }
          });
        }
      }
      /**
       * Ensure that if we WERE active and now are not
       * and have a reference to the custom element menu in hax
       * and are the right break type, that we reset these items
       */

    }, {
      key: "haxactiveElementChanged",
      value: function haxactiveElementChanged(element, value) {
        if (!value && this._ceMenu) {
          if (this.breakType === "site") {
            this._ceMenu.disableOps = false;
            this._ceMenu.canMoveElement = true;
            this._ceMenu.insertAbove = true;
          } else {
            this._ceMenu.disableDuplicate = false;
          }
        }
      }
      /**
       * ensure that when we flip states here that we are actively switching the original level var
       */

    }, {
      key: "haxeditModeChanged",
      value: function haxeditModeChanged(value) {
        this._haxState = value;
      }
      /**
       * add buttons when it is in context
       */

    }, {
      key: "haxinlineContextMenu",
      value: function haxinlineContextMenu(ceMenu) {
        this._ceMenu = ceMenu;

        this._updateHAXCEMenu(); // forcibly prevent duplication and deleting of the node controlling the page itself


        if (this.breakType === "site") {
          this._ceMenu.disableOps = true;
          this._ceMenu.canMoveElement = false;
          this._ceMenu.insertAbove = false;
        } else {
          this._ceMenu.disableDuplicate = true;
        }
      } // update custom element buttons so we can do live status changes

    }, {
      key: "_updateHAXCEMenu",
      value: function _updateHAXCEMenu() {
        this._ceMenu.ceButtons = [{
          icon: this.locked ? "icons:lock" : "icons:lock-open",
          callback: "haxClickInlineLock",
          label: this.t.toggleLock
        }, {
          icon: this.published ? "lrn:view" : "lrn:view-off",
          callback: "haxClickInlinePublished",
          label: this.t.togglePublished
        }];
      }
    }, {
      key: "haxClickLockInPage",
      value: function haxClickLockInPage(e) {
        this.locked = !this.locked;
        window.dispatchEvent(new CustomEvent("hax-refresh-tray-form", {}));
      }
    }, {
      key: "haxClickInlineLock",
      value: function haxClickInlineLock(e) {
        this.locked = !this.locked;
        return true;
      }
    }, {
      key: "haxClickInlinePublished",
      value: function haxClickInlinePublished(e) {
        this.published = !this.published;
        return true;
      }
    }], [{
      key: "tag",
      get: function get() {
        return "page-break";
      }
    }, {
      key: "properties",
      get: function get() {
        var props = babelHelpers.get(babelHelpers.getPrototypeOf(PageBreak), "properties", this) || {};
        return _objectSpread(_objectSpread({}, props), {}, {
          order: {
            type: Number
          },
          title: {
            type: String,
            reflect: true
          },
          slug: {
            type: String
          },
          parent: {
            type: String,
            reflect: true
          },
          published: {
            type: Boolean,
            reflect: true
          },
          locked: {
            type: Boolean,
            reflect: true
          },
          depth: {
            type: Number,
            reflect: true
          },
          itemId: {
            type: String,
            attribute: "item-id",
            reflect: true
          },
          breakType: {
            type: String,
            attribute: "break-type"
          },
          status: {
            type: String
          },
          _haxState: {
            type: Boolean
          }
        });
      }
    }, {
      key: "styles",
      get: function get() {
        return [(0, _index.css)(_templateObject3_e75babe0ce4611ecb13bcf602138080f || (_templateObject3_e75babe0ce4611ecb13bcf602138080f = babelHelpers.taggedTemplateLiteral(["\n        :host {\n          display: block;\n          opacity: 0;\n          height: 1px;\n        }\n        :host([data-hax-ray]) {\n          display: block;\n          margin: 20px 0;\n          padding: 20px;\n          opacity: 0.2;\n          background-position: center;\n          background-repeat: no-repeat;\n          transition: all 0.2s linear;\n        }\n        .mid {\n          border: none;\n          border-top: 2px solid #cccccc;\n          overflow: visible;\n          margin: 4px 0 0 0;\n          padding: 0;\n          height: 0;\n        }\n        :host([data-hax-ray]:hover) {\n          opacity: 1;\n        }\n        :host([data-hax-ray]:hover) .mid::before {\n          font-weight: bold;\n          color: #000000;\n          background-color: #ffffff;\n          font-size: 16px;\n          left: calc(50% - 2.5em);\n          top: -16px;\n          position: relative;\n          height: 0;\n          line-height: 36px;\n        }\n        simple-icon-button-lite {\n          float: right;\n          color: #000000;\n          --simple-icon-width: 36px;\n          --simple-icon-height: 36px;\n          margin-top: -28px;\n          margin-right: -46px;\n        }\n        .sr-only {\n          position: absolute;\n          left: -10000px;\n          top: auto;\n          width: 1px;\n          height: 1px;\n          overflow: hidden;\n        }\n      "])))];
      }
    }, {
      key: "haxProperties",
      get: function get() {
        return new URL("./lib/page-break.haxProperties.json", meta.url).href;
      }
    }]);
    return PageBreak;
  }((0, _IntersectionObserverMixin.IntersectionObserverMixin)((0, _I18NMixin.I18NMixin)((0, _schemaBehaviors.SchemaBehaviors)(_index.LitElement))));

  _exports.PageBreak = PageBreak;
  customElements.define(PageBreak.tag, PageBreak);
});