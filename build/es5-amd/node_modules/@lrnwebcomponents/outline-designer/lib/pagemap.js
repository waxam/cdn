define(["exports"], function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.pagemap = void 0;
  var docEl = window.document.documentElement;
  var doc = window.document;
  var body = doc.querySelector("body");

  var Rect = function Rect(x, y, w, h) {
    return Object.assign(Object.create(Rect.prototype), {
      x: x,
      y: y,
      w: w,
      h: h
    });
  };

  Rect.prototype = {
    constructor: Rect,
    relativeTo: function relativeTo() {
      var pos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        x: 0,
        y: 0
      };
      return Rect(this.x - pos.x, this.y - pos.y, this.w, this.h);
    }
  };

  Rect.ofDocument = function () {
    return Rect(0, 0, docEl.scrollWidth, docEl.scrollHeight);
  };

  Rect.ofWindow = function () {
    return Rect(window.pageXOffset, window.pageYOffset, docEl.clientWidth, docEl.clientHeight);
  };

  var getOffset = function getOffset(el) {
    var br = el.getBoundingClientRect();
    return {
      x: br.left + window.pageXOffset,
      y: br.top + window.pageYOffset,
      width: br.width,
      height: br.height
    };
  };

  Rect.ofElement = function (el) {
    var _getOffset = getOffset(el),
        x = _getOffset.x,
        y = _getOffset.y,
        width = _getOffset.width,
        height = _getOffset.height;

    return Rect(x, y, width, height);
  };

  Rect.ofViewport = function (el) {
    var _getOffset2 = getOffset(el),
        x = _getOffset2.x,
        y = _getOffset2.y;

    return Rect(x + el.clientLeft, y + el.clientTop, el.clientWidth, el.clientHeight);
  };

  Rect.ofContent = function (el) {
    var _getOffset3 = getOffset(el),
        x = _getOffset3.x,
        y = _getOffset3.y;

    return Rect(x + el.clientLeft - el.scrollLeft, y + el.clientTop - el.scrollTop, el.scrollWidth, el.scrollHeight);
  };

  var black = function black(pc) {
    return "rgba(0,0,0,".concat(pc / 100, ")");
  };

  var defaults = {
    viewport: null,
    styles: {
      "header,footer,section,article": black(8),
      "h1,a": black(10),
      "h2,h3,h4": black(8)
    },
    back: black(2),
    view: black(5),
    drag: black(10),
    interval: null
  };

  var _listener = function _listener(el, method, types, fn) {
    return types.split(/\s+/).forEach(function (type) {
      return el[method](type, fn);
    });
  };

  var on = function on(el, types, fn) {
    return _listener(el, "addEventListener", types, fn);
  };

  var off = function off(el, types, fn) {
    return _listener(el, "removeEventListener", types, fn);
  };

  var pagemap = function pagemap(canvas, options) {
    var settings = Object.assign({}, defaults, options);
    var context = canvas.getContext("2d");

    var calcScale = function () {
      var width = canvas.clientWidth;
      var height = canvas.clientHeight;
      return function (w, h) {
        return Math.min(width / w, height / h);
      };
    }();

    var resizeCanvas = function resizeCanvas(w, h) {
      canvas.width = w;
      canvas.height = h;
      canvas.style.width = "".concat(w, "px");
      canvas.style.height = "".concat(h, "px");
    };

    var viewport = settings.viewport;

    var find = function find(sel) {
      return Array.from((viewport || doc).querySelectorAll(sel));
    };

    var drag = false;
    var rootRect;
    var viewRect;
    var scale;
    var dragRx;
    var dragRy;

    var drawRect = function drawRect(rect, col) {
      if (!col) {
        return;
      }

      context.beginPath();
      context.rect(rect.x, rect.y, rect.w, rect.h);
      context.fillStyle = col;
      context.fill();
    };

    var applyStyles = function applyStyles(styles) {
      Object.keys(styles).forEach(function (sel) {
        var col = styles[sel];
        find(sel).forEach(function (el) {
          drawRect(Rect.ofElement(el).relativeTo(rootRect), col);
        });
      });
    };

    var draw = function draw() {
      rootRect = viewport ? Rect.ofContent(viewport) : Rect.ofDocument();
      viewRect = viewport ? Rect.ofViewport(viewport) : Rect.ofWindow();
      scale = calcScale(rootRect.w, rootRect.h);
      resizeCanvas(rootRect.w * scale, rootRect.h * scale);
      context.setTransform(1, 0, 0, 1, 0, 0);
      context.clearRect(0, 0, canvas.width, canvas.height);
      context.scale(scale, scale);
      drawRect(rootRect.relativeTo(rootRect), settings.back);
      applyStyles(settings.styles);
      drawRect(viewRect.relativeTo(rootRect), drag ? settings.drag : settings.view);
    };

    var onDrag = function onDrag(ev) {
      ev.preventDefault();
      var cr = Rect.ofViewport(canvas);
      var x = (ev.pageX - cr.x) / scale - viewRect.w * dragRx;
      var y = (ev.pageY - cr.y) / scale - viewRect.h * dragRy;

      if (viewport) {
        viewport.scrollLeft = x;
        viewport.scrollTop = y;
      } else {
        window.scrollTo(x, y);
      }

      draw();
    };

    var onDragEnd = function onDragEnd(ev) {
      drag = false;
      canvas.style.cursor = "pointer";
      body.style.cursor = "auto";
      off(window, "mousemove", onDrag);
      off(window, "mouseup", onDragEnd);
      onDrag(ev);
    };

    var onDragStart = function onDragStart(ev) {
      drag = true;
      var cr = Rect.ofViewport(canvas);
      var vr = viewRect.relativeTo(rootRect);
      dragRx = ((ev.pageX - cr.x) / scale - vr.x) / vr.w;
      dragRy = ((ev.pageY - cr.y) / scale - vr.y) / vr.h;

      if (dragRx < 0 || dragRx > 1 || dragRy < 0 || dragRy > 1) {
        dragRx = 0.5;
        dragRy = 0.5;
      }

      canvas.style.cursor = "crosshair";
      body.style.cursor = "crosshair";
      on(window, "mousemove", onDrag);
      on(window, "mouseup", onDragEnd);
      onDrag(ev);
    };

    var init = function init() {
      canvas.style.cursor = "pointer";
      on(canvas, "mousedown", onDragStart);
      on(viewport || window, "load resize scroll", draw);

      if (settings.interval > 0) {
        setInterval(function () {
          return draw();
        }, settings.interval);
      }

      draw();
    };

    init();
    return {
      redraw: draw
    };
  };

  _exports.pagemap = pagemap;
});