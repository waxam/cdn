define(["exports", "meta", "require", "../../lit-element/lit-element.js", "../schema-behaviors/schema-behaviors.js"], function (_exports, meta, _require, _litElement, _schemaBehaviors) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.CodeEditor = void 0;
  meta = babelHelpers.interopRequireWildcard(meta);
  _require = babelHelpers.interopRequireWildcard(_require);

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  function _templateObject2_78161f50c96f11ea8be5e1d5fe7ec787() {
    var data = babelHelpers.taggedTemplateLiteral(["\n      <label for=\"codeeditor\" ?hidden=\"", "\">", "</label>\n      <monaco-element\n        id=\"codeeditor\"\n        ?autofocus=\"", "\"\n        ?hide-line-numbers=\"", "\"\n        lib-path=\"", "\"\n        language=\"", "\"\n        tab-size=\"", "\"\n        theme=\"", "\"\n        @value-changed=\"", "\"\n        font-size=\"", "\"\n        ?read-only=\"", "\"\n        @code-editor-focus=\"", "\"\n        @code-editor-blur=\"", "\"\n      >\n      </monaco-element>\n      <slot hidden></slot>\n      <div class=\"code-pen-container\" ?hidden=\"", "\">\n        <span>Check it out on code pen: </span\n        ><code-pen-button .data=\"", "\"></code-pen-button>\n      </div>\n    "]);

    _templateObject2_78161f50c96f11ea8be5e1d5fe7ec787 = function _templateObject2_78161f50c96f11ea8be5e1d5fe7ec787() {
      return data;
    };

    return data;
  }

  function _templateObject_78161f50c96f11ea8be5e1d5fe7ec787() {
    var data = babelHelpers.taggedTemplateLiteral(["\n        :host {\n          display: block;\n          font-family: unset;\n          margin: var(--code-pen-margin, 16px 0);\n        }\n        :host([hidden]) {\n          display: none !important;\n        }\n        .code-pen-container:not([hidden]) {\n          width: 100%;\n          display: flex;\n          background-color: var(--code-pen-button-color, #222222);\n          color: white;\n          height: 40px;\n          justify-content: flex-end;\n          align-items: center;\n        }\n        .code-pen-container span {\n          display: inline-flex;\n          line-height: 16px;\n          font-size: 16px;\n          padding: 12px;\n        }\n        code-pen-button {\n          float: right;\n          height: 40px;\n        }\n        label {\n          color: var(--code-editor-label-color, #888);\n          transition: all 0.5s;\n        }\n\n        :host([focused]) label {\n          color: var(\n            --code-editor-float-label-active-color,\n            var(--code-editor-label-color, #000)\n          );\n        }\n\n        #codeeditor {\n          height: 100%;\n          display: flex;\n          border: var(--code-editor-code-border);\n          border-radius: var(--code-editor-code-border-radius);\n        }\n\n        :host([focused]) #codeeditor {\n          border: var(--code-editor-focus-code-border);\n        }\n      "]);

    _templateObject_78161f50c96f11ea8be5e1d5fe7ec787 = function _templateObject_78161f50c96f11ea8be5e1d5fe7ec787() {
      return data;
    };

    return data;
  }

  /**
   * `code-editor`
   * `Wrapper on top of a code editor`
   *
   * @demo demo/index.html
   * @microcopy - the mental model for this element
   * - monaco is the VS code editor
   * @element code-editor
   */
  var CodeEditor =
  /*#__PURE__*/
  function (_SchemaBehaviors) {
    babelHelpers.inherits(CodeEditor, _SchemaBehaviors);
    babelHelpers.createClass(CodeEditor, null, [{
      key: "styles",

      /**
       * LitElement constructable styles enhancement
       */
      get: function get() {
        return [(0, _litElement.css)(_templateObject_78161f50c96f11ea8be5e1d5fe7ec787())];
      }
      /**
       * HTMLElement
       */

    }]);

    function CodeEditor() {
      var _this;

      babelHelpers.classCallCheck(this, CodeEditor);
      _this = babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(CodeEditor).call(this));
      _this.showCodePen = false;
      _this.readOnly = false;
      _this.theme = "vs-dark";
      _this.language = "javascript";
      _this.fontSize = 16;
      _this.tabSize = 2;
      _this.autofocus = false;
      _this.hideLineNumbers = false;
      _this.focused = false; // helps in local testing and some edge cases of CDNs

      if (window.WCGlobalBasePath) {
        _this.libPath = window.WCGlobalBasePath;
      } else {
        _this.libPath = _this.pathFromUrl(decodeURIComponent(meta.url)) + "../../";
      }

      _this.libPath += "monaco-editor/min/vs";
      new Promise(function (res, rej) {
        return _require.default(["./lib/monaco-element/monaco-element.js"], res, rej);
      });
      new Promise(function (res, rej) {
        return _require.default(["./lib/code-pen-button.js"], res, rej);
      });
      setTimeout(function () {
        _this.addEventListener("monaco-element-ready", _this.editorReady.bind(babelHelpers.assertThisInitialized(_this)));
      }, 0);
      return _this;
    }

    babelHelpers.createClass(CodeEditor, [{
      key: "pathFromUrl",
      value: function pathFromUrl(url) {
        return url.substring(0, url.lastIndexOf("/") + 1);
      }
      /**
       * LitElement render
       */

    }, {
      key: "render",
      value: function render() {
        return (0, _litElement.html)(_templateObject2_78161f50c96f11ea8be5e1d5fe7ec787(), !this.title, this.title, this.autofocus, this.hideLineNumbers, this.libPath, this.language, this.tabSize, this.theme, this._editorDataChanged, this.fontSize, this.readOnly, this._handleFocus, this._handleBlur, !this.showCodePen, this.codePenData);
      }
    }, {
      key: "updated",
      value: function updated(changedProperties) {
        var _this2 = this;

        changedProperties.forEach(function (oldValue, propName) {
          if (propName == "editorValue") {
            _this2._editorValueChanged(_this2[propName], oldValue);
          }

          if (propName == "mode") {
            _this2._modeChanged(_this2[propName], oldValue);
          }

          if (propName === "showCodePen") {
            // notify
            _this2.dispatchEvent(new CustomEvent("show-code-pen-changed", {
              detail: {
                value: _this2[propName]
              }
            }));
          }

          if (propName === "value") {
            // notify
            _this2.dispatchEvent(new CustomEvent("value-changed", {
              detail: {
                value: _this2[propName]
              }
            }));
          }

          if (["title", "value"].includes(propName)) {
            _this2.codePenData = _this2._computeCodePenData(_this2.title, _this2.value);
          }
        });
      }
      /**
       * Update the post data whenever the editor has been updated
       */

    }, {
      key: "_computeCodePenData",
      value: function _computeCodePenData(title, editorValue) {
        return {
          title: title,
          html: editorValue
        };
      }
      /**
       * sets focused attribute when monaco-elements's focus event fires
       * @param {event} e the monaco-elements's focus event
       */

    }, {
      key: "_handleFocus",
      value: function _handleFocus(e) {
        this.focused = true;
      }
      /**
       * unsets focused attribute when monaco-elements's blur event fires
       * @param {event} e the monaco-elements's blur event
       */

    }, {
      key: "_handleBlur",
      value: function _handleBlur(e) {
        this.focused = false;
      }
      /**
       * LEGACY: pass down mode to language if that api is used
       */

    }, {
      key: "_modeChanged",
      value: function _modeChanged(newValue) {
        this.language = this.mode;
      }
      /**
       * Notice code editor changes and reflect them into this element
       */

    }, {
      key: "_editorDataChanged",
      value: function _editorDataChanged(e) {
        // value coming up off of thiss
        this.value = e.detail;
      }
      /**
       * Calculate what's in slot currently and then inject it into the editor.
       */

    }, {
      key: "updateEditorValue",
      value: function updateEditorValue(node) {
        if (node) {
          var content = "";
          var children = node;

          if (node.tagName !== "TEMPLATE") {
            console.warn("code-editor works best with a template tag provided in light dom");
            children = this.childNodes;

            if (children.length > 0) {
              // loop through everything found in the slotted area and put it back in
              for (var j = 0, len2 = children.length; j < len2; j++) {
                if (babelHelpers.typeof(children[j].tagName) !== (typeof undefined === "undefined" ? "undefined" : babelHelpers.typeof(undefined))) {
                  content += children[j].outerHTML;
                } else {
                  content += children[j].textContent;
                }
              }
            }
          } else {
            content = children.innerHTML;
          }

          if (content) {
            this.shadowRoot.querySelector("#codeeditor").value = content.trim();
          }
        }
      }
    }, {
      key: "_editorValueChanged",
      value: function _editorValueChanged(newValue) {
        if (newValue) {
          this.shadowRoot.querySelector("#codeeditor").value = newValue;
        }
      }
      /**
       * Ensure fields don't pass through to HAX if in that context
       */

    }, {
      key: "preProcessHaxNodeToContent",
      value: function preProcessHaxNodeToContent(node) {
        node.editorValue = null;
        node.codePenData = null;
        node.value = null;
        node.removeAttribute("value");
        node.removeAttribute("code-pen-data");
        return node;
      }
      /**
       * attached life cycle
       */

    }, {
      key: "connectedCallback",
      value: function connectedCallback() {
        var _this3 = this;

        babelHelpers.get(babelHelpers.getPrototypeOf(CodeEditor.prototype), "connectedCallback", this).call(this); // mutation observer that ensures state of hax applied correctly

        this._observer = new MutationObserver(function (mutations) {
          mutations.forEach(function (mutation) {
            if (mutation.addedNodes.length > 0) {
              mutation.addedNodes.forEach(function (node) {
                if (node.tagName) {
                  _this3.updateEditorValue(node);
                }
              });
            } // if we dropped nodes via the UI (delete event basically)


            if (mutation.removedNodes.length > 0) {
              // handle removing items... not sure we need to do anything here
              mutation.removedNodes.forEach(function (node) {
                if (node.tagName) {
                  _this3.updateEditorValue(node);
                }
              });
            }
          });
        });
      }
    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        if (this._observer) {
          this._observer.disconnect();

          this._observer = null;
        }

        babelHelpers.get(babelHelpers.getPrototypeOf(CodeEditor.prototype), "disconnectedCallback", this).call(this);
      }
    }, {
      key: "editorReady",
      value: function editorReady(e) {
        var _this4 = this;

        if (this.editorValue) {
          this.shadowRoot.querySelector("#codeeditor").value = this.editorValue;
        } else {
          this.childNodes.forEach(function (node) {
            return _this4.updateEditorValue(node);
          });
        }

        if (this._observer) {
          this._observer.observe(this, {
            childList: true
          });
        }
      }
    }], [{
      key: "tag",
      get: function get() {
        return "code-editor";
      }
    }, {
      key: "properties",
      get: function get() {
        return _objectSpread({}, babelHelpers.get(babelHelpers.getPrototypeOf(CodeEditor), "properties", this), {
          libPath: {
            type: String
          },

          /**
           * Title
           */
          title: {
            type: String
          },

          /**
           * Show codePen button to fork it to there to run
           */
          showCodePen: {
            type: Boolean,
            reflect: true,
            attribute: "show-code-pen"
          },

          /**
           * Readonly setting for the editor
           */
          readOnly: {
            type: Boolean,
            reflect: true,
            attribute: "read-only"
          },

          /**
           * Code pen data, computed based on the HTML editor
           */
          codePenData: {
            type: Object,
            attribute: "code-pen-data"
          },

          /**
           * contents of the editor
           */
          editorValue: {
            type: String,
            attribute: "editor-value"
          },

          /**
           * value of the editor after the fact
           */
          value: {
            type: String
          },

          /**
           * Theme for the Ace editor.
           */
          theme: {
            type: String
          },

          /**
           * Mode / language for editor
           */
          mode: {
            type: String
          },

          /**
           * Language to present color coding for
           */
          language: {
            type: String
          },

          /**
           * font size for the editor
           */
          fontSize: {
            type: Number,
            attribute: "font-size"
          },

          /**
           * automatically set focus on the editor
           */
          autofocus: {
            type: Boolean,
            reflect: true
          },

          /**
           * hide the line numbers
           */
          hideLineNumbers: {
            type: Boolean,
            attribute: "hide-line-numbers"
          },

          /**
           * does the monaco-editor have focus
           */
          focused: {
            type: Boolean,
            reflect: true
          },

          /**
           * number of characters for tabs
           */
          tabSize: {
            type: Number,
            attribute: "tab-size"
          }
        });
      }
    }, {
      key: "haxProperties",
      get: function get() {
        return {
          canScale: false,
          canPosition: true,
          canEditSource: false,
          gizmo: {
            title: "Code Editor",
            description: "A code editor.",
            icon: "polymer",
            color: "cyan",
            groups: ["Code"]
          },
          settings: {
            quick: [],
            configure: [{
              property: "title",
              title: "Title",
              description: "Optional title for editor",
              inputMethod: "textfield"
            }, {
              slot: "",
              title: "Content",
              description: "Code inside editor",
              inputMethod: "code-editor"
            }, {
              property: "readOnly",
              title: "Read-only",
              description: "Prevent the code from being edited?",
              inputMethod: "boolean"
            }, {
              property: "hideLineNumbers",
              title: "Hide Line Numbers",
              inputMethod: "boolean"
            }, {
              property: "showCodePen",
              title: "CodePen",
              description: "Include a link to CodePen?",
              inputMethod: "boolean"
            }, {
              property: "tabSize",
              title: "Tab Size",
              inputMethod: "number"
            }, {
              property: "theme",
              title: "Theme",
              inputMethod: "select",
              itemsList: ["hc-black", "vs-light", "vs-dark"]
            }, {
              property: "language",
              title: "Code Language",
              inputMethod: "select",
              itemsList: ["apex", "azcli", "bat", "c", "clojure", "coffeescript", "cpp", "csharp", "csp", "css", "dockerfile", "fsharp", "go", "handlebars", "html", "ini", "java", "javascript", "json", "less", "lua", "markdown", "msdax", "mysql", "objective-c", "perl", "pgsql", "php", "plaintext", "postiats", "powerquery", "powershell", "pug", "python", "r", "razor", "redis", "redshift", "ruby", "rust", "sb", "scheme", "scss", "shell", "sol", "sql", "st", "swift", "typescript", "vb", "xml", "yaml"]
            }],
            advanced: [{
              property: "autofocus",
              title: "Autofocus",
              inputMethod: "boolean"
            }, {
              property: "fontSize",
              title: "Font Size",
              inputMethod: "number"
            }, {
              property: "editorValue",
              title: "Editor Value",
              description: "Initial contents of the editor",
              inputMethod: "textfield"
            }]
          }
        };
      }
    }]);
    return CodeEditor;
  }((0, _schemaBehaviors.SchemaBehaviors)(_litElement.LitElement));

  _exports.CodeEditor = CodeEditor;
  window.customElements.define(CodeEditor.tag, CodeEditor);
});