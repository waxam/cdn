define(["exports", "./marked.js"], function (_exports, _marked) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.WCMarkdown = void 0;

  function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var WCMarkdown = /*#__PURE__*/function (_HTMLElement) {
    babelHelpers.inherits(WCMarkdown, _HTMLElement);

    var _super = _createSuper(WCMarkdown);

    function WCMarkdown() {
      var _this;

      babelHelpers.classCallCheck(this, WCMarkdown);
      _this = _super.call(this);
      _this.__value = "";
      return _this;
    }

    babelHelpers.createClass(WCMarkdown, [{
      key: "attributeChangedCallback",
      value: function attributeChangedCallback(name, oldValue, newValue) {
        if (oldValue !== newValue) {
          this[name] = newValue;
        }
      }
    }, {
      key: "src",
      get: function get() {
        return this.getAttribute("src");
      },
      set: function set(value) {
        this.setAttribute("src", value);
        this.setSrc(value);
      }
    }, {
      key: "value",
      get: function get() {
        return this.__value;
      },
      set: function set(value) {
        this.__value = value;
        this.setValue();
      }
    }, {
      key: "connectedCallback",
      value: function () {
        var _connectedCallback = babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  this.style.display = "block";
                  _context.next = 3;
                  return this.renderSlotMD();

                case 3:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));

        function connectedCallback() {
          return _connectedCallback.apply(this, arguments);
        }

        return connectedCallback;
      }()
    }, {
      key: "renderSlotMD",
      value: function () {
        var _renderSlotMD = babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
          var scriptTag, content;
          return regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  scriptTag = this.getElementsByTagName("script")[0];

                  if (scriptTag) {
                    if (scriptTag.getAttribute("type") === "wc-content") {
                      content = WCMarkdown.dedentText(scriptTag.innerHTML);
                      content = content.replace(/&lt;(\/?script)(.*?)&gt;/g, "<$1$2>");
                      this.value = content;
                    }
                  } else {
                    if (this.textContent) {
                      this.__value = this.textContent;
                      this.setValue();
                    }
                  }

                case 2:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, this);
        }));

        function renderSlotMD() {
          return _renderSlotMD.apply(this, arguments);
        }

        return renderSlotMD;
      }()
    }, {
      key: "setSrc",
      value: function () {
        var _setSrc = babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(src) {
          return regeneratorRuntime.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  _context3.next = 2;
                  return this.fetchSrc(src);

                case 2:
                  this.__value = _context3.sent;
                  this.setValue();

                case 4:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3, this);
        }));

        function setSrc(_x) {
          return _setSrc.apply(this, arguments);
        }

        return setSrc;
      }()
    }, {
      key: "fetchSrc",
      value: function () {
        var _fetchSrc = babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(src) {
          var response;
          return regeneratorRuntime.wrap(function _callee4$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  _context4.next = 2;
                  return fetch(src);

                case 2:
                  response = _context4.sent;
                  return _context4.abrupt("return", response.text());

                case 4:
                case "end":
                  return _context4.stop();
              }
            }
          }, _callee4);
        }));

        function fetchSrc(_x2) {
          return _fetchSrc.apply(this, arguments);
        }

        return fetchSrc;
      }()
    }, {
      key: "setValue",
      value: function setValue() {
        var contents = this.__value;
        contents = WCMarkdown.prepare(contents);
        contents = WCMarkdown.toHtml(contents);
        this.innerHTML = contents;
      }
    }], [{
      key: "observedAttributes",
      get: function get() {
        return ["src"];
      }
    }, {
      key: "prepare",
      value: function prepare(markdown) {
        return markdown.split("\n").map(function (line) {
          line = line.replace("&lt;", "<");
          return line.replace("&gt;", ">");
        }).join("\n");
      }
    }, {
      key: "toHtml",
      value: function toHtml(markdown) {
        return (0, _marked.marked)(markdown);
      }
      /**
       * De-dents the code by getting the padding from the first line,
       * then removes the same indent amount padding from the rest of the lines
       *
       * @param {string} text - the text to dedent
       * @returns {string} the dedented text
       */

    }, {
      key: "dedentText",
      value: function dedentText(text) {
        var lines = text.split("\n"); // remove the first line if it is an empty line

        if (lines[0] === "") lines.splice(0, 1);
        var initline = lines[0];
        var fwdPad = 0;
        var usingTabs = initline[0] === "\t";
        var checkChar = usingTabs ? "\t" : " ";

        while (true) {
          if (initline[fwdPad] === checkChar) {
            fwdPad += 1;
          } else {
            break;
          }
        }

        var fixedLines = [];

        var _iterator = _createForOfIteratorHelper(lines),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var line = _step.value;
            var fixedLine = line;

            for (var i = 0; i < fwdPad; i++) {
              if (fixedLine[0] === checkChar) {
                fixedLine = fixedLine.substring(1);
              } else {
                break;
              }
            }

            fixedLines.push(fixedLine);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        if (fixedLines[fixedLines.length - 1] === "") fixedLines.splice(fixedLines.length - 1, 1);
        return fixedLines.join("\n");
      }
    }]);
    return WCMarkdown;
  }( /*#__PURE__*/babelHelpers.wrapNativeSuper(HTMLElement));

  _exports.WCMarkdown = WCMarkdown;
  customElements.define("wc-markdown", WCMarkdown);
});