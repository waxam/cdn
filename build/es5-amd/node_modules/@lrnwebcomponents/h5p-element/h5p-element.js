define(["exports", "meta", "../../lit-element/lit-element.js", "../es-global-bridge/es-global-bridge.js"], function (_exports, meta, _litElement, _esGlobalBridge) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.Toposort = _exports.H5PStandalone = _exports.H5PElement = void 0;
  meta = babelHelpers.interopRequireWildcard(meta);

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  function _templateObject2_58afcc00d34d11ea880ba1e93364c49c() {
    var data = babelHelpers.taggedTemplateLiteral(["\n        :host {\n          display: block;\n        }\n      "]);

    _templateObject2_58afcc00d34d11ea880ba1e93364c49c = function _templateObject2_58afcc00d34d11ea880ba1e93364c49c() {
      return data;
    };

    return data;
  }

  function _templateObject_58afcc00d34d11ea880ba1e93364c49c() {
    var data = babelHelpers.taggedTemplateLiteral(["\n      <div\n        class=\"h5p-container\"\n        data-content-id=\"wrapper-", "\"\n      ></div>\n    "]);

    _templateObject_58afcc00d34d11ea880ba1e93364c49c = function _templateObject_58afcc00d34d11ea880ba1e93364c49c() {
      return data;
    };

    return data;
  }

  window.__H5PBridgeTimeOut = function () {
    setTimeout(function () {
      window.H5P.init();
    }, 500);
  };
  /**
   * `h5p-element`
   * @element h5p-element
   * `h5p wrapper for loading and presenting .h5p files`
   *
   * @microcopy - language worth noting:
   *  - h5p is it's own eco system, we're just trying to wrap it a bit
   *
  
   * @lit-element
   * @demo demo/index.html
   */


  var H5PElement =
  /*#__PURE__*/
  function (_LitElement) {
    babelHelpers.inherits(H5PElement, _LitElement);
    babelHelpers.createClass(H5PElement, [{
      key: "render",
      // render function
      value: function render() {
        return (0, _litElement.html)(_templateObject_58afcc00d34d11ea880ba1e93364c49c(), this.contentId);
      } // haxProperty definition

    }], [{
      key: "styles",
      //styles function
      get: function get() {
        return [(0, _litElement.css)(_templateObject2_58afcc00d34d11ea880ba1e93364c49c())];
      }
    }, {
      key: "haxProperties",
      get: function get() {
        return {
          canScale: true,
          canPosition: true,
          canEditSource: false,
          gizmo: {
            title: "H5P element",
            description: "h5p wrapper for loading and presenting .h5p files",
            icon: "icons:android",
            color: "green",
            groups: ["Interactive"],
            meta: {
              author: "btopro",
              owner: "The Pennsylvania State University"
            }
          },
          settings: {
            quick: [],
            configure: [{
              attribute: "source",
              description: "Location the H5P file was unpacked to",
              inputMethod: "textfield",
              required: true,
              icon: "icons:link"
            }],
            advanced: []
          },
          saveOptions: {
            wipeSlot: true,
            unsetAttributes: ["content-id"]
          }
        };
      } // properties available to the custom element for data binding

    }, {
      key: "properties",
      get: function get() {
        return _objectSpread({}, babelHelpers.get(babelHelpers.getPrototypeOf(H5PElement), "properties", this), {
          /**
           * Source of the .h5p file
           */
          source: {
            name: "source",
            type: String
          }
        });
      }
      /**
       * Store the tag name to make it easier to obtain directly.
       * @notice function name must be here for tooling to operate correctly
       */

    }, {
      key: "tag",
      get: function get() {
        return "h5p-element";
      } // life cycle

    }]);

    function H5PElement() {
      var _this;

      babelHelpers.classCallCheck(this, H5PElement);
      _this = babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(H5PElement).call(this)); // make a random ID for the targeting

      _this.contentId = _this.generateUUID(); // should kick off all dependencies to start loading on window

      _this.H5PDepsLoader();

      return _this;
    }
    /**
     * This breaks shadowRoot in LitElement
     */


    babelHelpers.createClass(H5PElement, [{
      key: "createRenderRoot",
      value: function createRenderRoot() {
        return this;
      } // simple path from a url modifier

    }, {
      key: "pathFromUrl",
      value: function pathFromUrl(url) {
        return url.substring(0, url.lastIndexOf("/") + 1);
      }
      /**
       * load dependencies that need to be global in scope
       */

    }, {
      key: "H5PDepsLoader",
      value: function () {
        var _H5PDepsLoader = babelHelpers.asyncToGenerator(
        /*#__PURE__*/
        regeneratorRuntime.mark(function _callee() {
          var basePath;
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  window.ESGlobalBridge.requestAvailability();
                  basePath = this.pathFromUrl(decodeURIComponent(meta.url)) + "lib/h5p/";
                  this.h5pJSDeps = [basePath + "js/jquery.js", basePath + "js/h5p.js", basePath + "js/h5p-event-dispatcher.js", basePath + "js/h5p-content-type.js", basePath + "js/h5p-action-bar.js", basePath + "js/h5p-confirmation-dialog.js", basePath + "js/h5p-x-api-event.js", basePath + "js/h5p-x-api.js"];
                  this.__h5pDepsLength = this.h5pJSDeps.length - 1;
                  _context.next = 6;
                  return window.ESGlobalBridge.instance.load("h5p-jquery", basePath + "js/jquery.js");

                case 6:
                  window.addEventListener("es-bridge-h5p-jquery-loaded", this.h5pJqueryReady.bind(this));
                  window.addEventListener("es-bridge-h5p-" + this.__h5pDepsLength + "-loaded", this.h5pReadyCallback.bind(this));

                case 8:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));

        function H5PDepsLoader() {
          return _H5PDepsLoader.apply(this, arguments);
        }

        return H5PDepsLoader;
      }()
    }, {
      key: "generateUUID",
      value: function generateUUID() {
        return "item-sss-ss-ss".replace(/s/g, this._uuidPart);
      }
    }, {
      key: "_uuidPart",
      value: function _uuidPart() {
        return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
      }
      /**
       * life cycle, element is afixed to the DOM
       */

    }, {
      key: "firstUpdated",
      value: function firstUpdated() {
        if (window.ESGlobalBridge.imports["h5p-" + this.__h5pDepsLength] && this.contentId) {
          this.setupH5P(this.contentId);
        }
      }
    }, {
      key: "h5pJqueryReady",
      value: function () {
        var _h5pJqueryReady = babelHelpers.asyncToGenerator(
        /*#__PURE__*/
        regeneratorRuntime.mark(function _callee2(e) {
          var i;
          return regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  _context2.t0 = regeneratorRuntime.keys(this.h5pJSDeps);

                case 1:
                  if ((_context2.t1 = _context2.t0()).done) {
                    _context2.next = 7;
                    break;
                  }

                  i = _context2.t1.value;
                  _context2.next = 5;
                  return window.ESGlobalBridge.instance.load("h5p-" + i, this.h5pJSDeps[i]);

                case 5:
                  _context2.next = 1;
                  break;

                case 7:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, this);
        }));

        function h5pJqueryReady(_x) {
          return _h5pJqueryReady.apply(this, arguments);
        }

        return h5pJqueryReady;
      }()
    }, {
      key: "h5pReadyCallback",
      value: function h5pReadyCallback(e) {
        if (this.contentId) {
          this.setupH5P(this.contentId);
        }
      }
      /**
       * This does the heavy lifting to kick it off
       */

    }, {
      key: "setupH5P",
      value: function () {
        var _setupH5P = babelHelpers.asyncToGenerator(
        /*#__PURE__*/
        regeneratorRuntime.mark(function _callee3() {
          var id,
              displayOptions,
              basePath,
              frag,
              stand,
              _args3 = arguments;
          return regeneratorRuntime.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  id = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : 1;
                  displayOptions = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : {};
                  displayOptions = Object.assign(displayOptions, {
                    frame: displayOptions.frame = false,
                    copyright: displayOptions.copyright = false,
                    embed: displayOptions.embed = false,
                    download: displayOptions.download = false,
                    icon: displayOptions.icon = false,
                    export: displayOptions.export = false
                  });
                  basePath = this.pathFromUrl(decodeURIComponent(meta.url)) + "lib/h5p/";
                  H5PIntegration.core = {
                    styles: [basePath + "styles/h5p.css", basePath + "styles/h5p-confirmation-dialog.css", basePath + "styles/h5p-core-button.css"],
                    scripts: this.h5pJSDeps
                  };
                  frag = document.createRange().createContextualFragment("\n    <div class=\"h5p-iframe-wrapper\" style=\"background-color:#DDD;\">\n      <iframe id=\"h5p-iframe-".concat(id, "\" class=\"h5p-iframe\" data-content-id=\"").concat(id, "\" style=\"width: 100%; height: 100%; border: none; display: block;\" src=\"about:blank\" frameBorder=\"0\"></iframe>\n    </div>\n    "));
                  this.querySelector('[data-content-id="wrapper-' + this.contentId + '"').appendChild(frag);

                  if (!this.source) {
                    _context3.next = 12;
                    break;
                  }

                  stand = new H5PStandalone(id, this.source, displayOptions);
                  _context3.next = 11;
                  return stand.init();

                case 11:
                  // clear previous calls to this exact thing
                  // this accounts for multiples on the DOM and the exccess
                  // file parsing required per each in order to use this thing
                  if (window.__H5PBridgeTimeOut) {
                    clearTimeout(window.__H5PBridgeTimeOut);

                    window.__H5PBridgeTimeOut();
                  }

                case 12:
                  return _context3.abrupt("return", true);

                case 13:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3, this);
        }));

        function setupH5P() {
          return _setupH5P.apply(this, arguments);
        }

        return setupH5P;
      }()
      /**
       * life cycle, element removed from DOM
       */

    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        window.removeEventListener("es-bridge-h5p-" + this.__h5pDepsLength + "-loaded", this.h5pReadyCallback.bind(this));
        window.removeEventListener("es-bridge-h5p-jquery-loaded", this.h5pJqueryReady.bind(this));
        babelHelpers.get(babelHelpers.getPrototypeOf(H5PElement.prototype), "disconnectedCallback", this).call(this);
      }
    }, {
      key: "updated",
      value: function updated(changedProperties) {
        changedProperties.forEach(function (oldValue, propName) {});
      }
    }]);
    return H5PElement;
  }(_litElement.LitElement);

  _exports.H5PElement = H5PElement;
  customElements.define("h5p-element", H5PElement);
  window.H5P = window.H5P || {};
  window.H5PIntegration = window.H5PIntegration || {};
  H5PIntegration.l10n = {
    H5P: {
      advancedHelp: "Include this script on your website if you want dynamic sizing of the embedded content:",
      author: "Author",
      by: "by",
      close: "Close",
      contentChanged: "This content has changed since you last used it.",
      copyrightInformation: "Rights of use",
      copyrights: "Rights of use",
      copyrightsDescription: "View copyright information for this content.",
      disableFullscreen: "Disable fullscreen",
      download: "Download",
      downloadDescription: "Download this content as a H5P file.",
      embed: "Embed",
      embedDescription: "View the embed code for this content.",
      fullscreen: "Fullscreen",
      h5pDescription: "Visit H5P.org to check out more cool content.",
      hideAdvanced: "Hide advanced",
      license: "License",
      noCopyrights: "No copyright information available for this content.",
      showAdvanced: "Show advanced",
      showLess: "Show less",
      showMore: "Show more",
      size: "Size",
      source: "Source",
      startingOver: "You'll be starting over.",
      subLevel: "Sublevel",
      thumbnail: "Thumbnail",
      title: "Title",
      year: "Year"
    }
  };

  var H5PStandalone =
  /*#__PURE__*/
  function () {
    function H5PStandalone() {
      var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var pathToContent = arguments.length > 1 ? arguments[1] : undefined;
      var displayOptions = arguments.length > 2 ? arguments[2] : undefined;
      babelHelpers.classCallCheck(this, H5PStandalone);
      this.id = id;
      this.path = pathToContent;
      this.displayOptions = displayOptions;
      return true;
    }

    babelHelpers.createClass(H5PStandalone, [{
      key: "getJSONPromise",
      value: function getJSONPromise(url) {
        return fetch(url).then(function (response) {
          return response.json();
        });
      }
      /**
       * Initialize the H5P
       */

    }, {
      key: "init",
      value: function () {
        var _init = babelHelpers.asyncToGenerator(
        /*#__PURE__*/
        regeneratorRuntime.mark(function _callee4() {
          var dependencies, _ref, styles, scripts;

          return regeneratorRuntime.wrap(function _callee4$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  _context4.next = 2;
                  return this.getJSONPromise("".concat(this.path, "/h5p.json"));

                case 2:
                  this.h5p = _context4.sent;
                  _context4.t0 = JSON;
                  _context4.next = 6;
                  return this.getJSONPromise("".concat(this.path, "/content/content.json"));

                case 6:
                  _context4.t1 = _context4.sent;
                  this.content = _context4.t0.stringify.call(_context4.t0, _context4.t1);
                  _context4.next = 10;
                  return this.checkIfPathIncludesVersion();

                case 10:
                  window.H5PIntegration.pathIncludesVersion = this.pathIncludesVersion = _context4.sent;
                  _context4.next = 13;
                  return this.findMainLibrary();

                case 13:
                  this.mainLibrary = _context4.sent;
                  _context4.next = 16;
                  return this.findAllDependencies();

                case 16:
                  dependencies = _context4.sent;
                  _context4.next = 19;
                  return this.sortDependencies(dependencies);

                case 19:
                  _ref = _context4.sent;
                  styles = _ref.styles;
                  scripts = _ref.scripts;
                  H5PIntegration.url = this.path;
                  H5PIntegration.contents = H5PIntegration.contents ? H5PIntegration.contents : {};
                  H5PIntegration.contents["cid-" + this.id] = {
                    library: "".concat(this.mainLibrary.machineName, " ").concat(this.mainLibrary.majorVersion, ".").concat(this.mainLibrary.minorVersion),
                    jsonContent: this.content,
                    styles: styles,
                    scripts: scripts,
                    displayOptions: this.displayOptions
                  };
                  return _context4.abrupt("return", true);

                case 26:
                case "end":
                  return _context4.stop();
              }
            }
          }, _callee4, this);
        }));

        function init() {
          return _init.apply(this, arguments);
        }

        return init;
      }()
      /**
       * Check if the library folder include the version or not
       * This was changed at some point in H5P and we need to be backwards compatible
       *
       * @return {boolean}
       */

    }, {
      key: "checkIfPathIncludesVersion",
      value: function () {
        var _checkIfPathIncludesVersion = babelHelpers.asyncToGenerator(
        /*#__PURE__*/
        regeneratorRuntime.mark(function _callee5() {
          var dependency, machinePath, pathIncludesVersion;
          return regeneratorRuntime.wrap(function _callee5$(_context5) {
            while (1) {
              switch (_context5.prev = _context5.next) {
                case 0:
                  dependency = this.h5p.preloadedDependencies[0];
                  machinePath = dependency.machineName + "-" + dependency.majorVersion + "." + dependency.minorVersion;
                  _context5.prev = 2;
                  _context5.next = 5;
                  return this.getJSONPromise("".concat(this.path, "/").concat(machinePath, "/library.json"));

                case 5:
                  pathIncludesVersion = true;
                  _context5.next = 11;
                  break;

                case 8:
                  _context5.prev = 8;
                  _context5.t0 = _context5["catch"](2);
                  pathIncludesVersion = false;

                case 11:
                  return _context5.abrupt("return", pathIncludesVersion);

                case 12:
                case "end":
                  return _context5.stop();
              }
            }
          }, _callee5, this, [[2, 8]]);
        }));

        function checkIfPathIncludesVersion() {
          return _checkIfPathIncludesVersion.apply(this, arguments);
        }

        return checkIfPathIncludesVersion;
      }()
      /**
       * return the path to a library
       * @param {object} library
       * @return {string}
       */

    }, {
      key: "libraryPath",
      value: function libraryPath(library) {
        return library.machineName + (this.pathIncludesVersion ? "-" + library.majorVersion + "." + library.minorVersion : "");
      }
      /**
       * FInd the main library for this H5P
       * @return {Promise}
       */

    }, {
      key: "findMainLibrary",
      value: function findMainLibrary() {
        var _this2 = this;

        var mainLibraryInfo = this.h5p.preloadedDependencies.find(function (dep) {
          return dep.machineName === _this2.h5p.mainLibrary;
        });
        this.mainLibraryPath = this.h5p.mainLibrary + (this.pathIncludesVersion ? "-" + mainLibraryInfo.majorVersion + "." + mainLibraryInfo.minorVersion : "");
        return this.getJSONPromise("".concat(this.path, "/").concat(this.mainLibraryPath, "/library.json"));
      }
      /**
       * find all the libraries used in this H5P
       * @return {Promise}
       */

    }, {
      key: "findAllDependencies",
      value: function findAllDependencies() {
        var _this3 = this;

        var directDependencyNames = this.h5p.preloadedDependencies.map(function (dependency) {
          return _this3.libraryPath(dependency);
        });
        return this.loadDependencies(directDependencyNames, []);
      }
      /**
       * searches through all supplied libraries for dependencies, this is recursive and repeats until all deep dependencies have been found
       * @param {string[]} toFind list of libraries to find the dependencies of
       * @param {string[]} alreadyFound the dependencies that have already been found
       */

    }, {
      key: "loadDependencies",
      value: function () {
        var _loadDependencies = babelHelpers.asyncToGenerator(
        /*#__PURE__*/
        regeneratorRuntime.mark(function _callee6(toFind, alreadyFound) {
          var _this4 = this;

          var dependencies, findNext, newDependencies;
          return regeneratorRuntime.wrap(function _callee6$(_context6) {
            while (1) {
              switch (_context6.prev = _context6.next) {
                case 0:
                  // dependencyDepth++;
                  dependencies = alreadyFound;
                  findNext = [];
                  _context6.next = 4;
                  return Promise.all(toFind.map(function (libraryName) {
                    return _this4.findLibraryDependencies(libraryName);
                  }));

                case 4:
                  newDependencies = _context6.sent;
                  // loop over newly found libraries
                  newDependencies.forEach(function (library) {
                    // push into found list
                    dependencies.push(library); // check if any dependencies haven't been found yet

                    library.dependencies.forEach(function (dependency) {
                      if (!dependencies.find(function (foundLibrary) {
                        return foundLibrary.libraryPath === dependency;
                      }) && !newDependencies.find(function (foundLibrary) {
                        return foundLibrary.libraryPath === dependency;
                      })) {
                        findNext.push(dependency);
                      }
                    });
                  });

                  if (!(findNext.length > 0)) {
                    _context6.next = 8;
                    break;
                  }

                  return _context6.abrupt("return", this.loadDependencies(findNext, dependencies));

                case 8:
                  return _context6.abrupt("return", dependencies);

                case 9:
                case "end":
                  return _context6.stop();
              }
            }
          }, _callee6, this);
        }));

        function loadDependencies(_x2, _x3) {
          return _loadDependencies.apply(this, arguments);
        }

        return loadDependencies;
      }()
      /**
       * Loads a dependencies library.json and finds the libraries it dependson as well ass the JS and CSS it needs
       * @param {string} libraryName
       */

    }, {
      key: "findLibraryDependencies",
      value: function () {
        var _findLibraryDependencies = babelHelpers.asyncToGenerator(
        /*#__PURE__*/
        regeneratorRuntime.mark(function _callee7(libraryName) {
          var _this5 = this;

          var library, libraryPath, dependencies;
          return regeneratorRuntime.wrap(function _callee7$(_context7) {
            while (1) {
              switch (_context7.prev = _context7.next) {
                case 0:
                  _context7.next = 2;
                  return this.getJSONPromise("".concat(this.path, "/").concat(libraryName, "/library.json"));

                case 2:
                  library = _context7.sent;
                  libraryPath = this.libraryPath(library);
                  dependencies = [];

                  if (library.preloadedDependencies) {
                    dependencies = library.preloadedDependencies.map(function (dependency) {
                      return _this5.libraryPath(dependency);
                    });
                  }

                  return _context7.abrupt("return", {
                    libraryPath: libraryPath,
                    dependencies: dependencies,
                    preloadedCss: library.preloadedCss,
                    preloadedJs: library.preloadedJs
                  });

                case 7:
                case "end":
                  return _context7.stop();
              }
            }
          }, _callee7, this);
        }));

        function findLibraryDependencies(_x4) {
          return _findLibraryDependencies.apply(this, arguments);
        }

        return findLibraryDependencies;
      }()
      /**
       * Resolves the library dependency tree and sorts the JS and CSS files into order
       * @param {object[]} dependencies
       * @return {object}
       */

    }, {
      key: "sortDependencies",
      value: function () {
        var _sortDependencies = babelHelpers.asyncToGenerator(
        /*#__PURE__*/
        regeneratorRuntime.mark(function _callee8(dependencies) {
          var _this6 = this;

          var dependencySorter, CSSDependencies, JSDependencies, styles, scripts;
          return regeneratorRuntime.wrap(function _callee8$(_context8) {
            while (1) {
              switch (_context8.prev = _context8.next) {
                case 0:
                  dependencySorter = new Toposort();
                  CSSDependencies = {};
                  JSDependencies = {};
                  dependencies.forEach(function (dependency) {
                    dependencySorter.add(dependency.libraryPath, dependency.dependencies);

                    if (dependency.preloadedCss) {
                      CSSDependencies[dependency.libraryPath] = CSSDependencies[dependency.libraryPath] ? CSSDependencies[dependency.libraryPath] : [];
                      dependency.preloadedCss.forEach(function (style) {
                        CSSDependencies[dependency.libraryPath].push("".concat(_this6.path, "/").concat(dependency.libraryPath, "/").concat(style.path));
                      });
                    }

                    if (dependency.preloadedJs) {
                      JSDependencies[dependency.libraryPath] = JSDependencies[dependency.libraryPath] ? JSDependencies[dependency.libraryPath] : [];
                      dependency.preloadedJs.forEach(function (script) {
                        JSDependencies[dependency.libraryPath].push("".concat(_this6.path, "/").concat(dependency.libraryPath, "/").concat(script.path));
                      });
                    }
                  });
                  styles = [];
                  scripts = [];
                  dependencySorter.sort().reverse().forEach(function (dependencyName) {
                    Array.prototype.push.apply(styles, CSSDependencies[dependencyName]);
                    Array.prototype.push.apply(scripts, JSDependencies[dependencyName]);
                  });
                  Array.prototype.push.apply(styles, this.mainLibrary.preloadedCss.map(function (style) {
                    return "".concat(_this6.path, "/").concat(_this6.mainLibraryPath, "/").concat(style.path);
                  }));
                  Array.prototype.push.apply(scripts, this.mainLibrary.preloadedJs.map(function (script) {
                    return "".concat(_this6.path, "/").concat(_this6.mainLibraryPath, "/").concat(script.path);
                  }));
                  return _context8.abrupt("return", {
                    styles: styles,
                    scripts: scripts
                  });

                case 10:
                case "end":
                  return _context8.stop();
              }
            }
          }, _callee8, this);
        }));

        function sortDependencies(_x5) {
          return _sortDependencies.apply(this, arguments);
        }

        return sortDependencies;
      }()
    }]);
    return H5PStandalone;
  }();

  _exports.H5PStandalone = H5PStandalone;

  var Toposort =
  /*#__PURE__*/
  function () {
    function Toposort() {
      babelHelpers.classCallCheck(this, Toposort);
      this.edges = [];
    }
    /**
     * Adds dependency edges.
     *
     * @since   0.1.0
     * @param   {String} item               An dependent name. Must be an string and not empty
     * @param   {String[]|String} [deps]    An dependency or array of dependencies
     * @returns {Toposort}                  The Toposort instance
     */


    babelHelpers.createClass(Toposort, [{
      key: "add",
      value: function add(item, deps) {
        if (typeof item !== "string" || !item) {
          throw new TypeError("Dependent name must be given as a not empty string");
        }

        deps = Array.isArray(deps) ? deps : [deps];

        if (deps.length > 0) {
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = deps[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var dep = _step.value;

              if (typeof dep !== "string" || !dep) {
                throw new TypeError("Dependency name must be given as a not empty string");
              }

              this.edges.push([item, dep]);
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
        } else {
          this.edges.push([item]);
        }

        return this;
      }
      /**
       * Runs the toposorting and return an ordered array of strings
       *
       * @since   0.1.0
       * @returns {String[]}  The list of items topologically sorted.
       */

    }, {
      key: "sort",
      value: function sort() {
        var _this7 = this;

        var nodes = []; //accumulate unique nodes into a large list

        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = this.edges[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var _edge = _step2.value;
            var _iteratorNormalCompletion5 = true;
            var _didIteratorError5 = false;
            var _iteratorError5 = undefined;

            try {
              for (var _iterator5 = _edge[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                var _node = _step5.value;

                if (nodes.indexOf(_node) === -1) {
                  nodes.push(_node);
                }
              }
            } catch (err) {
              _didIteratorError5 = true;
              _iteratorError5 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion5 && _iterator5.return != null) {
                  _iterator5.return();
                }
              } finally {
                if (_didIteratorError5) {
                  throw _iteratorError5;
                }
              }
            }
          } //initialize the placement of nodes into the sorted array at the end

        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

        var place = nodes.length; //initialize the sorted array with the same length as the unique nodes array

        var sorted = new Array(nodes.length); //define a visitor function that recursively traverses dependencies.

        var visit = function visit(node, predecessors) {
          //check if a node is dependent of itself
          if (predecessors.length !== 0 && predecessors.indexOf(node) !== -1) {
            throw new Error("Cyclic dependency found. ".concat(node, " is dependent of itself.\nDependency chain: ").concat(predecessors.join(" -> "), " => ").concat(node));
          }

          var index = nodes.indexOf(node); //if the node still exists, traverse its dependencies

          if (index !== -1) {
            var copy = false; //mark the node as false to exclude it from future iterations

            nodes[index] = false; //loop through all edges and follow dependencies of the current node

            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = undefined;

            try {
              for (var _iterator3 = _this7.edges[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                var edge = _step3.value;

                if (edge[0] === node) {
                  //lazily create a copy of predecessors with the current node concatenated onto it
                  copy = copy || predecessors.concat([node]); //recurse to node dependencies

                  visit(edge[1], copy);
                }
              } //add the node to the next place in the sorted array

            } catch (err) {
              _didIteratorError3 = true;
              _iteratorError3 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
                  _iterator3.return();
                }
              } finally {
                if (_didIteratorError3) {
                  throw _iteratorError3;
                }
              }
            }

            sorted[--place] = node;
          }
        };

        for (var i = 0; i < nodes.length; i++) {
          var node = nodes[i]; //ignore nodes that have been excluded

          if (node !== false) {
            //mark the node as false to exclude it from future iterations
            nodes[i] = false; //loop through all edges and follow dependencies of the current node

            var _iteratorNormalCompletion4 = true;
            var _didIteratorError4 = false;
            var _iteratorError4 = undefined;

            try {
              for (var _iterator4 = this.edges[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                var edge = _step4.value;

                if (edge[0] === node) {
                  //recurse to node dependencies
                  visit(edge[1], [node]);
                }
              } //add the node to the next place in the sorted array

            } catch (err) {
              _didIteratorError4 = true;
              _iteratorError4 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
                  _iterator4.return();
                }
              } finally {
                if (_didIteratorError4) {
                  throw _iteratorError4;
                }
              }
            }

            sorted[--place] = node;
          }
        }

        return sorted;
      }
      /**
       * Clears edges
       *
       * @since   0.4.0
       * @returns {Toposort}                  The Toposort instance
       */

    }, {
      key: "clear",
      value: function clear() {
        this.edges = [];
        return this;
      }
    }]);
    return Toposort;
  }();

  _exports.Toposort = Toposort;
});