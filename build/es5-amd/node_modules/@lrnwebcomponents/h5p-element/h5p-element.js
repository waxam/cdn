define(["exports", "meta", "require", "../../lit/index.js", "../es-global-bridge/es-global-bridge.js"], function (_exports, meta, _require, _index, _esGlobalBridge) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.Toposort = _exports.H5PStandalone = _exports.H5PElement = void 0;
  meta = _interopRequireWildcard(meta);
  _require = _interopRequireWildcard(_require);

  var _templateObject_df8e72d0ce4611ecb13bcf602138080f, _templateObject2_df8e72d0ce4611ecb13bcf602138080f, _templateObject3_df8e72d0ce4611ecb13bcf602138080f, _templateObject4_df8e72d0ce4611ecb13bcf602138080f;

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || babelHelpers.typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { babelHelpers.defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  window.__H5PBridgeTimeOut = function () {
    setTimeout(function () {
      window.H5P.init();
    }, 500);
  };
  /**
   * `h5p-element`
   * @element h5p-element
   * `h5p wrapper for loading and presenting .h5p files`
   *
   * @microcopy - language worth noting:
   *  - h5p is it's own eco system, we're just trying to wrap it a bit
   *
  
   * @lit-element
   * @demo demo/index.html
   */


  var H5PElement = /*#__PURE__*/function (_LitElement) {
    babelHelpers.inherits(H5PElement, _LitElement);

    var _super = _createSuper(H5PElement);

    // life cycle
    function H5PElement() {
      var _this;

      babelHelpers.classCallCheck(this, H5PElement);
      _this = _super.call(this); // make a random ID for the targeting

      _this.contentId = _this.generateUUID(); // should kick off all dependencies to start loading on window

      _this.H5PDepsLoader();

      return _this;
    }
    /**
     * This breaks shadowRoot in LitElement
     */


    babelHelpers.createClass(H5PElement, [{
      key: "render",
      value: // render function
      function render() {
        return (0, _index.html)(_templateObject_df8e72d0ce4611ecb13bcf602138080f || (_templateObject_df8e72d0ce4611ecb13bcf602138080f = babelHelpers.taggedTemplateLiteral([" ", ""])), !this.source ? (0, _index.html)(_templateObject2_df8e72d0ce4611ecb13bcf602138080f || (_templateObject2_df8e72d0ce4611ecb13bcf602138080f = babelHelpers.taggedTemplateLiteral(["<h5p-wrapped-element><slot></slot></h5p-wrapped-element>"]))) : (0, _index.html)(_templateObject3_df8e72d0ce4611ecb13bcf602138080f || (_templateObject3_df8e72d0ce4611ecb13bcf602138080f = babelHelpers.taggedTemplateLiteral(["<div\n          class=\"h5p-container\"\n          data-content-id=\"wrapper-", "\"\n        ></div>"])), this.contentId));
      } // haxProperty definition

    }, {
      key: "createRenderRoot",
      value: function createRenderRoot() {
        if (this.source) {
          return this;
        }

        return babelHelpers.get(babelHelpers.getPrototypeOf(H5PElement.prototype), "createRenderRoot", this).call(this);
      }
      /**
       * load dependencies that need to be global in scope
       */

    }, {
      key: "H5PDepsLoader",
      value: function () {
        var _H5PDepsLoader = babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
          var basePath;
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  basePath = new URL("./lib/", meta.url).href;
                  this.h5pJSDeps = [basePath + "h5p-resizer.js", basePath + "h5p/js/jquery.js", basePath + "h5p/js/h5p.js", basePath + "h5p/js/h5p-event-dispatcher.js", basePath + "h5p/js/h5p-content-type.js", basePath + "h5p/js/h5p-action-bar.js", basePath + "h5p/js/h5p-confirmation-dialog.js", basePath + "h5p/js/h5p-x-api-event.js", basePath + "h5p/js/h5p-x-api.js"];
                  this.__h5pDepsLength = this.h5pJSDeps.length - 1;
                  _context.next = 5;
                  return window.ESGlobalBridge.requestAvailability().load("h5p-jquery", basePath + "h5p/js/jquery.js");

                case 5:
                  window.addEventListener("es-bridge-h5p-jquery-loaded", this.h5pJqueryReady.bind(this));
                  window.addEventListener("es-bridge-h5p-" + this.__h5pDepsLength + "-loaded", this.h5pReadyCallback.bind(this));

                case 7:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));

        function H5PDepsLoader() {
          return _H5PDepsLoader.apply(this, arguments);
        }

        return H5PDepsLoader;
      }()
    }, {
      key: "generateUUID",
      value: function generateUUID() {
        return "item-sss-ss-ss".replace(/s/g, this._uuidPart);
      }
    }, {
      key: "_uuidPart",
      value: function _uuidPart() {
        return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
      }
      /**
       * life cycle, element is afixed to the DOM
       */

    }, {
      key: "firstUpdated",
      value: function firstUpdated() {
        if (this.source && window.ESGlobalBridge.requestAvailability().imports["h5p-" + this.__h5pDepsLength] === true && this.contentId) {
          this.setupH5P(this.contentId);
        } // no source, try to make use of the wrapped element methodology


        if (!this.source) {
          new Promise(function (res, rej) {
            return _require.default(["./lib/h5p-wrapped-element.js"], res, rej);
          });
        }
      }
    }, {
      key: "h5pJqueryReady",
      value: function () {
        var _h5pJqueryReady = babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(e) {
          var i;
          return regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  _context2.t0 = regeneratorRuntime.keys(this.h5pJSDeps);

                case 1:
                  if ((_context2.t1 = _context2.t0()).done) {
                    _context2.next = 7;
                    break;
                  }

                  i = _context2.t1.value;
                  _context2.next = 5;
                  return window.ESGlobalBridge.requestAvailability().load("h5p-" + i, this.h5pJSDeps[i]);

                case 5:
                  _context2.next = 1;
                  break;

                case 7:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, this);
        }));

        function h5pJqueryReady(_x) {
          return _h5pJqueryReady.apply(this, arguments);
        }

        return h5pJqueryReady;
      }()
    }, {
      key: "h5pReadyCallback",
      value: function h5pReadyCallback(e) {
        if (this.contentId) {
          this.setupH5P(this.contentId);
        }
      }
      /**
       * This does the heavy lifting to kick it off
       */

    }, {
      key: "setupH5P",
      value: function () {
        var _setupH5P = babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
          var id,
              displayOptions,
              basePath,
              frag,
              stand,
              _args3 = arguments;
          return regeneratorRuntime.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  id = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : 1;
                  displayOptions = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : {};
                  displayOptions = Object.assign(displayOptions, {
                    frame: displayOptions.frame = false,
                    copyright: displayOptions.copyright = false,
                    embed: displayOptions.embed = false,
                    download: displayOptions.download = false,
                    icon: displayOptions.icon = false,
                    export: displayOptions.export = false
                  });
                  basePath = new URL("./lib/", meta.url).href;
                  H5PIntegration.core = {
                    styles: [basePath + "h5p/styles/h5p.css", basePath + "h5p/styles/h5p-confirmation-dialog.css", basePath + "h5p/styles/h5p-core-button.css"],
                    scripts: this.h5pJSDeps
                  };
                  frag = document.createRange().createContextualFragment("\n    <div class=\"h5p-iframe-wrapper\" style=\"background-color:#DDD;\">\n      <iframe id=\"h5p-iframe-".concat(id, "\" class=\"h5p-iframe\" data-content-id=\"").concat(id, "\" style=\"width: 100%; height: 100%; border: none; display: block;\" src=\"about:blank\" frameBorder=\"0\"></iframe>\n    </div>\n    "));

                  if (this.querySelector('[data-content-id="wrapper-' + this.contentId + '"')) {
                    this.querySelector('[data-content-id="wrapper-' + this.contentId + '"').appendChild(frag);
                  }

                  if (!this.source) {
                    _context3.next = 12;
                    break;
                  }

                  stand = new H5PStandalone(id, this.source, displayOptions);
                  _context3.next = 11;
                  return stand.init();

                case 11:
                  // clear previous calls to this exact thing
                  // this accounts for multiples on the DOM and the exccess
                  // file parsing required per each in order to use this thing
                  if (window.__H5PBridgeTimeOut) {
                    clearTimeout(window.__H5PBridgeTimeOut);

                    window.__H5PBridgeTimeOut();
                  }

                case 12:
                  return _context3.abrupt("return", true);

                case 13:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3, this);
        }));

        function setupH5P() {
          return _setupH5P.apply(this, arguments);
        }

        return setupH5P;
      }()
      /**
       * life cycle, element removed from DOM
       */

    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        window.removeEventListener("es-bridge-h5p-" + this.__h5pDepsLength + "-loaded", this.h5pReadyCallback.bind(this));
        window.removeEventListener("es-bridge-h5p-jquery-loaded", this.h5pJqueryReady.bind(this));
        babelHelpers.get(babelHelpers.getPrototypeOf(H5PElement.prototype), "disconnectedCallback", this).call(this);
      }
    }, {
      key: "updated",
      value: function updated(changedProperties) {
        changedProperties.forEach(function (oldValue, propName) {});
      }
    }], [{
      key: "styles",
      get: //styles function
      function get() {
        return [(0, _index.css)(_templateObject4_df8e72d0ce4611ecb13bcf602138080f || (_templateObject4_df8e72d0ce4611ecb13bcf602138080f = babelHelpers.taggedTemplateLiteral(["\n        :host {\n          display: block;\n        }\n      "])))];
      }
    }, {
      key: "haxProperties",
      get: function get() {
        return {
          canScale: true,
          canPosition: true,
          canEditSource: true,
          gizmo: {
            title: "H5P element",
            description: "h5p wrapper for loading and presenting .h5p files",
            icon: "icons:android",
            color: "green",
            groups: ["Interactive"],
            meta: {
              author: "btopro",
              owner: "The Pennsylvania State University"
            }
          },
          settings: {
            configure: [{
              attribute: "source",
              description: "Location the H5P file was unpacked to",
              inputMethod: "textfield",
              required: true,
              icon: "icons:link"
            }],
            advanced: []
          },
          saveOptions: {
            wipeSlot: true,
            unsetAttributes: ["content-id"]
          }
        };
      } // properties available to the custom element for data binding

    }, {
      key: "properties",
      get: function get() {
        return _objectSpread(_objectSpread({}, babelHelpers.get(babelHelpers.getPrototypeOf(H5PElement), "properties", this)), {}, {
          /**
           * Source of the .h5p file
           */
          source: {
            name: "source",
            type: String
          }
        });
      }
      /**
       * Store the tag name to make it easier to obtain directly.
       * @notice function name must be here for tooling to operate correctly
       */

    }, {
      key: "tag",
      get: function get() {
        return "h5p-element";
      }
    }]);
    return H5PElement;
  }(_index.LitElement);

  _exports.H5PElement = H5PElement;
  customElements.define("h5p-element", H5PElement);
  window.H5P = window.H5P || {};
  window.H5PIntegration = window.H5PIntegration || {};
  H5PIntegration.l10n = {
    H5P: {
      advancedHelp: "Include this script on your website if you want dynamic sizing of the embedded content:",
      author: "Author",
      by: "by",
      close: "Close",
      contentChanged: "This content has changed since you last used it.",
      copyrightInformation: "Rights of use",
      copyrights: "Rights of use",
      copyrightsDescription: "View copyright information for this content.",
      disableFullscreen: "Disable fullscreen",
      download: "Download",
      downloadDescription: "Download this content as a H5P file.",
      embed: "Embed",
      embedDescription: "View the embed code for this content.",
      fullscreen: "Fullscreen",
      h5pDescription: "Visit H5P.org to check out more cool content.",
      hideAdvanced: "Hide advanced",
      license: "License",
      noCopyrights: "No copyright information available for this content.",
      showAdvanced: "Show advanced",
      showLess: "Show less",
      showMore: "Show more",
      size: "Size",
      source: "Source",
      startingOver: "You'll be starting over.",
      subLevel: "Sublevel",
      thumbnail: "Thumbnail",
      title: "Title",
      year: "Year"
    }
  };

  var H5PStandalone = /*#__PURE__*/function () {
    function H5PStandalone() {
      var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var pathToContent = arguments.length > 1 ? arguments[1] : undefined;
      var displayOptions = arguments.length > 2 ? arguments[2] : undefined;
      babelHelpers.classCallCheck(this, H5PStandalone);
      this.id = id;
      this.path = pathToContent;
      this.displayOptions = displayOptions;
      return true;
    }

    babelHelpers.createClass(H5PStandalone, [{
      key: "getJSONPromise",
      value: function getJSONPromise(url) {
        return fetch(url).then(function (response) {
          return response.json();
        });
      }
      /**
       * Initialize the H5P
       */

    }, {
      key: "init",
      value: function () {
        var _init = babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
          var dependencies, _yield$this$sortDepen, styles, scripts;

          return regeneratorRuntime.wrap(function _callee4$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  _context4.next = 2;
                  return this.getJSONPromise("".concat(this.path, "/h5p.json"));

                case 2:
                  this.h5p = _context4.sent;
                  _context4.t0 = JSON;
                  _context4.next = 6;
                  return this.getJSONPromise("".concat(this.path, "/content/content.json"));

                case 6:
                  _context4.t1 = _context4.sent;
                  this.content = _context4.t0.stringify.call(_context4.t0, _context4.t1);
                  _context4.next = 10;
                  return this.checkIfPathIncludesVersion();

                case 10:
                  window.H5PIntegration.pathIncludesVersion = this.pathIncludesVersion = _context4.sent;
                  _context4.next = 13;
                  return this.findMainLibrary();

                case 13:
                  this.mainLibrary = _context4.sent;
                  _context4.next = 16;
                  return this.findAllDependencies();

                case 16:
                  dependencies = _context4.sent;
                  _context4.next = 19;
                  return this.sortDependencies(dependencies);

                case 19:
                  _yield$this$sortDepen = _context4.sent;
                  styles = _yield$this$sortDepen.styles;
                  scripts = _yield$this$sortDepen.scripts;
                  H5PIntegration.url = this.path;
                  H5PIntegration.contents = H5PIntegration.contents ? H5PIntegration.contents : {};
                  H5PIntegration.contents["cid-" + this.id] = {
                    library: "".concat(this.mainLibrary.machineName, " ").concat(this.mainLibrary.majorVersion, ".").concat(this.mainLibrary.minorVersion),
                    jsonContent: this.content,
                    styles: styles,
                    scripts: scripts,
                    displayOptions: this.displayOptions
                  };
                  return _context4.abrupt("return", true);

                case 26:
                case "end":
                  return _context4.stop();
              }
            }
          }, _callee4, this);
        }));

        function init() {
          return _init.apply(this, arguments);
        }

        return init;
      }()
      /**
       * Check if the library folder include the version or not
       * This was changed at some point in H5P and we need to be backwards compatible
       *
       * @return {boolean}
       */

    }, {
      key: "checkIfPathIncludesVersion",
      value: function () {
        var _checkIfPathIncludesVersion = babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
          var dependency, machinePath, pathIncludesVersion;
          return regeneratorRuntime.wrap(function _callee5$(_context5) {
            while (1) {
              switch (_context5.prev = _context5.next) {
                case 0:
                  dependency = this.h5p.preloadedDependencies[0];
                  machinePath = dependency.machineName + "-" + dependency.majorVersion + "." + dependency.minorVersion;
                  _context5.prev = 2;
                  _context5.next = 5;
                  return this.getJSONPromise("".concat(this.path, "/").concat(machinePath, "/library.json"));

                case 5:
                  pathIncludesVersion = true;
                  _context5.next = 11;
                  break;

                case 8:
                  _context5.prev = 8;
                  _context5.t0 = _context5["catch"](2);
                  pathIncludesVersion = false;

                case 11:
                  return _context5.abrupt("return", pathIncludesVersion);

                case 12:
                case "end":
                  return _context5.stop();
              }
            }
          }, _callee5, this, [[2, 8]]);
        }));

        function checkIfPathIncludesVersion() {
          return _checkIfPathIncludesVersion.apply(this, arguments);
        }

        return checkIfPathIncludesVersion;
      }()
      /**
       * return the path to a library
       * @param {object} library
       * @return {string}
       */

    }, {
      key: "libraryPath",
      value: function libraryPath(library) {
        return library.machineName + (this.pathIncludesVersion ? "-" + library.majorVersion + "." + library.minorVersion : "");
      }
      /**
       * FInd the main library for this H5P
       * @return {Promise}
       */

    }, {
      key: "findMainLibrary",
      value: function findMainLibrary() {
        var _this2 = this;

        var mainLibraryInfo = this.h5p.preloadedDependencies.find(function (dep) {
          return dep.machineName === _this2.h5p.mainLibrary;
        });
        this.mainLibraryPath = this.h5p.mainLibrary + (this.pathIncludesVersion ? "-" + mainLibraryInfo.majorVersion + "." + mainLibraryInfo.minorVersion : "");
        return this.getJSONPromise("".concat(this.path, "/").concat(this.mainLibraryPath, "/library.json"));
      }
      /**
       * find all the libraries used in this H5P
       * @return {Promise}
       */

    }, {
      key: "findAllDependencies",
      value: function findAllDependencies() {
        var _this3 = this;

        var directDependencyNames = this.h5p.preloadedDependencies.map(function (dependency) {
          return _this3.libraryPath(dependency);
        });
        return this.loadDependencies(directDependencyNames, []);
      }
      /**
       * searches through all supplied libraries for dependencies, this is recursive and repeats until all deep dependencies have been found
       * @param {string[]} toFind list of libraries to find the dependencies of
       * @param {string[]} alreadyFound the dependencies that have already been found
       */

    }, {
      key: "loadDependencies",
      value: function () {
        var _loadDependencies = babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(toFind, alreadyFound) {
          var _this4 = this;

          var dependencies, findNext, newDependencies;
          return regeneratorRuntime.wrap(function _callee6$(_context6) {
            while (1) {
              switch (_context6.prev = _context6.next) {
                case 0:
                  // dependencyDepth++;
                  dependencies = alreadyFound;
                  findNext = [];
                  _context6.next = 4;
                  return Promise.all(toFind.map(function (libraryName) {
                    return _this4.findLibraryDependencies(libraryName);
                  }));

                case 4:
                  newDependencies = _context6.sent;
                  // loop over newly found libraries
                  newDependencies.forEach(function (library) {
                    // push into found list
                    dependencies.push(library); // check if any dependencies haven't been found yet

                    library.dependencies.forEach(function (dependency) {
                      if (!dependencies.find(function (foundLibrary) {
                        return foundLibrary.libraryPath === dependency;
                      }) && !newDependencies.find(function (foundLibrary) {
                        return foundLibrary.libraryPath === dependency;
                      })) {
                        findNext.push(dependency);
                      }
                    });
                  });

                  if (!(findNext.length > 0)) {
                    _context6.next = 8;
                    break;
                  }

                  return _context6.abrupt("return", this.loadDependencies(findNext, dependencies));

                case 8:
                  return _context6.abrupt("return", dependencies);

                case 9:
                case "end":
                  return _context6.stop();
              }
            }
          }, _callee6, this);
        }));

        function loadDependencies(_x2, _x3) {
          return _loadDependencies.apply(this, arguments);
        }

        return loadDependencies;
      }()
      /**
       * Loads a dependencies library.json and finds the libraries it dependson as well ass the JS and CSS it needs
       * @param {string} libraryName
       */

    }, {
      key: "findLibraryDependencies",
      value: function () {
        var _findLibraryDependencies = babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(libraryName) {
          var _this5 = this;

          var library, libraryPath, dependencies;
          return regeneratorRuntime.wrap(function _callee7$(_context7) {
            while (1) {
              switch (_context7.prev = _context7.next) {
                case 0:
                  _context7.next = 2;
                  return this.getJSONPromise("".concat(this.path, "/").concat(libraryName, "/library.json"));

                case 2:
                  library = _context7.sent;
                  libraryPath = this.libraryPath(library);
                  dependencies = [];

                  if (library.preloadedDependencies) {
                    dependencies = library.preloadedDependencies.map(function (dependency) {
                      return _this5.libraryPath(dependency);
                    });
                  }

                  return _context7.abrupt("return", {
                    libraryPath: libraryPath,
                    dependencies: dependencies,
                    preloadedCss: library.preloadedCss,
                    preloadedJs: library.preloadedJs
                  });

                case 7:
                case "end":
                  return _context7.stop();
              }
            }
          }, _callee7, this);
        }));

        function findLibraryDependencies(_x4) {
          return _findLibraryDependencies.apply(this, arguments);
        }

        return findLibraryDependencies;
      }()
      /**
       * Resolves the library dependency tree and sorts the JS and CSS files into order
       * @param {object[]} dependencies
       * @return {object}
       */

    }, {
      key: "sortDependencies",
      value: function () {
        var _sortDependencies = babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(dependencies) {
          var _this6 = this;

          var dependencySorter, CSSDependencies, JSDependencies, styles, scripts;
          return regeneratorRuntime.wrap(function _callee8$(_context8) {
            while (1) {
              switch (_context8.prev = _context8.next) {
                case 0:
                  dependencySorter = new Toposort();
                  CSSDependencies = {};
                  JSDependencies = {};
                  dependencies.forEach(function (dependency) {
                    dependencySorter.add(dependency.libraryPath, dependency.dependencies);

                    if (dependency.preloadedCss) {
                      CSSDependencies[dependency.libraryPath] = CSSDependencies[dependency.libraryPath] ? CSSDependencies[dependency.libraryPath] : [];
                      dependency.preloadedCss.forEach(function (style) {
                        CSSDependencies[dependency.libraryPath].push("".concat(_this6.path, "/").concat(dependency.libraryPath, "/").concat(style.path));
                      });
                    }

                    if (dependency.preloadedJs) {
                      JSDependencies[dependency.libraryPath] = JSDependencies[dependency.libraryPath] ? JSDependencies[dependency.libraryPath] : [];
                      dependency.preloadedJs.forEach(function (script) {
                        JSDependencies[dependency.libraryPath].push("".concat(_this6.path, "/").concat(dependency.libraryPath, "/").concat(script.path));
                      });
                    }
                  });
                  styles = [];
                  scripts = [];
                  dependencySorter.sort().reverse().forEach(function (dependencyName) {
                    Array.prototype.push.apply(styles, CSSDependencies[dependencyName]);
                    Array.prototype.push.apply(scripts, JSDependencies[dependencyName]);
                  });
                  Array.prototype.push.apply(styles, this.mainLibrary.preloadedCss.map(function (style) {
                    return "".concat(_this6.path, "/").concat(_this6.mainLibraryPath, "/").concat(style.path);
                  }));
                  Array.prototype.push.apply(scripts, this.mainLibrary.preloadedJs.map(function (script) {
                    return "".concat(_this6.path, "/").concat(_this6.mainLibraryPath, "/").concat(script.path);
                  }));
                  return _context8.abrupt("return", {
                    styles: styles,
                    scripts: scripts
                  });

                case 10:
                case "end":
                  return _context8.stop();
              }
            }
          }, _callee8, this);
        }));

        function sortDependencies(_x5) {
          return _sortDependencies.apply(this, arguments);
        }

        return sortDependencies;
      }()
    }]);
    return H5PStandalone;
  }();

  _exports.H5PStandalone = H5PStandalone;

  var Toposort = /*#__PURE__*/function () {
    function Toposort() {
      babelHelpers.classCallCheck(this, Toposort);
      this.edges = [];
    }
    /**
     * Adds dependency edges.
     *
     * @since   0.1.0
     * @param   {String} item               An dependent name. Must be an string and not empty
     * @param   {String[]|String} [deps]    An dependency or array of dependencies
     * @returns {Toposort}                  The Toposort instance
     */


    babelHelpers.createClass(Toposort, [{
      key: "add",
      value: function add(item, deps) {
        if (typeof item !== "string" || !item) {
          throw new TypeError("Dependent name must be given as a not empty string");
        }

        deps = Array.isArray(deps) ? deps : [deps];

        if (deps.length > 0) {
          var _iterator = _createForOfIteratorHelper(deps),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var dep = _step.value;

              if (typeof dep !== "string" || !dep) {
                throw new TypeError("Dependency name must be given as a not empty string");
              }

              this.edges.push([item, dep]);
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        } else {
          this.edges.push([item]);
        }

        return this;
      }
      /**
       * Runs the toposorting and return an ordered array of strings
       *
       * @since   0.1.0
       * @returns {String[]}  The list of items topologically sorted.
       */

    }, {
      key: "sort",
      value: function sort() {
        var _this7 = this;

        var nodes = []; //accumulate unique nodes into a large list

        var _iterator2 = _createForOfIteratorHelper(this.edges),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var _edge = _step2.value;

            var _iterator5 = _createForOfIteratorHelper(_edge),
                _step5;

            try {
              for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                var _node = _step5.value;

                if (nodes.indexOf(_node) === -1) {
                  nodes.push(_node);
                }
              }
            } catch (err) {
              _iterator5.e(err);
            } finally {
              _iterator5.f();
            }
          } //initialize the placement of nodes into the sorted array at the end

        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }

        var place = nodes.length; //initialize the sorted array with the same length as the unique nodes array

        var sorted = new Array(nodes.length); //define a visitor function that recursively traverses dependencies.

        var visit = function visit(node, predecessors) {
          //check if a node is dependent of itself
          if (predecessors.length !== 0 && predecessors.indexOf(node) !== -1) {
            throw new Error("Cyclic dependency found. ".concat(node, " is dependent of itself.\nDependency chain: ").concat(predecessors.join(" -> "), " => ").concat(node));
          }

          var index = nodes.indexOf(node); //if the node still exists, traverse its dependencies

          if (index !== -1) {
            var copy = false; //mark the node as false to exclude it from future iterations

            nodes[index] = false; //loop through all edges and follow dependencies of the current node

            var _iterator3 = _createForOfIteratorHelper(_this7.edges),
                _step3;

            try {
              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                var edge = _step3.value;

                if (edge[0] === node) {
                  //lazily create a copy of predecessors with the current node concatenated onto it
                  copy = copy || predecessors.concat([node]); //recurse to node dependencies

                  visit(edge[1], copy);
                }
              } //add the node to the next place in the sorted array

            } catch (err) {
              _iterator3.e(err);
            } finally {
              _iterator3.f();
            }

            sorted[--place] = node;
          }
        };

        for (var i = 0; i < nodes.length; i++) {
          var node = nodes[i]; //ignore nodes that have been excluded

          if (node !== false) {
            //mark the node as false to exclude it from future iterations
            nodes[i] = false; //loop through all edges and follow dependencies of the current node

            var _iterator4 = _createForOfIteratorHelper(this.edges),
                _step4;

            try {
              for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                var edge = _step4.value;

                if (edge[0] === node) {
                  //recurse to node dependencies
                  visit(edge[1], [node]);
                }
              } //add the node to the next place in the sorted array

            } catch (err) {
              _iterator4.e(err);
            } finally {
              _iterator4.f();
            }

            sorted[--place] = node;
          }
        }

        return sorted;
      }
      /**
       * Clears edges
       *
       * @since   0.4.0
       * @returns {Toposort}                  The Toposort instance
       */

    }, {
      key: "clear",
      value: function clear() {
        this.edges = [];
        return this;
      }
    }]);
    return Toposort;
  }();

  _exports.Toposort = Toposort;
});