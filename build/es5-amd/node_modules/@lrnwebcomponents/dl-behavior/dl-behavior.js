define(["exports"], function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.MtzFileDownloadBehaviors = void 0;

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var MtzFileDownloadBehaviors = function MtzFileDownloadBehaviors(SuperClass) {
    return /*#__PURE__*/function (_SuperClass) {
      babelHelpers.inherits(_class, _SuperClass);

      var _super = _createSuper(_class);

      function _class() {
        babelHelpers.classCallCheck(this, _class);
        return _super.apply(this, arguments);
      }

      babelHelpers.createClass(_class, [{
        key: "downloadFromData",
        value:
        /**
         * Converts the data to a blob then uses navigator to save blob if itâ€™s available, otherwise
         * creates an <a> with [download] attribute then simulates a click.
         * @param {String} data - data to encode.
         * @param {String} type - type of file to generate (i.e, JSON or CSV).
         * @param {String} [name = 'download'] - file name to save data under.
         * @param {Boolean} [newTab = true] - If false, downloads uri in existing tab. Otherwise,
         * downloads in new tab.
         */
        function downloadFromData(data, type) {
          var name = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "download";
          var newTab = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
          var mimeType = this.fileTypes[type.toUpperCase()];
          var blob = new Blob([decodeURIComponent(encodeURI(data))], {
            type: mimeType
          });
          var filename = name + "." + type.toLowerCase();

          if (window.navigator && window.navigator.msSaveOrOpenBlob) {
            window.navigator.msSaveOrOpenBlob(blob, filename);
          } else {
            // Link elements have a download attribute which provides cross-platform
            // download behavior supporting all but IE 11. This creates new link and then
            // clicks it to initiate download.
            var link = document.createElement("a");
            link.href = (window.URL || window.webkitURL).createObjectURL(blob);
            link.download = filename;
            link.target = newTab ? "_blank" : "_self";
            this.appendChild(link);
            link.click();
            this.removeChild(link);
          }
        }
        /**
         * Opens a new tab at the URI so that download can be initiated from the page.
         * @param {String} uri - The uri to open.
         * @param {Boolean} [newTab = true] - If false, downloads uri in existing tab. Otherwise,
         * downloads in new tab.
         * @return {Boolean} Returns true.
         */

      }, {
        key: "downloadFromURI",
        value: function downloadFromURI(uri) {
          var newTab = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
          window.open(uri, newTab ? "_blank" : "_self");
          return true; // NOTE: Returning true to prevent error in some browsers during download.
        }
      }], [{
        key: "properties",
        get: function get() {
          if (babelHelpers.get(babelHelpers.getPrototypeOf(_class), "properties", this)) {
            return Object.assign({
              fileTypes: {
                type: Object,
                value: function value() {
                  return {
                    CSV: "text/csv",
                    JSON: "text/json",
                    PDF: "application/pdf",
                    TXT: "text/plain",
                    HTML: "text/html"
                  };
                }
              }
            }, babelHelpers.get(babelHelpers.getPrototypeOf(_class), "properties", this));
          } else {
            return {
              fileTypes: {
                type: Object,
                value: function value() {
                  return {
                    CSV: "text/csv",
                    JSON: "text/json",
                    PDF: "application/pdf",
                    TXT: "text/plain",
                    HTML: "text/html"
                  };
                }
              }
            };
          }
        }
      }]);
      return _class;
    }(SuperClass);
  };

  _exports.MtzFileDownloadBehaviors = MtzFileDownloadBehaviors;
});