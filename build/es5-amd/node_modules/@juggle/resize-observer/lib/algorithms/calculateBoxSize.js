define(["exports", "../ResizeObserverBoxOptions.js", "../ResizeObserverSize.js", "../DOMRectReadOnly.js", "../utils/element.js", "../utils/freeze.js", "../utils/global.js"], function (_exports, _ResizeObserverBoxOptions, _ResizeObserverSize, _DOMRectReadOnly, _element, _freeze, _global) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.calculateBoxSizes = _exports.calculateBoxSize = void 0;
  var cache = new WeakMap();
  var scrollRegexp = /auto|scroll/;
  var verticalRegexp = /^tb|vertical/;
  var IE = /msie|trident/i.test(_global.global.navigator && _global.global.navigator.userAgent);

  var parseDimension = function parseDimension(pixel) {
    return parseFloat(pixel || '0');
  };

  var size = function size(inlineSize, blockSize, switchSizes) {
    if (inlineSize === void 0) {
      inlineSize = 0;
    }

    if (blockSize === void 0) {
      blockSize = 0;
    }

    if (switchSizes === void 0) {
      switchSizes = false;
    }

    return new _ResizeObserverSize.ResizeObserverSize((switchSizes ? blockSize : inlineSize) || 0, (switchSizes ? inlineSize : blockSize) || 0);
  };

  var zeroBoxes = (0, _freeze.freeze)({
    devicePixelContentBoxSize: size(),
    borderBoxSize: size(),
    contentBoxSize: size(),
    contentRect: new _DOMRectReadOnly.DOMRectReadOnly(0, 0, 0, 0)
  });

  var calculateBoxSizes = function calculateBoxSizes(target, forceRecalculation) {
    if (forceRecalculation === void 0) {
      forceRecalculation = false;
    }

    if (cache.has(target) && !forceRecalculation) {
      return cache.get(target);
    }

    if ((0, _element.isHidden)(target)) {
      cache.set(target, zeroBoxes);
      return zeroBoxes;
    }

    var cs = getComputedStyle(target);
    var svg = (0, _element.isSVG)(target) && target.ownerSVGElement && target.getBBox();
    var removePadding = !IE && cs.boxSizing === 'border-box';
    var switchSizes = verticalRegexp.test(cs.writingMode || '');
    var canScrollVertically = !svg && scrollRegexp.test(cs.overflowY || '');
    var canScrollHorizontally = !svg && scrollRegexp.test(cs.overflowX || '');
    var paddingTop = svg ? 0 : parseDimension(cs.paddingTop);
    var paddingRight = svg ? 0 : parseDimension(cs.paddingRight);
    var paddingBottom = svg ? 0 : parseDimension(cs.paddingBottom);
    var paddingLeft = svg ? 0 : parseDimension(cs.paddingLeft);
    var borderTop = svg ? 0 : parseDimension(cs.borderTopWidth);
    var borderRight = svg ? 0 : parseDimension(cs.borderRightWidth);
    var borderBottom = svg ? 0 : parseDimension(cs.borderBottomWidth);
    var borderLeft = svg ? 0 : parseDimension(cs.borderLeftWidth);
    var horizontalPadding = paddingLeft + paddingRight;
    var verticalPadding = paddingTop + paddingBottom;
    var horizontalBorderArea = borderLeft + borderRight;
    var verticalBorderArea = borderTop + borderBottom;
    var horizontalScrollbarThickness = !canScrollHorizontally ? 0 : target.offsetHeight - verticalBorderArea - target.clientHeight;
    var verticalScrollbarThickness = !canScrollVertically ? 0 : target.offsetWidth - horizontalBorderArea - target.clientWidth;
    var widthReduction = removePadding ? horizontalPadding + horizontalBorderArea : 0;
    var heightReduction = removePadding ? verticalPadding + verticalBorderArea : 0;
    var contentWidth = svg ? svg.width : parseDimension(cs.width) - widthReduction - verticalScrollbarThickness;
    var contentHeight = svg ? svg.height : parseDimension(cs.height) - heightReduction - horizontalScrollbarThickness;
    var borderBoxWidth = contentWidth + horizontalPadding + verticalScrollbarThickness + horizontalBorderArea;
    var borderBoxHeight = contentHeight + verticalPadding + horizontalScrollbarThickness + verticalBorderArea;
    var boxes = (0, _freeze.freeze)({
      devicePixelContentBoxSize: size(Math.round(contentWidth * devicePixelRatio), Math.round(contentHeight * devicePixelRatio), switchSizes),
      borderBoxSize: size(borderBoxWidth, borderBoxHeight, switchSizes),
      contentBoxSize: size(contentWidth, contentHeight, switchSizes),
      contentRect: new _DOMRectReadOnly.DOMRectReadOnly(paddingLeft, paddingTop, contentWidth, contentHeight)
    });
    cache.set(target, boxes);
    return boxes;
  };

  _exports.calculateBoxSizes = calculateBoxSizes;

  var calculateBoxSize = function calculateBoxSize(target, observedBox, forceRecalculation) {
    var _a = calculateBoxSizes(target, forceRecalculation),
        borderBoxSize = _a.borderBoxSize,
        contentBoxSize = _a.contentBoxSize,
        devicePixelContentBoxSize = _a.devicePixelContentBoxSize;

    switch (observedBox) {
      case _ResizeObserverBoxOptions.ResizeObserverBoxOptions.DEVICE_PIXEL_CONTENT_BOX:
        return devicePixelContentBoxSize;

      case _ResizeObserverBoxOptions.ResizeObserverBoxOptions.BORDER_BOX:
        return borderBoxSize;

      default:
        return contentBoxSize;
    }
  };

  _exports.calculateBoxSize = calculateBoxSize;
});