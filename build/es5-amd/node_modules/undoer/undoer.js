define(["exports"],function(_exports){"use strict";Object.defineProperty(_exports,"__esModule",{value:!0});_exports.Undoer=void 0;var Undoer=/*#__PURE__*/function(){/**
   * @template T
   * @param {function(T)} callback to call when undo/redo occurs
   * @param {T=} zero the zero state for undoing everything
   */function Undoer(callback){var _this=this,zero=1<arguments.length&&arguments[1]!==void 0?arguments[1]:null;babelHelpers.classCallCheck(this,Undoer);this._duringUpdate=!1;this._stack=[zero];// nb. Previous versions of this used `input` for browsers other than Firefox (as Firefox
// _only_ supports execCommand on contentEditable)
this._ctrl=document.createElement("div");this._ctrl.setAttribute("aria-hidden","true");this._ctrl.style.opacity=0;this._ctrl.style.position="fixed";this._ctrl.style.top="-1000px";this._ctrl.style.pointerEvents="none";this._ctrl.tabIndex=-1;this._ctrl.contentEditable=!0;this._ctrl.textContent="0";this._ctrl.style.visibility="hidden";// hide element while not used
this._ctrl.addEventListener("focus",function(ev){// Safari needs us to wait, can't blur immediately.
window.setTimeout(function(){return void _this._ctrl.blur()},0)});this._ctrl.addEventListener("input",function(ev){if(!_this._duringUpdate){callback(_this.data)}// clear selection, otherwise user copy gesture will copy value
// nb. this _probably_ won't work inside Shadow DOM
// nb. this is mitigated by the fact that we set visibility: 'hidden'
var s=window.getSelection();if(s.containsNode(_this._ctrl,!0)){s.removeAllRanges()}})}/**
   * @return {number} the current stack value
   */babelHelpers.createClass(Undoer,[{key:"push",/**
   * Pushes a new undoable event. Adds to the browser's native undo/redo stack.
   *
   * @param {T} data the data for this undo event
   * @param {!Node=} parent to add to, uses document.body by default
   * @export
   */value:function push(data,parent){// nb. We can't remove this later: the only case we could is if the user undoes everything
// and then does some _other_ action (which we can't detect).
if(!this._ctrl.parentNode){// nb. we check parentNode as this would remove contentEditable's history
(parent||document.body).appendChild(this._ctrl)}var nextID=this._depth+1;this._stack.splice(nextID,this._stack.length-nextID,data);var previousFocus=document.activeElement;try{this._duringUpdate=!0;this._ctrl.style.visibility=null;this._ctrl.focus();document.execCommand("selectAll");document.execCommand("insertText",!1,nextID)}finally{this._duringUpdate=!1;this._ctrl.style.visibility="hidden"}previousFocus&&previousFocus.focus()}},{key:"_depth",get:function get(){return+this._ctrl.textContent||0}/**
   * @return {T} the current data
   * @export
   */},{key:"data",get:function get(){return this._stack[this._depth]}}]);return Undoer}();_exports.Undoer=Undoer});