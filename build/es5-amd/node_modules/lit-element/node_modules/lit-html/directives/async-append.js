define(["exports", "../lit-html.js"], function (_exports, _litHtml) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.asyncAppend = void 0;

  /**
   * @license
   * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   */
  var __asyncValues = void 0 && (void 0).__asyncValues || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator],
        i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
      return this;
    }, i);

    function verb(n) {
      i[n] = o[n] && function (v) {
        return new Promise(function (resolve, reject) {
          v = o[n](v), settle(resolve, reject, v.done, v.value);
        });
      };
    }

    function settle(resolve, reject, d, v) {
      Promise.resolve(v).then(function (v) {
        resolve({
          value: v,
          done: d
        });
      }, reject);
    }
  };

  /**
   * A directive that renders the items of an async iterable[1], appending new
   * values after previous values, similar to the built-in support for iterables.
   *
   * Async iterables are objects with a [Symbol.asyncIterator] method, which
   * returns an iterator who's `next()` method returns a Promise. When a new
   * value is available, the Promise resolves and the value is appended to the
   * Part controlled by the directive. If another value other than this
   * directive has been set on the Part, the iterable will no longer be listened
   * to and new values won't be written to the Part.
   *
   * [1]: https://github.com/tc39/proposal-async-iteration
   *
   * @param value An async iterable
   * @param mapper An optional function that maps from (value, index) to another
   *     value. Useful for generating templates for each item in the iterable.
   */
  var asyncAppend = (0, _litHtml.directive)(function (value, mapper) {
    return (
      /*#__PURE__*/
      function () {
        var _ref = babelHelpers.asyncToGenerator(
        /*#__PURE__*/
        regeneratorRuntime.mark(function _callee(part) {
          var e_1, _a, itemPart, i, value_1, value_1_1, v, itemStartNode;

          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  if (babelHelpers.instanceof(part, _litHtml.NodePart)) {
                    _context.next = 2;
                    break;
                  }

                  throw new Error('asyncAppend can only be used in text bindings');

                case 2:
                  if (!(value === part.value)) {
                    _context.next = 4;
                    break;
                  }

                  return _context.abrupt("return");

                case 4:
                  part.value = value; // We keep track of item Parts across iterations, so that we can
                  // share marker nodes between consecutive Parts.

                  i = 0;
                  _context.prev = 6;
                  value_1 = __asyncValues(value);

                case 8:
                  _context.next = 10;
                  return value_1.next();

                case 10:
                  value_1_1 = _context.sent;

                  if (value_1_1.done) {
                    _context.next = 26;
                    break;
                  }

                  v = value_1_1.value; // Check to make sure that value is the still the current value of
                  // the part, and if not bail because a new value owns this part

                  if (!(part.value !== value)) {
                    _context.next = 15;
                    break;
                  }

                  return _context.abrupt("break", 26);

                case 15:
                  // When we get the first value, clear the part. This lets the
                  // previous value display until we can replace it.
                  if (i === 0) {
                    part.clear();
                  } // As a convenience, because functional-programming-style
                  // transforms of iterables and async iterables requires a library,
                  // we accept a mapper function. This is especially convenient for
                  // rendering a template for each item.


                  if (mapper !== undefined) {
                    // This is safe because T must otherwise be treated as unknown by
                    // the rest of the system.
                    v = mapper(v, i);
                  } // Like with sync iterables, each item induces a Part, so we need
                  // to keep track of start and end nodes for the Part.
                  // Note: Because these Parts are not updatable like with a sync
                  // iterable (if we render a new value, we always clear), it may
                  // be possible to optimize away the Parts and just re-use the
                  // Part.setValue() logic.


                  itemStartNode = part.startNode; // Check to see if we have a previous item and Part

                  if (itemPart !== undefined) {
                    // Create a new node to separate the previous and next Parts
                    itemStartNode = (0, _litHtml.createMarker)(); // itemPart is currently the Part for the previous item. Set
                    // it's endNode to the node we'll use for the next Part's
                    // startNode.

                    itemPart.endNode = itemStartNode;
                    part.endNode.parentNode.insertBefore(itemStartNode, part.endNode);
                  }

                  itemPart = new _litHtml.NodePart(part.options);
                  itemPart.insertAfterNode(itemStartNode);
                  itemPart.setValue(v);
                  itemPart.commit();
                  i++;

                case 24:
                  _context.next = 8;
                  break;

                case 26:
                  _context.next = 31;
                  break;

                case 28:
                  _context.prev = 28;
                  _context.t0 = _context["catch"](6);
                  e_1 = {
                    error: _context.t0
                  };

                case 31:
                  _context.prev = 31;
                  _context.prev = 32;

                  if (!(value_1_1 && !value_1_1.done && (_a = value_1.return))) {
                    _context.next = 36;
                    break;
                  }

                  _context.next = 36;
                  return _a.call(value_1);

                case 36:
                  _context.prev = 36;

                  if (!e_1) {
                    _context.next = 39;
                    break;
                  }

                  throw e_1.error;

                case 39:
                  return _context.finish(36);

                case 40:
                  return _context.finish(31);

                case 41:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, null, [[6, 28, 31, 41], [32,, 36, 40]]);
        }));

        return function (_x) {
          return _ref.apply(this, arguments);
        };
      }()
    );
  });
  _exports.asyncAppend = asyncAppend;
});