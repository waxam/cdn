define(["exports", "../lib/template-instance.js", "../lit-html.js"], function (_exports, _templateInstance, _litHtml) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.cache = void 0;

  /**
   * @license
   * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   */
  var templateCaches = new WeakMap();
  /**
   * Enables fast switching between multiple templates by caching the DOM nodes
   * and TemplateInstances produced by the templates.
   *
   * Example:
   *
   * ```
   * let checked = false;
   *
   * html`
   *   ${cache(checked ? html`input is checked` : html`input is not checked`)}
   * `
   * ```
   */

  var cache = (0, _litHtml.directive)(function (value) {
    return function (part) {
      if (!babelHelpers.instanceof(part, _litHtml.NodePart)) {
        throw new Error('cache can only be used in text bindings');
      }

      var templateCache = templateCaches.get(part);

      if (templateCache === undefined) {
        templateCache = new WeakMap();
        templateCaches.set(part, templateCache);
      }

      var previousValue = part.value; // First, can we update the current TemplateInstance, or do we need to move
      // the current nodes into the cache?

      if (babelHelpers.instanceof(previousValue, _templateInstance.TemplateInstance)) {
        if (babelHelpers.instanceof(value, _litHtml.TemplateResult) && previousValue.template === part.options.templateFactory(value)) {
          // Same Template, just trigger an update of the TemplateInstance
          part.setValue(value);
          return;
        } else {
          // Not the same Template, move the nodes from the DOM into the cache.
          var cachedTemplate = templateCache.get(previousValue.template);

          if (cachedTemplate === undefined) {
            cachedTemplate = {
              instance: previousValue,
              nodes: document.createDocumentFragment()
            };
            templateCache.set(previousValue.template, cachedTemplate);
          }

          (0, _litHtml.reparentNodes)(cachedTemplate.nodes, part.startNode.nextSibling, part.endNode);
        }
      } // Next, can we reuse nodes from the cache?


      if (babelHelpers.instanceof(value, _litHtml.TemplateResult)) {
        var template = part.options.templateFactory(value);

        var _cachedTemplate = templateCache.get(template);

        if (_cachedTemplate !== undefined) {
          // Move nodes out of cache
          part.setValue(_cachedTemplate.nodes);
          part.commit(); // Set the Part value to the TemplateInstance so it'll update it.

          part.value = _cachedTemplate.instance;
        }
      }

      part.setValue(value);
    };
  });
  _exports.cache = cache;
});