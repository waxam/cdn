define(["exports", "require"], function (_exports, _require) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.w = _exports.r = _exports.p = _exports.h = _exports.g = _exports.d = _exports.c = _exports.b = _exports.a = _exports.N = _exports.C = void 0;
  _require = babelHelpers.interopRequireWildcard(_require);

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

  var NAMESPACE = 'websocialshare';
  _exports.N = NAMESPACE;
  var scopeId;
  var contentRef;
  var hostTagName;
  var useNativeShadowDom = false;
  var checkSlotFallbackVisibility = false;
  var checkSlotRelocate = false;
  var isSvgMode = false;
  var queueCongestion = 0;
  var queuePending = false;
  var win = typeof window !== 'undefined' ? window : {};
  _exports.w = win;
  var CSS = win.CSS;
  _exports.C = CSS;
  var doc = win.document || {
    head: {}
  };
  _exports.d = doc;
  var plt = {
    $flags$: 0,
    $resourcesUrl$: '',
    jmp: function jmp(h) {
      return h();
    },
    raf: function raf(h) {
      return requestAnimationFrame(h);
    },
    ael: function ael(el, eventName, listener, opts) {
      return el.addEventListener(eventName, listener, opts);
    },
    rel: function rel(el, eventName, listener, opts) {
      return el.removeEventListener(eventName, listener, opts);
    },
    ce: function ce(eventName, opts) {
      return new CustomEvent(eventName, opts);
    }
  };
  _exports.p = plt;

  var supportsShadow = /*@__PURE__*/function () {
    return (doc.head.attachShadow + '').indexOf('[native') > -1;
  }();

  var promiseResolve = function promiseResolve(v) {
    return Promise.resolve(v);
  };

  _exports.a = promiseResolve;

  var supportsConstructibleStylesheets = /*@__PURE__*/function () {
    try {
      new CSSStyleSheet();
      return true;
    } catch (e) {}

    return false;
  }();

  var HYDRATED_CSS = '{visibility:hidden}.hydrated{visibility:inherit}';

  var createTime = function createTime(fnName) {
    var tagName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    {
      return function () {
        return;
      };
    }
  };

  var uniqueTime = function uniqueTime(key, measureText) {
    {
      return function () {
        return;
      };
    }
  };

  var rootAppliedStyles = new WeakMap();

  var registerStyle = function registerStyle(scopeId, cssText, allowCS) {
    var style = styles.get(scopeId);

    if (supportsConstructibleStylesheets && allowCS) {
      style = style || new CSSStyleSheet();
      style.replace(cssText);
    } else {
      style = cssText;
    }

    styles.set(scopeId, style);
  };

  var addStyle = function addStyle(styleContainerNode, cmpMeta, mode, hostElm) {
    var scopeId = getScopeId(cmpMeta);
    var style = styles.get(scopeId); // if an element is NOT connected then getRootNode() will return the wrong root node
    // so the fallback is to always use the document for the root node in those cases

    styleContainerNode = styleContainerNode.nodeType === 11
    /* DocumentFragment */
    ? styleContainerNode : doc;

    if (style) {
      if (typeof style === 'string') {
        styleContainerNode = styleContainerNode.head || styleContainerNode;
        var appliedStyles = rootAppliedStyles.get(styleContainerNode);
        var styleElm;

        if (!appliedStyles) {
          rootAppliedStyles.set(styleContainerNode, appliedStyles = new Set());
        }

        if (!appliedStyles.has(scopeId)) {
          {
            if (plt.$cssShim$) {
              styleElm = plt.$cssShim$.createHostStyle(hostElm, scopeId, style, !!(cmpMeta.$flags$ & 10
              /* needsScopedEncapsulation */
              ));
              var newScopeId = styleElm['s-sc'];

              if (newScopeId) {
                scopeId = newScopeId; // we don't want to add this styleID to the appliedStyles Set
                // since the cssVarShim might need to apply several different
                // stylesheets for the same component

                appliedStyles = null;
              }
            } else {
              styleElm = doc.createElement('style');
              styleElm.innerHTML = style;
            }

            styleContainerNode.insertBefore(styleElm, styleContainerNode.querySelector('link'));
          }

          if (appliedStyles) {
            appliedStyles.add(scopeId);
          }
        }
      } else if (!styleContainerNode.adoptedStyleSheets.includes(style)) {
        styleContainerNode.adoptedStyleSheets = [].concat(babelHelpers.toConsumableArray(styleContainerNode.adoptedStyleSheets), [style]);
      }
    }

    return scopeId;
  };

  var attachStyles = function attachStyles(hostRef) {
    var cmpMeta = hostRef.$cmpMeta$;
    var elm = hostRef.$hostElement$;
    var flags = cmpMeta.$flags$;
    var endAttachStyles = createTime('attachStyles', cmpMeta.$tagName$);
    var scopeId = addStyle(supportsShadow && elm.shadowRoot ? elm.shadowRoot : elm.getRootNode(), cmpMeta, hostRef.$modeName$, elm);

    if (flags & 10
    /* needsScopedEncapsulation */
    ) {
        // only required when we're NOT using native shadow dom (slot)
        // or this browser doesn't support native shadow dom
        // and this host element was NOT created with SSR
        // let's pick out the inner content for slot projection
        // create a node to represent where the original
        // content was first placed, which is useful later on
        // DOM WRITE!!
        elm['s-sc'] = scopeId;
        elm.classList.add(scopeId + '-h');
      }

    endAttachStyles();
  };

  var getScopeId = function getScopeId(cmp, mode) {
    return 'sc-' + cmp.$tagName$;
  };
  /**
   * Default style mode id
   */

  /**
   * Reusable empty obj/array
   * Don't add values to these!!
   */


  var EMPTY_OBJ = {};

  var isDef = function isDef(v) {
    return v != null;
  };

  var noop = function noop() {
    /* noop*/
  };

  var isComplexType = function isComplexType(o) {
    // https://jsperf.com/typeof-fn-object/5
    o = babelHelpers.typeof(o);
    return o === 'object' || o === 'function';
  };

  var IS_DENO_ENV = typeof Deno !== 'undefined';
  var IS_NODE_ENV = !IS_DENO_ENV && typeof global !== 'undefined' && typeof require === 'function' && !!global.process && typeof __filename === 'string' && (!global.origin || typeof global.origin !== 'string');
  var IS_DENO_WINDOWS_ENV = IS_DENO_ENV && Deno.build.os === 'windows';
  var getCurrentDirectory = IS_NODE_ENV ? process.cwd : IS_DENO_ENV ? Deno.cwd : function () {
    return '/';
  };
  var exit = IS_NODE_ENV ? process.exit : IS_DENO_ENV ? Deno.exit : noop;
  /**
   * Production h() function based on Preact by
   * Jason Miller (@developit)
   * Licensed under the MIT License
   * https://github.com/developit/preact/blob/master/LICENSE
   *
   * Modified for Stencil's compiler and vdom
   */
  // const stack: any[] = [];
  // export function h(nodeName: string | d.FunctionalComponent, vnodeData: d.PropsType, child?: d.ChildType): d.VNode;
  // export function h(nodeName: string | d.FunctionalComponent, vnodeData: d.PropsType, ...children: d.ChildType[]): d.VNode;

  var h = function h(nodeName, vnodeData) {
    var child = null;
    var slotName = null;
    var simple = false;
    var lastSimple = false;
    var vNodeChildren = [];

    var walk = function walk(c) {
      for (var i = 0; i < c.length; i++) {
        child = c[i];

        if (Array.isArray(child)) {
          walk(child);
        } else if (child != null && typeof child !== 'boolean') {
          if (simple = typeof nodeName !== 'function' && !isComplexType(child)) {
            child = String(child);
          }

          if (simple && lastSimple) {
            // If the previous child was simple (string), we merge both
            vNodeChildren[vNodeChildren.length - 1].$text$ += child;
          } else {
            // Append a new vNode, if it's text, we create a text vNode
            vNodeChildren.push(simple ? newVNode(null, child) : child);
          }

          lastSimple = simple;
        }
      }
    };

    for (var _len = arguments.length, children = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      children[_key - 2] = arguments[_key];
    }

    walk(children);

    if (vnodeData) {
      if (vnodeData.name) {
        slotName = vnodeData.name;
      }

      {
        var classData = vnodeData.className || vnodeData.class;

        if (classData) {
          vnodeData.class = babelHelpers.typeof(classData) !== 'object' ? classData : Object.keys(classData).filter(function (k) {
            return classData[k];
          }).join(' ');
        }
      }
    }

    var vnode = newVNode(nodeName, null);
    vnode.$attrs$ = vnodeData;

    if (vNodeChildren.length > 0) {
      vnode.$children$ = vNodeChildren;
    }

    {
      vnode.$name$ = slotName;
    }
    return vnode;
  };

  _exports.h = h;

  var newVNode = function newVNode(tag, text) {
    var vnode = {
      $flags$: 0,
      $tag$: tag,
      $text$: text,
      $elm$: null,
      $children$: null
    };
    {
      vnode.$attrs$ = null;
    }
    {
      vnode.$name$ = null;
    }
    return vnode;
  };

  var Host = {};

  var isHost = function isHost(node) {
    return node && node.$tag$ === Host;
  };
  /**
   * Production setAccessor() function based on Preact by
   * Jason Miller (@developit)
   * Licensed under the MIT License
   * https://github.com/developit/preact/blob/master/LICENSE
   *
   * Modified for Stencil's compiler and vdom
   */


  var setAccessor = function setAccessor(elm, memberName, oldValue, newValue, isSvg, flags) {
    if (oldValue !== newValue) {
      var isProp = isMemberInElement(elm, memberName);
      var ln = memberName.toLowerCase();

      if (memberName === 'class') {
        var classList = elm.classList;
        var oldClasses = parseClassList(oldValue);
        var newClasses = parseClassList(newValue);
        classList.remove.apply(classList, babelHelpers.toConsumableArray(oldClasses.filter(function (c) {
          return c && !newClasses.includes(c);
        })));
        classList.add.apply(classList, babelHelpers.toConsumableArray(newClasses.filter(function (c) {
          return c && !oldClasses.includes(c);
        })));
      } else if (!isProp && memberName[0] === 'o' && memberName[1] === 'n') {
        // Event Handlers
        // so if the member name starts with "on" and the 3rd characters is
        // a capital letter, and it's not already a member on the element,
        // then we're assuming it's an event listener
        if (memberName[2] === '-') {
          // on- prefixed events
          // allows to be explicit about the dom event to listen without any magic
          // under the hood:
          // <my-cmp on-click> // listens for "click"
          // <my-cmp on-Click> // listens for "Click"
          // <my-cmp on-ionChange> // listens for "ionChange"
          // <my-cmp on-EVENTS> // listens for "EVENTS"
          memberName = memberName.slice(3);
        } else if (isMemberInElement(win, ln)) {
          // standard event
          // the JSX attribute could have been "onMouseOver" and the
          // member name "onmouseover" is on the window's prototype
          // so let's add the listener "mouseover", which is all lowercased
          memberName = ln.slice(2);
        } else {
          // custom event
          // the JSX attribute could have been "onMyCustomEvent"
          // so let's trim off the "on" prefix and lowercase the first character
          // and add the listener "myCustomEvent"
          // except for the first character, we keep the event name case
          memberName = ln[2] + memberName.slice(3);
        }

        if (oldValue) {
          plt.rel(elm, memberName, oldValue, false);
        }

        if (newValue) {
          plt.ael(elm, memberName, newValue, false);
        }
      } else {
        // Set property if it exists and it's not a SVG
        var isComplex = isComplexType(newValue);

        if ((isProp || isComplex && newValue !== null) && !isSvg) {
          try {
            if (!elm.tagName.includes('-')) {
              var n = newValue == null ? '' : newValue; // Workaround for Safari, moving the <input> caret when re-assigning the same valued

              if (memberName === 'list') {
                isProp = false; // tslint:disable-next-line: triple-equals
              } else if (oldValue == null || elm[memberName] != n) {
                elm[memberName] = n;
              }
            } else {
              elm[memberName] = newValue;
            }
          } catch (e) {}
        }

        if (newValue == null || newValue === false) {
          if (newValue !== false || elm.getAttribute(memberName) === '') {
            {
              elm.removeAttribute(memberName);
            }
          }
        } else if ((!isProp || flags & 4
        /* isHost */
        || isSvg) && !isComplex) {
          newValue = newValue === true ? '' : newValue;
          {
            elm.setAttribute(memberName, newValue);
          }
        }
      }
    }
  };

  var parseClassListRegex = /\s/;

  var parseClassList = function parseClassList(value) {
    return !value ? [] : value.split(parseClassListRegex);
  };

  var updateElement = function updateElement(oldVnode, newVnode, isSvgMode, memberName) {
    // if the element passed in is a shadow root, which is a document fragment
    // then we want to be adding attrs/props to the shadow root's "host" element
    // if it's not a shadow root, then we add attrs/props to the same element
    var elm = newVnode.$elm$.nodeType === 11
    /* DocumentFragment */
    && newVnode.$elm$.host ? newVnode.$elm$.host : newVnode.$elm$;
    var oldVnodeAttrs = oldVnode && oldVnode.$attrs$ || EMPTY_OBJ;
    var newVnodeAttrs = newVnode.$attrs$ || EMPTY_OBJ;
    {
      // remove attributes no longer present on the vnode by setting them to undefined
      for (memberName in oldVnodeAttrs) {
        if (!(memberName in newVnodeAttrs)) {
          setAccessor(elm, memberName, oldVnodeAttrs[memberName], undefined, isSvgMode, newVnode.$flags$);
        }
      }
    } // add new & update changed attributes

    for (memberName in newVnodeAttrs) {
      setAccessor(elm, memberName, oldVnodeAttrs[memberName], newVnodeAttrs[memberName], isSvgMode, newVnode.$flags$);
    }
  };

  var createElm = function createElm(oldParentVNode, newParentVNode, childIndex, parentElm) {
    // tslint:disable-next-line: prefer-const
    var newVNode = newParentVNode.$children$[childIndex];
    var i = 0;
    var elm;
    var childNode;
    var oldVNode;

    if (!useNativeShadowDom) {
      // remember for later we need to check to relocate nodes
      checkSlotRelocate = true;

      if (newVNode.$tag$ === 'slot') {
        if (scopeId) {
          // scoped css needs to add its scoped id to the parent element
          parentElm.classList.add(scopeId + '-s');
        }

        newVNode.$flags$ |= newVNode.$children$ ? // slot element has fallback content
        2
        /* isSlotFallback */
        : // slot element does not have fallback content
        1
        /* isSlotReference */
        ;
      }
    }

    if (newVNode.$text$ !== null) {
      // create text node
      elm = newVNode.$elm$ = doc.createTextNode(newVNode.$text$);
    } else if (newVNode.$flags$ & 1
    /* isSlotReference */
    ) {
        // create a slot reference node
        elm = newVNode.$elm$ = doc.createTextNode('');
      } else {
      // create element
      elm = newVNode.$elm$ = doc.createElement(newVNode.$flags$ & 2
      /* isSlotFallback */
      ? 'slot-fb' : newVNode.$tag$); // add css classes, attrs, props, listeners, etc.

      {
        updateElement(null, newVNode, isSvgMode);
      }

      if (isDef(scopeId) && elm['s-si'] !== scopeId) {
        // if there is a scopeId and this is the initial render
        // then let's add the scopeId as a css class
        elm.classList.add(elm['s-si'] = scopeId);
      }

      if (newVNode.$children$) {
        for (i = 0; i < newVNode.$children$.length; ++i) {
          // create the node
          childNode = createElm(oldParentVNode, newVNode, i, elm); // return node could have been null

          if (childNode) {
            // append our new node
            elm.appendChild(childNode);
          }
        }
      }
    }

    {
      elm['s-hn'] = hostTagName;

      if (newVNode.$flags$ & (2
      /* isSlotFallback */
      | 1
      /* isSlotReference */
      )) {
        // remember the content reference comment
        elm['s-sr'] = true; // remember the content reference comment

        elm['s-cr'] = contentRef; // remember the slot name, or empty string for default slot

        elm['s-sn'] = newVNode.$name$ || ''; // check if we've got an old vnode for this slot

        oldVNode = oldParentVNode && oldParentVNode.$children$ && oldParentVNode.$children$[childIndex];

        if (oldVNode && oldVNode.$tag$ === newVNode.$tag$ && oldParentVNode.$elm$) {
          // we've got an old slot vnode and the wrapper is being replaced
          // so let's move the old slot content back to it's original location
          putBackInOriginalLocation(oldParentVNode.$elm$, false);
        }
      }
    }
    return elm;
  };

  var putBackInOriginalLocation = function putBackInOriginalLocation(parentElm, recursive) {
    plt.$flags$ |= 1
    /* isTmpDisconnected */
    ;
    var oldSlotChildNodes = parentElm.childNodes;

    for (var i = oldSlotChildNodes.length - 1; i >= 0; i--) {
      var childNode = oldSlotChildNodes[i];

      if (childNode['s-hn'] !== hostTagName && childNode['s-ol']) {
        // // this child node in the old element is from another component
        // // remove this node from the old slot's parent
        // childNode.remove();
        // and relocate it back to it's original location
        parentReferenceNode(childNode).insertBefore(childNode, referenceNode(childNode)); // remove the old original location comment entirely
        // later on the patch function will know what to do
        // and move this to the correct spot in need be

        childNode['s-ol'].remove();
        childNode['s-ol'] = undefined;
        checkSlotRelocate = true;
      }

      if (recursive) {
        putBackInOriginalLocation(childNode, recursive);
      }
    }

    plt.$flags$ &= ~1
    /* isTmpDisconnected */
    ;
  };

  var addVnodes = function addVnodes(parentElm, before, parentVNode, vnodes, startIdx, endIdx) {
    var containerElm = parentElm['s-cr'] && parentElm['s-cr'].parentNode || parentElm;
    var childNode;

    if (containerElm.shadowRoot && containerElm.tagName === hostTagName) {
      containerElm = containerElm.shadowRoot;
    }

    for (; startIdx <= endIdx; ++startIdx) {
      if (vnodes[startIdx]) {
        childNode = createElm(null, parentVNode, startIdx, parentElm);

        if (childNode) {
          vnodes[startIdx].$elm$ = childNode;
          containerElm.insertBefore(childNode, referenceNode(before));
        }
      }
    }
  };

  var removeVnodes = function removeVnodes(vnodes, startIdx, endIdx, vnode, elm) {
    for (; startIdx <= endIdx; ++startIdx) {
      if (vnode = vnodes[startIdx]) {
        elm = vnode.$elm$;
        {
          // we're removing this element
          // so it's possible we need to show slot fallback content now
          checkSlotFallbackVisibility = true;

          if (elm['s-ol']) {
            // remove the original location comment
            elm['s-ol'].remove();
          } else {
            // it's possible that child nodes of the node
            // that's being removed are slot nodes
            putBackInOriginalLocation(elm, true);
          }
        } // remove the vnode's element from the dom

        elm.remove();
      }
    }
  };

  var updateChildren = function updateChildren(parentElm, oldCh, newVNode, newCh) {
    var oldStartIdx = 0;
    var newStartIdx = 0;
    var oldEndIdx = oldCh.length - 1;
    var oldStartVnode = oldCh[0];
    var oldEndVnode = oldCh[oldEndIdx];
    var newEndIdx = newCh.length - 1;
    var newStartVnode = newCh[0];
    var newEndVnode = newCh[newEndIdx];
    var node;

    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
      if (oldStartVnode == null) {
        // Vnode might have been moved left
        oldStartVnode = oldCh[++oldStartIdx];
      } else if (oldEndVnode == null) {
        oldEndVnode = oldCh[--oldEndIdx];
      } else if (newStartVnode == null) {
        newStartVnode = newCh[++newStartIdx];
      } else if (newEndVnode == null) {
        newEndVnode = newCh[--newEndIdx];
      } else if (isSameVnode(oldStartVnode, newStartVnode)) {
        patch(oldStartVnode, newStartVnode);
        oldStartVnode = oldCh[++oldStartIdx];
        newStartVnode = newCh[++newStartIdx];
      } else if (isSameVnode(oldEndVnode, newEndVnode)) {
        patch(oldEndVnode, newEndVnode);
        oldEndVnode = oldCh[--oldEndIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (isSameVnode(oldStartVnode, newEndVnode)) {
        // Vnode moved right
        if (oldStartVnode.$tag$ === 'slot' || newEndVnode.$tag$ === 'slot') {
          putBackInOriginalLocation(oldStartVnode.$elm$.parentNode, false);
        }

        patch(oldStartVnode, newEndVnode);
        parentElm.insertBefore(oldStartVnode.$elm$, oldEndVnode.$elm$.nextSibling);
        oldStartVnode = oldCh[++oldStartIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (isSameVnode(oldEndVnode, newStartVnode)) {
        // Vnode moved left
        if (oldStartVnode.$tag$ === 'slot' || newEndVnode.$tag$ === 'slot') {
          putBackInOriginalLocation(oldEndVnode.$elm$.parentNode, false);
        }

        patch(oldEndVnode, newStartVnode);
        parentElm.insertBefore(oldEndVnode.$elm$, oldStartVnode.$elm$);
        oldEndVnode = oldCh[--oldEndIdx];
        newStartVnode = newCh[++newStartIdx];
      } else {
        {
          // new element
          node = createElm(oldCh && oldCh[newStartIdx], newVNode, newStartIdx, parentElm);
          newStartVnode = newCh[++newStartIdx];
        }

        if (node) {
          {
            parentReferenceNode(oldStartVnode.$elm$).insertBefore(node, referenceNode(oldStartVnode.$elm$));
          }
        }
      }
    }

    if (oldStartIdx > oldEndIdx) {
      addVnodes(parentElm, newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].$elm$, newVNode, newCh, newStartIdx, newEndIdx);
    } else if (newStartIdx > newEndIdx) {
      removeVnodes(oldCh, oldStartIdx, oldEndIdx);
    }
  };

  var isSameVnode = function isSameVnode(vnode1, vnode2) {
    // compare if two vnode to see if they're "technically" the same
    // need to have the same element tag, and same key to be the same
    if (vnode1.$tag$ === vnode2.$tag$) {
      if (vnode1.$tag$ === 'slot') {
        return vnode1.$name$ === vnode2.$name$;
      }

      return true;
    }

    return false;
  };

  var referenceNode = function referenceNode(node) {
    // this node was relocated to a new location in the dom
    // because of some other component's slot
    // but we still have an html comment in place of where
    // it's original location was according to it's original vdom
    return node && node['s-ol'] || node;
  };

  var parentReferenceNode = function parentReferenceNode(node) {
    return (node['s-ol'] ? node['s-ol'] : node).parentNode;
  };

  var patch = function patch(oldVNode, newVNode) {
    var elm = newVNode.$elm$ = oldVNode.$elm$;
    var oldChildren = oldVNode.$children$;
    var newChildren = newVNode.$children$;
    var tag = newVNode.$tag$;
    var text = newVNode.$text$;
    var defaultHolder;

    if (text === null) {
      // element node
      {
        if (tag === 'slot') ;else {
          // either this is the first render of an element OR it's an update
          // AND we already know it's possible it could have changed
          // this updates the element's css classes, attrs, props, listeners, etc.
          updateElement(oldVNode, newVNode, isSvgMode);
        }
      }

      if (oldChildren !== null && newChildren !== null) {
        // looks like there's child vnodes for both the old and new vnodes
        updateChildren(elm, oldChildren, newVNode, newChildren);
      } else if (newChildren !== null) {
        // no old child vnodes, but there are new child vnodes to add
        if (oldVNode.$text$ !== null) {
          // the old vnode was text, so be sure to clear it out
          elm.textContent = '';
        } // add the new vnode children


        addVnodes(elm, null, newVNode, newChildren, 0, newChildren.length - 1);
      } else if (oldChildren !== null) {
        // no new child vnodes, but there are old child vnodes to remove
        removeVnodes(oldChildren, 0, oldChildren.length - 1);
      }
    } else if (defaultHolder = elm['s-cr']) {
      // this element has slotted content
      defaultHolder.parentNode.textContent = text;
    } else if (oldVNode.$text$ !== text) {
      // update the text content for the text only vnode
      // and also only if the text is different than before
      elm.data = text;
    }
  };

  var updateFallbackSlotVisibility = function updateFallbackSlotVisibility(elm) {
    // tslint:disable-next-line: prefer-const
    var childNodes = elm.childNodes;
    var childNode;
    var i;
    var ilen;
    var j;
    var slotNameAttr;
    var nodeType;

    for (i = 0, ilen = childNodes.length; i < ilen; i++) {
      childNode = childNodes[i];

      if (childNode.nodeType === 1
      /* ElementNode */
      ) {
          if (childNode['s-sr']) {
            // this is a slot fallback node
            // get the slot name for this slot reference node
            slotNameAttr = childNode['s-sn']; // by default always show a fallback slot node
            // then hide it if there are other slots in the light dom

            childNode.hidden = false;

            for (j = 0; j < ilen; j++) {
              if (childNodes[j]['s-hn'] !== childNode['s-hn']) {
                // this sibling node is from a different component
                nodeType = childNodes[j].nodeType;

                if (slotNameAttr !== '') {
                  // this is a named fallback slot node
                  if (nodeType === 1
                  /* ElementNode */
                  && slotNameAttr === childNodes[j].getAttribute('slot')) {
                    childNode.hidden = true;
                    break;
                  }
                } else {
                  // this is a default fallback slot node
                  // any element or text node (with content)
                  // should hide the default fallback slot node
                  if (nodeType === 1
                  /* ElementNode */
                  || nodeType === 3
                  /* TextNode */
                  && childNodes[j].textContent.trim() !== '') {
                    childNode.hidden = true;
                    break;
                  }
                }
              }
            }
          } // keep drilling down


          updateFallbackSlotVisibility(childNode);
        }
    }
  };

  var relocateNodes = [];

  var relocateSlotContent = function relocateSlotContent(elm) {
    // tslint:disable-next-line: prefer-const
    var childNode;
    var node;
    var hostContentNodes;
    var slotNameAttr;
    var relocateNodeData;
    var j;
    var i = 0;
    var childNodes = elm.childNodes;
    var ilen = childNodes.length;

    for (; i < ilen; i++) {
      childNode = childNodes[i];

      if (childNode['s-sr'] && (node = childNode['s-cr'])) {
        // first got the content reference comment node
        // then we got it's parent, which is where all the host content is in now
        hostContentNodes = node.parentNode.childNodes;
        slotNameAttr = childNode['s-sn'];

        for (j = hostContentNodes.length - 1; j >= 0; j--) {
          node = hostContentNodes[j];

          if (!node['s-cn'] && !node['s-nr'] && node['s-hn'] !== childNode['s-hn']) {
            // let's do some relocating to its new home
            // but never relocate a content reference node
            // that is suppose to always represent the original content location
            if (isNodeLocatedInSlot(node, slotNameAttr)) {
              // it's possible we've already decided to relocate this node
              relocateNodeData = relocateNodes.find(function (r) {
                return r.$nodeToRelocate$ === node;
              }); // made some changes to slots
              // let's make sure we also double check
              // fallbacks are correctly hidden or shown

              checkSlotFallbackVisibility = true;
              node['s-sn'] = node['s-sn'] || slotNameAttr;

              if (relocateNodeData) {
                // previously we never found a slot home for this node
                // but turns out we did, so let's remember it now
                relocateNodeData.$slotRefNode$ = childNode;
              } else {
                // add to our list of nodes to relocate
                relocateNodes.push({
                  $slotRefNode$: childNode,
                  $nodeToRelocate$: node
                });
              }

              if (node['s-sr']) {
                relocateNodes.map(function (relocateNode) {
                  if (isNodeLocatedInSlot(relocateNode.$nodeToRelocate$, node['s-sn'])) {
                    relocateNodeData = relocateNodes.find(function (r) {
                      return r.$nodeToRelocate$ === node;
                    });

                    if (relocateNodeData && !relocateNode.$slotRefNode$) {
                      relocateNode.$slotRefNode$ = relocateNodeData.$slotRefNode$;
                    }
                  }
                });
              }
            } else if (!relocateNodes.some(function (r) {
              return r.$nodeToRelocate$ === node;
            })) {
              // so far this element does not have a slot home, not setting slotRefNode on purpose
              // if we never find a home for this element then we'll need to hide it
              relocateNodes.push({
                $nodeToRelocate$: node
              });
            }
          }
        }
      }

      if (childNode.nodeType === 1
      /* ElementNode */
      ) {
          relocateSlotContent(childNode);
        }
    }
  };

  var isNodeLocatedInSlot = function isNodeLocatedInSlot(nodeToRelocate, slotNameAttr) {
    if (nodeToRelocate.nodeType === 1
    /* ElementNode */
    ) {
        if (nodeToRelocate.getAttribute('slot') === null && slotNameAttr === '') {
          return true;
        }

        if (nodeToRelocate.getAttribute('slot') === slotNameAttr) {
          return true;
        }

        return false;
      }

    if (nodeToRelocate['s-sn'] === slotNameAttr) {
      return true;
    }

    return slotNameAttr === '';
  };

  var renderVdom = function renderVdom(hostRef, renderFnResults) {
    var hostElm = hostRef.$hostElement$;
    var cmpMeta = hostRef.$cmpMeta$;
    var oldVNode = hostRef.$vnode$ || newVNode(null, null);
    var rootVnode = isHost(renderFnResults) ? renderFnResults : h(null, null, renderFnResults);
    hostTagName = hostElm.tagName;
    rootVnode.$tag$ = null;
    rootVnode.$flags$ |= 4
    /* isHost */
    ;
    hostRef.$vnode$ = rootVnode;
    rootVnode.$elm$ = oldVNode.$elm$ = hostElm.shadowRoot || hostElm;
    {
      scopeId = hostElm['s-sc'];
    }
    {
      contentRef = hostElm['s-cr'];
      useNativeShadowDom = supportsShadow && (cmpMeta.$flags$ & 1
      /* shadowDomEncapsulation */
      ) !== 0; // always reset

      checkSlotFallbackVisibility = false;
    } // synchronous patch

    patch(oldVNode, rootVnode);
    {
      // while we're moving nodes around existing nodes, temporarily disable
      // the disconnectCallback from working
      plt.$flags$ |= 1
      /* isTmpDisconnected */
      ;

      if (checkSlotRelocate) {
        relocateSlotContent(rootVnode.$elm$);
        var relocateData;
        var nodeToRelocate;
        var orgLocationNode;
        var parentNodeRef;
        var insertBeforeNode;
        var refNode;
        var i = 0;

        for (; i < relocateNodes.length; i++) {
          relocateData = relocateNodes[i];
          nodeToRelocate = relocateData.$nodeToRelocate$;

          if (!nodeToRelocate['s-ol']) {
            // add a reference node marking this node's original location
            // keep a reference to this node for later lookups
            orgLocationNode = doc.createTextNode('');
            orgLocationNode['s-nr'] = nodeToRelocate;
            nodeToRelocate.parentNode.insertBefore(nodeToRelocate['s-ol'] = orgLocationNode, nodeToRelocate);
          }
        }

        for (i = 0; i < relocateNodes.length; i++) {
          relocateData = relocateNodes[i];
          nodeToRelocate = relocateData.$nodeToRelocate$;

          if (relocateData.$slotRefNode$) {
            // by default we're just going to insert it directly
            // after the slot reference node
            parentNodeRef = relocateData.$slotRefNode$.parentNode;
            insertBeforeNode = relocateData.$slotRefNode$.nextSibling;
            orgLocationNode = nodeToRelocate['s-ol'];

            while (orgLocationNode = orgLocationNode.previousSibling) {
              refNode = orgLocationNode['s-nr'];

              if (refNode && refNode['s-sn'] === nodeToRelocate['s-sn'] && parentNodeRef === refNode.parentNode) {
                refNode = refNode.nextSibling;

                if (!refNode || !refNode['s-nr']) {
                  insertBeforeNode = refNode;
                  break;
                }
              }
            }

            if (!insertBeforeNode && parentNodeRef !== nodeToRelocate.parentNode || nodeToRelocate.nextSibling !== insertBeforeNode) {
              // we've checked that it's worth while to relocate
              // since that the node to relocate
              // has a different next sibling or parent relocated
              if (nodeToRelocate !== insertBeforeNode) {
                if (!nodeToRelocate['s-hn'] && nodeToRelocate['s-ol']) {
                  // probably a component in the index.html that doesn't have it's hostname set
                  nodeToRelocate['s-hn'] = nodeToRelocate['s-ol'].parentNode.nodeName;
                } // add it back to the dom but in its new home


                parentNodeRef.insertBefore(nodeToRelocate, insertBeforeNode);
              }
            }
          } else {
            // this node doesn't have a slot home to go to, so let's hide it
            if (nodeToRelocate.nodeType === 1
            /* ElementNode */
            ) {
                nodeToRelocate.hidden = true;
              }
          }
        }
      }

      if (checkSlotFallbackVisibility) {
        updateFallbackSlotVisibility(rootVnode.$elm$);
      } // done moving nodes around
      // allow the disconnect callback to work again


      plt.$flags$ &= ~1
      /* isTmpDisconnected */
      ; // always reset

      relocateNodes.length = 0;
    }
  };

  var getElement = function getElement(ref) {
    return getHostRef(ref).$hostElement$;
  };

  _exports.g = getElement;

  var createEvent = function createEvent(ref, name, flags) {
    var elm = getElement(ref);
    return {
      emit: function emit(detail) {
        return emitEvent(elm, name, {
          bubbles: !!(flags & 4
          /* Bubbles */
          ),
          composed: !!(flags & 2
          /* Composed */
          ),
          cancelable: !!(flags & 1
          /* Cancellable */
          ),
          detail: detail
        });
      }
    };
  };

  _exports.c = createEvent;

  var emitEvent = function emitEvent(elm, name, opts) {
    var ev = plt.ce(name, opts);
    elm.dispatchEvent(ev);
    return ev;
  };

  var attachToAncestor = function attachToAncestor(hostRef, ancestorComponent) {
    if (ancestorComponent && !hostRef.$onRenderResolve$ && ancestorComponent['s-p']) {
      ancestorComponent['s-p'].push(new Promise(function (r) {
        return hostRef.$onRenderResolve$ = r;
      }));
    }
  };

  var scheduleUpdate = function scheduleUpdate(hostRef, isInitialLoad) {
    {
      hostRef.$flags$ |= 16
      /* isQueuedForUpdate */
      ;
    }

    if (hostRef.$flags$ & 4
    /* isWaitingForChildren */
    ) {
        hostRef.$flags$ |= 512
        /* needsRerender */
        ;
        return;
      }

    attachToAncestor(hostRef, hostRef.$ancestorComponent$); // there is no ancestorc omponent or the ancestor component
    // has already fired off its lifecycle update then
    // fire off the initial update

    var dispatch = function dispatch() {
      return dispatchHooks(hostRef, isInitialLoad);
    };

    return writeTask(dispatch);
  };

  var dispatchHooks = function dispatchHooks(hostRef, isInitialLoad) {
    var endSchedule = createTime('scheduleUpdate', hostRef.$cmpMeta$.$tagName$);
    var instance = hostRef.$lazyInstance$;
    var promise;
    endSchedule();
    return then(promise, function () {
      return updateComponent(hostRef, instance, isInitialLoad);
    });
  };

  var updateComponent = function updateComponent(hostRef, instance, isInitialLoad) {
    // updateComponent
    var elm = hostRef.$hostElement$;
    var endUpdate = createTime('update', hostRef.$cmpMeta$.$tagName$);
    var rc = elm['s-rc'];

    if (isInitialLoad) {
      // DOM WRITE!
      attachStyles(hostRef);
    }

    var endRender = createTime('render', hostRef.$cmpMeta$.$tagName$);
    {
      {
        // looks like we've got child nodes to render into this host element
        // or we need to update the css class/attrs on the host element
        // DOM WRITE!
        renderVdom(hostRef, callRender(hostRef, instance));
      }
    }

    if (plt.$cssShim$) {
      plt.$cssShim$.updateHost(elm);
    }

    if (rc) {
      // ok, so turns out there are some child host elements
      // waiting on this parent element to load
      // let's fire off all update callbacks waiting
      rc.map(function (cb) {
        return cb();
      });
      elm['s-rc'] = undefined;
    }

    endRender();
    endUpdate();
    {
      var childrenPromises = elm['s-p'];

      var postUpdate = function postUpdate() {
        return postUpdateComponent(hostRef);
      };

      if (childrenPromises.length === 0) {
        postUpdate();
      } else {
        Promise.all(childrenPromises).then(postUpdate);
        hostRef.$flags$ |= 4
        /* isWaitingForChildren */
        ;
        childrenPromises.length = 0;
      }
    }
  };

  var callRender = function callRender(hostRef, instance) {
    try {
      instance = instance.render();
      {
        hostRef.$flags$ &= ~16
        /* isQueuedForUpdate */
        ;
      }
      {
        hostRef.$flags$ |= 2
        /* hasRendered */
        ;
      }
    } catch (e) {
      consoleError(e);
    }

    return instance;
  };

  var postUpdateComponent = function postUpdateComponent(hostRef) {
    var tagName = hostRef.$cmpMeta$.$tagName$;
    var elm = hostRef.$hostElement$;
    var endPostUpdate = createTime('postUpdate', tagName);
    var ancestorComponent = hostRef.$ancestorComponent$;

    if (!(hostRef.$flags$ & 64
    /* hasLoadedComponent */
    )) {
      hostRef.$flags$ |= 64
      /* hasLoadedComponent */
      ;
      {
        // DOM WRITE!
        addHydratedFlag(elm);
      }
      endPostUpdate();
      {
        hostRef.$onReadyResolve$(elm);

        if (!ancestorComponent) {
          appDidLoad();
        }
      }
    } else {
      endPostUpdate();
    } // load events fire from bottom to top
    // the deepest elements load first then bubbles up


    {
      if (hostRef.$onRenderResolve$) {
        hostRef.$onRenderResolve$();
        hostRef.$onRenderResolve$ = undefined;
      }

      if (hostRef.$flags$ & 512
      /* needsRerender */
      ) {
          nextTick(function () {
            return scheduleUpdate(hostRef, false);
          });
        }

      hostRef.$flags$ &= ~(4
      /* isWaitingForChildren */
      | 512
      /* needsRerender */
      );
    } // ( •_•)
    // ( •_•)>⌐■-■
    // (⌐■_■)
  };

  var _forceUpdate = function forceUpdate(ref) {
    {
      var hostRef = getHostRef(ref);
      var isConnected = hostRef.$hostElement$.isConnected;

      if (isConnected && (hostRef.$flags$ & (2
      /* hasRendered */
      | 16
      /* isQueuedForUpdate */
      )) === 2
      /* hasRendered */
      ) {
          scheduleUpdate(hostRef, false);
        } // Returns "true" when the forced update was successfully scheduled


      return isConnected;
    }
  };

  var appDidLoad = function appDidLoad(who) {
    // on appload
    // we have finish the first big initial render
    {
      addHydratedFlag(doc.documentElement);
    }
    {
      plt.$flags$ |= 2
      /* appLoaded */
      ;
    }
    nextTick(function () {
      return emitEvent(win, 'appload', {
        detail: {
          namespace: NAMESPACE
        }
      });
    });
  };

  var then = function then(promise, thenFn) {
    return promise && promise.then ? promise.then(thenFn) : thenFn();
  };

  var addHydratedFlag = function addHydratedFlag(elm) {
    return elm.classList.add('hydrated');
  };

  var parsePropertyValue = function parsePropertyValue(propValue, propType) {
    // ensure this value is of the correct prop type
    if (propValue != null && !isComplexType(propValue)) {
      if (propType & 4
      /* Boolean */
      ) {
          // per the HTML spec, any string value means it is a boolean true value
          // but we'll cheat here and say that the string "false" is the boolean false
          return propValue === 'false' ? false : propValue === '' || !!propValue;
        } // redundant return here for better minification


      return propValue;
    } // not sure exactly what type we want
    // so no need to change to a different type


    return propValue;
  };

  var getValue = function getValue(ref, propName) {
    return getHostRef(ref).$instanceValues$.get(propName);
  };

  var setValue = function setValue(ref, propName, newVal, cmpMeta) {
    // check our new property value against our internal value
    var hostRef = getHostRef(ref);
    var oldVal = hostRef.$instanceValues$.get(propName);
    var flags = hostRef.$flags$;
    var instance = hostRef.$lazyInstance$;
    newVal = parsePropertyValue(newVal, cmpMeta.$members$[propName][0]);

    if ((!(flags & 8
    /* isConstructingInstance */
    ) || oldVal === undefined) && newVal !== oldVal) {
      // gadzooks! the property's value has changed!!
      // set our new value!
      hostRef.$instanceValues$.set(propName, newVal);

      if (instance) {
        if ((flags & (2
        /* hasRendered */
        | 16
        /* isQueuedForUpdate */
        )) === 2
        /* hasRendered */
        ) {
            // looks like this value actually changed, so we've got work to do!
            // but only if we've already rendered, otherwise just chill out
            // queue that we need to do an update, but don't worry about queuing
            // up millions cuz this function ensures it only runs once
            scheduleUpdate(hostRef, false);
          }
      }
    }
  };

  var proxyComponent = function proxyComponent(Cstr, cmpMeta, flags) {
    if (cmpMeta.$members$) {
      // It's better to have a const than two Object.entries()
      var members = Object.entries(cmpMeta.$members$);
      var prototype = Cstr.prototype;
      members.map(function (_ref) {
        var _ref2 = babelHelpers.slicedToArray(_ref, 2),
            memberName = _ref2[0],
            _ref2$ = babelHelpers.slicedToArray(_ref2[1], 1),
            memberFlags = _ref2$[0];

        if (memberFlags & 31
        /* Prop */
        || flags & 2
        /* proxyState */
        && memberFlags & 32
        /* State */
        ) {
          // proxyComponent - prop
          Object.defineProperty(prototype, memberName, {
            get: function get() {
              // proxyComponent, get value
              return getValue(this, memberName);
            },
            set: function set(newValue) {
              // proxyComponent, set value
              setValue(this, memberName, newValue, cmpMeta);
            },
            configurable: true,
            enumerable: true
          });
        }
      });

      if (flags & 1
      /* isElementConstructor */
      ) {
          var attrNameToPropName = new Map();

          prototype.attributeChangedCallback = function (attrName, _oldValue, newValue) {
            var _this = this;

            plt.jmp(function () {
              var propName = attrNameToPropName.get(attrName);
              _this[propName] = newValue === null && typeof _this[propName] === 'boolean' ? false : newValue;
            });
          }; // create an array of attributes to observe
          // and also create a map of html attribute name to js property name


          Cstr.observedAttributes = members.filter(function (_ref3) {
            var _ref4 = babelHelpers.slicedToArray(_ref3, 2),
                _ = _ref4[0],
                m = _ref4[1];

            return m[0] & 15;
          }
          /* HasAttribute */
          ) // filter to only keep props that should match attributes
          .map(function (_ref5) {
            var _ref6 = babelHelpers.slicedToArray(_ref5, 2),
                propName = _ref6[0],
                m = _ref6[1];

            var attrName = m[1] || propName;
            attrNameToPropName.set(attrName, propName);
            return attrName;
          });
        }
    }

    return Cstr;
  };

  var initializeComponent = /*#__PURE__*/function () {
    var _ref7 = babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(elm, hostRef, cmpMeta, hmrVersionId, Cstr) {
      var endLoad, endNewInstance, style, _scopeId, endRegisterStyles, ancestorComponent, schedule;

      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!((hostRef.$flags$ & 32
              /* hasInitializedComponent */
              ) === 0)) {
                _context.next = 26;
                break;
              }

              // we haven't initialized this element yet
              hostRef.$flags$ |= 32
              /* hasInitializedComponent */
              ; // lazy loaded components
              // request the component's implementation to be
              // wired up with the host element

              Cstr = loadModule(cmpMeta);

              if (!Cstr.then) {
                _context.next = 9;
                break;
              }

              // Await creates a micro-task avoid if possible
              endLoad = uniqueTime();
              _context.next = 7;
              return Cstr;

            case 7:
              Cstr = _context.sent;
              endLoad();

            case 9:
              if (!Cstr.isProxied) {
                proxyComponent(Cstr, cmpMeta, 2
                /* proxyState */
                );
                Cstr.isProxied = true;
              }

              endNewInstance = createTime('createInstance', cmpMeta.$tagName$); // ok, time to construct the instance
              // but let's keep track of when we start and stop
              // so that the getters/setters don't incorrectly step on data

              hostRef.$flags$ |= 8
              /* isConstructingInstance */
              ;

              // construct the lazy-loaded component implementation
              // passing the hostRef is very important during
              // construction in order to directly wire together the
              // host element and the lazy-loaded instance
              try {
                new Cstr(hostRef);
              } catch (e) {
                consoleError(e);
              }

              hostRef.$flags$ &= ~8
              /* isConstructingInstance */
              ;
              endNewInstance();

              if (!Cstr.style) {
                _context.next = 26;
                break;
              }

              // this component has styles but we haven't registered them yet
              style = Cstr.style;
              _scopeId = getScopeId(cmpMeta);

              if (styles.has(_scopeId)) {
                _context.next = 26;
                break;
              }

              endRegisterStyles = createTime('registerStyles', cmpMeta.$tagName$);

              if (!(cmpMeta.$flags$ & 8
              /* needsShadowDomShim */
              )) {
                _context.next = 24;
                break;
              }

              _context.next = 23;
              return new Promise(function (res, rej) {
                return _require.default(['./shadow-css-c63963b5.js'], res, rej);
              }).then(function (m) {
                return m.scopeCss(style, _scopeId, false);
              });

            case 23:
              style = _context.sent;

            case 24:
              registerStyle(_scopeId, style, !!(cmpMeta.$flags$ & 1
              /* shadowDomEncapsulation */
              ));
              endRegisterStyles();

            case 26:
              // we've successfully created a lazy instance
              ancestorComponent = hostRef.$ancestorComponent$;

              schedule = function schedule() {
                return scheduleUpdate(hostRef, true);
              };

              if (ancestorComponent && ancestorComponent['s-rc']) {
                // this is the intial load and this component it has an ancestor component
                // but the ancestor component has NOT fired its will update lifecycle yet
                // so let's just cool our jets and wait for the ancestor to continue first
                // this will get fired off when the ancestor component
                // finally gets around to rendering its lazy self
                // fire off the initial update
                ancestorComponent['s-rc'].push(schedule);
              } else {
                schedule();
              }

            case 29:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function initializeComponent(_x, _x2, _x3, _x4, _x5) {
      return _ref7.apply(this, arguments);
    };
  }();

  var _connectedCallback = function connectedCallback(elm) {
    if ((plt.$flags$ & 1
    /* isTmpDisconnected */
    ) === 0) {
      var hostRef = getHostRef(elm);
      var cmpMeta = hostRef.$cmpMeta$;
      var endConnected = createTime('connectedCallback', cmpMeta.$tagName$);

      if (!(hostRef.$flags$ & 1
      /* hasConnected */
      )) {
        // first time this component has connected
        hostRef.$flags$ |= 1
        /* hasConnected */
        ;
        {
          // initUpdate
          // if the slot polyfill is required we'll need to put some nodes
          // in here to act as original content anchors as we move nodes around
          // host element has been connected to the DOM
          if (cmpMeta.$flags$ & (4
          /* hasSlotRelocation */
          | 8
          /* needsShadowDomShim */
          )) {
            setContentReference(elm);
          }
        }
        {
          // find the first ancestor component (if there is one) and register
          // this component as one of the actively loading child components for its ancestor
          var ancestorComponent = elm;

          while (ancestorComponent = ancestorComponent.parentNode || ancestorComponent.host) {
            // climb up the ancestors looking for the first
            // component that hasn't finished its lifecycle update yet
            if (ancestorComponent['s-p']) {
              // we found this components first ancestor component
              // keep a reference to this component's ancestor component
              attachToAncestor(hostRef, hostRef.$ancestorComponent$ = ancestorComponent);
              break;
            }
          }
        } // Lazy properties
        // https://developers.google.com/web/fundamentals/web-components/best-practices#lazy-properties

        if (cmpMeta.$members$) {
          Object.entries(cmpMeta.$members$).map(function (_ref8) {
            var _ref9 = babelHelpers.slicedToArray(_ref8, 2),
                memberName = _ref9[0],
                _ref9$ = babelHelpers.slicedToArray(_ref9[1], 1),
                memberFlags = _ref9$[0];

            if (memberFlags & 31
            /* Prop */
            && elm.hasOwnProperty(memberName)) {
              var value = elm[memberName];
              delete elm[memberName];
              elm[memberName] = value;
            }
          });
        }

        {
          // connectedCallback, taskQueue, initialLoad
          // angular sets attribute AFTER connectCallback
          // https://github.com/angular/angular/issues/18909
          // https://github.com/angular/angular/issues/19940
          nextTick(function () {
            return initializeComponent(elm, hostRef, cmpMeta);
          });
        }
      }

      endConnected();
    }
  };

  var setContentReference = function setContentReference(elm) {
    // only required when we're NOT using native shadow dom (slot)
    // or this browser doesn't support native shadow dom
    // and this host element was NOT created with SSR
    // let's pick out the inner content for slot projection
    // create a node to represent where the original
    // content was first placed, which is useful later on
    var contentRefElm = elm['s-cr'] = doc.createComment('');
    contentRefElm['s-cn'] = true;
    elm.insertBefore(contentRefElm, elm.firstChild);
  };

  var _disconnectedCallback = function disconnectedCallback(elm) {
    if ((plt.$flags$ & 1
    /* isTmpDisconnected */
    ) === 0) {
      var hostRef = getHostRef(elm); // clear CSS var-shim tracking

      if (plt.$cssShim$) {
        plt.$cssShim$.removeHost(elm);
      }
    }
  };

  var bootstrapLazy = function bootstrapLazy(lazyBundles) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var endBootstrap = createTime();
    var cmpTags = [];
    var exclude = options.exclude || [];
    var customElements = win.customElements;
    var head = doc.head;
    var metaCharset = /*@__PURE__*/head.querySelector('meta[charset]');
    var visibilityStyle = /*@__PURE__*/doc.createElement('style');
    var deferredConnectedCallbacks = [];
    var appLoadFallback;
    var isBootstrapping = true;
    Object.assign(plt, options);
    plt.$resourcesUrl$ = new URL(options.resourcesUrl || './', doc.baseURI).href;
    {
      if (options.syncQueue) {
        plt.$flags$ |= 4
        /* queueSync */
        ;
      }
    }
    lazyBundles.map(function (lazyBundle) {
      return lazyBundle[1].map(function (compactMeta) {
        var cmpMeta = {
          $flags$: compactMeta[0],
          $tagName$: compactMeta[1],
          $members$: compactMeta[2],
          $listeners$: compactMeta[3]
        };
        {
          cmpMeta.$members$ = compactMeta[2];
        }

        if (!supportsShadow && cmpMeta.$flags$ & 1
        /* shadowDomEncapsulation */
        ) {
            cmpMeta.$flags$ |= 8
            /* needsShadowDomShim */
            ;
          }

        var tagName = cmpMeta.$tagName$;

        var HostElement = /*#__PURE__*/function (_HTMLElement) {
          babelHelpers.inherits(HostElement, _HTMLElement);

          var _super = _createSuper(HostElement);

          // StencilLazyHost
          function HostElement(self) {
            var _this2;

            babelHelpers.classCallCheck(this, HostElement);
            // @ts-ignore
            _this2 = _super.call(this, self);
            self = babelHelpers.assertThisInitialized(_this2);
            registerHost(self, cmpMeta);

            if (cmpMeta.$flags$ & 1
            /* shadowDomEncapsulation */
            ) {
                // this component is using shadow dom
                // and this browser supports shadow dom
                // add the read-only property "shadowRoot" to the host element
                // adding the shadow root build conditionals to minimize runtime
                if (supportsShadow) {
                  {
                    self.attachShadow({
                      mode: 'open'
                    });
                  }
                } else if (!('shadowRoot' in self)) {
                  self.shadowRoot = self;
                }
              }

            return _this2;
          }

          babelHelpers.createClass(HostElement, [{
            key: "connectedCallback",
            value: function connectedCallback() {
              var _this3 = this;

              if (appLoadFallback) {
                clearTimeout(appLoadFallback);
                appLoadFallback = null;
              }

              if (isBootstrapping) {
                // connectedCallback will be processed once all components have been registered
                deferredConnectedCallbacks.push(this);
              } else {
                plt.jmp(function () {
                  return _connectedCallback(_this3);
                });
              }
            }
          }, {
            key: "disconnectedCallback",
            value: function disconnectedCallback() {
              var _this4 = this;

              plt.jmp(function () {
                return _disconnectedCallback(_this4);
              });
            }
          }, {
            key: "forceUpdate",
            value: function forceUpdate() {
              _forceUpdate(this);
            }
          }, {
            key: "componentOnReady",
            value: function componentOnReady() {
              return getHostRef(this).$onReadyPromise$;
            }
          }]);
          return HostElement;
        }( /*#__PURE__*/babelHelpers.wrapNativeSuper(HTMLElement));

        cmpMeta.$lazyBundleId$ = lazyBundle[0];

        if (!exclude.includes(tagName) && !customElements.get(tagName)) {
          cmpTags.push(tagName);
          customElements.define(tagName, proxyComponent(HostElement, cmpMeta, 1
          /* isElementConstructor */
          ));
        }
      });
    });
    {
      visibilityStyle.innerHTML = cmpTags + HYDRATED_CSS;
      visibilityStyle.setAttribute('data-styles', '');
      head.insertBefore(visibilityStyle, metaCharset ? metaCharset.nextSibling : head.firstChild);
    } // Process deferred connectedCallbacks now all components have been registered

    isBootstrapping = false;

    if (deferredConnectedCallbacks.length) {
      deferredConnectedCallbacks.map(function (host) {
        return host.connectedCallback();
      });
    } else {
      {
        plt.jmp(function () {
          return appLoadFallback = setTimeout(appDidLoad, 30);
        });
      }
    } // Fallback appLoad event


    endBootstrap();
  };

  _exports.b = bootstrapLazy;
  var hostRefs = new WeakMap();

  var getHostRef = function getHostRef(ref) {
    return hostRefs.get(ref);
  };

  var registerInstance = function registerInstance(lazyInstance, hostRef) {
    return hostRefs.set(hostRef.$lazyInstance$ = lazyInstance, hostRef);
  };

  _exports.r = registerInstance;

  var registerHost = function registerHost(elm, cmpMeta) {
    var hostRef = {
      $flags$: 0,
      $hostElement$: elm,
      $cmpMeta$: cmpMeta,
      $instanceValues$: new Map()
    };
    {
      hostRef.$onReadyPromise$ = new Promise(function (r) {
        return hostRef.$onReadyResolve$ = r;
      });
      elm['s-p'] = [];
      elm['s-rc'] = [];
    }
    return hostRefs.set(elm, hostRef);
  };

  var isMemberInElement = function isMemberInElement(elm, memberName) {
    return memberName in elm;
  };

  var consoleError = function consoleError(e) {
    return console.error(e);
  };

  var cmpModules = /*@__PURE__*/new Map();

  var loadModule = function loadModule(cmpMeta, hostRef, hmrVersionId) {
    // loadModuleImport
    var exportName = cmpMeta.$tagName$.replace(/-/g, '_');
    var bundleId = cmpMeta.$lazyBundleId$;
    var module = cmpModules.get(bundleId);

    if (module) {
      return module[exportName];
    }

    return new Promise(function (res, rej) {
      return _require.default([
      /* webpackInclude: /\.entry\.js$/ */

      /* webpackExclude: /\.system\.entry\.js$/ */

      /* webpackMode: "lazy" */
      "./".concat(bundleId, ".entry.js")], res, rej);
    }).then(function (importedModule) {
      {
        cmpModules.set(bundleId, importedModule);
      }
      return importedModule[exportName];
    }, consoleError);
  };

  var styles = new Map();
  var queueDomReads = [];
  var queueDomWrites = [];
  var queueDomWritesLow = [];

  var queueTask = function queueTask(queue, write) {
    return function (cb) {
      queue.push(cb);

      if (!queuePending) {
        queuePending = true;

        if (write && plt.$flags$ & 4
        /* queueSync */
        ) {
            nextTick(flush);
          } else {
          plt.raf(flush);
        }
      }
    };
  };

  var consume = function consume(queue) {
    for (var i = 0; i < queue.length; i++) {
      try {
        queue[i](performance.now());
      } catch (e) {
        consoleError(e);
      }
    }

    queue.length = 0;
  };

  var consumeTimeout = function consumeTimeout(queue, timeout) {
    var i = 0;
    var ts = 0;

    while (i < queue.length && (ts = performance.now()) < timeout) {
      try {
        queue[i++](ts);
      } catch (e) {
        consoleError(e);
      }
    }

    if (i === queue.length) {
      queue.length = 0;
    } else if (i !== 0) {
      queue.splice(0, i);
    }
  };

  var flush = function flush() {
    {
      queueCongestion++;
    } // always force a bunch of medium callbacks to run, but still have
    // a throttle on how many can run in a certain time
    // DOM READS!!!

    consume(queueDomReads); // DOM WRITES!!!

    {
      var timeout = (plt.$flags$ & 6
      /* queueMask */
      ) === 2
      /* appLoaded */
      ? performance.now() + 14 * Math.ceil(queueCongestion * (1.0 / 10.0)) : Infinity;
      consumeTimeout(queueDomWrites, timeout);
      consumeTimeout(queueDomWritesLow, timeout);

      if (queueDomWrites.length > 0) {
        queueDomWritesLow.push.apply(queueDomWritesLow, queueDomWrites);
        queueDomWrites.length = 0;
      }

      if (queuePending = queueDomReads.length + queueDomWrites.length + queueDomWritesLow.length > 0) {
        // still more to do yet, but we've run out of time
        // let's let this thing cool off and try again in the next tick
        plt.raf(flush);
      } else {
        queueCongestion = 0;
      }
    }
  };

  var nextTick = /*@__PURE__*/function nextTick(cb) {
    return promiseResolve().then(cb);
  };

  var writeTask = /*@__PURE__*/queueTask(queueDomWrites, true);
});