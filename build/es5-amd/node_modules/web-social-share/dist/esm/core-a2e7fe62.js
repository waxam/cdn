define(["exports","require"],function(_exports,_require){"use strict";Object.defineProperty(_exports,"__esModule",{value:!0});_exports.r=_exports.p=_exports.h=_exports.g=_exports.c=_exports.b=_exports.a=void 0;_require=babelHelpers.interopRequireWildcard(_require);var NAMESPACE="websocialshare",queueCongestion=0,queuePending=!1,scopeId,contentRef,hostTagName,useNativeShadowDom=!1,checkSlotFallbackVisibility=!1,checkSlotRelocate=!1,isSvgMode=!1,win="undefined"!==typeof window?window:{},doc=win.document||{head:{}},plt={$flags$:0,$resourcesUrl$:"",jmp:function jmp(h){return h()},raf:function raf(h){return requestAnimationFrame(h)},ael:function ael(el,eventName,listener,opts){return el.addEventListener(eventName,listener,opts)},rel:function rel(el,eventName,listener,opts){return el.removeEventListener(eventName,listener,opts)}},supportsShadowDom=/*@__PURE__*/function(){return-1<(doc.head.attachShadow+"").indexOf("[native")}(),supportsConstructibleStylesheets=/*@__PURE__*/function(){try{new CSSStyleSheet;return!0}catch(e){}return!1}(),hostRefs=new WeakMap,getHostRef=function getHostRef(ref){return hostRefs.get(ref)},registerInstance=function registerInstance(lazyInstance,hostRef){return hostRefs.set(hostRef.$lazyInstance$=lazyInstance,hostRef)};_exports.r=registerInstance;var registerHost=function registerHost(elm){var hostRef={$flags$:0,$hostElement$:elm,$instanceValues$:new Map};{hostRef.$onReadyPromise$=new Promise(function(r){return hostRef.$onReadyResolve$=r});elm["s-p"]=[];elm["s-rc"]=[]}return hostRefs.set(elm,hostRef)},isMemberInElement=function isMemberInElement(elm,memberName){return memberName in elm},consoleError=function consoleError(e){return console.error(e)},moduleCache=/*@__PURE__*/new Map,loadModule=function loadModule(cmpMeta,hostRef,hmrVersionId){// loadModuleImport
var exportName=cmpMeta.$tagName$.replace(/-/g,"_"),bundleId=cmpMeta.$lazyBundleIds$,module=moduleCache.get(bundleId);if(module){return module[exportName]}return new Promise(function(res,rej){return _require.default([/* webpackInclude: /\.entry\.js$/ */ /* webpackExclude: /\.system\.entry\.js$/ */ /* webpackMode: "lazy" */"./".concat(bundleId,".entry.js")],res,rej)}).then(function(importedModule){{moduleCache.set(bundleId,importedModule)}return importedModule[exportName]},consoleError)},styles=new Map,queueDomReads=[],queueDomWrites=[],queueDomWritesLow=[],queueTask=function queueTask(queue,write){return function(cb){queue.push(cb);if(!queuePending){queuePending=!0;if(write&&4&plt.$flags$/* queueSync */){nextTick(flush)}else{plt.raf(flush)}}}},consume=function consume(queue){for(var i=0;i<queue.length;i++){try{queue[i](performance.now())}catch(e){consoleError(e)}}queue.length=0},consumeTimeout=function consumeTimeout(queue,timeout){var i=0,ts=0;while(i<queue.length&&(ts=performance.now())<timeout){try{queue[i++](ts)}catch(e){consoleError(e)}}if(i===queue.length){queue.length=0}else if(0!==i){queue.splice(0,i)}},flush=function flush(){queueCongestion++;// always force a bunch of medium callbacks to run, but still have
// a throttle on how many can run in a certain time
// DOM READS!!!
consume(queueDomReads);var timeout=/* queueMask */2===(6&plt.$flags$)/* appLoaded */?performance.now()+10*Math.ceil(queueCongestion*(1/22)):1/0;// DOM WRITES!!!
consumeTimeout(queueDomWrites,timeout);consumeTimeout(queueDomWritesLow,timeout);if(0<queueDomWrites.length){queueDomWritesLow.push.apply(queueDomWritesLow,queueDomWrites);queueDomWrites.length=0}if(queuePending=0<queueDomReads.length+queueDomWrites.length+queueDomWritesLow.length){// still more to do yet, but we've run out of time
// let's let this thing cool off and try again in the next tick
plt.raf(flush)}else{queueCongestion=0}},nextTick=/*@__PURE__*/function nextTick(cb){return Promise.resolve().then(cb)},writeTask=/*@__PURE__*/queueTask(queueDomWrites,!0),EMPTY_OBJ={},isDef=function isDef(v){return null!=v},isComplexType=function isComplexType(o){// https://jsperf.com/typeof-fn-object/5
o=babelHelpers.typeof(o);return"object"===o||"function"===o},getDynamicImportFunction=function getDynamicImportFunction(namespace){return"__sc_import_".concat(namespace.replace(/\s|-/g,"_"))},patchEsm=function patchEsm(){// @ts-ignore
if(!(win.CSS&&win.CSS.supports&&win.CSS.supports("color","var(--c)"))){// @ts-ignore
return new Promise(function(res,rej){return _require.default(["./css-shim-6aaf713d-9b13816a.js"],res,rej)}).then(function(){plt.$cssShim$=win.__stencil_cssshim;if(plt.$cssShim$){return plt.$cssShim$.initShim()}})}return Promise.resolve()};_exports.a=patchEsm;var patchBrowser=function patchBrowser(){{// shim css vars
plt.$cssShim$=win.__stencil_cssshim}// @ts-ignore
var scriptElm=Array.from(doc.querySelectorAll("script")).find(function(s){return /\/websocialshare(\.esm)?\.js($|\?|#)/.test(s.src)||s.getAttribute("data-stencil-namespace")===NAMESPACE}),opts=scriptElm["data-opts"]||{},importMeta="";if("onbeforeload"in scriptElm&&!history.scrollRestoration/* IS_ESM_BUILD */){// Safari < v11 support: This IF is true if it's Safari below v11.
// This fn cannot use async/await since Safari didn't support it until v11,
// however, Safari 10 did support modules. Safari 10 also didn't support "nomodule",
// so both the ESM file and nomodule file would get downloaded. Only Safari
// has 'onbeforeload' in the script, and "history.scrollRestoration" was added
// to Safari in v11. Return a noop then() so the async/await ESM code doesn't continue.
// IS_ESM_BUILD is replaced at build time so this check doesn't happen in systemjs builds.
return{then:function then(){}}}if(""!==importMeta){opts.resourcesUrl=new URL(".",importMeta).href}else{opts.resourcesUrl=new URL(".",new URL(scriptElm.getAttribute("data-resources-url")||scriptElm.src,win.location.href)).href;patchDynamicImport(opts.resourcesUrl,scriptElm);if(!window.customElements){// module support, but no custom elements support (Old Edge)
// @ts-ignore
return new Promise(function(res,rej){return _require.default(["./dom-76cc7c7d-0a082895.js"],res,rej)}).then(function(){return opts})}}return Promise.resolve(opts)};_exports.p=patchBrowser;var patchDynamicImport=function patchDynamicImport(base,orgScriptElm){var importFunctionName=getDynamicImportFunction(NAMESPACE);try{// test if this browser supports dynamic imports
// There is a caching issue in V8, that breaks using import() in Function
// By generating a random string, we can workaround it
// Check https://bugs.chromium.org/p/v8/issues/detail?id=9558 for more info
win[importFunctionName]=new Function("w","return import(w);//".concat(Math.random()))}catch(e){// this shim is specifically for browsers that do support "esm" imports
// however, they do NOT support "dynamic" imports
// basically this code is for old Edge, v18 and below
var moduleMap=new Map;win[importFunctionName]=function(src){var url=new URL(src,base).href,mod=moduleMap.get(url);if(!mod){var script=doc.createElement("script");script.type="module";script.crossOrigin=orgScriptElm.crossOrigin;script.src=URL.createObjectURL(new Blob(["import * as m from '".concat(url,"'; window.").concat(importFunctionName,".m = m;")],{type:"application/javascript"}));mod=new Promise(function(resolve){script.onload=function(){resolve(win[importFunctionName].m);script.remove()}});moduleMap.set(url,mod);doc.head.appendChild(script)}return mod}}},parsePropertyValue=function parsePropertyValue(propValue,propType){// ensure this value is of the correct prop type
if(null!=propValue&&!isComplexType(propValue)){if(4&propType/* Boolean */){// per the HTML spec, any string value means it is a boolean true value
// but we'll cheat here and say that the string "false" is the boolean false
return"false"===propValue?!1:""===propValue||!!propValue}// redundant return here for better minification
return propValue}// not sure exactly what type we want
// so no need to change to a different type
return propValue},HYDRATED_CLASS="hydrated",createTime=function createTime(fnName){var tagName=1<arguments.length&&arguments[1]!==void 0?arguments[1]:"";{return function(){return}}},uniqueTime=function uniqueTime(key,measureText){{return function(){return}}},rootAppliedStyles=new WeakMap,registerStyle=function registerStyle(scopeId,cssText,allowCS){var style=styles.get(scopeId);if(supportsConstructibleStylesheets&&allowCS){style=style||new CSSStyleSheet;style.replace(cssText)}else{style=cssText}styles.set(scopeId,style)},addStyle=function addStyle(styleContainerNode,cmpMeta,mode,hostElm){var scopeId=getScopeId(cmpMeta.$tagName$),style=styles.get(scopeId);// if an element is NOT connected then getRootNode() will return the wrong root node
// so the fallback is to always use the document for the root node in those cases
styleContainerNode=11===styleContainerNode.nodeType/* DocumentFragment */?styleContainerNode:doc;if(style){if("string"===typeof style){styleContainerNode=styleContainerNode.head||styleContainerNode;var appliedStyles=rootAppliedStyles.get(styleContainerNode),styleElm;if(!appliedStyles){rootAppliedStyles.set(styleContainerNode,appliedStyles=new Set)}if(!appliedStyles.has(scopeId)){{if(plt.$cssShim$){styleElm=plt.$cssShim$.createHostStyle(hostElm,scopeId,style,!!(10&cmpMeta.$flags$/* needsScopedEncapsulation */));var newScopeId=styleElm["s-sc"];if(newScopeId){scopeId=newScopeId;// we don't want to add this styleID to the appliedStyles Set
// since the cssVarShim might need to apply several different
// stylesheets for the same component
appliedStyles=null}}else{styleElm=doc.createElement("style");styleElm.innerHTML=style}styleContainerNode.insertBefore(styleElm,styleContainerNode.querySelector("link"))}if(appliedStyles){appliedStyles.add(scopeId)}}}else if(!styleContainerNode.adoptedStyleSheets.includes(style)){styleContainerNode.adoptedStyleSheets=[].concat(babelHelpers.toConsumableArray(styleContainerNode.adoptedStyleSheets),[style])}}return scopeId},attachStyles=function attachStyles(elm,cmpMeta,mode){var endAttachStyles=createTime("attachStyles",cmpMeta.$tagName$),scopeId=addStyle(supportsShadowDom&&elm.shadowRoot?elm.shadowRoot:elm.getRootNode(),cmpMeta,mode,elm);if(10&cmpMeta.$flags$/* needsScopedEncapsulation */){// only required when we're NOT using native shadow dom (slot)
// or this browser doesn't support native shadow dom
// and this host element was NOT created with SSR
// let's pick out the inner content for slot projection
// create a node to represent where the original
// content was first placed, which is useful later on
// DOM WRITE!!
elm["s-sc"]=scopeId;elm.classList.add(scopeId+"-h")}endAttachStyles()},getScopeId=function getScopeId(tagName,mode){return"sc-"+tagName},h=function h(nodeName,vnodeData){for(var child=null,slotName=null,simple=!1,lastSimple=!1,vNodeChildren=[],walk=function walk(c){for(var i=0;i<c.length;i++){child=c[i];if(Array.isArray(child)){walk(child)}else if(null!=child&&"boolean"!==typeof child){if(simple="function"!==typeof nodeName&&!isComplexType(child)){child=child+""}if(simple&&lastSimple){// If the previous child was simple (string), we merge both
vNodeChildren[vNodeChildren.length-1].$text$+=child}else{// Append a new vNode, if it's text, we create a text vNode
vNodeChildren.push(simple?newVNode(null,child):child)}lastSimple=simple}}},_len=arguments.length,children=Array(2<_len?_len-2:0),_key=2;_key<_len;_key++){children[_key-2]=arguments[_key]}walk(children);if(vnodeData){if(vnodeData.name){slotName=vnodeData.name}{var classData=vnodeData.className||vnodeData.class;if(classData){vnodeData.class="object"!==babelHelpers.typeof(classData)?classData:Object.keys(classData).filter(function(k){return classData[k]}).join(" ")}}}var vnode=newVNode(nodeName,null);vnode.$attrs$=vnodeData;if(0<vNodeChildren.length){vnode.$children$=vNodeChildren}{vnode.$name$=slotName}return vnode};_exports.h=h;var newVNode=function newVNode(tag,text){var vnode={$flags$:0,$tag$:tag,$text$:text,$elm$:null,$children$:null};{vnode.$attrs$=null}{vnode.$name$=null}return vnode},Host={},isHost=function isHost(node){return node&&node.$tag$===Host},setAccessor=function setAccessor(elm,memberName,oldValue,newValue,isSvg,flags){if(oldValue===newValue){return}var isProp=isMemberInElement(elm,memberName),ln=memberName.toLowerCase();if("class"===memberName){var classList=elm.classList,oldClasses=parseClassList(oldValue),newClasses=parseClassList(newValue);classList.remove.apply(classList,babelHelpers.toConsumableArray(oldClasses.filter(function(c){return c&&!newClasses.includes(c)})));classList.add.apply(classList,babelHelpers.toConsumableArray(newClasses.filter(function(c){return c&&!oldClasses.includes(c)})))}else if(!isProp&&"o"===memberName[0]&&"n"===memberName[1]){// Event Handlers
// so if the member name starts with "on" and the 3rd characters is
// a capital letter, and it's not already a member on the element,
// then we're assuming it's an event listener
if("-"===memberName[2]){// on- prefixed events
// allows to be explicit about the dom event to listen without any magic
// under the hood:
// <my-cmp on-click> // listens for "click"
// <my-cmp on-Click> // listens for "Click"
// <my-cmp on-ionChange> // listens for "ionChange"
// <my-cmp on-EVENTS> // listens for "EVENTS"
memberName=memberName.slice(3)}else if(isMemberInElement(win,ln)){// standard event
// the JSX attribute could have been "onMouseOver" and the
// member name "onmouseover" is on the window's prototype
// so let's add the listener "mouseover", which is all lowercased
memberName=ln.slice(2)}else{// custom event
// the JSX attribute could have been "onMyCustomEvent"
// so let's trim off the "on" prefix and lowercase the first character
// and add the listener "myCustomEvent"
// except for the first character, we keep the event name case
memberName=ln[2]+memberName.slice(3)}if(oldValue){plt.rel(elm,memberName,oldValue,!1)}if(newValue){plt.ael(elm,memberName,newValue,!1)}}else{// Set property if it exists and it's not a SVG
var isComplex=isComplexType(newValue);if((isProp||isComplex&&null!==newValue)&&!isSvg){try{if(!elm.tagName.includes("-")){var n=null==newValue?"":newValue;// Workaround for Safari, moving the <input> caret when re-assigning the same valued
if("list"===memberName){isProp=!1;// tslint:disable-next-line: triple-equals
}else if(null==oldValue||elm[memberName]!=n){elm[memberName]=n}}else{elm[memberName]=newValue}}catch(e){}}if(null==newValue||!1===newValue){{elm.removeAttribute(memberName)}}else if((!isProp||4&flags/* isHost */||isSvg)&&!isComplex){newValue=!0===newValue?"":newValue;{elm.setAttribute(memberName,newValue)}}}},parseClassListRegex=/\s/,parseClassList=function parseClassList(value){return!value?[]:value.split(parseClassListRegex)},updateElement=function updateElement(oldVnode,newVnode,isSvgMode,memberName){// if the element passed in is a shadow root, which is a document fragment
// then we want to be adding attrs/props to the shadow root's "host" element
// if it's not a shadow root, then we add attrs/props to the same element
var elm=11===newVnode.$elm$.nodeType/* DocumentFragment */&&newVnode.$elm$.host?newVnode.$elm$.host:newVnode.$elm$,oldVnodeAttrs=oldVnode&&oldVnode.$attrs$||EMPTY_OBJ,newVnodeAttrs=newVnode.$attrs$||EMPTY_OBJ;{// remove attributes no longer present on the vnode by setting them to undefined
for(memberName in oldVnodeAttrs){if(!(memberName in newVnodeAttrs)){setAccessor(elm,memberName,oldVnodeAttrs[memberName],void 0,isSvgMode,newVnode.$flags$)}}}// add new & update changed attributes
for(memberName in newVnodeAttrs){setAccessor(elm,memberName,oldVnodeAttrs[memberName],newVnodeAttrs[memberName],isSvgMode,newVnode.$flags$)}},createElm=function createElm(oldParentVNode,newParentVNode,childIndex,parentElm){// tslint:disable-next-line: prefer-const
var newVNode=newParentVNode.$children$[childIndex],i=0,elm,childNode,oldVNode;if(!useNativeShadowDom){// remember for later we need to check to relocate nodes
checkSlotRelocate=!0;if("slot"===newVNode.$tag$){if(scopeId){// scoped css needs to add its scoped id to the parent element
parentElm.classList.add(scopeId+"-s")}newVNode.$flags$|=newVNode.$children$?// slot element has fallback content
// still create an element that "mocks" the slot element
2/* isSlotFallback */ // slot element does not have fallback content
// create an html comment we'll use to always reference
// where actual slot content should sit next to
:1/* isSlotReference */}}if(null!==newVNode.$text$){// create text node
elm=newVNode.$elm$=doc.createTextNode(newVNode.$text$)}else if(1&newVNode.$flags$/* isSlotReference */){// create a slot reference node
elm=newVNode.$elm$=doc.createTextNode("")}else{// create element
elm=newVNode.$elm$=doc.createElement(2&newVNode.$flags$/* isSlotFallback */?"slot-fb":newVNode.$tag$);// add css classes, attrs, props, listeners, etc.
{updateElement(null,newVNode,isSvgMode)}if(isDef(scopeId)&&elm["s-si"]!==scopeId){// if there is a scopeId and this is the initial render
// then let's add the scopeId as a css class
elm.classList.add(elm["s-si"]=scopeId)}if(newVNode.$children$){for(i=0;i<newVNode.$children$.length;++i){// create the node
childNode=createElm(oldParentVNode,newVNode,i,elm);// return node could have been null
if(childNode){// append our new node
elm.appendChild(childNode)}}}}{elm["s-hn"]=hostTagName;if(newVNode.$flags$&(/* isSlotFallback */1|2/* isSlotReference */)){// remember the content reference comment
elm["s-sr"]=!0;// remember the content reference comment
elm["s-cr"]=contentRef;// remember the slot name, or empty string for default slot
elm["s-sn"]=newVNode.$name$||"";// check if we've got an old vnode for this slot
oldVNode=oldParentVNode&&oldParentVNode.$children$&&oldParentVNode.$children$[childIndex];if(oldVNode&&oldVNode.$tag$===newVNode.$tag$&&oldParentVNode.$elm$){// we've got an old slot vnode and the wrapper is being replaced
// so let's move the old slot content back to it's original location
putBackInOriginalLocation(oldParentVNode.$elm$,!1)}}}return elm},putBackInOriginalLocation=function putBackInOriginalLocation(parentElm,recursive){plt.$flags$|=1/* isTmpDisconnected */;for(var oldSlotChildNodes=parentElm.childNodes,i=oldSlotChildNodes.length-1,childNode;0<=i;i--){childNode=oldSlotChildNodes[i];if(childNode["s-hn"]!==hostTagName&&childNode["s-ol"]){// // this child node in the old element is from another component
// // remove this node from the old slot's parent
// childNode.remove();
// and relocate it back to it's original location
parentReferenceNode(childNode).insertBefore(childNode,referenceNode(childNode));// remove the old original location comment entirely
// later on the patch function will know what to do
// and move this to the correct spot in need be
childNode["s-ol"].remove();childNode["s-ol"]=void 0;checkSlotRelocate=!0}if(recursive){putBackInOriginalLocation(childNode,recursive)}}plt.$flags$&=~1/* isTmpDisconnected */},addVnodes=function addVnodes(parentElm,before,parentVNode,vnodes,startIdx,endIdx){var containerElm=parentElm["s-cr"]&&parentElm["s-cr"].parentNode||parentElm,childNode;if(containerElm.shadowRoot&&containerElm.tagName===hostTagName){containerElm=containerElm.shadowRoot}for(;startIdx<=endIdx;++startIdx){if(vnodes[startIdx]){childNode=createElm(null,parentVNode,startIdx,parentElm);if(childNode){vnodes[startIdx].$elm$=childNode;containerElm.insertBefore(childNode,referenceNode(before))}}}},removeVnodes=function removeVnodes(vnodes,startIdx,endIdx,vnode,elm){for(;startIdx<=endIdx;++startIdx){if(vnode=vnodes[startIdx]){elm=vnode.$elm$;{// we're removing this element
// so it's possible we need to show slot fallback content now
checkSlotFallbackVisibility=!0;if(elm["s-ol"]){// remove the original location comment
elm["s-ol"].remove()}else{// it's possible that child nodes of the node
// that's being removed are slot nodes
putBackInOriginalLocation(elm,!0)}}// remove the vnode's element from the dom
elm.remove()}}},updateChildren=function updateChildren(parentElm,oldCh,newVNode,newCh){var oldStartIdx=0,newStartIdx=0,oldEndIdx=oldCh.length-1,oldStartVnode=oldCh[0],oldEndVnode=oldCh[oldEndIdx],newEndIdx=newCh.length-1,newStartVnode=newCh[0],newEndVnode=newCh[newEndIdx],node;while(oldStartIdx<=oldEndIdx&&newStartIdx<=newEndIdx){if(null==oldStartVnode){// Vnode might have been moved left
oldStartVnode=oldCh[++oldStartIdx]}else if(null==oldEndVnode){oldEndVnode=oldCh[--oldEndIdx]}else if(null==newStartVnode){newStartVnode=newCh[++newStartIdx]}else if(null==newEndVnode){newEndVnode=newCh[--newEndIdx]}else if(isSameVnode(oldStartVnode,newStartVnode)){patch(oldStartVnode,newStartVnode);oldStartVnode=oldCh[++oldStartIdx];newStartVnode=newCh[++newStartIdx]}else if(isSameVnode(oldEndVnode,newEndVnode)){patch(oldEndVnode,newEndVnode);oldEndVnode=oldCh[--oldEndIdx];newEndVnode=newCh[--newEndIdx]}else if(isSameVnode(oldStartVnode,newEndVnode)){// Vnode moved right
if("slot"===oldStartVnode.$tag$||"slot"===newEndVnode.$tag$){putBackInOriginalLocation(oldStartVnode.$elm$.parentNode,!1)}patch(oldStartVnode,newEndVnode);parentElm.insertBefore(oldStartVnode.$elm$,oldEndVnode.$elm$.nextSibling);oldStartVnode=oldCh[++oldStartIdx];newEndVnode=newCh[--newEndIdx]}else if(isSameVnode(oldEndVnode,newStartVnode)){// Vnode moved left
if("slot"===oldStartVnode.$tag$||"slot"===newEndVnode.$tag$){putBackInOriginalLocation(oldEndVnode.$elm$.parentNode,!1)}patch(oldEndVnode,newStartVnode);parentElm.insertBefore(oldEndVnode.$elm$,oldStartVnode.$elm$);oldEndVnode=oldCh[--oldEndIdx];newStartVnode=newCh[++newStartIdx]}else{{// new element
node=createElm(oldCh&&oldCh[newStartIdx],newVNode,newStartIdx,parentElm);newStartVnode=newCh[++newStartIdx]}if(node){{parentReferenceNode(oldStartVnode.$elm$).insertBefore(node,referenceNode(oldStartVnode.$elm$))}}}}if(oldStartIdx>oldEndIdx){addVnodes(parentElm,null==newCh[newEndIdx+1]?null:newCh[newEndIdx+1].$elm$,newVNode,newCh,newStartIdx,newEndIdx)}else if(newStartIdx>newEndIdx){removeVnodes(oldCh,oldStartIdx,oldEndIdx)}},isSameVnode=function isSameVnode(vnode1,vnode2){// compare if two vnode to see if they're "technically" the same
// need to have the same element tag, and same key to be the same
if(vnode1.$tag$===vnode2.$tag$){if("slot"===vnode1.$tag$){return vnode1.$name$===vnode2.$name$}return!0}return!1},referenceNode=function referenceNode(node){// this node was relocated to a new location in the dom
// because of some other component's slot
// but we still have an html comment in place of where
// it's original location was according to it's original vdom
return node&&node["s-ol"]||node},parentReferenceNode=function parentReferenceNode(node){return(node["s-ol"]?node["s-ol"]:node).parentNode},patch=function patch(oldVNode,newVNode){var elm=newVNode.$elm$=oldVNode.$elm$,oldChildren=oldVNode.$children$,newChildren=newVNode.$children$,tag=newVNode.$tag$,text=newVNode.$text$,defaultHolder;if(null===text){// element node
{if("slot"===tag);else{// either this is the first render of an element OR it's an update
// AND we already know it's possible it could have changed
// this updates the element's css classes, attrs, props, listeners, etc.
updateElement(oldVNode,newVNode,isSvgMode)}}if(null!==oldChildren&&null!==newChildren){// looks like there's child vnodes for both the old and new vnodes
updateChildren(elm,oldChildren,newVNode,newChildren)}else if(null!==newChildren){// no old child vnodes, but there are new child vnodes to add
if(null!==oldVNode.$text$){// the old vnode was text, so be sure to clear it out
elm.textContent=""}// add the new vnode children
addVnodes(elm,null,newVNode,newChildren,0,newChildren.length-1)}else if(null!==oldChildren){// no new child vnodes, but there are old child vnodes to remove
removeVnodes(oldChildren,0,oldChildren.length-1)}}else if(defaultHolder=elm["s-cr"]){// this element has slotted content
defaultHolder.parentNode.textContent=text}else if(oldVNode.$text$!==text){// update the text content for the text only vnode
// and also only if the text is different than before
elm.data=text}},updateFallbackSlotVisibility=function updateFallbackSlotVisibility(elm){// tslint:disable-next-line: prefer-const
var childNodes=elm.childNodes,childNode,i,ilen,j,slotNameAttr,nodeType;for(i=0,ilen=childNodes.length;i<ilen;i++){childNode=childNodes[i];if(1===childNode.nodeType/* ElementNode */){if(childNode["s-sr"]){// this is a slot fallback node
// get the slot name for this slot reference node
slotNameAttr=childNode["s-sn"];// by default always show a fallback slot node
// then hide it if there are other slots in the light dom
childNode.hidden=!1;for(j=0;j<ilen;j++){if(childNodes[j]["s-hn"]!==childNode["s-hn"]){// this sibling node is from a different component
nodeType=childNodes[j].nodeType;if(""!==slotNameAttr){// this is a named fallback slot node
if(1===nodeType/* ElementNode */&&slotNameAttr===childNodes[j].getAttribute("slot")){childNode.hidden=!0;break}}else{// this is a default fallback slot node
// any element or text node (with content)
// should hide the default fallback slot node
if(1===nodeType/* ElementNode */||3===nodeType/* TextNode */&&""!==childNodes[j].textContent.trim()){childNode.hidden=!0;break}}}}}// keep drilling down
updateFallbackSlotVisibility(childNode)}}},relocateNodes=[],relocateSlotContent=function relocateSlotContent(elm){// tslint:disable-next-line: prefer-const
var childNode,node,hostContentNodes,slotNameAttr,relocateNodeData,j,i=0,childNodes=elm.childNodes,ilen=childNodes.length;for(;i<ilen;i++){childNode=childNodes[i];if(childNode["s-sr"]&&(node=childNode["s-cr"])){// first got the content reference comment node
// then we got it's parent, which is where all the host content is in now
hostContentNodes=node.parentNode.childNodes;slotNameAttr=childNode["s-sn"];for(j=hostContentNodes.length-1;0<=j;j--){node=hostContentNodes[j];if(!node["s-cn"]&&!node["s-nr"]&&node["s-hn"]!==childNode["s-hn"]){// let's do some relocating to its new home
// but never relocate a content reference node
// that is suppose to always represent the original content location
if(isNodeLocatedInSlot(node,slotNameAttr)){// it's possible we've already decided to relocate this node
relocateNodeData=relocateNodes.find(function(r){return r.$nodeToRelocate$===node});// made some changes to slots
// let's make sure we also double check
// fallbacks are correctly hidden or shown
checkSlotFallbackVisibility=!0;node["s-sn"]=node["s-sn"]||slotNameAttr;if(relocateNodeData){// previously we never found a slot home for this node
// but turns out we did, so let's remember it now
relocateNodeData.$slotRefNode$=childNode}else{// add to our list of nodes to relocate
relocateNodes.push({$slotRefNode$:childNode,$nodeToRelocate$:node})}if(node["s-sr"]){relocateNodes.forEach(function(relocateNode){if(isNodeLocatedInSlot(relocateNode.$nodeToRelocate$,node["s-sn"])){relocateNodeData=relocateNodes.find(function(r){return r.$nodeToRelocate$===node});if(relocateNodeData){relocateNode.$slotRefNode$=relocateNodeData.$slotRefNode$}}})}}else if(!relocateNodes.some(function(r){return r.$nodeToRelocate$===node})){// so far this element does not have a slot home, not setting slotRefNode on purpose
// if we never find a home for this element then we'll need to hide it
relocateNodes.push({$nodeToRelocate$:node})}}}}if(1===childNode.nodeType/* ElementNode */){relocateSlotContent(childNode)}}},isNodeLocatedInSlot=function isNodeLocatedInSlot(nodeToRelocate,slotNameAttr){if(1===nodeToRelocate.nodeType/* ElementNode */){if(null===nodeToRelocate.getAttribute("slot")&&""===slotNameAttr){return!0}if(nodeToRelocate.getAttribute("slot")===slotNameAttr){return!0}return!1}if(nodeToRelocate["s-sn"]===slotNameAttr){return!0}return""===slotNameAttr},renderVdom=function renderVdom(hostElm,hostRef,cmpMeta,renderFnResults){hostTagName=hostElm.tagName;var oldVNode=hostRef.$vnode$||newVNode(null,null),rootVnode=isHost(renderFnResults)?renderFnResults:h(null,null,renderFnResults);rootVnode.$tag$=null;rootVnode.$flags$|=4/* isHost */;hostRef.$vnode$=rootVnode;rootVnode.$elm$=oldVNode.$elm$=hostElm.shadowRoot||hostElm;{scopeId=hostElm["s-sc"]}{contentRef=hostElm["s-cr"];useNativeShadowDom=supportsShadowDom&&/* shadowDomEncapsulation */0!==(1&cmpMeta.$flags$);// always reset
checkSlotFallbackVisibility=!1}// synchronous patch
patch(oldVNode,rootVnode);{if(checkSlotRelocate){relocateSlotContent(rootVnode.$elm$);var relocateData,nodeToRelocate,orgLocationNode,parentNodeRef,insertBeforeNode,refNode,i=0;for(;i<relocateNodes.length;i++){relocateData=relocateNodes[i];nodeToRelocate=relocateData.$nodeToRelocate$;if(!nodeToRelocate["s-ol"]){// add a reference node marking this node's original location
// keep a reference to this node for later lookups
orgLocationNode=doc.createTextNode("");orgLocationNode["s-nr"]=nodeToRelocate;nodeToRelocate.parentNode.insertBefore(nodeToRelocate["s-ol"]=orgLocationNode,nodeToRelocate)}}// while we're moving nodes around existing nodes, temporarily disable
// the disconnectCallback from working
plt.$flags$|=1/* isTmpDisconnected */;for(i=0;i<relocateNodes.length;i++){relocateData=relocateNodes[i];nodeToRelocate=relocateData.$nodeToRelocate$;if(relocateData.$slotRefNode$){// by default we're just going to insert it directly
// after the slot reference node
parentNodeRef=relocateData.$slotRefNode$.parentNode;insertBeforeNode=relocateData.$slotRefNode$.nextSibling;orgLocationNode=nodeToRelocate["s-ol"];while(orgLocationNode=orgLocationNode.previousSibling){refNode=orgLocationNode["s-nr"];if(refNode&&refNode["s-sn"]===nodeToRelocate["s-sn"]&&parentNodeRef===refNode.parentNode){refNode=refNode.nextSibling;if(!refNode||!refNode["s-nr"]){insertBeforeNode=refNode;break}}}if(!insertBeforeNode&&parentNodeRef!==nodeToRelocate.parentNode||nodeToRelocate.nextSibling!==insertBeforeNode){// we've checked that it's worth while to relocate
// since that the node to relocate
// has a different next sibling or parent relocated
if(nodeToRelocate!==insertBeforeNode){if(!nodeToRelocate["s-hn"]&&nodeToRelocate["s-ol"]){// probably a component in the index.html that doesn't have it's hostname set
nodeToRelocate["s-hn"]=nodeToRelocate["s-ol"].parentNode.nodeName}// add it back to the dom but in its new home
parentNodeRef.insertBefore(nodeToRelocate,insertBeforeNode)}}}else{// this node doesn't have a slot home to go to, so let's hide it
if(1===nodeToRelocate.nodeType/* ElementNode */){nodeToRelocate.hidden=!0}}}// done moving nodes around
// allow the disconnect callback to work again
plt.$flags$&=~1/* isTmpDisconnected */}if(checkSlotFallbackVisibility){updateFallbackSlotVisibility(rootVnode.$elm$)}// always reset
relocateNodes.length=0}},attachToAncestor=function attachToAncestor(hostRef,ancestorComponent){if(ancestorComponent&&!hostRef.$onRenderResolve$){ancestorComponent["s-p"].push(new Promise(function(r){return hostRef.$onRenderResolve$=r}))}},scheduleUpdate=function scheduleUpdate(elm,hostRef,cmpMeta,isInitialLoad){{hostRef.$flags$|=16/* isQueuedForUpdate */}if(4&hostRef.$flags$/* isWaitingForChildren */){hostRef.$flags$|=512/* needsRerender */;return}var endSchedule=createTime("scheduleUpdate",cmpMeta.$tagName$),ancestorComponent=hostRef.$ancestorComponent$,instance=hostRef.$lazyInstance$,update=function update(){return updateComponent(elm,hostRef,cmpMeta,instance,isInitialLoad)};attachToAncestor(hostRef,ancestorComponent);var promise;endSchedule();// there is no ancestorc omponent or the ancestor component
// has already fired off its lifecycle update then
// fire off the initial update
return then(promise,function(){return writeTask(update)})},updateComponent=function updateComponent(elm,hostRef,cmpMeta,instance,isInitialLoad){// updateComponent
var endUpdate=createTime("update",cmpMeta.$tagName$),rc=elm["s-rc"];if(isInitialLoad){// DOM WRITE!
attachStyles(elm,cmpMeta,hostRef.$modeName$)}var endRender=createTime("render",cmpMeta.$tagName$);{{// looks like we've got child nodes to render into this host element
// or we need to update the css class/attrs on the host element
// DOM WRITE!
renderVdom(elm,hostRef,cmpMeta,callRender(instance))}}if(plt.$cssShim$){plt.$cssShim$.updateHost(elm)}{hostRef.$flags$&=~16/* isQueuedForUpdate */}{hostRef.$flags$|=2/* hasRendered */}if(rc){// ok, so turns out there are some child host elements
// waiting on this parent element to load
// let's fire off all update callbacks waiting
rc.forEach(function(cb){return cb()});elm["s-rc"]=void 0}endRender();endUpdate();{var childrenPromises=elm["s-p"],postUpdate=function postUpdate(){return postUpdateComponent(elm,hostRef,cmpMeta)};if(0===childrenPromises.length){postUpdate()}else{Promise.all(childrenPromises).then(postUpdate);hostRef.$flags$|=4/* isWaitingForChildren */;childrenPromises.length=0}}},callRender=function callRender(instance,elm){try{instance=instance.render()}catch(e){consoleError(e)}return instance},postUpdateComponent=function postUpdateComponent(elm,hostRef,cmpMeta){var endPostUpdate=createTime("postUpdate",cmpMeta.$tagName$),ancestorComponent=hostRef.$ancestorComponent$;if(!(64&hostRef.$flags$/* hasLoadedComponent */)){hostRef.$flags$|=64/* hasLoadedComponent */;{// DOM WRITE!
// add the css class that this element has officially hydrated
elm.classList.add(HYDRATED_CLASS)}endPostUpdate();{hostRef.$onReadyResolve$(elm);if(!ancestorComponent){appDidLoad()}}}else{endPostUpdate()}// load events fire from bottom to top
// the deepest elements load first then bubbles up
{if(hostRef.$onRenderResolve$){hostRef.$onRenderResolve$();hostRef.$onRenderResolve$=void 0}if(512&hostRef.$flags$/* needsRerender */){nextTick(function(){return scheduleUpdate(elm,hostRef,cmpMeta,!1)})}hostRef.$flags$&=~(/* isWaitingForChildren */512|4/* needsRerender */)}// ( •_•)
// ( •_•)>⌐■-■
// (⌐■_■)
},_forceUpdate=function forceUpdate(elm,cmpMeta){{var hostRef=getHostRef(elm),isConnected=hostRef.$hostElement$.isConnected;if(isConnected&&/* hasRendered */ /* isQueuedForUpdate */2===(hostRef.$flags$&(16|2))/* hasRendered */){scheduleUpdate(elm,hostRef,cmpMeta,!1)}// Returns "true" when the forced update was successfully scheduled
return isConnected}},appDidLoad=function appDidLoad(who){// on appload
// we have finish the first big initial render
{doc.documentElement.classList.add(HYDRATED_CLASS)}{plt.$flags$|=2/* appLoaded */}},then=function then(promise,thenFn){return promise&&promise.then?promise.then(thenFn):thenFn()},getValue=function getValue(ref,propName){return getHostRef(ref).$instanceValues$.get(propName)},setValue=function setValue(ref,propName,newVal,cmpMeta){// check our new property value against our internal value
var hostRef=getHostRef(ref),elm=hostRef.$hostElement$,oldVal=hostRef.$instanceValues$.get(propName),flags=hostRef.$flags$,instance=hostRef.$lazyInstance$;newVal=parsePropertyValue(newVal,cmpMeta.$members$[propName][0]);if(newVal!==oldVal&&(!(8&flags/* isConstructingInstance */)||oldVal===void 0)){// gadzooks! the property's value has changed!!
// set our new value!
hostRef.$instanceValues$.set(propName,newVal);if(instance){if(/* hasRendered */ /* isQueuedForUpdate */2===(flags&(16|2))/* hasRendered */){// looks like this value actually changed, so we've got work to do!
// but only if we've already rendered, otherwise just chill out
// queue that we need to do an update, but don't worry about queuing
// up millions cuz this function ensures it only runs once
scheduleUpdate(elm,hostRef,cmpMeta,!1)}}}},proxyComponent=function proxyComponent(Cstr,cmpMeta,flags){if(cmpMeta.$members$){// It's better to have a const than two Object.entries()
var members=Object.entries(cmpMeta.$members$),prototype=Cstr.prototype;members.forEach(function(_ref){var _ref2=babelHelpers.slicedToArray(_ref,2),memberName=_ref2[0],_ref2$=babelHelpers.slicedToArray(_ref2[1],1),memberFlags=_ref2$[0];if(31&memberFlags/* Prop */||2&flags/* proxyState */&&32&memberFlags/* State */){// proxyComponent - prop
Object.defineProperty(prototype,memberName,{get:function get(){// proxyComponent, get value
return getValue(this,memberName)},set:function set(newValue){// proxyComponent, set value
setValue(this,memberName,newValue,cmpMeta)},configurable:!0,enumerable:!0})}});if(1&flags/* isElementConstructor */){var attrNameToPropName=new Map;prototype.attributeChangedCallback=function(attrName,_oldValue,newValue){var _this=this;plt.jmp(function(){var propName=attrNameToPropName.get(attrName);_this[propName]=null===newValue&&"boolean"===typeof _this[propName]?!1:newValue})};// create an array of attributes to observe
// and also create a map of html attribute name to js property name
Cstr.observedAttributes=members.filter(function(_ref3){var _ref4=babelHelpers.slicedToArray(_ref3,2),_=_ref4[0],m=_ref4[1];return 15&m[0]}/* HasAttribute */)// filter to only keep props that should match attributes
.map(function(_ref5){var _ref6=babelHelpers.slicedToArray(_ref5,2),propName=_ref6[0],m=_ref6[1],attrName=m[1]||propName;attrNameToPropName.set(attrName,propName);return attrName})}}return Cstr},initializeComponent=/*#__PURE__*/function(){var _ref7=babelHelpers.asyncToGenerator(/*#__PURE__*/regeneratorRuntime.mark(function _callee(elm,hostRef,cmpMeta,hmrVersionId,Cstr){var endLoad,endNewInstance,_scopeId,endRegisterStyles,style,ancestorComponent,schedule;return regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:if(!(/* hasInitializedComponent */0===(32&hostRef.$flags$))){_context.next=25;break}// we haven't initialized this element yet
hostRef.$flags$|=32/* hasInitializedComponent */;// lazy loaded components
// request the component's implementation to be
// wired up with the host element
Cstr=loadModule(cmpMeta);if(!Cstr.then){_context.next=9;break}// Await creates a micro-task avoid if possible
endLoad=uniqueTime();_context.next=7;return Cstr;case 7:Cstr=_context.sent;endLoad();case 9:if(!Cstr.isProxied){proxyComponent(Cstr,cmpMeta,2/* proxyState */);Cstr.isProxied=!0}endNewInstance=createTime("createInstance",cmpMeta.$tagName$);// ok, time to construct the instance
// but let's keep track of when we start and stop
// so that the getters/setters don't incorrectly step on data
hostRef.$flags$|=8/* isConstructingInstance */;// construct the lazy-loaded component implementation
// passing the hostRef is very important during
// construction in order to directly wire together the
// host element and the lazy-loaded instance
try{new Cstr(hostRef)}catch(e){consoleError(e)}hostRef.$flags$&=~8/* isConstructingInstance */;endNewInstance();_scopeId=getScopeId(cmpMeta.$tagName$);if(!(!styles.has(_scopeId)&&Cstr.style)){_context.next=25;break}endRegisterStyles=createTime("registerStyles",cmpMeta.$tagName$);// this component has styles but we haven't registered them yet
style=Cstr.style;if(!(8&cmpMeta.$flags$/* needsShadowDomShim */)){_context.next=23;break}_context.next=22;return new Promise(function(res,rej){return _require.default(["./shadow-css-4889ae62-23996f3f.js"],res,rej)}).then(function(m){return m.scopeCss(style,_scopeId,!1)});case 22:style=_context.sent;case 23:registerStyle(_scopeId,style,!!(1&cmpMeta.$flags$/* shadowDomEncapsulation */));endRegisterStyles();case 25:// we've successfully created a lazy instance
ancestorComponent=hostRef.$ancestorComponent$;schedule=function schedule(){return scheduleUpdate(elm,hostRef,cmpMeta,!0)};if(ancestorComponent&&ancestorComponent["s-rc"]){// this is the intial load and this component it has an ancestor component
// but the ancestor component has NOT fired its will update lifecycle yet
// so let's just cool our jets and wait for the ancestor to continue first
// this will get fired off when the ancestor component
// finally gets around to rendering its lazy self
// fire off the initial update
ancestorComponent["s-rc"].push(schedule)}else{schedule()}case 28:case"end":return _context.stop();}}},_callee)}));return function initializeComponent(_x,_x2,_x3,_x4,_x5){return _ref7.apply(this,arguments)}}(),_connectedCallback=function connectedCallback(elm,cmpMeta){if(/* isTmpDisconnected */0===(1&plt.$flags$)){var endConnected=createTime("connectedCallback",cmpMeta.$tagName$),hostRef=getHostRef(elm);// connectedCallback
if(!(1&hostRef.$flags$/* hasConnected */)){// first time this component has connected
hostRef.$flags$|=1/* hasConnected */;{// initUpdate
// if the slot polyfill is required we'll need to put some nodes
// in here to act as original content anchors as we move nodes around
// host element has been connected to the DOM
if(4&cmpMeta.$flags$/* hasSlotRelocation */||8&cmpMeta.$flags$/* needsShadowDomShim */){setContentReference(elm)}}{// find the first ancestor component (if there is one) and register
// this component as one of the actively loading child components for its ancestor
var ancestorComponent=elm;while(ancestorComponent=ancestorComponent.parentNode||ancestorComponent.host){// climb up the ancestors looking for the first
// component that hasn't finished its lifecycle update yet
if(ancestorComponent["s-p"]){// we found this components first ancestor component
// keep a reference to this component's ancestor component
attachToAncestor(hostRef,hostRef.$ancestorComponent$=ancestorComponent);break}}}// Lazy properties
// https://developers.google.com/web/fundamentals/web-components/best-practices#lazy-properties
if(cmpMeta.$members$){Object.entries(cmpMeta.$members$).forEach(function(_ref8){var _ref9=babelHelpers.slicedToArray(_ref8,2),memberName=_ref9[0],_ref9$=babelHelpers.slicedToArray(_ref9[1],1),memberFlags=_ref9$[0];if(31&memberFlags/* Prop */&&elm.hasOwnProperty(memberName)){var value=elm[memberName];delete elm[memberName];elm[memberName]=value}})}{// connectedCallback, taskQueue, initialLoad
// angular sets attribute AFTER connectCallback
// https://github.com/angular/angular/issues/18909
// https://github.com/angular/angular/issues/19940
nextTick(function(){return initializeComponent(elm,hostRef,cmpMeta)})}}endConnected()}},setContentReference=function setContentReference(elm){// only required when we're NOT using native shadow dom (slot)
// or this browser doesn't support native shadow dom
// and this host element was NOT created with SSR
// let's pick out the inner content for slot projection
// create a node to represent where the original
// content was first placed, which is useful later on
var contentRefElm=elm["s-cr"]=doc.createComment("");contentRefElm["s-cn"]=!0;elm.insertBefore(contentRefElm,elm.firstChild)},_disconnectedCallback=function disconnectedCallback(elm){if(/* isTmpDisconnected */0===(1&plt.$flags$)){var hostRef=getHostRef(elm);// clear CSS var-shim tracking
if(plt.$cssShim$){plt.$cssShim$.removeHost(elm)}}},bootstrapLazy=function bootstrapLazy(lazyBundles){var options=1<arguments.length&&arguments[1]!==void 0?arguments[1]:{},endBootstrap=createTime(),cmpTags=[],exclude=options.exclude||[],head=doc.head,customElements=win.customElements,y=/*@__PURE__*/head.querySelector("meta[charset]"),visibilityStyle=/*@__PURE__*/doc.createElement("style"),deferredConnectedCallbacks=[],appLoadFallback,isBootstrapping=!0;Object.assign(plt,options);plt.$resourcesUrl$=new URL(options.resourcesUrl||"./",doc.baseURI).href;if(options.syncQueue){plt.$flags$|=4/* queueSync */}lazyBundles.forEach(function(lazyBundle){return lazyBundle[1].forEach(function(compactMeta){var cmpMeta={$flags$:compactMeta[0],$tagName$:compactMeta[1],$members$:compactMeta[2],$listeners$:compactMeta[3]};{cmpMeta.$members$=compactMeta[2]}if(!supportsShadowDom&&1&cmpMeta.$flags$/* shadowDomEncapsulation */){cmpMeta.$flags$|=8/* needsShadowDomShim */}var tagName=cmpMeta.$tagName$,HostElement=/*#__PURE__*/function(_HTMLElement){babelHelpers.inherits(HostElement,_HTMLElement);// StencilLazyHost
function HostElement(self){var _this2;babelHelpers.classCallCheck(this,HostElement);// @ts-ignore
_this2=babelHelpers.possibleConstructorReturn(this,babelHelpers.getPrototypeOf(HostElement).call(this,self));self=babelHelpers.assertThisInitialized(_this2);registerHost(self);if(1&cmpMeta.$flags$/* shadowDomEncapsulation */){// this component is using shadow dom
// and this browser supports shadow dom
// add the read-only property "shadowRoot" to the host element
// adding the shadow root build conditionals to minimize runtime
if(supportsShadowDom){{self.attachShadow({mode:"open"})}}else if(!("shadowRoot"in self)){self.shadowRoot=self}}return _this2}babelHelpers.createClass(HostElement,[{key:"connectedCallback",value:function connectedCallback(){var _this3=this;if(appLoadFallback){clearTimeout(appLoadFallback);appLoadFallback=null}if(isBootstrapping){// connectedCallback will be processed once all components have been registered
deferredConnectedCallbacks.push(this)}else{plt.jmp(function(){return _connectedCallback(_this3,cmpMeta)})}}},{key:"disconnectedCallback",value:function disconnectedCallback(){var _this4=this;plt.jmp(function(){return _disconnectedCallback(_this4)})}},{key:"forceUpdate",value:function forceUpdate(){_forceUpdate(this,cmpMeta)}},{key:"componentOnReady",value:function componentOnReady(){return getHostRef(this).$onReadyPromise$}}]);return HostElement}(babelHelpers.wrapNativeSuper(HTMLElement));cmpMeta.$lazyBundleIds$=lazyBundle[0];if(!exclude.includes(tagName)&&!customElements.get(tagName)){cmpTags.push(tagName);customElements.define(tagName,proxyComponent(HostElement,cmpMeta,1/* isElementConstructor */))}})});// visibilityStyle.innerHTML = cmpTags.map(t => `${t}:not(.hydrated)`) + '{display:none}';
visibilityStyle.innerHTML=cmpTags+"{visibility:hidden}.hydrated{visibility:inherit}";visibilityStyle.setAttribute("data-styles","");head.insertBefore(visibilityStyle,y?y.nextSibling:head.firstChild);// Process deferred connectedCallbacks now all components have been registered
isBootstrapping=!1;if(0<deferredConnectedCallbacks.length){deferredConnectedCallbacks.forEach(function(host){return host.connectedCallback()})}else{plt.jmp(function(){return appLoadFallback=setTimeout(appDidLoad,30,"timeout")})}// Fallback appLoad event
endBootstrap()};_exports.b=bootstrapLazy;var createEvent=function createEvent(ref,name,flags){var elm=getElement(ref);return{emit:function emit(detail){var ev=new CustomEvent(name,{bubbles:!!(4&flags/* Bubbles */),composed:!!(2&flags/* Composed */),cancelable:!!(1&flags/* Cancellable */),detail:detail});elm.dispatchEvent(ev);return ev}}};_exports.c=createEvent;var getElement=function getElement(ref){return getHostRef(ref).$hostElement$};_exports.g=getElement});