define(["exports", "require"], function (_exports, _require) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.r = _exports.p = _exports.h = _exports.g = _exports.c = _exports.b = void 0;
  _require = _interopRequireWildcard(_require);

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || babelHelpers.typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var NAMESPACE = 'websocialshare';
  var scopeId;
  var hostTagName;
  var isSvgMode = false;
  var queuePending = false;
  var win = typeof window !== 'undefined' ? window : {};
  var doc = win.document || {
    head: {}
  };
  var plt = {
    $flags$: 0,
    $resourcesUrl$: '',
    jmp: function jmp(h) {
      return h();
    },
    raf: function raf(h) {
      return requestAnimationFrame(h);
    },
    ael: function ael(el, eventName, listener, opts) {
      return el.addEventListener(eventName, listener, opts);
    },
    rel: function rel(el, eventName, listener, opts) {
      return el.removeEventListener(eventName, listener, opts);
    },
    ce: function ce(eventName, opts) {
      return new CustomEvent(eventName, opts);
    }
  };

  var promiseResolve = function promiseResolve(v) {
    return Promise.resolve(v);
  };

  _exports.p = promiseResolve;

  var supportsConstructibleStylesheets = /*@__PURE__*/function () {
    try {
      new CSSStyleSheet();
      return typeof new CSSStyleSheet().replace === 'function';
    } catch (e) {}

    return false;
  }();

  var HYDRATED_CSS = '{visibility:hidden}.hydrated{visibility:inherit}';

  var createTime = function createTime(fnName) {
    var tagName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    {
      return function () {
        return;
      };
    }
  };

  var uniqueTime = function uniqueTime(key, measureText) {
    {
      return function () {
        return;
      };
    }
  };

  var rootAppliedStyles = new WeakMap();

  var registerStyle = function registerStyle(scopeId, cssText, allowCS) {
    var style = styles.get(scopeId);

    if (supportsConstructibleStylesheets && allowCS) {
      style = style || new CSSStyleSheet();
      style.replace(cssText);
    } else {
      style = cssText;
    }

    styles.set(scopeId, style);
  };

  var addStyle = function addStyle(styleContainerNode, cmpMeta, mode, hostElm) {
    var scopeId = getScopeId(cmpMeta);
    var style = styles.get(scopeId); // if an element is NOT connected then getRootNode() will return the wrong root node
    // so the fallback is to always use the document for the root node in those cases

    styleContainerNode = styleContainerNode.nodeType === 11
    /* DocumentFragment */
    ? styleContainerNode : doc;

    if (style) {
      if (typeof style === 'string') {
        styleContainerNode = styleContainerNode.head || styleContainerNode;
        var appliedStyles = rootAppliedStyles.get(styleContainerNode);
        var styleElm;

        if (!appliedStyles) {
          rootAppliedStyles.set(styleContainerNode, appliedStyles = new Set());
        }

        if (!appliedStyles.has(scopeId)) {
          {
            {
              styleElm = doc.createElement('style');
              styleElm.innerHTML = style;
            }
            styleContainerNode.insertBefore(styleElm, styleContainerNode.querySelector('link'));
          }

          if (appliedStyles) {
            appliedStyles.add(scopeId);
          }
        }
      } else if (!styleContainerNode.adoptedStyleSheets.includes(style)) {
        styleContainerNode.adoptedStyleSheets = [].concat(babelHelpers.toConsumableArray(styleContainerNode.adoptedStyleSheets), [style]);
      }
    }

    return scopeId;
  };

  var attachStyles = function attachStyles(hostRef) {
    var cmpMeta = hostRef.$cmpMeta$;
    var elm = hostRef.$hostElement$;
    var flags = cmpMeta.$flags$;
    var endAttachStyles = createTime('attachStyles', cmpMeta.$tagName$);
    var scopeId = addStyle(elm.shadowRoot ? elm.shadowRoot : elm.getRootNode(), cmpMeta);

    if (flags & 10
    /* needsScopedEncapsulation */
    ) {
        // only required when we're NOT using native shadow dom (slot)
        // or this browser doesn't support native shadow dom
        // and this host element was NOT created with SSR
        // let's pick out the inner content for slot projection
        // create a node to represent where the original
        // content was first placed, which is useful later on
        // DOM WRITE!!
        elm['s-sc'] = scopeId;
        elm.classList.add(scopeId + '-h');
      }

    endAttachStyles();
  };

  var getScopeId = function getScopeId(cmp, mode) {
    return 'sc-' + cmp.$tagName$;
  };
  /**
   * Default style mode id
   */

  /**
   * Reusable empty obj/array
   * Don't add values to these!!
   */


  var EMPTY_OBJ = {};

  var isDef = function isDef(v) {
    return v != null;
  };

  var isComplexType = function isComplexType(o) {
    // https://jsperf.com/typeof-fn-object/5
    o = babelHelpers.typeof(o);
    return o === 'object' || o === 'function';
  };
  /**
   * Production h() function based on Preact by
   * Jason Miller (@developit)
   * Licensed under the MIT License
   * https://github.com/developit/preact/blob/master/LICENSE
   *
   * Modified for Stencil's compiler and vdom
   */
  // const stack: any[] = [];
  // export function h(nodeName: string | d.FunctionalComponent, vnodeData: d.PropsType, child?: d.ChildType): d.VNode;
  // export function h(nodeName: string | d.FunctionalComponent, vnodeData: d.PropsType, ...children: d.ChildType[]): d.VNode;


  var h = function h(nodeName, vnodeData) {
    var child = null;
    var simple = false;
    var lastSimple = false;
    var vNodeChildren = [];

    var walk = function walk(c) {
      for (var i = 0; i < c.length; i++) {
        child = c[i];

        if (Array.isArray(child)) {
          walk(child);
        } else if (child != null && typeof child !== 'boolean') {
          if (simple = typeof nodeName !== 'function' && !isComplexType(child)) {
            child = String(child);
          }

          if (simple && lastSimple) {
            // If the previous child was simple (string), we merge both
            vNodeChildren[vNodeChildren.length - 1].$text$ += child;
          } else {
            // Append a new vNode, if it's text, we create a text vNode
            vNodeChildren.push(simple ? newVNode(null, child) : child);
          }

          lastSimple = simple;
        }
      }
    };

    for (var _len = arguments.length, children = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      children[_key - 2] = arguments[_key];
    }

    walk(children);

    if (vnodeData) {
      {
        var classData = vnodeData.className || vnodeData.class;

        if (classData) {
          vnodeData.class = babelHelpers.typeof(classData) !== 'object' ? classData : Object.keys(classData).filter(function (k) {
            return classData[k];
          }).join(' ');
        }
      }
    }

    var vnode = newVNode(nodeName, null);
    vnode.$attrs$ = vnodeData;

    if (vNodeChildren.length > 0) {
      vnode.$children$ = vNodeChildren;
    }

    return vnode;
  };

  _exports.h = h;

  var newVNode = function newVNode(tag, text) {
    var vnode = {
      $flags$: 0,
      $tag$: tag,
      $text$: text,
      $elm$: null,
      $children$: null
    };
    {
      vnode.$attrs$ = null;
    }
    return vnode;
  };

  var Host = {};

  var isHost = function isHost(node) {
    return node && node.$tag$ === Host;
  };
  /**
   * Production setAccessor() function based on Preact by
   * Jason Miller (@developit)
   * Licensed under the MIT License
   * https://github.com/developit/preact/blob/master/LICENSE
   *
   * Modified for Stencil's compiler and vdom
   */


  var setAccessor = function setAccessor(elm, memberName, oldValue, newValue, isSvg, flags) {
    if (oldValue !== newValue) {
      var isProp = isMemberInElement(elm, memberName);
      var ln = memberName.toLowerCase();

      if (memberName === 'class') {
        var classList = elm.classList;
        var oldClasses = parseClassList(oldValue);
        var newClasses = parseClassList(newValue);
        classList.remove.apply(classList, babelHelpers.toConsumableArray(oldClasses.filter(function (c) {
          return c && !newClasses.includes(c);
        })));
        classList.add.apply(classList, babelHelpers.toConsumableArray(newClasses.filter(function (c) {
          return c && !oldClasses.includes(c);
        })));
      } else if (memberName === 'ref') {
        // minifier will clean this up
        if (newValue) {
          newValue(elm);
        }
      } else if (!isProp && memberName[0] === 'o' && memberName[1] === 'n') {
        // Event Handlers
        // so if the member name starts with "on" and the 3rd characters is
        // a capital letter, and it's not already a member on the element,
        // then we're assuming it's an event listener
        if (memberName[2] === '-') {
          // on- prefixed events
          // allows to be explicit about the dom event to listen without any magic
          // under the hood:
          // <my-cmp on-click> // listens for "click"
          // <my-cmp on-Click> // listens for "Click"
          // <my-cmp on-ionChange> // listens for "ionChange"
          // <my-cmp on-EVENTS> // listens for "EVENTS"
          memberName = memberName.slice(3);
        } else if (isMemberInElement(win, ln)) {
          // standard event
          // the JSX attribute could have been "onMouseOver" and the
          // member name "onmouseover" is on the window's prototype
          // so let's add the listener "mouseover", which is all lowercased
          memberName = ln.slice(2);
        } else {
          // custom event
          // the JSX attribute could have been "onMyCustomEvent"
          // so let's trim off the "on" prefix and lowercase the first character
          // and add the listener "myCustomEvent"
          // except for the first character, we keep the event name case
          memberName = ln[2] + memberName.slice(3);
        }

        if (oldValue) {
          plt.rel(elm, memberName, oldValue, false);
        }

        if (newValue) {
          plt.ael(elm, memberName, newValue, false);
        }
      } else {
        // Set property if it exists and it's not a SVG
        var isComplex = isComplexType(newValue);

        if ((isProp || isComplex && newValue !== null) && !isSvg) {
          try {
            if (!elm.tagName.includes('-')) {
              var n = newValue == null ? '' : newValue; // Workaround for Safari, moving the <input> caret when re-assigning the same valued

              if (memberName === 'list') {
                isProp = false;
              } else if (oldValue == null || elm[memberName] != n) {
                elm[memberName] = n;
              }
            } else {
              elm[memberName] = newValue;
            }
          } catch (e) {}
        }

        if (newValue == null || newValue === false) {
          if (newValue !== false || elm.getAttribute(memberName) === '') {
            {
              elm.removeAttribute(memberName);
            }
          }
        } else if ((!isProp || flags & 4
        /* isHost */
        || isSvg) && !isComplex) {
          newValue = newValue === true ? '' : newValue;
          {
            elm.setAttribute(memberName, newValue);
          }
        }
      }
    }
  };

  var parseClassListRegex = /\s/;

  var parseClassList = function parseClassList(value) {
    return !value ? [] : value.split(parseClassListRegex);
  };

  var updateElement = function updateElement(oldVnode, newVnode, isSvgMode, memberName) {
    // if the element passed in is a shadow root, which is a document fragment
    // then we want to be adding attrs/props to the shadow root's "host" element
    // if it's not a shadow root, then we add attrs/props to the same element
    var elm = newVnode.$elm$.nodeType === 11
    /* DocumentFragment */
    && newVnode.$elm$.host ? newVnode.$elm$.host : newVnode.$elm$;
    var oldVnodeAttrs = oldVnode && oldVnode.$attrs$ || EMPTY_OBJ;
    var newVnodeAttrs = newVnode.$attrs$ || EMPTY_OBJ;
    {
      // remove attributes no longer present on the vnode by setting them to undefined
      for (memberName in oldVnodeAttrs) {
        if (!(memberName in newVnodeAttrs)) {
          setAccessor(elm, memberName, oldVnodeAttrs[memberName], undefined, isSvgMode, newVnode.$flags$);
        }
      }
    } // add new & update changed attributes

    for (memberName in newVnodeAttrs) {
      setAccessor(elm, memberName, oldVnodeAttrs[memberName], newVnodeAttrs[memberName], isSvgMode, newVnode.$flags$);
    }
  };

  var createElm = function createElm(oldParentVNode, newParentVNode, childIndex, parentElm) {
    // tslint:disable-next-line: prefer-const
    var newVNode = newParentVNode.$children$[childIndex];
    var i = 0;
    var elm;
    var childNode;

    if (newVNode.$text$ !== null) {
      // create text node
      elm = newVNode.$elm$ = doc.createTextNode(newVNode.$text$);
    } else {
      // create element
      elm = newVNode.$elm$ = doc.createElement(newVNode.$tag$); // add css classes, attrs, props, listeners, etc.

      {
        updateElement(null, newVNode, isSvgMode);
      }

      if (isDef(scopeId) && elm['s-si'] !== scopeId) {
        // if there is a scopeId and this is the initial render
        // then let's add the scopeId as a css class
        elm.classList.add(elm['s-si'] = scopeId);
      }

      if (newVNode.$children$) {
        for (i = 0; i < newVNode.$children$.length; ++i) {
          // create the node
          childNode = createElm(oldParentVNode, newVNode, i); // return node could have been null

          if (childNode) {
            // append our new node
            elm.appendChild(childNode);
          }
        }
      }
    }

    return elm;
  };

  var addVnodes = function addVnodes(parentElm, before, parentVNode, vnodes, startIdx, endIdx) {
    var containerElm = parentElm;
    var childNode;

    if (containerElm.shadowRoot && containerElm.tagName === hostTagName) {
      containerElm = containerElm.shadowRoot;
    }

    for (; startIdx <= endIdx; ++startIdx) {
      if (vnodes[startIdx]) {
        childNode = createElm(null, parentVNode, startIdx);

        if (childNode) {
          vnodes[startIdx].$elm$ = childNode;
          containerElm.insertBefore(childNode, before);
        }
      }
    }
  };

  var removeVnodes = function removeVnodes(vnodes, startIdx, endIdx, vnode, elm) {
    for (; startIdx <= endIdx; ++startIdx) {
      if (vnode = vnodes[startIdx]) {
        elm = vnode.$elm$;
        callNodeRefs(vnode); // remove the vnode's element from the dom

        elm.remove();
      }
    }
  };

  var updateChildren = function updateChildren(parentElm, oldCh, newVNode, newCh) {
    var oldStartIdx = 0;
    var newStartIdx = 0;
    var oldEndIdx = oldCh.length - 1;
    var oldStartVnode = oldCh[0];
    var oldEndVnode = oldCh[oldEndIdx];
    var newEndIdx = newCh.length - 1;
    var newStartVnode = newCh[0];
    var newEndVnode = newCh[newEndIdx];
    var node;

    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
      if (oldStartVnode == null) {
        // Vnode might have been moved left
        oldStartVnode = oldCh[++oldStartIdx];
      } else if (oldEndVnode == null) {
        oldEndVnode = oldCh[--oldEndIdx];
      } else if (newStartVnode == null) {
        newStartVnode = newCh[++newStartIdx];
      } else if (newEndVnode == null) {
        newEndVnode = newCh[--newEndIdx];
      } else if (isSameVnode(oldStartVnode, newStartVnode)) {
        patch(oldStartVnode, newStartVnode);
        oldStartVnode = oldCh[++oldStartIdx];
        newStartVnode = newCh[++newStartIdx];
      } else if (isSameVnode(oldEndVnode, newEndVnode)) {
        patch(oldEndVnode, newEndVnode);
        oldEndVnode = oldCh[--oldEndIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (isSameVnode(oldStartVnode, newEndVnode)) {
        patch(oldStartVnode, newEndVnode);
        parentElm.insertBefore(oldStartVnode.$elm$, oldEndVnode.$elm$.nextSibling);
        oldStartVnode = oldCh[++oldStartIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (isSameVnode(oldEndVnode, newStartVnode)) {
        patch(oldEndVnode, newStartVnode);
        parentElm.insertBefore(oldEndVnode.$elm$, oldStartVnode.$elm$);
        oldEndVnode = oldCh[--oldEndIdx];
        newStartVnode = newCh[++newStartIdx];
      } else {
        {
          // new element
          node = createElm(oldCh && oldCh[newStartIdx], newVNode, newStartIdx);
          newStartVnode = newCh[++newStartIdx];
        }

        if (node) {
          {
            oldStartVnode.$elm$.parentNode.insertBefore(node, oldStartVnode.$elm$);
          }
        }
      }
    }

    if (oldStartIdx > oldEndIdx) {
      addVnodes(parentElm, newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].$elm$, newVNode, newCh, newStartIdx, newEndIdx);
    } else if (newStartIdx > newEndIdx) {
      removeVnodes(oldCh, oldStartIdx, oldEndIdx);
    }
  };

  var isSameVnode = function isSameVnode(vnode1, vnode2) {
    // compare if two vnode to see if they're "technically" the same
    // need to have the same element tag, and same key to be the same
    if (vnode1.$tag$ === vnode2.$tag$) {
      return true;
    }

    return false;
  };

  var patch = function patch(oldVNode, newVNode) {
    var elm = newVNode.$elm$ = oldVNode.$elm$;
    var oldChildren = oldVNode.$children$;
    var newChildren = newVNode.$children$;
    var tag = newVNode.$tag$;
    var text = newVNode.$text$;

    if (text === null) {
      // element node
      {
        if (tag === 'slot') ;else {
          // either this is the first render of an element OR it's an update
          // AND we already know it's possible it could have changed
          // this updates the element's css classes, attrs, props, listeners, etc.
          updateElement(oldVNode, newVNode, isSvgMode);
        }
      }

      if (oldChildren !== null && newChildren !== null) {
        // looks like there's child vnodes for both the old and new vnodes
        updateChildren(elm, oldChildren, newVNode, newChildren);
      } else if (newChildren !== null) {
        // no old child vnodes, but there are new child vnodes to add
        if (oldVNode.$text$ !== null) {
          // the old vnode was text, so be sure to clear it out
          elm.textContent = '';
        } // add the new vnode children


        addVnodes(elm, null, newVNode, newChildren, 0, newChildren.length - 1);
      } else if (oldChildren !== null) {
        // no new child vnodes, but there are old child vnodes to remove
        removeVnodes(oldChildren, 0, oldChildren.length - 1);
      }
    } else if (oldVNode.$text$ !== text) {
      // update the text content for the text only vnode
      // and also only if the text is different than before
      elm.data = text;
    }
  };

  var callNodeRefs = function callNodeRefs(vNode) {
    {
      vNode.$attrs$ && vNode.$attrs$.ref && vNode.$attrs$.ref(null);
      vNode.$children$ && vNode.$children$.map(callNodeRefs);
    }
  };

  var renderVdom = function renderVdom(hostRef, renderFnResults) {
    var hostElm = hostRef.$hostElement$;
    var oldVNode = hostRef.$vnode$ || newVNode(null, null);
    var rootVnode = isHost(renderFnResults) ? renderFnResults : h(null, null, renderFnResults);
    hostTagName = hostElm.tagName;
    rootVnode.$tag$ = null;
    rootVnode.$flags$ |= 4
    /* isHost */
    ;
    hostRef.$vnode$ = rootVnode;
    rootVnode.$elm$ = oldVNode.$elm$ = hostElm.shadowRoot || hostElm;
    {
      scopeId = hostElm['s-sc'];
    } // synchronous patch

    patch(oldVNode, rootVnode);
  };

  var getElement = function getElement(ref) {
    return getHostRef(ref).$hostElement$;
  };

  _exports.g = getElement;

  var createEvent = function createEvent(ref, name, flags) {
    var elm = getElement(ref);
    return {
      emit: function emit(detail) {
        return emitEvent(elm, name, {
          bubbles: !!(flags & 4
          /* Bubbles */
          ),
          composed: !!(flags & 2
          /* Composed */
          ),
          cancelable: !!(flags & 1
          /* Cancellable */
          ),
          detail: detail
        });
      }
    };
  };
  /**
   * Helper function to create & dispatch a custom Event on a provided target
   * @param elm the target of the Event
   * @param name the name to give the custom Event
   * @param opts options for configuring a custom Event
   * @returns the custom Event
   */


  _exports.c = createEvent;

  var emitEvent = function emitEvent(elm, name, opts) {
    var ev = plt.ce(name, opts);
    elm.dispatchEvent(ev);
    return ev;
  };

  var attachToAncestor = function attachToAncestor(hostRef, ancestorComponent) {
    if (ancestorComponent && !hostRef.$onRenderResolve$ && ancestorComponent['s-p']) {
      ancestorComponent['s-p'].push(new Promise(function (r) {
        return hostRef.$onRenderResolve$ = r;
      }));
    }
  };

  var scheduleUpdate = function scheduleUpdate(hostRef, isInitialLoad) {
    {
      hostRef.$flags$ |= 16
      /* isQueuedForUpdate */
      ;
    }

    if (hostRef.$flags$ & 4
    /* isWaitingForChildren */
    ) {
        hostRef.$flags$ |= 512
        /* needsRerender */
        ;
        return;
      }

    attachToAncestor(hostRef, hostRef.$ancestorComponent$); // there is no ancestor component or the ancestor component
    // has already fired off its lifecycle update then
    // fire off the initial update

    var dispatch = function dispatch() {
      return dispatchHooks(hostRef, isInitialLoad);
    };

    return writeTask(dispatch);
  };

  var dispatchHooks = function dispatchHooks(hostRef, isInitialLoad) {
    var endSchedule = createTime('scheduleUpdate', hostRef.$cmpMeta$.$tagName$);
    var instance = hostRef.$lazyInstance$;
    var promise;
    endSchedule();
    return then(promise, function () {
      return updateComponent(hostRef, instance, isInitialLoad);
    });
  };

  var updateComponent = /*#__PURE__*/function () {
    var _ref = babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(hostRef, instance, isInitialLoad) {
      var elm, endUpdate, rc, endRender, childrenPromises, postUpdate;
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              // updateComponent
              elm = hostRef.$hostElement$;
              endUpdate = createTime('update', hostRef.$cmpMeta$.$tagName$);
              rc = elm['s-rc'];

              if (isInitialLoad) {
                // DOM WRITE!
                attachStyles(hostRef);
              }

              endRender = createTime('render', hostRef.$cmpMeta$.$tagName$);
              callRender(hostRef, instance);

              if (rc) {
                // ok, so turns out there are some child host elements
                // waiting on this parent element to load
                // let's fire off all update callbacks waiting
                rc.map(function (cb) {
                  return cb();
                });
                elm['s-rc'] = undefined;
              }

              endRender();
              endUpdate();
              childrenPromises = elm['s-p'];

              postUpdate = function postUpdate() {
                return postUpdateComponent(hostRef);
              };

              if (childrenPromises.length === 0) {
                postUpdate();
              } else {
                Promise.all(childrenPromises).then(postUpdate);
                hostRef.$flags$ |= 4
                /* isWaitingForChildren */
                ;
                childrenPromises.length = 0;
              }

            case 12:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function updateComponent(_x, _x2, _x3) {
      return _ref.apply(this, arguments);
    };
  }();

  var callRender = function callRender(hostRef, instance, elm) {
    try {
      instance = instance.render();
      {
        hostRef.$flags$ &= ~16
        /* isQueuedForUpdate */
        ;
      }
      {
        hostRef.$flags$ |= 2
        /* hasRendered */
        ;
      }
      {
        {
          // looks like we've got child nodes to render into this host element
          // or we need to update the css class/attrs on the host element
          // DOM WRITE!
          {
            renderVdom(hostRef, instance);
          }
        }
      }
    } catch (e) {
      consoleError(e, hostRef.$hostElement$);
    }

    return null;
  };

  var postUpdateComponent = function postUpdateComponent(hostRef) {
    var tagName = hostRef.$cmpMeta$.$tagName$;
    var elm = hostRef.$hostElement$;
    var endPostUpdate = createTime('postUpdate', tagName);
    var ancestorComponent = hostRef.$ancestorComponent$;

    if (!(hostRef.$flags$ & 64
    /* hasLoadedComponent */
    )) {
      hostRef.$flags$ |= 64
      /* hasLoadedComponent */
      ;
      {
        // DOM WRITE!
        addHydratedFlag(elm);
      }
      endPostUpdate();
      {
        hostRef.$onReadyResolve$(elm);

        if (!ancestorComponent) {
          appDidLoad();
        }
      }
    } else {
      endPostUpdate();
    } // load events fire from bottom to top
    // the deepest elements load first then bubbles up


    {
      if (hostRef.$onRenderResolve$) {
        hostRef.$onRenderResolve$();
        hostRef.$onRenderResolve$ = undefined;
      }

      if (hostRef.$flags$ & 512
      /* needsRerender */
      ) {
          nextTick(function () {
            return scheduleUpdate(hostRef, false);
          });
        }

      hostRef.$flags$ &= ~(4
      /* isWaitingForChildren */
      | 512
      /* needsRerender */
      );
    } // ( •_•)
    // ( •_•)>⌐■-■
    // (⌐■_■)
  };

  var appDidLoad = function appDidLoad(who) {
    // on appload
    // we have finish the first big initial render
    {
      addHydratedFlag(doc.documentElement);
    }
    nextTick(function () {
      return emitEvent(win, 'appload', {
        detail: {
          namespace: NAMESPACE
        }
      });
    });
  };

  var then = function then(promise, thenFn) {
    return promise && promise.then ? promise.then(thenFn) : thenFn();
  };

  var addHydratedFlag = function addHydratedFlag(elm) {
    return elm.classList.add('hydrated');
  };

  var parsePropertyValue = function parsePropertyValue(propValue, propType) {
    // ensure this value is of the correct prop type
    if (propValue != null && !isComplexType(propValue)) {
      if (propType & 4
      /* Boolean */
      ) {
          // per the HTML spec, any string value means it is a boolean true value
          // but we'll cheat here and say that the string "false" is the boolean false
          return propValue === 'false' ? false : propValue === '' || !!propValue;
        } // redundant return here for better minification


      return propValue;
    } // not sure exactly what type we want
    // so no need to change to a different type


    return propValue;
  };

  var getValue = function getValue(ref, propName) {
    return getHostRef(ref).$instanceValues$.get(propName);
  };

  var setValue = function setValue(ref, propName, newVal, cmpMeta) {
    // check our new property value against our internal value
    var hostRef = getHostRef(ref);
    var oldVal = hostRef.$instanceValues$.get(propName);
    var flags = hostRef.$flags$;
    var instance = hostRef.$lazyInstance$;
    newVal = parsePropertyValue(newVal, cmpMeta.$members$[propName][0]);

    if ((!(flags & 8
    /* isConstructingInstance */
    ) || oldVal === undefined) && newVal !== oldVal) {
      // gadzooks! the property's value has changed!!
      // set our new value!
      hostRef.$instanceValues$.set(propName, newVal);

      if (instance) {
        if ((flags & (2
        /* hasRendered */
        | 16
        /* isQueuedForUpdate */
        )) === 2
        /* hasRendered */
        ) {
            // looks like this value actually changed, so we've got work to do!
            // but only if we've already rendered, otherwise just chill out
            // queue that we need to do an update, but don't worry about queuing
            // up millions cuz this function ensures it only runs once
            scheduleUpdate(hostRef, false);
          }
      }
    }
  };

  var proxyComponent = function proxyComponent(Cstr, cmpMeta, flags) {
    if (cmpMeta.$members$) {
      // It's better to have a const than two Object.entries()
      var members = Object.entries(cmpMeta.$members$);
      var prototype = Cstr.prototype;
      members.map(function (_ref2) {
        var _ref3 = babelHelpers.slicedToArray(_ref2, 2),
            memberName = _ref3[0],
            _ref3$ = babelHelpers.slicedToArray(_ref3[1], 1),
            memberFlags = _ref3$[0];

        if (memberFlags & 31
        /* Prop */
        || flags & 2
        /* proxyState */
        && memberFlags & 32
        /* State */
        ) {
          // proxyComponent - prop
          Object.defineProperty(prototype, memberName, {
            get: function get() {
              // proxyComponent, get value
              return getValue(this, memberName);
            },
            set: function set(newValue) {
              // proxyComponent, set value
              setValue(this, memberName, newValue, cmpMeta);
            },
            configurable: true,
            enumerable: true
          });
        }
      });

      if (flags & 1
      /* isElementConstructor */
      ) {
          var attrNameToPropName = new Map();

          prototype.attributeChangedCallback = function (attrName, _oldValue, newValue) {
            var _this = this;

            plt.jmp(function () {
              var propName = attrNameToPropName.get(attrName); //  In a web component lifecycle the attributeChangedCallback runs prior to connectedCallback
              //  in the case where an attribute was set inline.
              //  ```html
              //    <my-component some-attribute="some-value"></my-component>
              //  ```
              //
              //  There is an edge case where a developer sets the attribute inline on a custom element and then
              //  programmatically changes it before it has been upgraded as shown below:
              //
              //  ```html
              //    <!-- this component has _not_ been upgraded yet -->
              //    <my-component id="test" some-attribute="some-value"></my-component>
              //    <script>
              //      // grab non-upgraded component
              //      el = document.querySelector("#test");
              //      el.someAttribute = "another-value";
              //      // upgrade component
              //      customElements.define('my-component', MyComponent);
              //    </script>
              //  ```
              //  In this case if we do not unshadow here and use the value of the shadowing property, attributeChangedCallback
              //  will be called with `newValue = "some-value"` and will set the shadowed property (this.someAttribute = "another-value")
              //  to the value that was set inline i.e. "some-value" from above example. When
              //  the connectedCallback attempts to unshadow it will use "some-value" as the initial value rather than "another-value"
              //
              //  The case where the attribute was NOT set inline but was not set programmatically shall be handled/unshadowed
              //  by connectedCallback as this attributeChangedCallback will not fire.
              //
              //  https://developers.google.com/web/fundamentals/web-components/best-practices#lazy-properties
              //
              //  TODO(STENCIL-16) we should think about whether or not we actually want to be reflecting the attributes to
              //  properties here given that this goes against best practices outlined here
              //  https://developers.google.com/web/fundamentals/web-components/best-practices#avoid-reentrancy

              if (_this.hasOwnProperty(propName)) {
                newValue = _this[propName];
                delete _this[propName];
              } else if (prototype.hasOwnProperty(propName) && typeof _this[propName] === 'number' && _this[propName] == newValue) {
                // if the propName exists on the prototype of `Cstr`, this update may be a result of Stencil using native
                // APIs to reflect props as attributes. Calls to `setAttribute(someElement, propName)` will result in
                // `propName` to be converted to a `DOMString`, which may not be what we want for other primitive props.
                return;
              }

              _this[propName] = newValue === null && typeof _this[propName] === 'boolean' ? false : newValue;
            });
          }; // create an array of attributes to observe
          // and also create a map of html attribute name to js property name


          Cstr.observedAttributes = members.filter(function (_ref4) {
            var _ref5 = babelHelpers.slicedToArray(_ref4, 2),
                _ = _ref5[0],
                m = _ref5[1];

            return m[0] & 15;
          }
          /* HasAttribute */
          ) // filter to only keep props that should match attributes
          .map(function (_ref6) {
            var _ref7 = babelHelpers.slicedToArray(_ref6, 2),
                propName = _ref7[0],
                m = _ref7[1];

            var attrName = m[1] || propName;
            attrNameToPropName.set(attrName, propName);
            return attrName;
          });
        }
    }

    return Cstr;
  };

  var initializeComponent = /*#__PURE__*/function () {
    var _ref8 = babelHelpers.asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(elm, hostRef, cmpMeta, hmrVersionId, Cstr) {
      var endLoad, endNewInstance, style, _scopeId, endRegisterStyles, ancestorComponent, schedule;

      return regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (!((hostRef.$flags$ & 32
              /* hasInitializedComponent */
              ) === 0)) {
                _context2.next = 16;
                break;
              }

              // we haven't initialized this element yet
              hostRef.$flags$ |= 32
              /* hasInitializedComponent */
              ; // lazy loaded components
              // request the component's implementation to be
              // wired up with the host element

              Cstr = loadModule(cmpMeta);

              if (!Cstr.then) {
                _context2.next = 9;
                break;
              }

              // Await creates a micro-task avoid if possible
              endLoad = uniqueTime();
              _context2.next = 7;
              return Cstr;

            case 7:
              Cstr = _context2.sent;
              endLoad();

            case 9:
              if (!Cstr.isProxied) {
                proxyComponent(Cstr, cmpMeta, 2
                /* proxyState */
                );
                Cstr.isProxied = true;
              }

              endNewInstance = createTime('createInstance', cmpMeta.$tagName$); // ok, time to construct the instance
              // but let's keep track of when we start and stop
              // so that the getters/setters don't incorrectly step on data

              hostRef.$flags$ |= 8
              /* isConstructingInstance */
              ;

              // construct the lazy-loaded component implementation
              // passing the hostRef is very important during
              // construction in order to directly wire together the
              // host element and the lazy-loaded instance
              try {
                new Cstr(hostRef);
              } catch (e) {
                consoleError(e);
              }

              hostRef.$flags$ &= ~8
              /* isConstructingInstance */
              ;
              endNewInstance();

              if (Cstr.style) {
                // this component has styles but we haven't registered them yet
                style = Cstr.style;
                _scopeId = getScopeId(cmpMeta);

                if (!styles.has(_scopeId)) {
                  endRegisterStyles = createTime('registerStyles', cmpMeta.$tagName$);
                  registerStyle(_scopeId, style, !!(cmpMeta.$flags$ & 1
                  /* shadowDomEncapsulation */
                  ));
                  endRegisterStyles();
                }
              }

            case 16:
              // we've successfully created a lazy instance
              ancestorComponent = hostRef.$ancestorComponent$;

              schedule = function schedule() {
                return scheduleUpdate(hostRef, true);
              };

              if (ancestorComponent && ancestorComponent['s-rc']) {
                // this is the initial load and this component it has an ancestor component
                // but the ancestor component has NOT fired its will update lifecycle yet
                // so let's just cool our jets and wait for the ancestor to continue first
                // this will get fired off when the ancestor component
                // finally gets around to rendering its lazy self
                // fire off the initial update
                ancestorComponent['s-rc'].push(schedule);
              } else {
                schedule();
              }

            case 19:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    return function initializeComponent(_x4, _x5, _x6, _x7, _x8) {
      return _ref8.apply(this, arguments);
    };
  }();

  var _connectedCallback = function connectedCallback(elm) {
    if ((plt.$flags$ & 1
    /* isTmpDisconnected */
    ) === 0) {
      var hostRef = getHostRef(elm);
      var cmpMeta = hostRef.$cmpMeta$;
      var endConnected = createTime('connectedCallback', cmpMeta.$tagName$);

      if (!(hostRef.$flags$ & 1
      /* hasConnected */
      )) {
        // first time this component has connected
        hostRef.$flags$ |= 1
        /* hasConnected */
        ;
        {
          // find the first ancestor component (if there is one) and register
          // this component as one of the actively loading child components for its ancestor
          var ancestorComponent = elm;

          while (ancestorComponent = ancestorComponent.parentNode || ancestorComponent.host) {
            // climb up the ancestors looking for the first
            // component that hasn't finished its lifecycle update yet
            if (ancestorComponent['s-p']) {
              // we found this components first ancestor component
              // keep a reference to this component's ancestor component
              attachToAncestor(hostRef, hostRef.$ancestorComponent$ = ancestorComponent);
              break;
            }
          }
        } // Lazy properties
        // https://developers.google.com/web/fundamentals/web-components/best-practices#lazy-properties

        if (cmpMeta.$members$) {
          Object.entries(cmpMeta.$members$).map(function (_ref9) {
            var _ref10 = babelHelpers.slicedToArray(_ref9, 2),
                memberName = _ref10[0],
                _ref10$ = babelHelpers.slicedToArray(_ref10[1], 1),
                memberFlags = _ref10$[0];

            if (memberFlags & 31
            /* Prop */
            && elm.hasOwnProperty(memberName)) {
              var value = elm[memberName];
              delete elm[memberName];
              elm[memberName] = value;
            }
          });
        }

        {
          initializeComponent(elm, hostRef, cmpMeta);
        }
      }

      endConnected();
    }
  };

  var _disconnectedCallback = function disconnectedCallback(elm) {
    if ((plt.$flags$ & 1
    /* isTmpDisconnected */
    ) === 0) {
      getHostRef(elm);
    }
  };

  var bootstrapLazy = function bootstrapLazy(lazyBundles) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var endBootstrap = createTime();
    var cmpTags = [];
    var exclude = options.exclude || [];
    var customElements = win.customElements;
    var head = doc.head;
    var metaCharset = /*@__PURE__*/head.querySelector('meta[charset]');
    var visibilityStyle = /*@__PURE__*/doc.createElement('style');
    var deferredConnectedCallbacks = [];
    var appLoadFallback;
    var isBootstrapping = true;
    Object.assign(plt, options);
    plt.$resourcesUrl$ = new URL(options.resourcesUrl || './', doc.baseURI).href;
    lazyBundles.map(function (lazyBundle) {
      lazyBundle[1].map(function (compactMeta) {
        var cmpMeta = {
          $flags$: compactMeta[0],
          $tagName$: compactMeta[1],
          $members$: compactMeta[2],
          $listeners$: compactMeta[3]
        };
        {
          cmpMeta.$members$ = compactMeta[2];
        }
        var tagName = cmpMeta.$tagName$;

        var HostElement = /*#__PURE__*/function (_HTMLElement) {
          babelHelpers.inherits(HostElement, _HTMLElement);

          var _super = _createSuper(HostElement);

          // StencilLazyHost
          function HostElement(self) {
            var _this2;

            babelHelpers.classCallCheck(this, HostElement);
            // @ts-ignore
            _this2 = _super.call(this, self);
            self = babelHelpers.assertThisInitialized(_this2);
            registerHost(self, cmpMeta);

            if (cmpMeta.$flags$ & 1
            /* shadowDomEncapsulation */
            ) {
                // this component is using shadow dom
                // and this browser supports shadow dom
                // add the read-only property "shadowRoot" to the host element
                // adding the shadow root build conditionals to minimize runtime
                {
                  {
                    self.attachShadow({
                      mode: 'open'
                    });
                  }
                }
              }

            return _this2;
          }

          babelHelpers.createClass(HostElement, [{
            key: "connectedCallback",
            value: function connectedCallback() {
              var _this3 = this;

              if (appLoadFallback) {
                clearTimeout(appLoadFallback);
                appLoadFallback = null;
              }

              if (isBootstrapping) {
                // connectedCallback will be processed once all components have been registered
                deferredConnectedCallbacks.push(this);
              } else {
                plt.jmp(function () {
                  return _connectedCallback(_this3);
                });
              }
            }
          }, {
            key: "disconnectedCallback",
            value: function disconnectedCallback() {
              var _this4 = this;

              plt.jmp(function () {
                return _disconnectedCallback(_this4);
              });
            }
          }, {
            key: "componentOnReady",
            value: function componentOnReady() {
              return getHostRef(this).$onReadyPromise$;
            }
          }]);
          return HostElement;
        }( /*#__PURE__*/babelHelpers.wrapNativeSuper(HTMLElement));

        cmpMeta.$lazyBundleId$ = lazyBundle[0];

        if (!exclude.includes(tagName) && !customElements.get(tagName)) {
          cmpTags.push(tagName);
          customElements.define(tagName, proxyComponent(HostElement, cmpMeta, 1
          /* isElementConstructor */
          ));
        }
      });
    });
    {
      visibilityStyle.innerHTML = cmpTags + HYDRATED_CSS;
      visibilityStyle.setAttribute('data-styles', '');
      head.insertBefore(visibilityStyle, metaCharset ? metaCharset.nextSibling : head.firstChild);
    } // Process deferred connectedCallbacks now all components have been registered

    isBootstrapping = false;

    if (deferredConnectedCallbacks.length) {
      deferredConnectedCallbacks.map(function (host) {
        return host.connectedCallback();
      });
    } else {
      {
        plt.jmp(function () {
          return appLoadFallback = setTimeout(appDidLoad, 30);
        });
      }
    } // Fallback appLoad event


    endBootstrap();
  };

  _exports.b = bootstrapLazy;
  var hostRefs = new WeakMap();

  var getHostRef = function getHostRef(ref) {
    return hostRefs.get(ref);
  };

  var registerInstance = function registerInstance(lazyInstance, hostRef) {
    return hostRefs.set(hostRef.$lazyInstance$ = lazyInstance, hostRef);
  };

  _exports.r = registerInstance;

  var registerHost = function registerHost(elm, cmpMeta) {
    var hostRef = {
      $flags$: 0,
      $hostElement$: elm,
      $cmpMeta$: cmpMeta,
      $instanceValues$: new Map()
    };
    {
      hostRef.$onReadyPromise$ = new Promise(function (r) {
        return hostRef.$onReadyResolve$ = r;
      });
      elm['s-p'] = [];
      elm['s-rc'] = [];
    }
    return hostRefs.set(elm, hostRef);
  };

  var isMemberInElement = function isMemberInElement(elm, memberName) {
    return memberName in elm;
  };

  var consoleError = function consoleError(e, el) {
    return (0, console.error)(e, el);
  };

  var cmpModules = /*@__PURE__*/new Map();

  var loadModule = function loadModule(cmpMeta, hostRef, hmrVersionId) {
    // loadModuleImport
    var exportName = cmpMeta.$tagName$.replace(/-/g, '_');
    var bundleId = cmpMeta.$lazyBundleId$;
    var module = cmpModules.get(bundleId);

    if (module) {
      return module[exportName];
    }

    return new Promise(function (res, rej) {
      return _require.default([
      /* webpackInclude: /\.entry\.js$/ */

      /* webpackExclude: /\.system\.entry\.js$/ */

      /* webpackMode: "lazy" */
      "./".concat(bundleId, ".entry.js")], res, rej);
    }).then(function (importedModule) {
      {
        cmpModules.set(bundleId, importedModule);
      }
      return importedModule[exportName];
    }, consoleError);
  };

  var styles = new Map();
  var queueDomReads = [];
  var queueDomWrites = [];

  var queueTask = function queueTask(queue, write) {
    return function (cb) {
      queue.push(cb);

      if (!queuePending) {
        queuePending = true;

        if (write && plt.$flags$ & 4
        /* queueSync */
        ) {
            nextTick(flush);
          } else {
          plt.raf(flush);
        }
      }
    };
  };

  var consume = function consume(queue) {
    for (var i = 0; i < queue.length; i++) {
      try {
        queue[i](performance.now());
      } catch (e) {
        consoleError(e);
      }
    }

    queue.length = 0;
  };

  var flush = function flush() {
    // always force a bunch of medium callbacks to run, but still have
    // a throttle on how many can run in a certain time
    // DOM READS!!!
    consume(queueDomReads); // DOM WRITES!!!

    {
      consume(queueDomWrites);

      if (queuePending = queueDomReads.length > 0) {
        // still more to do yet, but we've run out of time
        // let's let this thing cool off and try again in the next tick
        plt.raf(flush);
      }
    }
  };

  var nextTick = /*@__PURE__*/function nextTick(cb) {
    return promiseResolve().then(cb);
  };

  var writeTask = /*@__PURE__*/queueTask(queueDomWrites, true);
});