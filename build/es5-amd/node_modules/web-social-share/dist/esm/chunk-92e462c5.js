define(["exports", "require"], function (_exports, _require) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.r = _exports.p = _exports.h = _exports.g = _exports.c = _exports.b = _exports.a = void 0;
  _require = babelHelpers.interopRequireWildcard(_require);
  var BUILD = {
    "allRenderFn": true,
    "cmpDidLoad": false,
    "cmpDidUnload": false,
    "cmpDidUpdate": false,
    "cmpDidRender": false,
    "cmpWillLoad": false,
    "cmpWillUpdate": false,
    "cmpWillRender": false,
    "connectedCallback": false,
    "disconnectedCallback": false,
    "element": false,
    "event": true,
    "hasRenderFn": true,
    "lifecycle": false,
    "hostListener": false,
    "hostListenerTargetWindow": false,
    "hostListenerTargetDocument": false,
    "hostListenerTargetBody": false,
    "hostListenerTargetParent": false,
    "hostListenerTarget": false,
    "member": true,
    "method": false,
    "mode": false,
    "noVdomRender": false,
    "observeAttribute": true,
    "prop": true,
    "propBoolean": true,
    "propNumber": false,
    "propString": false,
    "propMutable": true,
    "reflect": false,
    "scoped": false,
    "shadowDom": true,
    "slot": true,
    "slotRelocation": true,
    "state": false,
    "style": true,
    "svg": false,
    "updatable": true,
    "vdomAttribute": true,
    "vdomClass": true,
    "vdomFunctional": true,
    "vdomKey": true,
    "vdomListener": true,
    "vdomRef": true,
    "vdomRender": true,
    "vdomStyle": true,
    "vdomText": true,
    "watchCallback": false,
    "taskQueue": true,
    "lazyLoad": true,
    "hydrateServerSide": false,
    "cssVarShim": true,
    "hydrateClientSide": false,
    "isDebug": false,
    "isDev": false,
    "lifecycleDOMEvents": false,
    "profile": false,
    "hotModuleReplacement": false,
    "constructableCSS": true,
    "initializeNextTick": true,
    "cssAnnotations": true
  };
  var NAMESPACE = 'websocialshare';
  var win = window;
  var doc = document;
  var plt = {
    $flags$: 0,
    $resourcesUrl$: '',
    jmp: function jmp(h) {
      return h();
    },
    raf: function raf(h) {
      return requestAnimationFrame(h);
    },
    ael: function ael(el, eventName, listener, opts) {
      return el.addEventListener(eventName, listener, opts);
    },
    rel: function rel(el, eventName, listener, opts) {
      return el.removeEventListener(eventName, listener, opts);
    }
  };
  var supportsShadowDom = !!doc.documentElement.attachShadow;

  var supportsConstructibleStylesheets =
  /*@__PURE__*/
  function () {
    try {
      new CSSStyleSheet();
      return true;
    } catch (e) {}

    return false;
  }();

  var hostRefs = new WeakMap();

  var getHostRef = function getHostRef(ref) {
    return hostRefs.get(ref);
  };

  var registerInstance = function registerInstance(lazyInstance, hostRef) {
    return hostRefs.set(hostRef.$lazyInstance$ = lazyInstance, hostRef);
  };

  _exports.r = registerInstance;

  var registerHost = function registerHost(elm) {
    {
      var hostRef = {
        $flags$: 0,
        $hostElement$: elm,
        $instanceValues$: new Map()
      };
      hostRef.$onReadyPromise$ = new Promise(function (r) {
        return hostRef.$onReadyResolve$ = r;
      });
      return hostRefs.set(elm, hostRef);
    }
  };

  var isMemberInElement = function isMemberInElement(elm, memberName) {
    return memberName in elm;
  };

  var consoleError = function consoleError(e) {
    return console.error(e);
  };

  var moduleCache =
  /*@__PURE__*/
  new Map();

  var loadModule = function loadModule(cmpMeta, hostRef, hmrVersionId) {
    // loadModuleImport
    var exportName = cmpMeta.$tagName$.replace(/-/g, '_');
    var bundleId = cmpMeta.$lazyBundleIds$;
    var module = moduleCache.get(bundleId);

    if (module) {
      return module[exportName];
    }

    return new Promise(function (res, rej) {
      return _require.default([
      /* webpackInclude: /\.entry\.js$/ */

      /* webpackExclude: /\.system\.entry\.js$/ */

      /* webpackMode: "lazy" */
      "./".concat(bundleId, ".entry.js")], res, rej);
    }).then(function (importedModule) {
      {
        moduleCache.set(bundleId, importedModule);
      }
      return importedModule[exportName];
    }, consoleError);
  };

  var styles = new Map();
  var cssVarShim =
  /*@__PURE__*/
  win.__stencil_cssshim;
  var queueCongestion = 0;
  var queuePending = false;
  var queueDomReads = [];
  var queueDomWrites = [];
  var queueDomWritesLow = [];

  var queueTask = function queueTask(queue, write) {
    return function (cb) {
      queue.push(cb);

      if (!queuePending) {
        queuePending = true;

        if (write && plt.$flags$ & 4
        /* queueSync */
        ) {
            nextTick(flush);
          } else {
          plt.raf(flush);
        }
      }
    };
  };

  var consume = function consume(queue) {
    for (var i = 0; i < queue.length; i++) {
      try {
        queue[i](performance.now());
      } catch (e) {
        consoleError(e);
      }
    }

    queue.length = 0;
  };

  var consumeTimeout = function consumeTimeout(queue, timeout) {
    var i = 0;
    var ts = 0;

    while (i < queue.length && (ts = performance.now()) < timeout) {
      try {
        queue[i++](ts);
      } catch (e) {
        consoleError(e);
      }
    }

    if (i === queue.length) {
      queue.length = 0;
    } else if (i !== 0) {
      queue.splice(0, i);
    }
  };

  var flush = function flush() {
    queueCongestion++; // always force a bunch of medium callbacks to run, but still have
    // a throttle on how many can run in a certain time
    // DOM READS!!!

    consume(queueDomReads);
    var timeout = (plt.$flags$ & 6
    /* queueMask */
    ) === 2
    /* appLoaded */
    ? performance.now() + 10 * Math.ceil(queueCongestion * (1.0 / 22.0)) : Infinity; // DOM WRITES!!!

    consumeTimeout(queueDomWrites, timeout);
    consumeTimeout(queueDomWritesLow, timeout);

    if (queueDomWrites.length > 0) {
      queueDomWritesLow.push.apply(queueDomWritesLow, queueDomWrites);
      queueDomWrites.length = 0;
    }

    if (queuePending = queueDomReads.length + queueDomWrites.length + queueDomWritesLow.length > 0) {
      // still more to do yet, but we've run out of time
      // let's let this thing cool off and try again in the next tick
      plt.raf(flush);
    } else {
      queueCongestion = 0;
    }
  };

  var nextTick =
  /*@__PURE__*/
  function nextTick(cb) {
    return Promise.resolve().then(cb);
  };

  var writeTask =
  /*@__PURE__*/
  queueTask(queueDomWrites, true);
  /**
   * Default style mode id
   */

  /**
   * Reusable empty obj/array
   * Don't add values to these!!
   */

  var EMPTY_OBJ = {};

  var isDef = function isDef(v) {
    return v != null;
  };

  var toLowerCase = function toLowerCase(str) {
    return str.toLowerCase();
  };

  var isComplexType = function isComplexType(o) {
    return ['object', 'function'].includes(babelHelpers.typeof(o));
  };

  var getDynamicImportFunction = function getDynamicImportFunction(namespace) {
    return "__sc_import_".concat(namespace.replace(/\s|-/g, '_'));
  };

  var patchEsm = function patchEsm() {
    // @ts-ignore
    if (!(win.CSS && win.CSS.supports && win.CSS.supports('color', 'var(--c)'))) {
      // @ts-ignore
      return new Promise(function (res, rej) {
        return _require.default(['./css-shim-3ea8955c-3ea8955c.js'], res, rej);
      });
    }

    return Promise.resolve();
  };

  _exports.a = patchEsm;

  var patchBrowser =
  /*#__PURE__*/
  function () {
    var _ref = babelHelpers.asyncToGenerator(
    /*#__PURE__*/
    regeneratorRuntime.mark(function _callee() {
      var importMeta, regex, scriptElm, opts, resourcesUrl;
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              // @ts-ignore
              importMeta = "";
              regex = new RegExp("/".concat(NAMESPACE, "(.esm)?.js$"));
              scriptElm = Array.from(doc.querySelectorAll('script')).find(function (s) {
                return regex.test(s.src) || s.getAttribute('data-namespace') === NAMESPACE;
              });
              opts = scriptElm['data-opts'];

              if (!(importMeta !== '')) {
                _context.next = 8;
                break;
              }

              return _context.abrupt("return", Object.assign({}, opts, {
                resourcesUrl: new URL('.', importMeta).href
              }));

            case 8:
              resourcesUrl = new URL('.', new URL(scriptElm.getAttribute('data-resources-url') || scriptElm.src, win.location.href));
              patchDynamicImport(resourcesUrl.href);

              if (window.customElements) {
                _context.next = 13;
                break;
              }

              _context.next = 13;
              return new Promise(function (res, rej) {
                return _require.default(['./dom-860d8016-860d8016.js'], res, rej);
              });

            case 13:
              return _context.abrupt("return", Object.assign({}, opts, {
                resourcesUrl: resourcesUrl.href
              }));

            case 14:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function patchBrowser() {
      return _ref.apply(this, arguments);
    };
  }();

  _exports.p = patchBrowser;

  var patchDynamicImport = function patchDynamicImport(base) {
    var importFunctionName = getDynamicImportFunction(NAMESPACE);

    try {
      win[importFunctionName] = new Function('w', 'return import(w);');
    } catch (e) {
      var moduleMap = new Map();

      win[importFunctionName] = function (src) {
        var url = new URL(src, base).href;
        var mod = moduleMap.get(url);

        if (!mod) {
          var script = doc.createElement('script');
          script.type = 'module';
          script.src = URL.createObjectURL(new Blob(["import * as m from '".concat(url, "'; window.").concat(importFunctionName, ".m = m;")], {
            type: 'application/javascript'
          }));
          mod = new Promise(function (resolve) {
            script.onload = function () {
              resolve(win[importFunctionName].m);
              script.remove();
            };
          });
          moduleMap.set(url, mod);
          doc.head.appendChild(script);
        }

        return mod;
      };
    }
  };

  var parsePropertyValue = function parsePropertyValue(propValue, propType) {
    // ensure this value is of the correct prop type
    if (propValue != null && !isComplexType(propValue)) {
      if (propType & 4
      /* Boolean */
      ) {
          // per the HTML spec, any string value means it is a boolean true value
          // but we'll cheat here and say that the string "false" is the boolean false
          return propValue === 'false' ? false : propValue === '' || !!propValue;
        } // redundant return here for better minification


      return propValue;
    } // not sure exactly what type we want
    // so no need to change to a different type


    return propValue;
  };

  var HYDRATED_CLASS = 'hydrated';
  var rootAppliedStyles = new WeakMap();

  var registerStyle = function registerStyle(scopeId, cssText, allowCS) {
    var style = styles.get(scopeId);

    if (supportsConstructibleStylesheets && allowCS) {
      style = style || new CSSStyleSheet();
      style.replace(cssText);
    } else {
      style = cssText;
    }

    styles.set(scopeId, style);
  };

  var addStyle = function addStyle(styleContainerNode, cmpMeta, mode, hostElm) {
    var scopeId = getScopeId(cmpMeta.$tagName$);
    var style = styles.get(scopeId); // if an element is NOT connected then getRootNode() will return the wrong root node
    // so the fallback is to always use the document for the root node in those cases

    styleContainerNode = styleContainerNode.nodeType === 11
    /* DocumentFragment */
    ? styleContainerNode : doc;

    if (style) {
      if (typeof style === 'string') {
        styleContainerNode = styleContainerNode.head || styleContainerNode;
        var appliedStyles = rootAppliedStyles.get(styleContainerNode);
        var styleElm;

        if (!appliedStyles) {
          rootAppliedStyles.set(styleContainerNode, appliedStyles = new Set());
        }

        if (!appliedStyles.has(scopeId)) {
          {
            if (cssVarShim) {
              styleElm = cssVarShim.createHostStyle(hostElm, scopeId, style, !!(cmpMeta.$flags$ & 10
              /* needsScopedEncapsulation */
              ));
              var newScopeId = styleElm['s-sc'];

              if (newScopeId) {
                scopeId = newScopeId; // we don't want to add this styleID to the appliedStyles Set
                // since the cssVarShim might need to apply several different
                // stylesheets for the same component

                appliedStyles = null;
              }
            } else {
              styleElm = doc.createElement('style');
              styleElm.innerHTML = style;
            }

            styleContainerNode.insertBefore(styleElm, styleContainerNode.querySelector('link'));
          }

          if (appliedStyles) {
            appliedStyles.add(scopeId);
          }
        }
      } else if (!styleContainerNode.adoptedStyleSheets.includes(style)) {
        styleContainerNode.adoptedStyleSheets = [].concat(babelHelpers.toConsumableArray(styleContainerNode.adoptedStyleSheets), [style]);
      }
    }

    return scopeId;
  };

  var attachStyles = function attachStyles(elm, cmpMeta, mode) {
    var styleId = addStyle(supportsShadowDom && elm.shadowRoot ? elm.shadowRoot : elm.getRootNode(), cmpMeta, mode, elm);

    if (cmpMeta.$flags$ & 10
    /* needsScopedEncapsulation */
    ) {
        // only required when we're NOT using native shadow dom (slot)
        // or this browser doesn't support native shadow dom
        // and this host element was NOT created with SSR
        // let's pick out the inner content for slot projection
        // create a node to represent where the original
        // content was first placed, which is useful later on
        // DOM WRITE!!
        elm['s-sc'] = styleId;
        elm.classList.add(styleId + '-h');
      }
  };

  var getScopeId = function getScopeId(tagName, mode) {
    return 'sc-' + tagName;
  };
  /**
   * Production h() function based on Preact by
   * Jason Miller (@developit)
   * Licensed under the MIT License
   * https://github.com/developit/preact/blob/master/LICENSE
   *
   * Modified for Stencil's compiler and vdom
   */
  // const stack: any[] = [];
  // export function h(nodeName: string | d.FunctionalComponent, vnodeData: d.PropsType, child?: d.ChildType): d.VNode;
  // export function h(nodeName: string | d.FunctionalComponent, vnodeData: d.PropsType, ...children: d.ChildType[]): d.VNode;


  var h = function h(nodeName, vnodeData) {
    var child = null;
    var simple = false;
    var lastSimple = false;
    var key;
    var slotName;
    var vNodeChildren = [];

    var walk = function walk(c) {
      for (var i = 0; i < c.length; i++) {
        child = c[i];

        if (Array.isArray(child)) {
          walk(child);
        } else if (child != null && typeof child !== 'boolean') {
          if (simple = typeof nodeName !== 'function' && !isComplexType(child)) {
            child = String(child);
          }

          if (simple && lastSimple) {
            // If the previous child was simple (string), we merge both
            vNodeChildren[vNodeChildren.length - 1].$text$ += child;
          } else {
            // Append a new vNode, if it's text, we create a text vNode
            vNodeChildren.push(simple ? {
              $flags$: 0,
              $text$: child
            } : child);
          }

          lastSimple = simple;
        }
      }
    };

    for (var _len = arguments.length, children = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      children[_key - 2] = arguments[_key];
    }

    walk(children);

    if (vnodeData) {
      // normalize class / classname attributes
      {
        key = vnodeData.key || undefined;
      }
      {
        slotName = vnodeData.name;
      }
      {
        var classData = vnodeData.className || vnodeData.class;

        if (classData) {
          vnodeData.class = babelHelpers.typeof(classData) !== 'object' ? classData : Object.keys(classData).filter(function (k) {
            return classData[k];
          }).join(' ');
        }
      }
    }

    if (typeof nodeName === 'function') {
      // nodeName is a functional component
      return nodeName(vnodeData, vNodeChildren, vdomFnUtils);
    }

    var vnode = {
      $flags$: 0,
      $tag$: nodeName,
      $children$: vNodeChildren.length > 0 ? vNodeChildren : null,
      $elm$: undefined,
      $attrs$: vnodeData
    };
    {
      vnode.$key$ = key;
    }
    {
      vnode.$name$ = slotName;
    }
    return vnode;
  };

  _exports.h = h;
  var Host = {};

  var isHost = function isHost(node) {
    return node && node.$tag$ === Host;
  };

  var vdomFnUtils = {
    'forEach': function forEach(children, cb) {
      return children.map(convertToPublic).forEach(cb);
    },
    'map': function map(children, cb) {
      return children.map(convertToPublic).map(cb).map(convertToPrivate);
    }
  };

  var convertToPublic = function convertToPublic(node) {
    return {
      vattrs: node.$attrs$,
      vchildren: node.$children$,
      vkey: node.$key$,
      vname: node.$name$,
      vtag: node.$tag$,
      vtext: node.$text$
    };
  };

  var convertToPrivate = function convertToPrivate(node) {
    return {
      $flags$: 0,
      $attrs$: node.vattrs,
      $children$: node.vchildren,
      $key$: node.vkey,
      $name$: node.vname,
      $tag$: node.vtag,
      $text$: node.vtext
    };
  };
  /**
   * Production setAccessor() function based on Preact by
   * Jason Miller (@developit)
   * Licensed under the MIT License
   * https://github.com/developit/preact/blob/master/LICENSE
   *
   * Modified for Stencil's compiler and vdom
   */


  var setAccessor = function setAccessor(elm, memberName, oldValue, newValue, isSvg, flags) {
    if (oldValue === newValue) {
      return;
    }

    if (memberName === 'class') {
      var classList = elm.classList;
      parseClassList(oldValue).forEach(function (cls) {
        return classList.remove(cls);
      });
      parseClassList(newValue).forEach(function (cls) {
        return classList.add(cls);
      });
    } else if (memberName === 'style') {
      // update style attribute, css properties and values
      {
        for (var prop in oldValue) {
          if (!newValue || newValue[prop] == null) {
            if (prop.includes('-')) {
              elm.style.removeProperty(prop);
            } else {
              elm.style[prop] = '';
            }
          }
        }
      }

      for (var _prop in newValue) {
        if (!oldValue || newValue[_prop] !== oldValue[_prop]) {
          if (_prop.includes('-')) {
            elm.style.setProperty(_prop, newValue[_prop]);
          } else {
            elm.style[_prop] = newValue[_prop];
          }
        }
      }
    } else if (memberName === 'key') ;else if (memberName === 'ref') {
      // minifier will clean this up
      if (newValue) {
        newValue(elm);
      }
    } else if (memberName.startsWith('on') && !isMemberInElement(elm, memberName)) {
      // Event Handlers
      // so if the member name starts with "on" and the 3rd characters is
      // a capital letter, and it's not already a member on the element,
      // then we're assuming it's an event listener
      if (isMemberInElement(elm, toLowerCase(memberName))) {
        // standard event
        // the JSX attribute could have been "onMouseOver" and the
        // member name "onmouseover" is on the element's prototype
        // so let's add the listener "mouseover", which is all lowercased
        memberName = toLowerCase(memberName.substring(2));
      } else {
        // custom event
        // the JSX attribute could have been "onMyCustomEvent"
        // so let's trim off the "on" prefix and lowercase the first character
        // and add the listener "myCustomEvent"
        // except for the first character, we keep the event name case
        memberName = toLowerCase(memberName[2]) + memberName.substring(3);
      }

      if (oldValue) {
        plt.rel(elm, memberName, oldValue, false);
      }

      if (newValue) {
        plt.ael(elm, memberName, newValue, false);
      }
    } else {
      // Set property if it exists and it's not a SVG
      var isProp = isMemberInElement(elm, memberName);
      var isComplex = isComplexType(newValue);
      var isCustomElement = elm.tagName.includes('-');

      if ((isProp || isComplex && newValue !== null) && !isSvg) {
        try {
          if (isCustomElement) {
            elm[memberName] = newValue;
          } else if (elm[memberName] !== newValue || '') {
            elm[memberName] = newValue || '';
          }
        } catch (e) {}
      }

      if (newValue == null || newValue === false) {
        {
          elm.removeAttribute(memberName);
        }
      } else if ((!isProp || flags & 4
      /* isHost */
      || isSvg) && !isComplex) {
        newValue = newValue === true ? '' : newValue.toString();
        {
          elm.setAttribute(memberName, newValue);
        }
      }
    }
  };

  var parseClassList = function parseClassList(value) {
    return !value ? [] : value.split(/\s+/).filter(function (c) {
      return c;
    });
  };

  var updateElement = function updateElement(oldVnode, newVnode, isSvgMode, memberName) {
    // if the element passed in is a shadow root, which is a document fragment
    // then we want to be adding attrs/props to the shadow root's "host" element
    // if it's not a shadow root, then we add attrs/props to the same element
    var elm = newVnode.$elm$.nodeType === 11
    /* DocumentFragment */
    && newVnode.$elm$.host ? newVnode.$elm$.host : newVnode.$elm$;
    var oldVnodeAttrs = oldVnode && oldVnode.$attrs$ || EMPTY_OBJ;
    var newVnodeAttrs = newVnode.$attrs$ || EMPTY_OBJ;
    {
      // remove attributes no longer present on the vnode by setting them to undefined
      for (memberName in oldVnodeAttrs) {
        if (!(memberName in newVnodeAttrs)) {
          setAccessor(elm, memberName, oldVnodeAttrs[memberName], undefined, isSvgMode, newVnode.$flags$);
        }
      }
    } // add new & update changed attributes

    for (memberName in newVnodeAttrs) {
      setAccessor(elm, memberName, oldVnodeAttrs[memberName], newVnodeAttrs[memberName], isSvgMode, newVnode.$flags$);
    }
  };

  var scopeId;
  var contentRef;
  var hostTagName;
  var useNativeShadowDom = false;
  var checkSlotFallbackVisibility = false;
  var checkSlotRelocate = false;
  var isSvgMode = false;

  var createElm = function createElm(oldParentVNode, newParentVNode, childIndex, parentElm) {
    // tslint:disable-next-line: prefer-const
    var newVNode = newParentVNode.$children$[childIndex];
    var i = 0;
    var elm;
    var childNode;
    var oldVNode;

    if (!useNativeShadowDom) {
      // remember for later we need to check to relocate nodes
      checkSlotRelocate = true;

      if (newVNode.$tag$ === 'slot') {
        if (scopeId) {
          // scoped css needs to add its scoped id to the parent element
          parentElm.classList.add(scopeId + '-s');
        }

        if (!newVNode.$children$) {
          // slot element does not have fallback content
          // create an html comment we'll use to always reference
          // where actual slot content should sit next to
          newVNode.$flags$ |= 1
          /* isSlotReference */
          ;
        } else {
          // slot element has fallback content
          // still create an element that "mocks" the slot element
          newVNode.$flags$ |= 2
          /* isSlotFallback */
          ;
        }
      }
    }

    if (isDef(newVNode.$text$)) {
      // create text node
      newVNode.$elm$ = doc.createTextNode(newVNode.$text$);
    } else if (newVNode.$flags$ & 1
    /* isSlotReference */
    ) {
        // create a slot reference node
        newVNode.$elm$ = doc.createTextNode('');
      } else {
      // create element
      elm = newVNode.$elm$ = doc.createElement(newVNode.$flags$ & 2
      /* isSlotFallback */
      ? 'slot-fb' : newVNode.$tag$); // add css classes, attrs, props, listeners, etc.

      {
        updateElement(null, newVNode, isSvgMode);
      }

      if (isDef(scopeId) && elm['s-si'] !== scopeId) {
        // if there is a scopeId and this is the initial render
        // then let's add the scopeId as a css class
        elm.classList.add(elm['s-si'] = scopeId);
      }

      if (newVNode.$children$) {
        for (i = 0; i < newVNode.$children$.length; ++i) {
          // create the node
          childNode = createElm(oldParentVNode, newVNode, i, elm); // return node could have been null

          if (childNode) {
            // append our new node
            elm.appendChild(childNode);
          }
        }
      }
    }

    {
      newVNode.$elm$['s-hn'] = hostTagName;

      if (newVNode.$flags$ & (2
      /* isSlotFallback */
      | 1
      /* isSlotReference */
      )) {
        // remember the content reference comment
        newVNode.$elm$['s-sr'] = true; // remember the content reference comment

        newVNode.$elm$['s-cr'] = contentRef; // remember the slot name, or empty string for default slot

        newVNode.$elm$['s-sn'] = newVNode.$name$ || ''; // check if we've got an old vnode for this slot

        oldVNode = oldParentVNode && oldParentVNode.$children$ && oldParentVNode.$children$[childIndex];

        if (oldVNode && oldVNode.$tag$ === newVNode.$tag$ && oldParentVNode.$elm$) {
          // we've got an old slot vnode and the wrapper is being replaced
          // so let's move the old slot content back to it's original location
          putBackInOriginalLocation(oldParentVNode.$elm$, false);
        }
      }
    }
    return newVNode.$elm$;
  };

  var putBackInOriginalLocation = function putBackInOriginalLocation(parentElm, recursive) {
    plt.$flags$ |= 1
    /* isTmpDisconnected */
    ;
    var oldSlotChildNodes = parentElm.childNodes;

    for (var i = oldSlotChildNodes.length - 1; i >= 0; i--) {
      var childNode = oldSlotChildNodes[i];

      if (childNode['s-hn'] !== hostTagName && childNode['s-ol']) {
        // // this child node in the old element is from another component
        // // remove this node from the old slot's parent
        // childNode.remove();
        // and relocate it back to it's original location
        parentReferenceNode(childNode).insertBefore(childNode, referenceNode(childNode)); // remove the old original location comment entirely
        // later on the patch function will know what to do
        // and move this to the correct spot in need be

        childNode['s-ol'].remove();
        childNode['s-ol'] = undefined;
        checkSlotRelocate = true;
      }

      if (recursive) {
        putBackInOriginalLocation(childNode, recursive);
      }
    }

    plt.$flags$ &= ~1
    /* isTmpDisconnected */
    ;
  };

  var addVnodes = function addVnodes(parentElm, before, parentVNode, vnodes, startIdx, endIdx) {
    var containerElm = parentElm['s-cr'] && parentElm['s-cr'].parentNode || parentElm;
    var childNode;

    if (containerElm.shadowRoot && toLowerCase(containerElm.tagName) === hostTagName) {
      containerElm = containerElm.shadowRoot;
    }

    for (; startIdx <= endIdx; ++startIdx) {
      if (vnodes[startIdx]) {
        childNode = createElm(null, parentVNode, startIdx, parentElm);

        if (childNode) {
          vnodes[startIdx].$elm$ = childNode;
          containerElm.insertBefore(childNode, referenceNode(before));
        }
      }
    }
  };

  var removeVnodes = function removeVnodes(vnodes, startIdx, endIdx, elm) {
    for (; startIdx <= endIdx; ++startIdx) {
      if (isDef(vnodes[startIdx])) {
        elm = vnodes[startIdx].$elm$;
        callNodeRefs(vnodes[startIdx], true);
        {
          // we're removing this element
          // so it's possible we need to show slot fallback content now
          checkSlotFallbackVisibility = true;

          if (elm['s-ol']) {
            // remove the original location comment
            elm['s-ol'].remove();
          } else {
            // it's possible that child nodes of the node
            // that's being removed are slot nodes
            putBackInOriginalLocation(elm, true);
          }
        } // remove the vnode's element from the dom

        elm.remove();
      }
    }
  };

  var updateChildren = function updateChildren(parentElm, oldCh, newVNode, newCh) {
    var oldStartIdx = 0;
    var newStartIdx = 0;
    var idxInOld = 0;
    var i = 0;
    var oldEndIdx = oldCh.length - 1;
    var oldStartVnode = oldCh[0];
    var oldEndVnode = oldCh[oldEndIdx];
    var newEndIdx = newCh.length - 1;
    var newStartVnode = newCh[0];
    var newEndVnode = newCh[newEndIdx];
    var node;
    var elmToMove;

    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
      if (oldStartVnode == null) {
        // Vnode might have been moved left
        oldStartVnode = oldCh[++oldStartIdx];
      } else if (oldEndVnode == null) {
        oldEndVnode = oldCh[--oldEndIdx];
      } else if (newStartVnode == null) {
        newStartVnode = newCh[++newStartIdx];
      } else if (newEndVnode == null) {
        newEndVnode = newCh[--newEndIdx];
      } else if (isSameVnode(oldStartVnode, newStartVnode)) {
        patch(oldStartVnode, newStartVnode);
        oldStartVnode = oldCh[++oldStartIdx];
        newStartVnode = newCh[++newStartIdx];
      } else if (isSameVnode(oldEndVnode, newEndVnode)) {
        patch(oldEndVnode, newEndVnode);
        oldEndVnode = oldCh[--oldEndIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (isSameVnode(oldStartVnode, newEndVnode)) {
        // Vnode moved right
        if (oldStartVnode.$tag$ === 'slot' || newEndVnode.$tag$ === 'slot') {
          putBackInOriginalLocation(oldStartVnode.$elm$.parentNode, false);
        }

        patch(oldStartVnode, newEndVnode);
        parentElm.insertBefore(oldStartVnode.$elm$, oldEndVnode.$elm$.nextSibling);
        oldStartVnode = oldCh[++oldStartIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (isSameVnode(oldEndVnode, newStartVnode)) {
        // Vnode moved left
        if (oldStartVnode.$tag$ === 'slot' || newEndVnode.$tag$ === 'slot') {
          putBackInOriginalLocation(oldEndVnode.$elm$.parentNode, false);
        }

        patch(oldEndVnode, newStartVnode);
        parentElm.insertBefore(oldEndVnode.$elm$, oldStartVnode.$elm$);
        oldEndVnode = oldCh[--oldEndIdx];
        newStartVnode = newCh[++newStartIdx];
      } else {
        // createKeyToOldIdx
        idxInOld = -1;
        {
          for (i = oldStartIdx; i <= oldEndIdx; ++i) {
            if (oldCh[i] && isDef(oldCh[i].$key$) && oldCh[i].$key$ === newStartVnode.$key$) {
              idxInOld = i;
              break;
            }
          }
        }

        if (idxInOld >= 0) {
          elmToMove = oldCh[idxInOld];

          if (elmToMove.$tag$ !== newStartVnode.$tag$) {
            node = createElm(oldCh && oldCh[newStartIdx], newVNode, idxInOld, parentElm);
          } else {
            patch(elmToMove, newStartVnode);
            oldCh[idxInOld] = undefined;
            node = elmToMove.$elm$;
          }

          newStartVnode = newCh[++newStartIdx];
        } else {
          // new element
          node = createElm(oldCh && oldCh[newStartIdx], newVNode, newStartIdx, parentElm);
          newStartVnode = newCh[++newStartIdx];
        }

        if (node) {
          {
            parentReferenceNode(oldStartVnode.$elm$).insertBefore(node, referenceNode(oldStartVnode.$elm$));
          }
        }
      }
    }

    if (oldStartIdx > oldEndIdx) {
      addVnodes(parentElm, newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].$elm$, newVNode, newCh, newStartIdx, newEndIdx);
    } else if (newStartIdx > newEndIdx) {
      removeVnodes(oldCh, oldStartIdx, oldEndIdx);
    }
  };

  var isSameVnode = function isSameVnode(vnode1, vnode2) {
    // compare if two vnode to see if they're "technically" the same
    // need to have the same element tag, and same key to be the same
    if (vnode1.$tag$ === vnode2.$tag$) {
      if (vnode1.$tag$ === 'slot') {
        return vnode1.$name$ === vnode2.$name$;
      }

      {
        return vnode1.$key$ === vnode2.$key$;
      }
      return true;
    }

    return false;
  };

  var referenceNode = function referenceNode(node) {
    // this node was relocated to a new location in the dom
    // because of some other component's slot
    // but we still have an html comment in place of where
    // it's original location was according to it's original vdom
    return node && node['s-ol'] || node;
  };

  var parentReferenceNode = function parentReferenceNode(node) {
    return (node['s-ol'] ? node['s-ol'] : node).parentNode;
  };

  var patch = function patch(oldVNode, newVNode) {
    var elm = newVNode.$elm$ = oldVNode.$elm$;
    var oldChildren = oldVNode.$children$;
    var newChildren = newVNode.$children$;
    var defaultHolder;

    if (!isDef(newVNode.$text$)) {
      // element node
      {
        if (newVNode.$tag$ === 'slot') ;else {
          // either this is the first render of an element OR it's an update
          // AND we already know it's possible it could have changed
          // this updates the element's css classes, attrs, props, listeners, etc.
          updateElement(oldVNode, newVNode, isSvgMode);
        }
      }

      if (isDef(oldChildren) && isDef(newChildren)) {
        // looks like there's child vnodes for both the old and new vnodes
        updateChildren(elm, oldChildren, newVNode, newChildren);
      } else if (isDef(newChildren)) {
        // no old child vnodes, but there are new child vnodes to add
        if (isDef(oldVNode.$text$)) {
          // the old vnode was text, so be sure to clear it out
          elm.textContent = '';
        } // add the new vnode children


        addVnodes(elm, null, newVNode, newChildren, 0, newChildren.length - 1);
      } else if (isDef(oldChildren)) {
        // no new child vnodes, but there are old child vnodes to remove
        removeVnodes(oldChildren, 0, oldChildren.length - 1);
      }
    } else if (defaultHolder = elm['s-cr']) {
      // this element has slotted content
      defaultHolder.parentNode.textContent = newVNode.$text$;
    } else if (oldVNode.$text$ !== newVNode.$text$) {
      // update the text content for the text only vnode
      // and also only if the text is different than before
      elm.textContent = newVNode.$text$;
    }
  };

  var updateFallbackSlotVisibility = function updateFallbackSlotVisibility(elm, childNode, childNodes, i, ilen, j, slotNameAttr, nodeType) {
    childNodes = elm.childNodes;

    for (i = 0, ilen = childNodes.length; i < ilen; i++) {
      childNode = childNodes[i];

      if (childNode.nodeType === 1
      /* ElementNode */
      ) {
          if (childNode['s-sr']) {
            // this is a slot fallback node
            // get the slot name for this slot reference node
            slotNameAttr = childNode['s-sn']; // by default always show a fallback slot node
            // then hide it if there are other slots in the light dom

            childNode.hidden = false;

            for (j = 0; j < ilen; j++) {
              if (childNodes[j]['s-hn'] !== childNode['s-hn']) {
                // this sibling node is from a different component
                nodeType = childNodes[j].nodeType;

                if (slotNameAttr !== '') {
                  // this is a named fallback slot node
                  if (nodeType === 1
                  /* ElementNode */
                  && slotNameAttr === childNodes[j].getAttribute('slot')) {
                    childNode.hidden = true;
                    break;
                  }
                } else {
                  // this is a default fallback slot node
                  // any element or text node (with content)
                  // should hide the default fallback slot node
                  if (nodeType === 1
                  /* ElementNode */
                  || nodeType === 3
                  /* TextNode */
                  && childNodes[j].textContent.trim() !== '') {
                    childNode.hidden = true;
                    break;
                  }
                }
              }
            }
          } // keep drilling down


          updateFallbackSlotVisibility(childNode);
        }
    }
  };

  var relocateNodes = [];

  var relocateSlotContent = function relocateSlotContent(elm) {
    // tslint:disable-next-line: prefer-const
    var childNodes = elm.childNodes;
    var ilen = childNodes.length;
    var i = 0;
    var j = 0;
    var nodeType = 0;
    var childNode;
    var node;
    var hostContentNodes;
    var slotNameAttr;

    for (ilen = childNodes.length; i < ilen; i++) {
      childNode = childNodes[i];

      if (childNode['s-sr'] && (node = childNode['s-cr'])) {
        // first got the content reference comment node
        // then we got it's parent, which is where all the host content is in now
        hostContentNodes = node.parentNode.childNodes;
        slotNameAttr = childNode['s-sn'];

        for (j = hostContentNodes.length - 1; j >= 0; j--) {
          node = hostContentNodes[j];

          if (!node['s-cn'] && !node['s-nr'] && node['s-hn'] !== childNode['s-hn']) {
            // let's do some relocating to its new home
            // but never relocate a content reference node
            // that is suppose to always represent the original content location
            nodeType = node.nodeType;

            if ((nodeType === 3
            /* TextNode */
            || nodeType === 8
            /* CommentNode */
            ) && slotNameAttr === '' || nodeType === 1
            /* ElementNode */
            && node.getAttribute('slot') === null && slotNameAttr === '' || nodeType === 1
            /* ElementNode */
            && node.getAttribute('slot') === slotNameAttr) {
              // it's possible we've already decided to relocate this node
              if (!relocateNodes.some(function (r) {
                return r.$nodeToRelocate$ === node;
              })) {
                // made some changes to slots
                // let's make sure we also double check
                // fallbacks are correctly hidden or shown
                checkSlotFallbackVisibility = true;
                node['s-sn'] = slotNameAttr; // add to our list of nodes to relocate

                relocateNodes.push({
                  $slotRefNode$: childNode,
                  $nodeToRelocate$: node
                });
              }
            }
          }
        }
      }

      if (childNode.nodeType === 1
      /* ElementNode */
      ) {
          relocateSlotContent(childNode);
        }
    }
  };

  var callNodeRefs = function callNodeRefs(vNode, isDestroy) {
    if (vNode) {
      vNode.$attrs$ && vNode.$attrs$.ref && vNode.$attrs$.ref(isDestroy ? null : vNode.$elm$);
      vNode.$children$ && vNode.$children$.forEach(function (vChild) {
        callNodeRefs(vChild, isDestroy);
      });
    }
  };

  var renderVdom = function renderVdom(hostElm, hostRef, cmpMeta, renderFnResults) {
    hostTagName = toLowerCase(hostElm.tagName);
    var oldVNode = hostRef.$vnode$ || {
      $flags$: 0
    };
    var rootVnode = isHost(renderFnResults) ? renderFnResults : h(null, null, renderFnResults);
    rootVnode.$tag$ = null;
    rootVnode.$flags$ |= 4
    /* isHost */
    ;
    hostRef.$vnode$ = rootVnode;
    rootVnode.$elm$ = oldVNode.$elm$ = hostElm.shadowRoot || hostElm;
    {
      scopeId = hostElm['s-sc'];
    }
    {
      contentRef = hostElm['s-cr'];
      useNativeShadowDom = supportsShadowDom && (cmpMeta.$flags$ & 1
      /* shadowDomEncapsulation */
      ) !== 0; // always reset

      checkSlotRelocate = checkSlotFallbackVisibility = false;
    } // synchronous patch

    patch(oldVNode, rootVnode);
    {
      if (checkSlotRelocate) {
        relocateSlotContent(rootVnode.$elm$);

        for (var i = 0; i < relocateNodes.length; i++) {
          var relocateNode = relocateNodes[i];

          if (!relocateNode.$nodeToRelocate$['s-ol']) {
            // add a reference node marking this node's original location
            // keep a reference to this node for later lookups
            var orgLocationNode = doc.createTextNode('');
            orgLocationNode['s-nr'] = relocateNode.$nodeToRelocate$;
            relocateNode.$nodeToRelocate$.parentNode.insertBefore(relocateNode.$nodeToRelocate$['s-ol'] = orgLocationNode, relocateNode.$nodeToRelocate$);
          }
        } // while we're moving nodes around existing nodes, temporarily disable
        // the disconnectCallback from working


        plt.$flags$ |= 1
        /* isTmpDisconnected */
        ;

        for (var _i = 0; _i < relocateNodes.length; _i++) {
          var _relocateNode = relocateNodes[_i]; // by default we're just going to insert it directly
          // after the slot reference node

          var parentNodeRef = _relocateNode.$slotRefNode$.parentNode;
          var insertBeforeNode = _relocateNode.$slotRefNode$.nextSibling;
          var _orgLocationNode = _relocateNode.$nodeToRelocate$['s-ol'];

          while (_orgLocationNode = _orgLocationNode.previousSibling) {
            var refNode = _orgLocationNode['s-nr'];

            if (refNode && refNode['s-sn'] === _relocateNode.$nodeToRelocate$['s-sn'] && parentNodeRef === refNode.parentNode) {
              refNode = refNode.nextSibling;

              if (!refNode || !refNode['s-nr']) {
                insertBeforeNode = refNode;
                break;
              }
            }
          }

          if (!insertBeforeNode && parentNodeRef !== _relocateNode.$nodeToRelocate$.parentNode || _relocateNode.$nodeToRelocate$.nextSibling !== insertBeforeNode) {
            // we've checked that it's worth while to relocate
            // since that the node to relocate
            // has a different next sibling or parent relocated
            if (_relocateNode.$nodeToRelocate$ !== insertBeforeNode) {
              // add it back to the dom but in its new home
              parentNodeRef.insertBefore(_relocateNode.$nodeToRelocate$, insertBeforeNode);
            }
          }
        } // done moving nodes around
        // allow the disconnect callback to work again


        plt.$flags$ &= ~1
        /* isTmpDisconnected */
        ;
      }

      if (checkSlotFallbackVisibility) {
        updateFallbackSlotVisibility(rootVnode.$elm$);
      } // always reset


      relocateNodes.length = 0;
    }
  };

  var scheduleUpdate = function scheduleUpdate(elm, hostRef, cmpMeta, isInitialLoad) {
    {
      hostRef.$flags$ |= 16
      /* isQueuedForUpdate */
      ;
    }
    var instance = hostRef.$lazyInstance$;
    var promise; // there is no ancestorc omponent or the ancestor component
    // has already fired off its lifecycle update then
    // fire off the initial update

    var update = function update() {
      return updateComponent(elm, hostRef, cmpMeta, instance, isInitialLoad);
    };

    return then(promise, function () {
      return writeTask(update);
    });
  };

  var updateComponent = function updateComponent(elm, hostRef, cmpMeta, instance, isInitialLoad) {
    // updateComponent
    {
      hostRef.$flags$ &= ~16
      /* isQueuedForUpdate */
      ;
    }

    if (isInitialLoad) {
      // DOM WRITE!
      attachStyles(elm, cmpMeta, hostRef.$modeName$);
    }

    {
      {
        // tell the platform we're actively rendering
        // if a value is changed within a render() then
        // this tells the platform not to queue the change
        hostRef.$flags$ |= 4
        /* isActiveRender */
        ;

        try {
          // looks like we've got child nodes to render into this host element
          // or we need to update the css class/attrs on the host element
          // DOM WRITE!
          renderVdom(elm, hostRef, cmpMeta, instance.render());
        } catch (e) {
          consoleError(e);
        }

        hostRef.$flags$ &= ~4
        /* isActiveRender */
        ;
      }
    }

    if (cssVarShim) {
      cssVarShim.updateHost(elm);
    }

    {
      hostRef.$flags$ |= 2
      /* hasRendered */
      ;
    }
    postUpdateComponent(elm, hostRef);
  };

  var postUpdateComponent = function postUpdateComponent(elm, hostRef, ancestorsActivelyLoadingChildren) {
    if (!elm['s-al']) {
      var ancestorComponent = hostRef.$ancestorComponent$;

      if (!(hostRef.$flags$ & 64
      /* hasLoadedComponent */
      )) {
        hostRef.$flags$ |= 64
        /* hasLoadedComponent */
        ;
        {
          // DOM WRITE!
          // add the css class that this element has officially hydrated
          elm.classList.add(HYDRATED_CLASS);
        }
        {
          hostRef.$onReadyResolve$(elm);
        }

        if (!ancestorComponent) {
          appDidLoad();
        }
      } // ( •_•)
      // ( •_•)>⌐■-■
      // (⌐■_■)

    }
  };

  var _forceUpdate = function forceUpdate(elm, cmpMeta) {
    {
      var hostRef = getHostRef(elm);

      if (hostRef.$flags$ & 2
      /* hasRendered */
      ) {
          scheduleUpdate(elm, hostRef, cmpMeta, false);
        }
    }
  };

  var appDidLoad = function appDidLoad() {
    // on appload
    // we have finish the first big initial render
    {
      doc.documentElement.classList.add(HYDRATED_CLASS);
    }
    {
      plt.$flags$ |= 2
      /* appLoaded */
      ;
    }
  };

  var then = function then(promise, thenFn) {
    return promise && promise.then ? promise.then(thenFn) : thenFn();
  };

  var getValue = function getValue(ref, propName) {
    return getHostRef(ref).$instanceValues$.get(propName);
  };

  var setValue = function setValue(ref, propName, newVal, cmpMeta) {
    // check our new property value against our internal value
    var hostRef = getHostRef(ref);
    var elm = hostRef.$hostElement$;
    var oldVal = hostRef.$instanceValues$.get(propName);
    var flags = hostRef.$flags$;
    newVal = parsePropertyValue(newVal, cmpMeta.$members$[propName][0]);

    if (newVal !== oldVal && (!(flags & 8
    /* isConstructingInstance */
    ) || oldVal === undefined)) {
      // gadzooks! the property's value has changed!!
      // set our new value!
      hostRef.$instanceValues$.set(propName, newVal);

      if (hostRef.$lazyInstance$) {
        if ((flags & (4
        /* isActiveRender */
        | 2
        /* hasRendered */
        | 16
        /* isQueuedForUpdate */
        )) === 2
        /* hasRendered */
        ) {
            // looks like this value actually changed, so we've got work to do!
            // but only if we've already rendered, otherwise just chill out
            // queue that we need to do an update, but don't worry about queuing
            // up millions cuz this function ensures it only runs once
            scheduleUpdate(elm, hostRef, cmpMeta, false);
          }
      }
    }
  };

  var proxyComponent = function proxyComponent(Cstr, cmpMeta, flags) {
    if (cmpMeta.$members$) {
      // It's better to have a const than two Object.entries()
      var members = Object.entries(cmpMeta.$members$);
      var prototype = Cstr.prototype;
      members.forEach(function (_ref2) {
        var _ref3 = babelHelpers.slicedToArray(_ref2, 2),
            memberName = _ref3[0],
            _ref3$ = babelHelpers.slicedToArray(_ref3[1], 1),
            memberFlags = _ref3$[0];

        if (memberFlags & 31
        /* Prop */
        || flags & 2
        /* proxyState */
        && memberFlags & 32
        /* State */
        ) {
          // proxyComponent - prop
          Object.defineProperty(prototype, memberName, {
            get: function get() {
              // proxyComponent, get value
              return getValue(this, memberName);
            },
            set: function set(newValue) {
              // proxyComponent, set value
              setValue(this, memberName, newValue, cmpMeta);
            },
            configurable: true,
            enumerable: true
          });
        }
      });

      if (flags & 1
      /* isElementConstructor */
      ) {
          var attrNameToPropName = new Map();

          prototype.attributeChangedCallback = function (attrName, _oldValue, newValue) {
            var _this = this;

            plt.jmp(function () {
              var propName = attrNameToPropName.get(attrName);
              _this[propName] = newValue === null && typeof _this[propName] === 'boolean' ? false : newValue;
            });
          }; // create an array of attributes to observe
          // and also create a map of html attribute name to js property name


          Cstr.observedAttributes = members.filter(function (_ref4) {
            var _ref5 = babelHelpers.slicedToArray(_ref4, 2),
                _ = _ref5[0],
                m = _ref5[1];

            return m[0] & 15;
          }
          /* HasAttribute */
          ) // filter to only keep props that should match attributes
          .map(function (_ref6) {
            var _ref7 = babelHelpers.slicedToArray(_ref6, 2),
                propName = _ref7[0],
                m = _ref7[1];

            var attrName = m[1] || propName;
            attrNameToPropName.set(attrName, propName);
            return attrName;
          });
        }
    }

    return Cstr;
  };

  var initializeComponent =
  /*#__PURE__*/
  function () {
    var _ref8 = babelHelpers.asyncToGenerator(
    /*#__PURE__*/
    regeneratorRuntime.mark(function _callee2(elm, hostRef, cmpMeta, hmrVersionId, Cstr) {
      var style, _scopeId, shadowCssPolyfill, runtimeScopedCss, schedule;

      return regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (!((hostRef.$flags$ & 32
              /* hasInitializedComponent */
              ) === 0)) {
                _context2.next = 22;
                break;
              }

              // we haven't initialized this element yet
              hostRef.$flags$ |= 32
              /* hasInitializedComponent */
              ;
              // lazy loaded components
              // request the component's implementation to be
              // wired up with the host element
              Cstr = loadModule(cmpMeta);

              if (!Cstr.then) {
                _context2.next = 7;
                break;
              }

              _context2.next = 6;
              return Cstr;

            case 6:
              Cstr = _context2.sent;

            case 7:
              if (!Cstr.isProxied) {
                proxyComponent(Cstr, cmpMeta, 2
                /* proxyState */
                );
                Cstr.isProxied = true;
              } // ok, time to construct the instance
              // but let's keep track of when we start and stop
              // so that the getters/setters don't incorrectly step on data


              hostRef.$flags$ |= 8
              /* isConstructingInstance */
              ;

              // construct the lazy-loaded component implementation
              // passing the hostRef is very important during
              // construction in order to directly wire together the
              // host element and the lazy-loaded instance
              try {
                new Cstr(hostRef);
              } catch (e) {
                consoleError(e);
              }

              hostRef.$flags$ &= ~8
              /* isConstructingInstance */
              ;

              if (!(!Cstr.$isStyleRegistered$ && Cstr.style)) {
                _context2.next = 22;
                break;
              }

              // this component has styles but we haven't registered them yet
              style = Cstr.style;
              _scopeId = getScopeId(cmpMeta.$tagName$);
              shadowCssPolyfill = cmpMeta.$flags$ & 8
              /* needsShadowDomShim */
              ;
              runtimeScopedCss = BUILD.runtimeScopeCss
              /* scopedCssEncapsulation */
              ;

              if (!(shadowCssPolyfill || runtimeScopedCss)) {
                _context2.next = 20;
                break;
              }

              _context2.next = 19;
              return new Promise(function (res, rej) {
                return _require.default(['./shadow-css-bbdf056f-05cd1ccb.js'], res, rej);
              }).then(function (m) {
                return m.scopeCss(style, _scopeId, false);
              });

            case 19:
              style = _context2.sent;

            case 20:
              registerStyle(_scopeId, style, !!(cmpMeta.$flags$ & 1
              /* shadowDomEncapsulation */
              ));
              Cstr.$isStyleRegistered$ = true;

            case 22:
              schedule = function schedule() {
                return scheduleUpdate(elm, hostRef, cmpMeta, true);
              };

              schedule();

            case 24:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    return function initializeComponent(_x, _x2, _x3, _x4, _x5) {
      return _ref8.apply(this, arguments);
    };
  }();

  var _connectedCallback = function connectedCallback(elm, cmpMeta) {
    if ((plt.$flags$ & 1
    /* isTmpDisconnected */
    ) === 0) {
      // connectedCallback
      var hostRef = getHostRef(elm);

      if (!(hostRef.$flags$ & 1
      /* hasConnected */
      )) {
        // first time this component has connected
        hostRef.$flags$ |= 1
        /* hasConnected */
        ;
        var hostId;

        if (!hostId) {
          // initUpdate
          // if the slot polyfill is required we'll need to put some nodes
          // in here to act as original content anchors as we move nodes around
          // host element has been connected to the DOM
          if (cmpMeta.$flags$ & 4
          /* hasSlotRelocation */
          || cmpMeta.$flags$ & 8
          /* needsShadowDomShim */
          ) {
            setContentReference(elm);
          }
        } // Lazy properties
        // https://developers.google.com/web/fundamentals/web-components/best-practices#lazy-properties


        if (cmpMeta.$members$) {
          Object.entries(cmpMeta.$members$).forEach(function (_ref9) {
            var _ref10 = babelHelpers.slicedToArray(_ref9, 2),
                memberName = _ref10[0],
                _ref10$ = babelHelpers.slicedToArray(_ref10[1], 1),
                memberFlags = _ref10$[0];

            if (memberFlags & 31
            /* Prop */
            && elm.hasOwnProperty(memberName)) {
              var value = elm[memberName];
              delete elm[memberName];
              elm[memberName] = value;
            }
          });
        }

        {
          // connectedCallback, taskQueue, initialLoad
          // angular sets attribute AFTER connectCallback
          // https://github.com/angular/angular/issues/18909
          // https://github.com/angular/angular/issues/19940
          nextTick(function () {
            return initializeComponent(elm, hostRef, cmpMeta);
          });
        }
      }
    }
  };

  var setContentReference = function setContentReference(elm, contentRefElm) {
    // only required when we're NOT using native shadow dom (slot)
    // or this browser doesn't support native shadow dom
    // and this host element was NOT created with SSR
    // let's pick out the inner content for slot projection
    // create a node to represent where the original
    // content was first placed, which is useful later on
    var crName;
    {
      crName = '';
    }
    contentRefElm = elm['s-cr'] = doc.createComment(crName);
    contentRefElm['s-cn'] = true;
    elm.insertBefore(contentRefElm, elm.firstChild);
  };

  var _disconnectedCallback = function disconnectedCallback(elm) {
    if ((plt.$flags$ & 1
    /* isTmpDisconnected */
    ) === 0) {
      var hostRef = getHostRef(elm); // clear CSS var-shim tracking

      if (cssVarShim) {
        cssVarShim.removeHost(elm);
      }
    }
  };

  var bootstrapLazy = function bootstrapLazy(lazyBundles) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var cmpTags = [];
    var exclude = options.exclude || [];
    var head = doc.head;
    var customElements = win.customElements;
    var y =
    /*@__PURE__*/
    head.querySelector('meta[charset]');
    var visibilityStyle =
    /*@__PURE__*/
    doc.createElement('style');
    var appLoadFallback;
    Object.assign(plt, options);
    plt.$resourcesUrl$ = new URL(options.resourcesUrl || './', doc.baseURI).href;

    if (options.syncQueue) {
      plt.$flags$ |= 4
      /* queueSync */
      ;
    }

    lazyBundles.forEach(function (lazyBundle) {
      return lazyBundle[1].forEach(function (compactMeta) {
        var cmpMeta = {
          $flags$: compactMeta[0],
          $tagName$: compactMeta[1],
          $members$: compactMeta[2],
          $listeners$: compactMeta[3]
        };

        if (!supportsShadowDom && cmpMeta.$flags$ & 1
        /* shadowDomEncapsulation */
        ) {
            cmpMeta.$flags$ |= 8
            /* needsShadowDomShim */
            ;
          }

        var tagName = cmpMeta.$tagName$;

        var HostElement =
        /*#__PURE__*/
        function (_HTMLElement) {
          babelHelpers.inherits(HostElement, _HTMLElement);

          // StencilLazyHost
          function HostElement(self) {
            var _this2;

            babelHelpers.classCallCheck(this, HostElement);
            // @ts-ignore
            _this2 = babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(HostElement).call(this, self));
            self = babelHelpers.assertThisInitialized(_this2);
            registerHost(self);

            if (cmpMeta.$flags$ & 1
            /* shadowDomEncapsulation */
            ) {
                // this component is using shadow dom
                // and this browser supports shadow dom
                // add the read-only property "shadowRoot" to the host element
                if (supportsShadowDom) {
                  self.attachShadow({
                    'mode': 'open'
                  });
                } else if (!('shadowRoot' in self)) {
                  self.shadowRoot = self;
                }
              }

            return _this2;
          }

          babelHelpers.createClass(HostElement, [{
            key: "connectedCallback",
            value: function connectedCallback() {
              var _this3 = this;

              if (appLoadFallback) {
                clearTimeout(appLoadFallback);
                appLoadFallback = null;
              }

              plt.jmp(function () {
                return _connectedCallback(_this3, cmpMeta);
              });
            }
          }, {
            key: "disconnectedCallback",
            value: function disconnectedCallback() {
              var _this4 = this;

              plt.jmp(function () {
                return _disconnectedCallback(_this4);
              });
            }
          }, {
            key: 's-init',
            value: function sInit() {
              var hostRef = getHostRef(this);

              if (hostRef.$lazyInstance$) {
                postUpdateComponent(this, hostRef);
              }
            }
          }, {
            key: 's-hmr',
            value: function sHmr(hmrVersionId) {}
          }, {
            key: "forceUpdate",
            value: function forceUpdate() {
              _forceUpdate(this, cmpMeta);
            }
          }, {
            key: "componentOnReady",
            value: function componentOnReady() {
              return getHostRef(this).$onReadyPromise$;
            }
          }]);
          return HostElement;
        }(babelHelpers.wrapNativeSuper(HTMLElement));

        cmpMeta.$lazyBundleIds$ = lazyBundle[0];

        if (!exclude.includes(tagName) && !customElements.get(tagName)) {
          cmpTags.push(tagName);
          customElements.define(tagName, proxyComponent(HostElement, cmpMeta, 1
          /* isElementConstructor */
          ));
        }
      });
    }); // visibilityStyle.innerHTML = cmpTags.map(t => `${t}:not(.hydrated)`) + '{display:none}';

    visibilityStyle.innerHTML = cmpTags + '{visibility:hidden}.hydrated{visibility:inherit}';
    visibilityStyle.setAttribute('data-styles', '');
    head.insertBefore(visibilityStyle, y ? y.nextSibling : head.firstChild); // Fallback appLoad event

    plt.jmp(function () {
      return appLoadFallback = setTimeout(appDidLoad, 30);
    });
  };

  _exports.b = bootstrapLazy;

  var createEvent = function createEvent(ref, name, flags) {
    var elm = getElement(ref);
    return {
      emit: function emit(detail) {
        return elm.dispatchEvent(new CustomEvent(name, {
          bubbles: !!(flags & 4
          /* Bubbles */
          ),
          composed: !!(flags & 2
          /* Composed */
          ),
          cancelable: !!(flags & 1
          /* Cancellable */
          ),
          detail: detail
        }));
      }
    };
  };

  _exports.c = createEvent;

  var getElement = function getElement(ref) {
    return getHostRef(ref).$hostElement$;
  };

  _exports.g = getElement;
});