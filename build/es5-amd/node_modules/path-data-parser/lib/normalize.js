define(["exports"], function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.normalize = normalize;

  function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  // Normalize path to include only M, L, C, and Z commands
  function normalize(segments) {
    var out = [];
    var lastType = '';
    var cx = 0,
        cy = 0;
    var subx = 0,
        suby = 0;
    var lcx = 0,
        lcy = 0;

    var _iterator = _createForOfIteratorHelper(segments),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _step$value = _step.value,
            key = _step$value.key,
            data = _step$value.data;

        switch (key) {
          case 'M':
            out.push({
              key: 'M',
              data: babelHelpers.toConsumableArray(data)
            });

            var _data = babelHelpers.slicedToArray(data, 2);

            cx = _data[0];
            cy = _data[1];

            var _data2 = babelHelpers.slicedToArray(data, 2);

            subx = _data2[0];
            suby = _data2[1];
            break;

          case 'C':
            out.push({
              key: 'C',
              data: babelHelpers.toConsumableArray(data)
            });
            cx = data[4];
            cy = data[5];
            lcx = data[2];
            lcy = data[3];
            break;

          case 'L':
            out.push({
              key: 'L',
              data: babelHelpers.toConsumableArray(data)
            });

            var _data3 = babelHelpers.slicedToArray(data, 2);

            cx = _data3[0];
            cy = _data3[1];
            break;

          case 'H':
            cx = data[0];
            out.push({
              key: 'L',
              data: [cx, cy]
            });
            break;

          case 'V':
            cy = data[0];
            out.push({
              key: 'L',
              data: [cx, cy]
            });
            break;

          case 'S':
            {
              var cx1 = 0,
                  cy1 = 0;

              if (lastType === 'C' || lastType === 'S') {
                cx1 = cx + (cx - lcx);
                cy1 = cy + (cy - lcy);
              } else {
                cx1 = cx;
                cy1 = cy;
              }

              out.push({
                key: 'C',
                data: [cx1, cy1].concat(babelHelpers.toConsumableArray(data))
              });
              lcx = data[0];
              lcy = data[1];
              cx = data[2];
              cy = data[3];
              break;
            }

          case 'T':
            {
              var _data4 = babelHelpers.slicedToArray(data, 2),
                  x = _data4[0],
                  y = _data4[1];

              var x1 = 0,
                  y1 = 0;

              if (lastType === 'Q' || lastType === 'T') {
                x1 = cx + (cx - lcx);
                y1 = cy + (cy - lcy);
              } else {
                x1 = cx;
                y1 = cy;
              }

              var _cx = cx + 2 * (x1 - cx) / 3;

              var _cy = cy + 2 * (y1 - cy) / 3;

              var cx2 = x + 2 * (x1 - x) / 3;
              var cy2 = y + 2 * (y1 - y) / 3;
              out.push({
                key: 'C',
                data: [_cx, _cy, cx2, cy2, x, y]
              });
              lcx = x1;
              lcy = y1;
              cx = x;
              cy = y;
              break;
            }

          case 'Q':
            {
              var _data5 = babelHelpers.slicedToArray(data, 4),
                  _x = _data5[0],
                  _y = _data5[1],
                  _x2 = _data5[2],
                  _y2 = _data5[3];

              var _cx2 = cx + 2 * (_x - cx) / 3;

              var _cy2 = cy + 2 * (_y - cy) / 3;

              var _cx3 = _x2 + 2 * (_x - _x2) / 3;

              var _cy3 = _y2 + 2 * (_y - _y2) / 3;

              out.push({
                key: 'C',
                data: [_cx2, _cy2, _cx3, _cy3, _x2, _y2]
              });
              lcx = _x;
              lcy = _y;
              cx = _x2;
              cy = _y2;
              break;
            }

          case 'A':
            {
              var r1 = Math.abs(data[0]);
              var r2 = Math.abs(data[1]);
              var angle = data[2];
              var largeArcFlag = data[3];
              var sweepFlag = data[4];
              var _x3 = data[5];
              var _y3 = data[6];

              if (r1 === 0 || r2 === 0) {
                out.push({
                  key: 'C',
                  data: [cx, cy, _x3, _y3, _x3, _y3]
                });
                cx = _x3;
                cy = _y3;
              } else {
                if (cx !== _x3 || cy !== _y3) {
                  var curves = arcToCubicCurves(cx, cy, _x3, _y3, r1, r2, angle, largeArcFlag, sweepFlag);
                  curves.forEach(function (curve) {
                    out.push({
                      key: 'C',
                      data: curve
                    });
                  });
                  cx = _x3;
                  cy = _y3;
                }
              }

              break;
            }

          case 'Z':
            out.push({
              key: 'Z',
              data: []
            });
            cx = subx;
            cy = suby;
            break;
        }

        lastType = key;
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return out;
  }

  function degToRad(degrees) {
    return Math.PI * degrees / 180;
  }

  function rotate(x, y, angleRad) {
    var X = x * Math.cos(angleRad) - y * Math.sin(angleRad);
    var Y = x * Math.sin(angleRad) + y * Math.cos(angleRad);
    return [X, Y];
  }

  function arcToCubicCurves(x1, y1, x2, y2, r1, r2, angle, largeArcFlag, sweepFlag, recursive) {
    var angleRad = degToRad(angle);
    var params = [];
    var f1 = 0,
        f2 = 0,
        cx = 0,
        cy = 0;

    if (recursive) {
      var _recursive = babelHelpers.slicedToArray(recursive, 4);

      f1 = _recursive[0];
      f2 = _recursive[1];
      cx = _recursive[2];
      cy = _recursive[3];
    } else {
      var _rotate = rotate(x1, y1, -angleRad);

      var _rotate2 = babelHelpers.slicedToArray(_rotate, 2);

      x1 = _rotate2[0];
      y1 = _rotate2[1];

      var _rotate3 = rotate(x2, y2, -angleRad);

      var _rotate4 = babelHelpers.slicedToArray(_rotate3, 2);

      x2 = _rotate4[0];
      y2 = _rotate4[1];
      var x = (x1 - x2) / 2;
      var y = (y1 - y2) / 2;
      var h = x * x / (r1 * r1) + y * y / (r2 * r2);

      if (h > 1) {
        h = Math.sqrt(h);
        r1 = h * r1;
        r2 = h * r2;
      }

      var sign = largeArcFlag === sweepFlag ? -1 : 1;
      var r1Pow = r1 * r1;
      var r2Pow = r2 * r2;
      var left = r1Pow * r2Pow - r1Pow * y * y - r2Pow * x * x;
      var right = r1Pow * y * y + r2Pow * x * x;
      var k = sign * Math.sqrt(Math.abs(left / right));
      cx = k * r1 * y / r2 + (x1 + x2) / 2;
      cy = k * -r2 * x / r1 + (y1 + y2) / 2;
      f1 = Math.asin(parseFloat(((y1 - cy) / r2).toFixed(9)));
      f2 = Math.asin(parseFloat(((y2 - cy) / r2).toFixed(9)));

      if (x1 < cx) {
        f1 = Math.PI - f1;
      }

      if (x2 < cx) {
        f2 = Math.PI - f2;
      }

      if (f1 < 0) {
        f1 = Math.PI * 2 + f1;
      }

      if (f2 < 0) {
        f2 = Math.PI * 2 + f2;
      }

      if (sweepFlag && f1 > f2) {
        f1 = f1 - Math.PI * 2;
      }

      if (!sweepFlag && f2 > f1) {
        f2 = f2 - Math.PI * 2;
      }
    }

    var df = f2 - f1;

    if (Math.abs(df) > Math.PI * 120 / 180) {
      var f2old = f2;
      var x2old = x2;
      var y2old = y2;

      if (sweepFlag && f2 > f1) {
        f2 = f1 + Math.PI * 120 / 180 * 1;
      } else {
        f2 = f1 + Math.PI * 120 / 180 * -1;
      }

      x2 = cx + r1 * Math.cos(f2);
      y2 = cy + r2 * Math.sin(f2);
      params = arcToCubicCurves(x2, y2, x2old, y2old, r1, r2, angle, 0, sweepFlag, [f2, f2old, cx, cy]);
    }

    df = f2 - f1;
    var c1 = Math.cos(f1);
    var s1 = Math.sin(f1);
    var c2 = Math.cos(f2);
    var s2 = Math.sin(f2);
    var t = Math.tan(df / 4);
    var hx = 4 / 3 * r1 * t;
    var hy = 4 / 3 * r2 * t;
    var m1 = [x1, y1];
    var m2 = [x1 + hx * s1, y1 - hy * c1];
    var m3 = [x2 + hx * s2, y2 - hy * c2];
    var m4 = [x2, y2];
    m2[0] = 2 * m1[0] - m2[0];
    m2[1] = 2 * m1[1] - m2[1];

    if (recursive) {
      return [m2, m3, m4].concat(params);
    } else {
      params = [m2, m3, m4].concat(params);
      var curves = [];

      for (var i = 0; i < params.length; i += 3) {
        var _r = rotate(params[i][0], params[i][1], angleRad);

        var _r2 = rotate(params[i + 1][0], params[i + 1][1], angleRad);

        var r3 = rotate(params[i + 2][0], params[i + 2][1], angleRad);
        curves.push([_r[0], _r[1], _r2[0], _r2[1], r3[0], r3[1]]);
      }

      return curves;
    }
  }
});