define(["exports"], function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.eventName = void 0;
  _exports.findCaretFocus = findCaretFocus;
  _exports.getRange = getRange;

  /**
   * Copyright 2018 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License"); you may not
   * use this file except in compliance with the License. You may obtain a copy of
   * the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   * License for the specific language governing permissions and limitations under
   * the License.
   */
  var debug = false;
  var hasShadow = 'attachShadow' in Element.prototype && 'getRootNode' in Element.prototype;
  var hasSelection = !!(hasShadow && document.createElement('div').attachShadow({
    mode: 'open'
  }).getSelection);
  var hasShady = window.ShadyDOM && window.ShadyDOM.inUse;
  var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
  var useDocument = !hasShadow || hasShady || !hasSelection && !isSafari;
  var invalidPartialElements = /^(area|base|br|col|command|embed|hr|img|input|keygen|link|meta|param|script|source|style|template|track|wbr)$/;
  var eventName = '-shadow-selectionchange';
  _exports.eventName = eventName;
  var validNodeTypes = [Node.ELEMENT_NODE, Node.TEXT_NODE, Node.DOCUMENT_FRAGMENT_NODE];

  function isValidNode(node) {
    return validNodeTypes.includes(node.nodeType);
  }
  /**
   * @param {!Selection} s selection to use
   * @param {!Node} node to find caret position within a shadow root
   * @return {!Node|!ShadowRoot}
   */


  function findCaretFocus(s, node) {
    var pending = [];

    var pushAll = function pushAll(nodeList) {
      for (var i = 0; i < nodeList.length; ++i) {
        if (nodeList[i].shadowRoot) {
          pending.push(nodeList[i].shadowRoot);
        }
      }
    }; // We're told by Safari that a node containing a child with a Shadow Root is selected, but check
    // the node directly too (just in case they change their mind later).


    if (node.shadowRoot) {
      pending.push(node.shadowRoot);
    }

    pushAll(node.childNodes);

    while (pending.length) {
      var root = pending.shift();

      for (var i = 0; i < root.childNodes.length; ++i) {
        if (s.containsNode(root.childNodes[i], true)) {
          return root;
        }
      } // The selection must be inside a further Shadow Root, but there's no good way to get a list of
      // them. Safari won't tell you what regular node contains the root which has a selection. So,
      // unfortunately if you stack them this will be slow(-ish).


      pushAll(root.querySelectorAll('*'));
    }

    return null;
  }

  function findNode(s, parentNode, isLeft) {
    var nodes = parentNode.childNodes || parentNode.children;

    if (!nodes) {
      return parentNode; // found it, probably text
    }

    for (var i = 0; i < nodes.length; ++i) {
      var j = isLeft ? i : nodes.length - 1 - i;
      var childNode = nodes[j];

      if (!isValidNode(childNode)) {
        continue;
      }

      debug && console.debug('checking child', childNode, 'IsLeft', isLeft);

      if (s.containsNode(childNode, true)) {
        if (s.containsNode(childNode, false)) {
          debug && console.info('found child', childNode);
          return childNode;
        } // Special-case elements that cannot have feasible children.


        if (!invalidPartialElements.exec(childNode.localName || '')) {
          debug && console.info('descending child', childNode);
          return findNode(s, childNode, isLeft);
        }
      }

      debug && console.info(parentNode, 'does NOT contain', childNode);
    }

    return parentNode;
  }

  var recentCaretRange = {
    node: null,
    offset: -1
  };

  (function () {
    if (hasSelection || useDocument) {
      // getSelection exists or document API can be used
      document.addEventListener('selectionchange', function (ev) {
        document.dispatchEvent(new CustomEvent(eventName));
      });
      return function () {};
    }

    var withinInternals = false;
    document.addEventListener('selectionchange', function (ev) {
      if (withinInternals) {
        return;
      }

      withinInternals = true;
      var s = window.getSelection();

      if (s.type === 'Caret') {
        var root = findCaretFocus(s, s.anchorNode);

        if (babelHelpers.instanceof(root, window.ShadowRoot)) {
          var range = getRange(root);

          if (range) {
            var node = range.startContainer;
            var offset = range.startOffset;
            recentCaretRange = {
              node: node,
              offset: offset
            };
          }
        }
      }

      document.dispatchEvent(new CustomEvent('-shadow-selectionchange'));
      window.requestAnimationFrame(function () {
        withinInternals = false;
      });
    });
  })();
  /**
   * @param {!Selection} s the window selection to use
   * @param {!Node} node the node to walk from
   * @param {boolean} walkForward should this walk in natural direction
   * @return {boolean} whether the selection contains the following node (even partially)
   */


  function containsNextElement(s, node, walkForward) {
    var start = node;

    while (node = walkFromNode(node, walkForward)) {
      // walking (left) can contain our own parent, which we don't want
      if (!node.contains(start)) {
        break;
      }
    }

    if (!node) {
      return false;
    } // we look for Element as .containsNode says true for _every_ text node, and we only care about
    // elements themselves


    return babelHelpers.instanceof(node, Element) && s.containsNode(node, true);
  }
  /**
   * @param {!Selection} s the window selection to use
   * @param {!Node} leftNode the left node
   * @param {!Node} rightNode the right node
   * @return {boolean|undefined} whether this has natural direction
   */


  function getSelectionDirection(s, leftNode, rightNode) {
    if (s.type !== 'Range') {
      return undefined; // no direction
    }

    var measure = function measure() {
      return s.toString().length;
    };

    var initialSize = measure();
    debug && console.info("initial selection: \"".concat(s.toString(), "\""));
    var updatedSize; // Try extending forward and seeing what happens.

    s.modify('extend', 'forward', 'character');
    updatedSize = measure();
    debug && console.info("forward selection: \"".concat(s.toString(), "\""));

    if (updatedSize > initialSize || containsNextElement(s, rightNode, true)) {
      debug && console.info('got forward >, moving right');
      s.modify('extend', 'backward', 'character');
      return true;
    } else if (updatedSize < initialSize || !s.containsNode(leftNode)) {
      debug && console.info('got forward <, moving left');
      s.modify('extend', 'backward', 'character');
      return false;
    } // Maybe we were at the end of something. Extend backwards instead.


    s.modify('extend', 'backward', 'character');
    updatedSize = measure();
    debug && console.info("backward selection: \"".concat(s.toString(), "\""));

    if (updatedSize > initialSize || containsNextElement(s, leftNode, false)) {
      debug && console.info('got backwards >, moving left');
      s.modify('extend', 'forward', 'character');
      return false;
    } else if (updatedSize < initialSize || !s.containsNode(rightNode)) {
      debug && console.info('got backwards <, moving right');
      s.modify('extend', 'forward', 'character');
      return true;
    } // This is likely a select-all.


    return undefined;
  }
  /**
   * Returns the next valid node (element or text). This is needed as Safari doesn't support
   * TreeWalker inside Shadow DOM. Don't escape shadow roots.
   *
   * @param {!Node} node to start from
   * @param {boolean} walkForward should this walk in natural direction
   * @return {Node} node found, if any
   */


  function walkFromNode(node, walkForward) {
    if (!walkForward) {
      return node.previousSibling || node.parentNode || null;
    }

    while (node) {
      if (node.nextSibling) {
        return node.nextSibling;
      }

      node = node.parentNode;
    }

    return null;
  }

  var cachedRange = new Map();

  function getRange(root) {
    if (useDocument) {
      // Document pierces Shadow Root for selection, so actively filter it down to the right node.
      // This is only for Firefox, which does not allow selection across Shadow Root boundaries.
      var s = document.getSelection();

      if (s.containsNode(root, true)) {
        return s.getRangeAt(0);
      }

      return null;
    } else if (hasSelection) {
      var _s = root.getSelection();

      return _s.rangeCount ? _s.getRangeAt(0) : null;
    }

    var thisFrame = cachedRange.get(root);

    if (thisFrame) {
      return thisFrame;
    }

    var result = internalGetShadowSelection(root);
    cachedRange.set(root, result.range);
    window.setTimeout(function () {
      cachedRange.delete(root);
    }, 0);
    debug && console.debug('getRange got', result);
    return result.range;
  }

  function internalGetShadowSelection(root) {
    // nb. We used to check whether the selection contained the host, but this broke in Safari 13.
    // This is "nicely formatted" whitespace as per the browser's renderer. This is fine, and we only
    // provide selection information at this granularity.
    var s = window.getSelection();

    if (s.type === 'None') {
      return {
        range: null,
        type: 'none'
      };
    } else if (!(s.type === 'Caret' || s.type === 'Range')) {
      throw new TypeError('unexpected type: ' + s.type);
    }

    var leftNode = findNode(s, root, true);

    if (leftNode === root) {
      return {
        range: null,
        mode: 'none'
      };
    }

    var range = document.createRange();
    var rightNode = null;
    var isNaturalDirection = undefined;

    if (s.type === 'Range') {
      rightNode = findNode(s, root, false); // get right node here _before_ getSelectionDirection

      isNaturalDirection = getSelectionDirection(s, leftNode, rightNode); // isNaturalDirection means "going right"

      if (isNaturalDirection === undefined) {
        // This occurs when we can't move because we can't extend left or right to measure the
        // direction we're moving in... because it's the entire range. Hooray!
        range.setStart(leftNode, 0);
        range.setEnd(rightNode, rightNode.length);
        return {
          range: range,
          mode: 'all'
        };
      }
    }

    var initialSize = s.toString().length; // Dumbest possible approach: remove characters from left side until no more selection,
    // re-add.
    // Try right side first, as we can trim characters until selection gets shorter.

    var leftOffset = 0;
    var rightOffset = 0;

    if (rightNode === null) {// This is a caret selection, do nothing.
    } else if (rightNode.nodeType === Node.TEXT_NODE) {
      var rightText = rightNode.textContent;
      var existingNextSibling = rightNode.nextSibling;

      for (var i = rightText.length - 1; i >= 0; --i) {
        rightNode.splitText(i);
        var updatedSize = s.toString().length;

        if (updatedSize !== initialSize) {
          rightOffset = i + 1;
          break;
        }
      } // We don't use .normalize() here, as the user might already have a weird node arrangement
      // they need to maintain.


      rightNode.insertData(rightNode.length, rightText.substr(rightNode.length));

      while (rightNode.nextSibling !== existingNextSibling) {
        rightNode.nextSibling.remove();
      }
    }

    if (leftNode.nodeType === Node.TEXT_NODE) {
      if (leftNode !== rightNode) {
        // If we're at the end of a text node, it's impossible to extend the selection, so add an
        // extra character to select (that we delete later).
        leftNode.appendData('?');
        s.collapseToStart();
        s.modify('extend', 'right', 'character');
      }

      var leftText = leftNode.textContent;
      var _existingNextSibling = leftNode.nextSibling;
      var start = leftNode === rightNode ? rightOffset : leftText.length - 1;

      for (var _i = start; _i >= 0; --_i) {
        leftNode.splitText(_i);

        if (s.toString() === '') {
          leftOffset = _i;
          break;
        }
      } // As above, we don't want to use .normalize().


      leftNode.insertData(leftNode.length, leftText.substr(leftNode.length));

      while (leftNode.nextSibling !== _existingNextSibling) {
        leftNode.nextSibling.remove();
      }

      if (leftNode !== rightNode) {
        leftNode.deleteData(leftNode.length - 1, 1);
      }

      if (rightNode === null) {
        rightNode = leftNode;
        rightOffset = leftOffset;
      }
    } else if (rightNode === null) {
      rightNode = leftNode;
    } // Work around common browser bug. Single character selction is always seen as 'forward'. Check
    // if it's actually supposed to be backward.


    if (initialSize === 1 && recentCaretRange && recentCaretRange.node === leftNode) {
      if (recentCaretRange.offset > leftOffset && isNaturalDirection) {
        isNaturalDirection = false;
      }
    }

    if (isNaturalDirection === true) {
      s.collapse(leftNode, leftOffset);
      s.extend(rightNode, rightOffset);
    } else if (isNaturalDirection === false) {
      s.collapse(rightNode, rightOffset);
      s.extend(leftNode, leftOffset);
    } else {
      s.setPosition(leftNode, leftOffset);
    }

    range.setStart(leftNode, leftOffset);
    range.setEnd(rightNode, rightOffset);
    return {
      range: range,
      mode: 'normal'
    };
  }
});