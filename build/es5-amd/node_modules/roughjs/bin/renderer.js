define(["exports", "./fillers/filler.js", "./math.js", "../../path-data-parser/lib/index.js"], function (_exports, _filler, _math, _index) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.arc = arc;
  _exports.curve = curve;
  _exports.doubleLineFillOps = doubleLineFillOps;
  _exports.ellipse = ellipse;
  _exports.ellipseWithParams = ellipseWithParams;
  _exports.generateEllipseParams = generateEllipseParams;
  _exports.line = line;
  _exports.linearPath = linearPath;
  _exports.patternFillArc = patternFillArc;
  _exports.patternFillPolygon = patternFillPolygon;
  _exports.polygon = polygon;
  _exports.randOffset = randOffset;
  _exports.randOffsetWithRange = randOffsetWithRange;
  _exports.rectangle = rectangle;
  _exports.solidFillPolygon = solidFillPolygon;
  _exports.svgPath = svgPath;

  function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  var helper = {
    randOffset: randOffset,
    randOffsetWithRange: randOffsetWithRange,
    ellipse: ellipse,
    doubleLineOps: doubleLineFillOps
  };

  function line(x1, y1, x2, y2, o) {
    return {
      type: 'path',
      ops: _doubleLine(x1, y1, x2, y2, o)
    };
  }

  function linearPath(points, close, o) {
    var len = (points || []).length;

    if (len > 2) {
      var ops = [];

      for (var i = 0; i < len - 1; i++) {
        ops.push.apply(ops, babelHelpers.toConsumableArray(_doubleLine(points[i][0], points[i][1], points[i + 1][0], points[i + 1][1], o)));
      }

      if (close) {
        ops.push.apply(ops, babelHelpers.toConsumableArray(_doubleLine(points[len - 1][0], points[len - 1][1], points[0][0], points[0][1], o)));
      }

      return {
        type: 'path',
        ops: ops
      };
    } else if (len === 2) {
      return line(points[0][0], points[0][1], points[1][0], points[1][1], o);
    }

    return {
      type: 'path',
      ops: []
    };
  }

  function polygon(points, o) {
    return linearPath(points, true, o);
  }

  function rectangle(x, y, width, height, o) {
    var points = [[x, y], [x + width, y], [x + width, y + height], [x, y + height]];
    return polygon(points, o);
  }

  function curve(points, o) {
    var o1 = _curveWithOffset(points, 1 * (1 + o.roughness * 0.2), o);

    if (!o.disableMultiStroke) {
      var o2 = _curveWithOffset(points, 1.5 * (1 + o.roughness * 0.22), cloneOptionsAlterSeed(o));

      o1 = o1.concat(o2);
    }

    return {
      type: 'path',
      ops: o1
    };
  }

  function ellipse(x, y, width, height, o) {
    var params = generateEllipseParams(width, height, o);
    return ellipseWithParams(x, y, o, params).opset;
  }

  function generateEllipseParams(width, height, o) {
    var psq = Math.sqrt(Math.PI * 2 * Math.sqrt((Math.pow(width / 2, 2) + Math.pow(height / 2, 2)) / 2));
    var stepCount = Math.max(o.curveStepCount, o.curveStepCount / Math.sqrt(200) * psq);
    var increment = Math.PI * 2 / stepCount;
    var rx = Math.abs(width / 2);
    var ry = Math.abs(height / 2);
    var curveFitRandomness = 1 - o.curveFitting;
    rx += _offsetOpt(rx * curveFitRandomness, o);
    ry += _offsetOpt(ry * curveFitRandomness, o);
    return {
      increment: increment,
      rx: rx,
      ry: ry
    };
  }

  function ellipseWithParams(x, y, o, ellipseParams) {
    var _computeEllipsePoints2 = _computeEllipsePoints(ellipseParams.increment, x, y, ellipseParams.rx, ellipseParams.ry, 1, ellipseParams.increment * _offset(0.1, _offset(0.4, 1, o), o), o),
        _computeEllipsePoints3 = babelHelpers.slicedToArray(_computeEllipsePoints2, 2),
        ap1 = _computeEllipsePoints3[0],
        cp1 = _computeEllipsePoints3[1];

    var o1 = _curve(ap1, null, o);

    if (!o.disableMultiStroke && o.roughness !== 0) {
      var _computeEllipsePoints4 = _computeEllipsePoints(ellipseParams.increment, x, y, ellipseParams.rx, ellipseParams.ry, 1.5, 0, o),
          _computeEllipsePoints5 = babelHelpers.slicedToArray(_computeEllipsePoints4, 1),
          ap2 = _computeEllipsePoints5[0];

      var o2 = _curve(ap2, null, o);

      o1 = o1.concat(o2);
    }

    return {
      estimatedPoints: cp1,
      opset: {
        type: 'path',
        ops: o1
      }
    };
  }

  function arc(x, y, width, height, start, stop, closed, roughClosure, o) {
    var cx = x;
    var cy = y;
    var rx = Math.abs(width / 2);
    var ry = Math.abs(height / 2);
    rx += _offsetOpt(rx * 0.01, o);
    ry += _offsetOpt(ry * 0.01, o);
    var strt = start;
    var stp = stop;

    while (strt < 0) {
      strt += Math.PI * 2;
      stp += Math.PI * 2;
    }

    if (stp - strt > Math.PI * 2) {
      strt = 0;
      stp = Math.PI * 2;
    }

    var ellipseInc = Math.PI * 2 / o.curveStepCount;
    var arcInc = Math.min(ellipseInc / 2, (stp - strt) / 2);

    var ops = _arc(arcInc, cx, cy, rx, ry, strt, stp, 1, o);

    if (!o.disableMultiStroke) {
      var o2 = _arc(arcInc, cx, cy, rx, ry, strt, stp, 1.5, o);

      ops.push.apply(ops, babelHelpers.toConsumableArray(o2));
    }

    if (closed) {
      if (roughClosure) {
        ops.push.apply(ops, babelHelpers.toConsumableArray(_doubleLine(cx, cy, cx + rx * Math.cos(strt), cy + ry * Math.sin(strt), o)).concat(babelHelpers.toConsumableArray(_doubleLine(cx, cy, cx + rx * Math.cos(stp), cy + ry * Math.sin(stp), o))));
      } else {
        ops.push({
          op: 'lineTo',
          data: [cx, cy]
        }, {
          op: 'lineTo',
          data: [cx + rx * Math.cos(strt), cy + ry * Math.sin(strt)]
        });
      }
    }

    return {
      type: 'path',
      ops: ops
    };
  }

  function svgPath(path, o) {
    var segments = (0, _index.normalize)((0, _index.absolutize)((0, _index.parsePath)(path)));
    var ops = [];
    var first = [0, 0];
    var current = [0, 0];

    var _iterator = _createForOfIteratorHelper(segments),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _step$value = _step.value,
            key = _step$value.key,
            data = _step$value.data;

        switch (key) {
          case 'M':
            {
              var _ret = function () {
                var ro = 1 * (o.maxRandomnessOffset || 0);
                var pv = o.preserveVertices;
                ops.push({
                  op: 'move',
                  data: data.map(function (d) {
                    return d + (pv ? 0 : _offsetOpt(ro, o));
                  })
                });
                current = [data[0], data[1]];
                first = [data[0], data[1]];
                return "break";
              }();

              if (_ret === "break") break;
            }

          case 'L':
            ops.push.apply(ops, babelHelpers.toConsumableArray(_doubleLine(current[0], current[1], data[0], data[1], o)));
            current = [data[0], data[1]];
            break;

          case 'C':
            {
              var _data = babelHelpers.slicedToArray(data, 6),
                  x1 = _data[0],
                  y1 = _data[1],
                  x2 = _data[2],
                  y2 = _data[3],
                  x = _data[4],
                  y = _data[5];

              ops.push.apply(ops, babelHelpers.toConsumableArray(_bezierTo(x1, y1, x2, y2, x, y, current, o)));
              current = [x, y];
              break;
            }

          case 'Z':
            ops.push.apply(ops, babelHelpers.toConsumableArray(_doubleLine(current[0], current[1], first[0], first[1], o)));
            current = [first[0], first[1]];
            break;
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return {
      type: 'path',
      ops: ops
    };
  } // Fills


  function solidFillPolygon(points, o) {
    var ops = [];

    if (points.length) {
      var offset = o.maxRandomnessOffset || 0;
      var len = points.length;

      if (len > 2) {
        ops.push({
          op: 'move',
          data: [points[0][0] + _offsetOpt(offset, o), points[0][1] + _offsetOpt(offset, o)]
        });

        for (var i = 1; i < len; i++) {
          ops.push({
            op: 'lineTo',
            data: [points[i][0] + _offsetOpt(offset, o), points[i][1] + _offsetOpt(offset, o)]
          });
        }
      }
    }

    return {
      type: 'fillPath',
      ops: ops
    };
  }

  function patternFillPolygon(points, o) {
    return (0, _filler.getFiller)(o, helper).fillPolygon(points, o);
  }

  function patternFillArc(x, y, width, height, start, stop, o) {
    var cx = x;
    var cy = y;
    var rx = Math.abs(width / 2);
    var ry = Math.abs(height / 2);
    rx += _offsetOpt(rx * 0.01, o);
    ry += _offsetOpt(ry * 0.01, o);
    var strt = start;
    var stp = stop;

    while (strt < 0) {
      strt += Math.PI * 2;
      stp += Math.PI * 2;
    }

    if (stp - strt > Math.PI * 2) {
      strt = 0;
      stp = Math.PI * 2;
    }

    var increment = (stp - strt) / o.curveStepCount;
    var points = [];

    for (var angle = strt; angle <= stp; angle = angle + increment) {
      points.push([cx + rx * Math.cos(angle), cy + ry * Math.sin(angle)]);
    }

    points.push([cx + rx * Math.cos(stp), cy + ry * Math.sin(stp)]);
    points.push([cx, cy]);
    return patternFillPolygon(points, o);
  }

  function randOffset(x, o) {
    return _offsetOpt(x, o);
  }

  function randOffsetWithRange(min, max, o) {
    return _offset(min, max, o);
  }

  function doubleLineFillOps(x1, y1, x2, y2, o) {
    return _doubleLine(x1, y1, x2, y2, o, true);
  } // Private helpers


  function cloneOptionsAlterSeed(ops) {
    var result = Object.assign({}, ops);
    result.randomizer = undefined;

    if (ops.seed) {
      result.seed = ops.seed + 1;
    }

    return result;
  }

  function random(ops) {
    if (!ops.randomizer) {
      ops.randomizer = new _math.Random(ops.seed || 0);
    }

    return ops.randomizer.next();
  }

  function _offset(min, max, ops) {
    var roughnessGain = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
    return ops.roughness * roughnessGain * (random(ops) * (max - min) + min);
  }

  function _offsetOpt(x, ops) {
    var roughnessGain = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    return _offset(-x, x, ops, roughnessGain);
  }

  function _doubleLine(x1, y1, x2, y2, o) {
    var filling = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
    var singleStroke = filling ? o.disableMultiStrokeFill : o.disableMultiStroke;

    var o1 = _line(x1, y1, x2, y2, o, true, false);

    if (singleStroke) {
      return o1;
    }

    var o2 = _line(x1, y1, x2, y2, o, true, true);

    return o1.concat(o2);
  }

  function _line(x1, y1, x2, y2, o, move, overlay) {
    var lengthSq = Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2);
    var length = Math.sqrt(lengthSq);
    var roughnessGain = 1;

    if (length < 200) {
      roughnessGain = 1;
    } else if (length > 500) {
      roughnessGain = 0.4;
    } else {
      roughnessGain = -0.0016668 * length + 1.233334;
    }

    var offset = o.maxRandomnessOffset || 0;

    if (offset * offset * 100 > lengthSq) {
      offset = length / 10;
    }

    var halfOffset = offset / 2;
    var divergePoint = 0.2 + random(o) * 0.2;
    var midDispX = o.bowing * o.maxRandomnessOffset * (y2 - y1) / 200;
    var midDispY = o.bowing * o.maxRandomnessOffset * (x1 - x2) / 200;
    midDispX = _offsetOpt(midDispX, o, roughnessGain);
    midDispY = _offsetOpt(midDispY, o, roughnessGain);
    var ops = [];

    var randomHalf = function randomHalf() {
      return _offsetOpt(halfOffset, o, roughnessGain);
    };

    var randomFull = function randomFull() {
      return _offsetOpt(offset, o, roughnessGain);
    };

    var preserveVertices = o.preserveVertices;

    if (move) {
      if (overlay) {
        ops.push({
          op: 'move',
          data: [x1 + (preserveVertices ? 0 : randomHalf()), y1 + (preserveVertices ? 0 : randomHalf())]
        });
      } else {
        ops.push({
          op: 'move',
          data: [x1 + (preserveVertices ? 0 : _offsetOpt(offset, o, roughnessGain)), y1 + (preserveVertices ? 0 : _offsetOpt(offset, o, roughnessGain))]
        });
      }
    }

    if (overlay) {
      ops.push({
        op: 'bcurveTo',
        data: [midDispX + x1 + (x2 - x1) * divergePoint + randomHalf(), midDispY + y1 + (y2 - y1) * divergePoint + randomHalf(), midDispX + x1 + 2 * (x2 - x1) * divergePoint + randomHalf(), midDispY + y1 + 2 * (y2 - y1) * divergePoint + randomHalf(), x2 + (preserveVertices ? 0 : randomHalf()), y2 + (preserveVertices ? 0 : randomHalf())]
      });
    } else {
      ops.push({
        op: 'bcurveTo',
        data: [midDispX + x1 + (x2 - x1) * divergePoint + randomFull(), midDispY + y1 + (y2 - y1) * divergePoint + randomFull(), midDispX + x1 + 2 * (x2 - x1) * divergePoint + randomFull(), midDispY + y1 + 2 * (y2 - y1) * divergePoint + randomFull(), x2 + (preserveVertices ? 0 : randomFull()), y2 + (preserveVertices ? 0 : randomFull())]
      });
    }

    return ops;
  }

  function _curveWithOffset(points, offset, o) {
    var ps = [];
    ps.push([points[0][0] + _offsetOpt(offset, o), points[0][1] + _offsetOpt(offset, o)]);
    ps.push([points[0][0] + _offsetOpt(offset, o), points[0][1] + _offsetOpt(offset, o)]);

    for (var i = 1; i < points.length; i++) {
      ps.push([points[i][0] + _offsetOpt(offset, o), points[i][1] + _offsetOpt(offset, o)]);

      if (i === points.length - 1) {
        ps.push([points[i][0] + _offsetOpt(offset, o), points[i][1] + _offsetOpt(offset, o)]);
      }
    }

    return _curve(ps, null, o);
  }

  function _curve(points, closePoint, o) {
    var len = points.length;
    var ops = [];

    if (len > 3) {
      var b = [];
      var s = 1 - o.curveTightness;
      ops.push({
        op: 'move',
        data: [points[1][0], points[1][1]]
      });

      for (var i = 1; i + 2 < len; i++) {
        var cachedVertArray = points[i];
        b[0] = [cachedVertArray[0], cachedVertArray[1]];
        b[1] = [cachedVertArray[0] + (s * points[i + 1][0] - s * points[i - 1][0]) / 6, cachedVertArray[1] + (s * points[i + 1][1] - s * points[i - 1][1]) / 6];
        b[2] = [points[i + 1][0] + (s * points[i][0] - s * points[i + 2][0]) / 6, points[i + 1][1] + (s * points[i][1] - s * points[i + 2][1]) / 6];
        b[3] = [points[i + 1][0], points[i + 1][1]];
        ops.push({
          op: 'bcurveTo',
          data: [b[1][0], b[1][1], b[2][0], b[2][1], b[3][0], b[3][1]]
        });
      }

      if (closePoint && closePoint.length === 2) {
        var ro = o.maxRandomnessOffset;
        ops.push({
          op: 'lineTo',
          data: [closePoint[0] + _offsetOpt(ro, o), closePoint[1] + _offsetOpt(ro, o)]
        });
      }
    } else if (len === 3) {
      ops.push({
        op: 'move',
        data: [points[1][0], points[1][1]]
      });
      ops.push({
        op: 'bcurveTo',
        data: [points[1][0], points[1][1], points[2][0], points[2][1], points[2][0], points[2][1]]
      });
    } else if (len === 2) {
      ops.push.apply(ops, babelHelpers.toConsumableArray(_doubleLine(points[0][0], points[0][1], points[1][0], points[1][1], o)));
    }

    return ops;
  }

  function _computeEllipsePoints(increment, cx, cy, rx, ry, offset, overlap, o) {
    var corePoints = [];
    var allPoints = [];
    var radOffset = _offsetOpt(0.5, o) - Math.PI / 2;
    var coreOnly = o.roughness === 0;

    if (!coreOnly) {
      allPoints.push([_offsetOpt(offset, o) + cx + 0.9 * rx * Math.cos(radOffset - increment), _offsetOpt(offset, o) + cy + 0.9 * ry * Math.sin(radOffset - increment)]);
    }

    var endAngle = Math.PI * 2 + (coreOnly ? 0 : radOffset - 0.01);

    for (var angle = radOffset; angle < endAngle; angle = angle + increment) {
      var p = [_offsetOpt(offset, o) + cx + rx * Math.cos(angle), _offsetOpt(offset, o) + cy + ry * Math.sin(angle)];
      corePoints.push(p);
      allPoints.push(p);
    }

    if (!coreOnly) {
      allPoints.push([_offsetOpt(offset, o) + cx + rx * Math.cos(radOffset + Math.PI * 2 + overlap * 0.5), _offsetOpt(offset, o) + cy + ry * Math.sin(radOffset + Math.PI * 2 + overlap * 0.5)]);
      allPoints.push([_offsetOpt(offset, o) + cx + 0.98 * rx * Math.cos(radOffset + overlap), _offsetOpt(offset, o) + cy + 0.98 * ry * Math.sin(radOffset + overlap)]);
      allPoints.push([_offsetOpt(offset, o) + cx + 0.9 * rx * Math.cos(radOffset + overlap * 0.5), _offsetOpt(offset, o) + cy + 0.9 * ry * Math.sin(radOffset + overlap * 0.5)]);
    }

    return [allPoints, corePoints];
  }

  function _arc(increment, cx, cy, rx, ry, strt, stp, offset, o) {
    var radOffset = strt + _offsetOpt(0.1, o);

    var points = [];
    points.push([_offsetOpt(offset, o) + cx + 0.9 * rx * Math.cos(radOffset - increment), _offsetOpt(offset, o) + cy + 0.9 * ry * Math.sin(radOffset - increment)]);

    for (var angle = radOffset; angle <= stp; angle = angle + increment) {
      points.push([_offsetOpt(offset, o) + cx + rx * Math.cos(angle), _offsetOpt(offset, o) + cy + ry * Math.sin(angle)]);
    }

    points.push([cx + rx * Math.cos(stp), cy + ry * Math.sin(stp)]);
    points.push([cx + rx * Math.cos(stp), cy + ry * Math.sin(stp)]);
    return _curve(points, null, o);
  }

  function _bezierTo(x1, y1, x2, y2, x, y, current, o) {
    var ops = [];
    var ros = [o.maxRandomnessOffset || 1, (o.maxRandomnessOffset || 1) + 0.3];
    var f = [0, 0];
    var iterations = o.disableMultiStroke ? 1 : 2;
    var preserveVertices = o.preserveVertices;

    for (var i = 0; i < iterations; i++) {
      if (i === 0) {
        ops.push({
          op: 'move',
          data: [current[0], current[1]]
        });
      } else {
        ops.push({
          op: 'move',
          data: [current[0] + (preserveVertices ? 0 : _offsetOpt(ros[0], o)), current[1] + (preserveVertices ? 0 : _offsetOpt(ros[0], o))]
        });
      }

      f = preserveVertices ? [x, y] : [x + _offsetOpt(ros[i], o), y + _offsetOpt(ros[i], o)];
      ops.push({
        op: 'bcurveTo',
        data: [x1 + _offsetOpt(ros[i], o), y1 + _offsetOpt(ros[i], o), x2 + _offsetOpt(ros[i], o), y2 + _offsetOpt(ros[i], o), f[0], f[1]]
      });
    }

    return ops;
  }
});