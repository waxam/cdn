define(["exports", "../geometry.js", "./scan-line-hachure.js"], function (_exports, _geometry, _scanLineHachure) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.ZigZagLineFiller = void 0;

  var ZigZagLineFiller = /*#__PURE__*/function () {
    function ZigZagLineFiller(helper) {
      babelHelpers.classCallCheck(this, ZigZagLineFiller);
      this.helper = helper;
    }

    babelHelpers.createClass(ZigZagLineFiller, [{
      key: "fillPolygon",
      value: function fillPolygon(points, o) {
        var gap = o.hachureGap < 0 ? o.strokeWidth * 4 : o.hachureGap;
        var zo = o.zigzagOffset < 0 ? gap : o.zigzagOffset;
        o = Object.assign({}, o, {
          hachureGap: gap + zo
        });
        var lines = (0, _scanLineHachure.polygonHachureLines)(points, o);
        return {
          type: 'fillSketch',
          ops: this.zigzagLines(lines, zo, o)
        };
      }
    }, {
      key: "zigzagLines",
      value: function zigzagLines(lines, zo, o) {
        var _this = this;

        var ops = [];
        lines.forEach(function (line) {
          var length = (0, _geometry.lineLength)(line);
          var count = Math.round(length / (2 * zo));
          var p1 = line[0];
          var p2 = line[1];

          if (p1[0] > p2[0]) {
            p1 = line[1];
            p2 = line[0];
          }

          var alpha = Math.atan((p2[1] - p1[1]) / (p2[0] - p1[0]));

          for (var i = 0; i < count; i++) {
            var lstart = i * 2 * zo;
            var lend = (i + 1) * 2 * zo;
            var dz = Math.sqrt(2 * Math.pow(zo, 2));
            var start = [p1[0] + lstart * Math.cos(alpha), p1[1] + lstart * Math.sin(alpha)];
            var end = [p1[0] + lend * Math.cos(alpha), p1[1] + lend * Math.sin(alpha)];
            var middle = [start[0] + dz * Math.cos(alpha + Math.PI / 4), start[1] + dz * Math.sin(alpha + Math.PI / 4)];
            ops.push.apply(ops, babelHelpers.toConsumableArray(_this.helper.doubleLineOps(start[0], start[1], middle[0], middle[1], o)).concat(babelHelpers.toConsumableArray(_this.helper.doubleLineOps(middle[0], middle[1], end[0], end[1], o))));
          }
        });
        return ops;
      }
    }]);
    return ZigZagLineFiller;
  }();

  _exports.ZigZagLineFiller = ZigZagLineFiller;
});