define(["exports", "../geometry.js", "./scan-line-hachure.js"], function (_exports, _geometry, _scanLineHachure) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.HachureFiller = void 0;

  function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  var HachureFiller = /*#__PURE__*/function () {
    function HachureFiller(helper) {
      babelHelpers.classCallCheck(this, HachureFiller);
      this.helper = helper;
    }

    babelHelpers.createClass(HachureFiller, [{
      key: "fillPolygon",
      value: function fillPolygon(points, o) {
        return this._fillPolygon(points, o);
      }
    }, {
      key: "_fillPolygon",
      value: function _fillPolygon(points, o) {
        var connectEnds = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var lines = (0, _scanLineHachure.polygonHachureLines)(points, o);

        if (connectEnds) {
          var connectingLines = this.connectingLines(points, lines);
          lines = lines.concat(connectingLines);
        }

        var ops = this.renderLines(lines, o);
        return {
          type: 'fillSketch',
          ops: ops
        };
      }
    }, {
      key: "renderLines",
      value: function renderLines(lines, o) {
        var ops = [];

        var _iterator = _createForOfIteratorHelper(lines),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var line = _step.value;
            ops.push.apply(ops, babelHelpers.toConsumableArray(this.helper.doubleLineOps(line[0][0], line[0][1], line[1][0], line[1][1], o)));
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        return ops;
      }
    }, {
      key: "connectingLines",
      value: function connectingLines(polygon, lines) {
        var result = [];

        if (lines.length > 1) {
          for (var i = 1; i < lines.length; i++) {
            var prev = lines[i - 1];

            if ((0, _geometry.lineLength)(prev) < 3) {
              continue;
            }

            var current = lines[i];
            var segment = [current[0], prev[1]];

            if ((0, _geometry.lineLength)(segment) > 3) {
              var segSplits = this.splitOnIntersections(polygon, segment);
              result.push.apply(result, babelHelpers.toConsumableArray(segSplits));
            }
          }
        }

        return result;
      }
    }, {
      key: "midPointInPolygon",
      value: function midPointInPolygon(polygon, segment) {
        return (0, _geometry.isPointInPolygon)(polygon, (segment[0][0] + segment[1][0]) / 2, (segment[0][1] + segment[1][1]) / 2);
      }
    }, {
      key: "splitOnIntersections",
      value: function splitOnIntersections(polygon, segment) {
        var error = Math.max(5, (0, _geometry.lineLength)(segment) * 0.1);
        var intersections = [];

        for (var i = 0; i < polygon.length; i++) {
          var p1 = polygon[i];
          var p2 = polygon[(i + 1) % polygon.length];

          if (_geometry.doIntersect.apply(void 0, [p1, p2].concat(babelHelpers.toConsumableArray(segment)))) {
            var ip = (0, _geometry.lineIntersection)(p1, p2, segment[0], segment[1]);

            if (ip) {
              var d0 = (0, _geometry.lineLength)([ip, segment[0]]);
              var d1 = (0, _geometry.lineLength)([ip, segment[1]]);

              if (d0 > error && d1 > error) {
                intersections.push({
                  point: ip,
                  distance: d0
                });
              }
            }
          }
        }

        if (intersections.length > 1) {
          var ips = intersections.sort(function (a, b) {
            return a.distance - b.distance;
          }).map(function (d) {
            return d.point;
          });

          if (!_geometry.isPointInPolygon.apply(void 0, [polygon].concat(babelHelpers.toConsumableArray(segment[0])))) {
            ips.shift();
          }

          if (!_geometry.isPointInPolygon.apply(void 0, [polygon].concat(babelHelpers.toConsumableArray(segment[1])))) {
            ips.pop();
          }

          if (ips.length <= 1) {
            if (this.midPointInPolygon(polygon, segment)) {
              return [segment];
            } else {
              return [];
            }
          }

          var spoints = [segment[0]].concat(babelHelpers.toConsumableArray(ips), [segment[1]]);
          var slines = [];

          for (var _i = 0; _i < spoints.length - 1; _i += 2) {
            var subSegment = [spoints[_i], spoints[_i + 1]];

            if (this.midPointInPolygon(polygon, subSegment)) {
              slines.push(subSegment);
            }
          }

          return slines;
        } else if (this.midPointInPolygon(polygon, segment)) {
          return [segment];
        } else {
          return [];
        }
      }
    }]);
    return HachureFiller;
  }();

  _exports.HachureFiller = HachureFiller;
});