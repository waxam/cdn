define(["exports", "../geometry.js"], function (_exports, _geometry) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.polygonHachureLines = polygonHachureLines;

  function polygonHachureLines(points, o) {
    var rotationCenter = [0, 0];
    var angle = Math.round(o.hachureAngle + 90);

    if (angle) {
      (0, _geometry.rotatePoints)(points, rotationCenter, angle);
    }

    var lines = straightHachureLines(points, o);

    if (angle) {
      (0, _geometry.rotatePoints)(points, rotationCenter, -angle);
      (0, _geometry.rotateLines)(lines, rotationCenter, -angle);
    }

    return lines;
  }

  function straightHachureLines(points, o) {
    var vertices = babelHelpers.toConsumableArray(points);

    if (vertices[0].join(',') !== vertices[vertices.length - 1].join(',')) {
      vertices.push([vertices[0][0], vertices[0][1]]);
    }

    var lines = [];

    if (vertices && vertices.length > 2) {
      var _ret = function () {
        var gap = o.hachureGap;

        if (gap < 0) {
          gap = o.strokeWidth * 4;
        }

        gap = Math.max(gap, 0.1); // Create sorted edges table

        var edges = [];

        for (var i = 0; i < vertices.length - 1; i++) {
          var p1 = vertices[i];
          var p2 = vertices[i + 1];

          if (p1[1] !== p2[1]) {
            var ymin = Math.min(p1[1], p2[1]);
            edges.push({
              ymin: ymin,
              ymax: Math.max(p1[1], p2[1]),
              x: ymin === p1[1] ? p1[0] : p2[0],
              islope: (p2[0] - p1[0]) / (p2[1] - p1[1])
            });
          }
        }

        edges.sort(function (e1, e2) {
          if (e1.ymin < e2.ymin) {
            return -1;
          }

          if (e1.ymin > e2.ymin) {
            return 1;
          }

          if (e1.x < e2.x) {
            return -1;
          }

          if (e1.x > e2.x) {
            return 1;
          }

          if (e1.ymax === e2.ymax) {
            return 0;
          }

          return (e1.ymax - e2.ymax) / Math.abs(e1.ymax - e2.ymax);
        });

        if (!edges.length) {
          return {
            v: lines
          };
        } // Start scanning


        var activeEdges = [];
        var y = edges[0].ymin;

        while (activeEdges.length || edges.length) {
          if (edges.length) {
            var ix = -1;

            for (var _i = 0; _i < edges.length; _i++) {
              if (edges[_i].ymin > y) {
                break;
              }

              ix = _i;
            }

            var removed = edges.splice(0, ix + 1);
            removed.forEach(function (edge) {
              activeEdges.push({
                s: y,
                edge: edge
              });
            });
          }

          activeEdges = activeEdges.filter(function (ae) {
            if (ae.edge.ymax <= y) {
              return false;
            }

            return true;
          });
          activeEdges.sort(function (ae1, ae2) {
            if (ae1.edge.x === ae2.edge.x) {
              return 0;
            }

            return (ae1.edge.x - ae2.edge.x) / Math.abs(ae1.edge.x - ae2.edge.x);
          }); // fill between the edges

          if (activeEdges.length > 1) {
            for (var _i2 = 0; _i2 < activeEdges.length; _i2 = _i2 + 2) {
              var nexti = _i2 + 1;

              if (nexti >= activeEdges.length) {
                break;
              }

              var ce = activeEdges[_i2].edge;
              var ne = activeEdges[nexti].edge;
              lines.push([[Math.round(ce.x), y], [Math.round(ne.x), y]]);
            }
          }

          y += gap;
          activeEdges.forEach(function (ae) {
            ae.edge.x = ae.edge.x + gap * ae.edge.islope;
          });
        }
      }();

      if (babelHelpers.typeof(_ret) === "object") return _ret.v;
    }

    return lines;
  }
});