define(["exports", "../utils/boot.js", "../mixins/property-effects.js", "../mixins/mutable-data.js", "../mixins/gesture-event-listeners.js", "../utils/settings.js", "../utils/wrap.js", "../utils/hide-template-controls.js"], function (_exports, _boot, _propertyEffects, _mutableData, _gestureEventListeners, _settings, _wrap, _hideTemplateControls) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.DomBind = void 0;

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  /**
   * @constructor
   * @extends {HTMLElement}
   * @implements {Polymer_PropertyEffects}
   * @implements {Polymer_OptionalMutableData}
   * @implements {Polymer_GestureEventListeners}
   * @private
   */
  var domBindBase = (0, _gestureEventListeners.GestureEventListeners)((0, _mutableData.OptionalMutableData)((0, _propertyEffects.PropertyEffects)(HTMLElement)));
  /**
   * Custom element to allow using Polymer's template features (data binding,
   * declarative event listeners, etc.) in the main document without defining
   * a new custom element.
   *
   * `<template>` tags utilizing bindings may be wrapped with the `<dom-bind>`
   * element, which will immediately stamp the wrapped template into the main
   * document and bind elements to the `dom-bind` element itself as the
   * binding scope.
   *
   * @polymer
   * @customElement
   * @appliesMixin PropertyEffects
   * @appliesMixin OptionalMutableData
   * @appliesMixin GestureEventListeners
   * @extends {domBindBase}
   * @summary Custom element to allow using Polymer's template features (data
   *   binding, declarative event listeners, etc.) in the main document.
   */

  var DomBind = /*#__PURE__*/function (_domBindBase) {
    babelHelpers.inherits(DomBind, _domBindBase);

    var _super = _createSuper(DomBind);

    function DomBind() {
      var _this;

      babelHelpers.classCallCheck(this, DomBind);
      _this = _super.call(this);

      if (_settings.strictTemplatePolicy) {
        throw new Error("strictTemplatePolicy: dom-bind not allowed");
      }

      _this.root = null;
      _this.$ = null;
      _this.__children = null;
      return _this;
    }
    /* eslint-disable no-unused-vars */

    /**
     * @override
     * @param {string} name Name of attribute that changed
     * @param {?string} old Old attribute value
     * @param {?string} value New attribute value
     * @param {?string} namespace Attribute namespace.
     * @return {void}
     */


    babelHelpers.createClass(DomBind, [{
      key: "attributeChangedCallback",
      value: function attributeChangedCallback(name, old, value, namespace) {
        // assumes only one observed attribute
        this.mutableData = true;
      }
      /**
       * @override
       * @return {void}
       */

    }, {
      key: "connectedCallback",
      value: function connectedCallback() {
        if (!(0, _hideTemplateControls.hideElementsGlobally)()) {
          this.style.display = 'none';
        }

        this.render();
      }
      /**
       * @override
       * @return {void}
       */

    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        this.__removeChildren();
      }
    }, {
      key: "__insertChildren",
      value: function __insertChildren() {
        (0, _wrap.wrap)((0, _wrap.wrap)(this).parentNode).insertBefore(this.root, this);
      }
    }, {
      key: "__removeChildren",
      value: function __removeChildren() {
        if (this.__children) {
          for (var i = 0; i < this.__children.length; i++) {
            this.root.appendChild(this.__children[i]);
          }
        }
      }
      /**
       * Forces the element to render its content. This is typically only
       * necessary to call if HTMLImports with the async attribute are used.
       * @return {void}
       */

    }, {
      key: "render",
      value: function render() {
        var _this2 = this;

        var template;

        if (!this.__children) {
          template =
          /** @type {?HTMLTemplateElement} */
          template || this.querySelector('template');

          if (!template) {
            // Wait until childList changes and template should be there by then
            var observer = new MutationObserver(function () {
              template =
              /** @type {HTMLTemplateElement} */
              _this2.querySelector('template');

              if (template) {
                observer.disconnect();

                _this2.render();
              } else {
                throw new Error('dom-bind requires a <template> child');
              }
            });
            observer.observe(this, {
              childList: true
            });
            return;
          }

          this.root = this._stampTemplate(
          /** @type {!HTMLTemplateElement} */
          template);
          this.$ = this.root.$;
          this.__children = [];

          for (var n = this.root.firstChild; n; n = n.nextSibling) {
            this.__children[this.__children.length] = n;
          }

          this._enableProperties();
        }

        this.__insertChildren();

        this.dispatchEvent(new CustomEvent('dom-change', {
          bubbles: true,
          composed: true
        }));
      }
    }], [{
      key: "observedAttributes",
      get: function get() {
        return ['mutable-data'];
      }
    }]);
    return DomBind;
  }(domBindBase);

  _exports.DomBind = DomBind;
  customElements.define('dom-bind', DomBind);
});