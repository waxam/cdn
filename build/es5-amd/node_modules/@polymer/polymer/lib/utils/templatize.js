define(["exports", "./boot.js", "../mixins/property-effects.js", "../mixins/mutable-data.js", "./settings.js", "./wrap.js"], function (_exports, _boot, _propertyEffects, _mutableData, _settings, _wrap) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.TemplateInstanceBase = void 0;
  _exports.modelForElement = modelForElement;
  _exports.showHideChildren = showHideChildren;
  _exports.templatize = templatize;

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  // Base class for HTMLTemplateElement extension that has property effects
  // machinery for propagating host properties to children. This is an ES5
  // class only because Babel (incorrectly) requires super() in the class
  // constructor even though no `this` is used and it returns an instance.
  var newInstance = null;
  /**
   * @constructor
   * @extends {HTMLTemplateElement}
   * @private
   */

  function HTMLTemplateElementExtension() {
    return newInstance;
  }

  HTMLTemplateElementExtension.prototype = Object.create(HTMLTemplateElement.prototype, {
    constructor: {
      value: HTMLTemplateElementExtension,
      writable: true
    }
  });
  /**
   * @constructor
   * @implements {Polymer_PropertyEffects}
   * @extends {HTMLTemplateElementExtension}
   * @private
   */

  var DataTemplate = (0, _propertyEffects.PropertyEffects)(HTMLTemplateElementExtension);
  /**
   * @constructor
   * @implements {Polymer_MutableData}
   * @extends {DataTemplate}
   * @private
   */

  var MutableDataTemplate = (0, _mutableData.MutableData)(DataTemplate); // Applies a DataTemplate subclass to a <template> instance

  function upgradeTemplate(template, constructor) {
    newInstance = template;
    Object.setPrototypeOf(template, constructor.prototype);
    new constructor();
    newInstance = null;
  }
  /**
   * Base class for TemplateInstance.
   * @constructor
   * @extends {HTMLElement}
   * @implements {Polymer_PropertyEffects}
   * @private
   */


  var templateInstanceBase = (0, _propertyEffects.PropertyEffects)( /*#__PURE__*/function () {
    function _class() {
      babelHelpers.classCallCheck(this, _class);
    }

    return babelHelpers.createClass(_class);
  }());

  function showHideChildren(hide, children) {
    for (var i = 0; i < children.length; i++) {
      var n = children[i]; // Ignore non-changes

      if (Boolean(hide) != Boolean(n.__hideTemplateChildren__)) {
        // clear and restore text
        if (n.nodeType === Node.TEXT_NODE) {
          if (hide) {
            n.__polymerTextContent__ = n.textContent;
            n.textContent = '';
          } else {
            n.textContent = n.__polymerTextContent__;
          } // remove and replace slot

        } else if (n.localName === 'slot') {
          if (hide) {
            n.__polymerReplaced__ = document.createComment('hidden-slot');
            (0, _wrap.wrap)((0, _wrap.wrap)(n).parentNode).replaceChild(n.__polymerReplaced__, n);
          } else {
            var replace = n.__polymerReplaced__;

            if (replace) {
              (0, _wrap.wrap)((0, _wrap.wrap)(replace).parentNode).replaceChild(n, replace);
            }
          }
        } // hide and show nodes
        else if (n.style) {
            if (hide) {
              n.__polymerDisplay__ = n.style.display;
              n.style.display = 'none';
            } else {
              n.style.display = n.__polymerDisplay__;
            }
          }
      }

      n.__hideTemplateChildren__ = hide;

      if (n._showHideChildren) {
        n._showHideChildren(hide);
      }
    }
  }
  /**
   * @polymer
   * @customElement
   * @appliesMixin PropertyEffects
   * @unrestricted
   */


  var TemplateInstanceBase = /*#__PURE__*/function (_templateInstanceBase) {
    babelHelpers.inherits(TemplateInstanceBase, _templateInstanceBase);

    var _super = _createSuper(TemplateInstanceBase);

    function TemplateInstanceBase(props) {
      var _this;

      babelHelpers.classCallCheck(this, TemplateInstanceBase);
      _this = _super.call(this);

      _this._configureProperties(props);
      /** @type {!StampedTemplate} */


      _this.root = _this._stampTemplate(_this.__dataHost); // Save list of stamped children

      var children = [];
      /** @suppress {invalidCasts} */

      _this.children =
      /** @type {!NodeList} */
      children; // Polymer 1.x did not use `Polymer.dom` here so not bothering.

      for (var n = _this.root.firstChild; n; n = n.nextSibling) {
        children.push(n);
        n.__templatizeInstance = babelHelpers.assertThisInitialized(_this);
      }

      if (_this.__templatizeOwner && _this.__templatizeOwner.__hideTemplateChildren__) {
        _this._showHideChildren(true);
      } // Flush props only when props are passed if instance props exist
      // or when there isn't instance props.


      var options = _this.__templatizeOptions;

      if (props && options.instanceProps || !options.instanceProps) {
        _this._enableProperties();
      }

      return _this;
    }
    /**
     * Configure the given `props` by calling `_setPendingProperty`. Also
     * sets any properties stored in `__hostProps`.
     * @private
     * @param {Object} props Object of property name-value pairs to set.
     * @return {void}
     */


    babelHelpers.createClass(TemplateInstanceBase, [{
      key: "_configureProperties",
      value: function _configureProperties(props) {
        var options = this.__templatizeOptions;

        if (options.forwardHostProp) {
          for (var hprop in this.__hostProps) {
            this._setPendingProperty(hprop, this.__dataHost['_host_' + hprop]);
          }
        } // Any instance props passed in the constructor will overwrite host props;
        // normally this would be a user error but we don't specifically filter them


        for (var iprop in props) {
          this._setPendingProperty(iprop, props[iprop]);
        }
      }
      /**
       * Forwards a host property to this instance.  This method should be
       * called on instances from the `options.forwardHostProp` callback
       * to propagate changes of host properties to each instance.
       *
       * Note this method enqueues the change, which are flushed as a batch.
       *
       * @param {string} prop Property or path name
       * @param {*} value Value of the property to forward
       * @return {void}
       */

    }, {
      key: "forwardHostProp",
      value: function forwardHostProp(prop, value) {
        if (this._setPendingPropertyOrPath(prop, value, false, true)) {
          this.__dataHost._enqueueClient(this);
        }
      }
      /**
       * Override point for adding custom or simulated event handling.
       *
       * @override
       * @param {!Node} node Node to add event listener to
       * @param {string} eventName Name of event
       * @param {function(!Event):void} handler Listener function to add
       * @return {void}
       */

    }, {
      key: "_addEventListenerToNode",
      value: function _addEventListenerToNode(node, eventName, handler) {
        var _this2 = this;

        if (this._methodHost && this.__templatizeOptions.parentModel) {
          // If this instance should be considered a parent model, decorate
          // events this template instance as `model`
          this._methodHost._addEventListenerToNode(node, eventName, function (e) {
            e.model = _this2;
            handler(e);
          });
        } else {
          // Otherwise delegate to the template's host (which could be)
          // another template instance
          var templateHost = this.__dataHost.__dataHost;

          if (templateHost) {
            templateHost._addEventListenerToNode(node, eventName, handler);
          }
        }
      }
      /**
       * Shows or hides the template instance top level child elements. For
       * text nodes, `textContent` is removed while "hidden" and replaced when
       * "shown."
       * @param {boolean} hide Set to true to hide the children;
       * set to false to show them.
       * @return {void}
       * @protected
       */

    }, {
      key: "_showHideChildren",
      value: function _showHideChildren(hide) {
        showHideChildren(hide, this.children);
      }
      /**
       * Overrides default property-effects implementation to intercept
       * textContent bindings while children are "hidden" and cache in
       * private storage for later retrieval.
       *
       * @override
       * @param {!Node} node The node to set a property on
       * @param {string} prop The property to set
       * @param {*} value The value to set
       * @return {void}
       * @protected
       */

    }, {
      key: "_setUnmanagedPropertyToNode",
      value: function _setUnmanagedPropertyToNode(node, prop, value) {
        if (node.__hideTemplateChildren__ && node.nodeType == Node.TEXT_NODE && prop == 'textContent') {
          node.__polymerTextContent__ = value;
        } else {
          babelHelpers.get(babelHelpers.getPrototypeOf(TemplateInstanceBase.prototype), "_setUnmanagedPropertyToNode", this).call(this, node, prop, value);
        }
      }
      /**
       * Find the parent model of this template instance.  The parent model
       * is either another templatize instance that had option `parentModel: true`,
       * or else the host element.
       *
       * @return {!Polymer_PropertyEffects} The parent model of this instance
       */

    }, {
      key: "parentModel",
      get: function get() {
        var model = this.__parentModel;

        if (!model) {
          var options;
          model = this;

          do {
            // A template instance's `__dataHost` is a <template>
            // `model.__dataHost.__dataHost` is the template's host
            model = model.__dataHost.__dataHost;
          } while ((options = model.__templatizeOptions) && !options.parentModel);

          this.__parentModel = model;
        }

        return model;
      }
      /**
       * Stub of HTMLElement's `dispatchEvent`, so that effects that may
       * dispatch events safely no-op.
       *
       * @param {Event} event Event to dispatch
       * @return {boolean} Always true.
       * @override
       */

    }, {
      key: "dispatchEvent",
      value: function dispatchEvent(event) {
        // eslint-disable-line no-unused-vars
        return true;
      }
    }]);
    return TemplateInstanceBase;
  }(templateInstanceBase);
  /** @type {!DataTemplate} */


  _exports.TemplateInstanceBase = TemplateInstanceBase;
  TemplateInstanceBase.prototype.__dataHost;
  /** @type {!TemplatizeOptions} */

  TemplateInstanceBase.prototype.__templatizeOptions;
  /** @type {!Polymer_PropertyEffects} */

  TemplateInstanceBase.prototype._methodHost;
  /** @type {!Object} */

  TemplateInstanceBase.prototype.__templatizeOwner;
  /** @type {!Object} */

  TemplateInstanceBase.prototype.__hostProps;
  /**
   * @constructor
   * @extends {TemplateInstanceBase}
   * @implements {Polymer_MutableData}
   * @private
   */

  var MutableTemplateInstanceBase = (0, _mutableData.MutableData)( // This cast shouldn't be neccessary, but Closure doesn't understand that
  // TemplateInstanceBase is a constructor function.

  /** @type {function(new:TemplateInstanceBase)} */
  TemplateInstanceBase);

  function findMethodHost(template) {
    // Technically this should be the owner of the outermost template.
    // In shadow dom, this is always getRootNode().host, but we can
    // approximate this via cooperation with our dataHost always setting
    // `_methodHost` as long as there were bindings (or id's) on this
    // instance causing it to get a dataHost.
    var templateHost = template.__dataHost;
    return templateHost && templateHost._methodHost || templateHost;
  }
  /* eslint-disable valid-jsdoc */

  /**
   * @suppress {missingProperties} class.prototype is not defined for some reason
   */


  function createTemplatizerClass(template, templateInfo, options) {
    /**
     * @constructor
     * @extends {TemplateInstanceBase}
     */
    var templatizerBase = options.mutableData ? MutableTemplateInstanceBase : TemplateInstanceBase; // Affordance for global mixins onto TemplatizeInstance

    if (templatize.mixin) {
      templatizerBase = templatize.mixin(templatizerBase);
    }
    /**
     * Anonymous class created by the templatize
     * @constructor
     * @private
     */


    var klass = /*#__PURE__*/function (_templatizerBase) {
      babelHelpers.inherits(klass, _templatizerBase);

      var _super2 = _createSuper(klass);

      function klass() {
        babelHelpers.classCallCheck(this, klass);
        return _super2.apply(this, arguments);
      }

      return babelHelpers.createClass(klass);
    }(templatizerBase);
    /** @override */


    klass.prototype.__templatizeOptions = options;

    klass.prototype._bindTemplate(template);

    addNotifyEffects(klass, template, templateInfo, options);
    return klass;
  }
  /**
   * Adds propagate effects from the template to the template instance for
   * properties that the host binds to the template using the `_host_` prefix.
   *
   * @suppress {missingProperties} class.prototype is not defined for some reason
   */


  function addPropagateEffects(target, templateInfo, options, methodHost) {
    var userForwardHostProp = options.forwardHostProp;

    if (userForwardHostProp && templateInfo.hasHostProps) {
      // Under the `removeNestedTemplates` optimization, a custom element like
      // `dom-if` or `dom-repeat` can itself be treated as the "template"; this
      // flag is used to switch between upgrading a `<template>` to be a property
      // effects client vs. adding the effects directly to the custom element
      var isTemplate = target.localName == 'template'; // Provide data API and property effects on memoized template class

      var klass = templateInfo.templatizeTemplateClass;

      if (!klass) {
        if (isTemplate) {
          /**
           * @constructor
           * @extends {DataTemplate}
           */
          var templatizedBase = options.mutableData ? MutableDataTemplate : DataTemplate; // NOTE: due to https://github.com/google/closure-compiler/issues/2928,
          // combining the next two lines into one assignment causes a spurious
          // type error.

          /** @private */

          var TemplatizedTemplate = /*#__PURE__*/function (_templatizedBase) {
            babelHelpers.inherits(TemplatizedTemplate, _templatizedBase);

            var _super3 = _createSuper(TemplatizedTemplate);

            function TemplatizedTemplate() {
              babelHelpers.classCallCheck(this, TemplatizedTemplate);
              return _super3.apply(this, arguments);
            }

            return babelHelpers.createClass(TemplatizedTemplate);
          }(templatizedBase);

          klass = templateInfo.templatizeTemplateClass = TemplatizedTemplate;
        } else {
          /**
           * @constructor
           * @extends {PolymerElement}
           */
          var _templatizedBase2 = target.constructor; // Create a cached subclass of the base custom element class onto which
          // to put the template-specific propagate effects
          // NOTE: due to https://github.com/google/closure-compiler/issues/2928,
          // combining the next two lines into one assignment causes a spurious
          // type error.

          /** @private */

          var TemplatizedTemplateExtension = /*#__PURE__*/function (_templatizedBase3) {
            babelHelpers.inherits(TemplatizedTemplateExtension, _templatizedBase3);

            var _super4 = _createSuper(TemplatizedTemplateExtension);

            function TemplatizedTemplateExtension() {
              babelHelpers.classCallCheck(this, TemplatizedTemplateExtension);
              return _super4.apply(this, arguments);
            }

            return babelHelpers.createClass(TemplatizedTemplateExtension);
          }(_templatizedBase2);

          klass = templateInfo.templatizeTemplateClass = TemplatizedTemplateExtension;
        } // Add template - >instances effects
        // and host <- template effects


        var hostProps = templateInfo.hostProps;

        for (var prop in hostProps) {
          klass.prototype._addPropertyEffect('_host_' + prop, klass.prototype.PROPERTY_EFFECT_TYPES.PROPAGATE, {
            fn: createForwardHostPropEffect(prop, userForwardHostProp)
          });

          klass.prototype._createNotifyingProperty('_host_' + prop);
        }

        if (_settings.legacyWarnings && methodHost) {
          warnOnUndeclaredProperties(templateInfo, options, methodHost);
        }
      } // Mix any pre-bound data into __data; no need to flush this to
      // instances since they pull from the template at instance-time


      if (target.__dataProto) {
        // Note, generally `__dataProto` could be chained, but it's guaranteed
        // to not be since this is a vanilla template we just added effects to
        Object.assign(target.__data, target.__dataProto);
      }

      if (isTemplate) {
        upgradeTemplate(target, klass); // Clear any pending data for performance

        target.__dataTemp = {};
        target.__dataPending = null;
        target.__dataOld = null;

        target._enableProperties();
      } else {
        // Swizzle the cached subclass prototype onto the custom element
        Object.setPrototypeOf(target, klass.prototype); // Check for any pre-bound instance host properties, and do the
        // instance property delete/assign dance for those (directly into data;
        // not need to go through accessor since they are pulled at instance time)

        var _hostProps = templateInfo.hostProps;

        for (var _prop in _hostProps) {
          _prop = '_host_' + _prop;

          if (_prop in target) {
            var val = target[_prop];
            delete target[_prop];
            target.__data[_prop] = val;
          }
        }
      }
    }
  }
  /* eslint-enable valid-jsdoc */


  function createForwardHostPropEffect(hostProp, userForwardHostProp) {
    return function forwardHostProp(template, prop, props) {
      userForwardHostProp.call(template.__templatizeOwner, prop.substring('_host_'.length), props[prop]);
    };
  }

  function addNotifyEffects(klass, template, templateInfo, options) {
    var hostProps = templateInfo.hostProps || {};

    for (var iprop in options.instanceProps) {
      delete hostProps[iprop];
      var userNotifyInstanceProp = options.notifyInstanceProp;

      if (userNotifyInstanceProp) {
        klass.prototype._addPropertyEffect(iprop, klass.prototype.PROPERTY_EFFECT_TYPES.NOTIFY, {
          fn: createNotifyInstancePropEffect(iprop, userNotifyInstanceProp)
        });
      }
    }

    if (options.forwardHostProp && template.__dataHost) {
      for (var hprop in hostProps) {
        // As we're iterating hostProps in this function, note whether
        // there were any, for an optimization in addPropagateEffects
        if (!templateInfo.hasHostProps) {
          templateInfo.hasHostProps = true;
        }

        klass.prototype._addPropertyEffect(hprop, klass.prototype.PROPERTY_EFFECT_TYPES.NOTIFY, {
          fn: createNotifyHostPropEffect()
        });
      }
    }
  }

  function createNotifyInstancePropEffect(instProp, userNotifyInstanceProp) {
    return function notifyInstanceProp(inst, prop, props) {
      userNotifyInstanceProp.call(inst.__templatizeOwner, inst, prop, props[prop]);
    };
  }

  function createNotifyHostPropEffect() {
    return function notifyHostProp(inst, prop, props) {
      inst.__dataHost._setPendingPropertyOrPath('_host_' + prop, props[prop], true, true);
    };
  }
  /**
   * Returns an anonymous `PropertyEffects` class bound to the
   * `<template>` provided.  Instancing the class will result in the
   * template being stamped into a document fragment stored as the instance's
   * `root` property, after which it can be appended to the DOM.
   *
   * Templates may utilize all Polymer data-binding features as well as
   * declarative event listeners.  Event listeners and inline computing
   * functions in the template will be called on the host of the template.
   *
   * The constructor returned takes a single argument dictionary of initial
   * property values to propagate into template bindings.  Additionally
   * host properties can be forwarded in, and instance properties can be
   * notified out by providing optional callbacks in the `options` dictionary.
   *
   * Valid configuration in `options` are as follows:
   *
   * - `forwardHostProp(property, value)`: Called when a property referenced
   *   in the template changed on the template's host. As this library does
   *   not retain references to templates instanced by the user, it is the
   *   templatize owner's responsibility to forward host property changes into
   *   user-stamped instances.  The `instance.forwardHostProp(property, value)`
   *    method on the generated class should be called to forward host
   *   properties into the template to prevent unnecessary property-changed
   *   notifications. Any properties referenced in the template that are not
   *   defined in `instanceProps` will be notified up to the template's host
   *   automatically.
   * - `instanceProps`: Dictionary of property names that will be added
   *   to the instance by the templatize owner.  These properties shadow any
   *   host properties, and changes within the template to these properties
   *   will result in `notifyInstanceProp` being called.
   * - `mutableData`: When `true`, the generated class will skip strict
   *   dirty-checking for objects and arrays (always consider them to be
   *   "dirty").
   * - `notifyInstanceProp(instance, property, value)`: Called when
   *   an instance property changes.  Users may choose to call `notifyPath`
   *   on e.g. the owner to notify the change.
   * - `parentModel`: When `true`, events handled by declarative event listeners
   *   (`on-event="handler"`) will be decorated with a `model` property pointing
   *   to the template instance that stamped it.  It will also be returned
   *   from `instance.parentModel` in cases where template instance nesting
   *   causes an inner model to shadow an outer model.
   *
   * All callbacks are called bound to the `owner`. Any context
   * needed for the callbacks (such as references to `instances` stamped)
   * should be stored on the `owner` such that they can be retrieved via
   * `this`.
   *
   * When `options.forwardHostProp` is declared as an option, any properties
   * referenced in the template will be automatically forwarded from the host of
   * the `<template>` to instances, with the exception of any properties listed in
   * the `options.instanceProps` object.  `instanceProps` are assumed to be
   * managed by the owner of the instances, either passed into the constructor
   * or set after the fact.  Note, any properties passed into the constructor will
   * always be set to the instance (regardless of whether they would normally
   * be forwarded from the host).
   *
   * Note that `templatize()` can be run only once for a given `<template>`.
   * Further calls will result in an error. Also, there is a special
   * behavior if the template was duplicated through a mechanism such as
   * `<dom-repeat>` or `<test-fixture>`. In this case, all calls to
   * `templatize()` return the same class for all duplicates of a template.
   * The class returned from `templatize()` is generated only once using
   * the `options` from the first call. This means that any `options`
   * provided to subsequent calls will be ignored. Therefore, it is very
   * important not to close over any variables inside the callbacks. Also,
   * arrow functions must be avoided because they bind the outer `this`.
   * Inside the callbacks, any contextual information can be accessed
   * through `this`, which points to the `owner`.
   *
   * @param {!HTMLTemplateElement} template Template to templatize
   * @param {Polymer_PropertyEffects=} owner Owner of the template instances;
   *   any optional callbacks will be bound to this owner.
   * @param {Object=} options Options dictionary (see summary for details)
   * @return {function(new:TemplateInstanceBase, Object=)} Generated class bound
   *   to the template provided
   * @suppress {invalidCasts}
   */


  function templatize(template, owner, options) {
    // Under strictTemplatePolicy, the templatized element must be owned
    // by a (trusted) Polymer element, indicated by existence of _methodHost;
    // e.g. for dom-if & dom-repeat in main document, _methodHost is null
    if (_settings.strictTemplatePolicy && !findMethodHost(template)) {
      throw new Error('strictTemplatePolicy: template owner not trusted');
    }

    options =
    /** @type {!TemplatizeOptions} */
    options || {};

    if (template.__templatizeOwner) {
      throw new Error('A <template> can only be templatized once');
    }

    template.__templatizeOwner = owner;
    var ctor = owner ? owner.constructor : TemplateInstanceBase;

    var templateInfo = ctor._parseTemplate(template); // Get memoized base class for the prototypical template, which
    // includes property effects for binding template & forwarding

    /**
     * @constructor
     * @extends {TemplateInstanceBase}
     */


    var baseClass = templateInfo.templatizeInstanceClass;

    if (!baseClass) {
      baseClass = createTemplatizerClass(template, templateInfo, options);
      templateInfo.templatizeInstanceClass = baseClass;
    }

    var methodHost = findMethodHost(template); // Host property forwarding must be installed onto template instance

    addPropagateEffects(template, templateInfo, options, methodHost); // Subclass base class and add reference for this specific template

    /** @private */

    var klass = /*#__PURE__*/function (_baseClass) {
      babelHelpers.inherits(TemplateInstance, _baseClass);

      var _super5 = _createSuper(TemplateInstance);

      function TemplateInstance() {
        babelHelpers.classCallCheck(this, TemplateInstance);
        return _super5.apply(this, arguments);
      }

      return babelHelpers.createClass(TemplateInstance);
    }(baseClass);
    /** @override */


    klass.prototype._methodHost = methodHost;
    /** @override */

    klass.prototype.__dataHost =
    /** @type {!DataTemplate} */
    template;
    /** @override */

    klass.prototype.__templatizeOwner =
    /** @type {!Object} */
    owner;
    /** @override */

    klass.prototype.__hostProps = templateInfo.hostProps;
    klass =
    /** @type {function(new:TemplateInstanceBase)} */
    klass; //eslint-disable-line no-self-assign

    return klass;
  }

  function warnOnUndeclaredProperties(templateInfo, options, methodHost) {
    var declaredProps = methodHost.constructor._properties;
    var propertyEffects = templateInfo.propertyEffects;
    var instanceProps = options.instanceProps;

    for (var prop in propertyEffects) {
      // Ensure properties with template effects are declared on the outermost
      // host (`methodHost`), unless they are instance props or static functions
      if (!declaredProps[prop] && !(instanceProps && instanceProps[prop])) {
        var effects = propertyEffects[prop];

        for (var i = 0; i < effects.length; i++) {
          var part = effects[i].info.part;

          if (!(part.signature && part.signature.static)) {
            console.warn("Property '".concat(prop, "' used in template but not ") + "declared in 'properties'; attribute will not be observed.");
            break;
          }
        }
      }
    }
  }
  /**
   * Returns the template "model" associated with a given element, which
   * serves as the binding scope for the template instance the element is
   * contained in. A template model is an instance of
   * `TemplateInstanceBase`, and should be used to manipulate data
   * associated with this template instance.
   *
   * Example:
   *
   *   let model = modelForElement(el);
   *   if (model.index < 10) {
   *     model.set('item.checked', true);
   *   }
   *
   * @param {HTMLElement} template The model will be returned for
   *   elements stamped from this template (accepts either an HTMLTemplateElement)
   *   or a `<dom-if>`/`<dom-repeat>` element when using `removeNestedTemplates`
   *   optimization.
   * @param {Node=} node Node for which to return a template model.
   * @return {TemplateInstanceBase} Template instance representing the
   *   binding scope for the element
   */


  function modelForElement(template, node) {
    var model;

    while (node) {
      // An element with a __templatizeInstance marks the top boundary
      // of a scope; walk up until we find one, and then ensure that
      // its __dataHost matches `this`, meaning this dom-repeat stamped it
      if (model = node.__dataHost ? node : node.__templatizeInstance) {
        // Found an element stamped by another template; keep walking up
        // from its __dataHost
        if (model.__dataHost != template) {
          node = model.__dataHost;
        } else {
          return model;
        }
      } else {
        // Still in a template scope, keep going up until
        // a __templatizeInstance is found
        node = (0, _wrap.wrap)(node).parentNode;
      }
    }

    return null;
  }
});