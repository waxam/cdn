define(["exports", "../utils/boot.js", "../utils/mixin.js", "../utils/gestures.js"], function (_exports, _boot, _mixin, _gestures) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.GestureEventListeners = void 0;

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  /**
   * Element class mixin that provides API for adding Polymer's cross-platform
   * gesture events to nodes.
   *
   * The API is designed to be compatible with override points implemented
   * in `TemplateStamp` such that declarative event listeners in
   * templates will support gesture events when this mixin is applied along with
   * `TemplateStamp`.
   *
   * @mixinFunction
   * @polymer
   * @summary Element class mixin that provides API for adding Polymer's
   *   cross-platform gesture events to nodes
   * @template T
   * @param {function(new:T)} superClass Class to apply mixin to.
   * @return {function(new:T)} superClass with mixin applied.
   */
  var GestureEventListeners = (0, _mixin.dedupingMixin)(function (superClass) {
    /**
     * @polymer
     * @mixinClass
     * @implements {Polymer_GestureEventListeners}
     */
    var GestureEventListeners = /*#__PURE__*/function (_superClass) {
      babelHelpers.inherits(GestureEventListeners, _superClass);

      var _super = _createSuper(GestureEventListeners);

      function GestureEventListeners() {
        babelHelpers.classCallCheck(this, GestureEventListeners);
        return _super.apply(this, arguments);
      }

      babelHelpers.createClass(GestureEventListeners, [{
        key: "_addEventListenerToNode",
        value:
        /**
         * Add the event listener to the node if it is a gestures event.
         *
         * @param {!EventTarget} node Node to add event listener to
         * @param {string} eventName Name of event
         * @param {function(!Event):void} handler Listener function to add
         * @return {void}
         * @override
         */
        function _addEventListenerToNode(node, eventName, handler) {
          if (!(0, _gestures.addListener)(node, eventName, handler)) {
            babelHelpers.get(babelHelpers.getPrototypeOf(GestureEventListeners.prototype), "_addEventListenerToNode", this).call(this, node, eventName, handler);
          }
        }
        /**
         * Remove the event listener to the node if it is a gestures event.
         *
         * @param {!EventTarget} node Node to remove event listener from
         * @param {string} eventName Name of event
         * @param {function(!Event):void} handler Listener function to remove
         * @return {void}
         * @override
         */

      }, {
        key: "_removeEventListenerFromNode",
        value: function _removeEventListenerFromNode(node, eventName, handler) {
          if (!(0, _gestures.removeListener)(node, eventName, handler)) {
            babelHelpers.get(babelHelpers.getPrototypeOf(GestureEventListeners.prototype), "_removeEventListenerFromNode", this).call(this, node, eventName, handler);
          }
        }
      }]);
      return GestureEventListeners;
    }(superClass);

    return GestureEventListeners;
  });
  _exports.GestureEventListeners = GestureEventListeners;
});