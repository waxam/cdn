define(["exports", "../utils/boot.js", "../utils/mixin.js", "../utils/telemetry.js", "./properties-changed.js"], function (_exports, _boot, _mixin, _telemetry, _propertiesChanged) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.PropertiesMixin = void 0;

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  /**
   * Creates a copy of `props` with each property normalized such that
   * upgraded it is an object with at least a type property { type: Type}.
   *
   * @param {!Object} props Properties to normalize
   * @return {!Object} Copy of input `props` with normalized properties that
   * are in the form {type: Type}
   * @private
   */
  function normalizeProperties(props) {
    var output = {};

    for (var p in props) {
      var o = props[p];
      output[p] = typeof o === 'function' ? {
        type: o
      } : o;
    }

    return output;
  }
  /**
   * Mixin that provides a minimal starting point to using the PropertiesChanged
   * mixin by providing a mechanism to declare properties in a static
   * getter (e.g. static get properties() { return { foo: String } }). Changes
   * are reported via the `_propertiesChanged` method.
   *
   * This mixin provides no specific support for rendering. Users are expected
   * to create a ShadowRoot and put content into it and update it in whatever
   * way makes sense. This can be done in reaction to properties changing by
   * implementing `_propertiesChanged`.
   *
   * @mixinFunction
   * @polymer
   * @appliesMixin PropertiesChanged
   * @summary Mixin that provides a minimal starting point for using
   * the PropertiesChanged mixin by providing a declarative `properties` object.
   * @template T
   * @param {function(new:T)} superClass Class to apply mixin to.
   * @return {function(new:T)} superClass with mixin applied.
   */


  var PropertiesMixin = (0, _mixin.dedupingMixin)(function (superClass) {
    /**
     * @constructor
     * @implements {Polymer_PropertiesChanged}
     * @private
     */
    var base = (0, _propertiesChanged.PropertiesChanged)(superClass);
    /**
     * Returns the super class constructor for the given class, if it is an
     * instance of the PropertiesMixin.
     *
     * @param {!PropertiesMixinConstructor} constructor PropertiesMixin constructor
     * @return {?PropertiesMixinConstructor} Super class constructor
     */

    function superPropertiesClass(constructor) {
      var superCtor = Object.getPrototypeOf(constructor); // Note, the `PropertiesMixin` class below only refers to the class
      // generated by this call to the mixin; the instanceof test only works
      // because the mixin is deduped and guaranteed only to apply once, hence
      // all constructors in a proto chain will see the same `PropertiesMixin`

      return babelHelpers.instanceof(superCtor.prototype, PropertiesMixin) ?
      /** @type {!PropertiesMixinConstructor} */
      superCtor : null;
    }
    /**
     * Returns a memoized version of the `properties` object for the
     * given class. Properties not in object format are converted to at
     * least {type}.
     *
     * @param {PropertiesMixinConstructor} constructor PropertiesMixin constructor
     * @return {Object} Memoized properties object
     */


    function ownProperties(constructor) {
      if (!constructor.hasOwnProperty(JSCompiler_renameProperty('__ownProperties', constructor))) {
        var props = null;

        if (constructor.hasOwnProperty(JSCompiler_renameProperty('properties', constructor))) {
          var properties = constructor.properties;

          if (properties) {
            props = normalizeProperties(properties);
          }
        }

        constructor.__ownProperties = props;
      }

      return constructor.__ownProperties;
    }
    /**
     * @polymer
     * @mixinClass
     * @extends {base}
     * @implements {Polymer_PropertiesMixin}
     * @unrestricted
     */


    var PropertiesMixin = /*#__PURE__*/function (_base) {
      babelHelpers.inherits(PropertiesMixin, _base);

      var _super = _createSuper(PropertiesMixin);

      function PropertiesMixin() {
        babelHelpers.classCallCheck(this, PropertiesMixin);
        return _super.apply(this, arguments);
      }

      babelHelpers.createClass(PropertiesMixin, [{
        key: "_initializeProperties",
        value:
        /**
         * Overrides `PropertiesChanged` method and adds a call to
         * `finalize` which lazily configures the element's property accessors.
         * @override
         * @return {void}
         */
        function _initializeProperties() {
          (0, _telemetry.incrementInstanceCount)();
          this.constructor.finalize();
          babelHelpers.get(babelHelpers.getPrototypeOf(PropertiesMixin.prototype), "_initializeProperties", this).call(this);
        }
        /**
         * Called when the element is added to a document.
         * Calls `_enableProperties` to turn on property system from
         * `PropertiesChanged`.
         * @suppress {missingProperties} Super may or may not implement the callback
         * @return {void}
         * @override
         */

      }, {
        key: "connectedCallback",
        value: function connectedCallback() {
          if (babelHelpers.get(babelHelpers.getPrototypeOf(PropertiesMixin.prototype), "connectedCallback", this)) {
            babelHelpers.get(babelHelpers.getPrototypeOf(PropertiesMixin.prototype), "connectedCallback", this).call(this);
          }

          this._enableProperties();
        }
        /**
         * Called when the element is removed from a document
         * @suppress {missingProperties} Super may or may not implement the callback
         * @return {void}
         * @override
         */

      }, {
        key: "disconnectedCallback",
        value: function disconnectedCallback() {
          if (babelHelpers.get(babelHelpers.getPrototypeOf(PropertiesMixin.prototype), "disconnectedCallback", this)) {
            babelHelpers.get(babelHelpers.getPrototypeOf(PropertiesMixin.prototype), "disconnectedCallback", this).call(this);
          }
        }
      }], [{
        key: "observedAttributes",
        get:
        /**
         * Implements standard custom elements getter to observes the attributes
         * listed in `properties`.
         * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
         * @nocollapse
         */
        function get() {
          var _this = this;

          if (!this.hasOwnProperty(JSCompiler_renameProperty('__observedAttributes', this))) {
            (0, _telemetry.register)(this.prototype);
            var props = this._properties;
            this.__observedAttributes = props ? Object.keys(props).map(function (p) {
              return _this.prototype._addPropertyToAttributeMap(p);
            }) : [];
          }

          return this.__observedAttributes;
        }
        /**
         * Finalizes an element definition, including ensuring any super classes
         * are also finalized. This includes ensuring property
         * accessors exist on the element prototype. This method calls
         * `_finalizeClass` to finalize each constructor in the prototype chain.
         * @return {void}
         * @nocollapse
         */

      }, {
        key: "finalize",
        value: function finalize() {
          if (!this.hasOwnProperty(JSCompiler_renameProperty('__finalized', this))) {
            var superCtor = superPropertiesClass(
            /** @type {!PropertiesMixinConstructor} */
            this);

            if (superCtor) {
              superCtor.finalize();
            }

            this.__finalized = true;

            this._finalizeClass();
          }
        }
        /**
         * Finalize an element class. This includes ensuring property
         * accessors exist on the element prototype. This method is called by
         * `finalize` and finalizes the class constructor.
         *
         * @protected
         * @nocollapse
         */

      }, {
        key: "_finalizeClass",
        value: function _finalizeClass() {
          var props = ownProperties(
          /** @type {!PropertiesMixinConstructor} */
          this);

          if (props) {
            /** @type {?} */
            this.createProperties(props);
          }
        }
        /**
         * Returns a memoized version of all properties, including those inherited
         * from super classes. Properties not in object format are converted to
         * at least {type}.
         *
         * @return {Object} Object containing properties for this class
         * @protected
         * @nocollapse
         */

      }, {
        key: "_properties",
        get: function get() {
          if (!this.hasOwnProperty(JSCompiler_renameProperty('__properties', this))) {
            var superCtor = superPropertiesClass(
            /** @type {!PropertiesMixinConstructor} */
            this);
            this.__properties = Object.assign({}, superCtor && superCtor._properties, ownProperties(
            /** @type {PropertiesMixinConstructor} */
            this));
          }

          return this.__properties;
        }
        /**
         * Overrides `PropertiesChanged` method to return type specified in the
         * static `properties` object for the given property.
         * @param {string} name Name of property
         * @return {*} Type to which to deserialize attribute
         *
         * @protected
         * @nocollapse
         */

      }, {
        key: "typeForProperty",
        value: function typeForProperty(name) {
          var info = this._properties[name];
          return info && info.type;
        }
      }]);
      return PropertiesMixin;
    }(base);

    return PropertiesMixin;
  });
  _exports.PropertiesMixin = PropertiesMixin;
});