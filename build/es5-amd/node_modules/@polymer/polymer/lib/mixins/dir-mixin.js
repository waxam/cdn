define(["exports", "./property-accessors.js", "../utils/mixin.js"], function (_exports, _propertyAccessors, _mixin) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.DirMixin = void 0;

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var HOST_DIR = /:host\(:dir\((ltr|rtl)\)\)/g;
  var HOST_DIR_REPLACMENT = ':host([dir="$1"])';
  var EL_DIR = /([\s\w-#\.\[\]\*]*):dir\((ltr|rtl)\)/g;
  var EL_DIR_REPLACMENT = ':host([dir="$2"]) $1';
  var DIR_CHECK = /:dir\((?:ltr|rtl)\)/;
  var SHIM_SHADOW = Boolean(window['ShadyDOM'] && window['ShadyDOM']['inUse']);
  /**
   * @type {!Array<!Polymer_DirMixin>}
   */

  var DIR_INSTANCES = [];
  /** @type {?MutationObserver} */

  var observer = null;
  var documentDir = '';

  function getRTL() {
    documentDir = document.documentElement.getAttribute('dir');
  }
  /**
   * @param {!Polymer_DirMixin} instance Instance to set RTL status on
   */


  function setRTL(instance) {
    if (!instance.__autoDirOptOut) {
      var el =
      /** @type {!HTMLElement} */
      instance;
      el.setAttribute('dir', documentDir);
    }
  }

  function updateDirection() {
    getRTL();
    documentDir = document.documentElement.getAttribute('dir');

    for (var i = 0; i < DIR_INSTANCES.length; i++) {
      setRTL(DIR_INSTANCES[i]);
    }
  }

  function takeRecords() {
    if (observer && observer.takeRecords().length) {
      updateDirection();
    }
  }
  /**
   * Element class mixin that allows elements to use the `:dir` CSS Selector to
   * have text direction specific styling.
   *
   * With this mixin, any stylesheet provided in the template will transform
   * `:dir` into `:host([dir])` and sync direction with the page via the
   * element's `dir` attribute.
   *
   * Elements can opt out of the global page text direction by setting the `dir`
   * attribute directly in `ready()` or in HTML.
   *
   * Caveats:
   * - Applications must set `<html dir="ltr">` or `<html dir="rtl">` to sync
   *   direction
   * - Automatic left-to-right or right-to-left styling is sync'd with the
   *   `<html>` element only.
   * - Changing `dir` at runtime is supported.
   * - Opting out of the global direction styling is permanent
   *
   * @mixinFunction
   * @polymer
   * @appliesMixin PropertyAccessors
   * @template T
   * @param {function(new:T)} superClass Class to apply mixin to.
   * @return {function(new:T)} superClass with mixin applied.
   */


  var DirMixin = (0, _mixin.dedupingMixin)(function (base) {
    if (!SHIM_SHADOW) {
      if (!observer) {
        getRTL();
        observer = new MutationObserver(updateDirection);
        observer.observe(document.documentElement, {
          attributes: true,
          attributeFilter: ['dir']
        });
      }
    }
    /**
     * @constructor
     * @implements {Polymer_PropertyAccessors}
     * @private
     */


    var elementBase = (0, _propertyAccessors.PropertyAccessors)(base);
    /**
     * @polymer
     * @mixinClass
     * @implements {Polymer_DirMixin}
     */

    var Dir = /*#__PURE__*/function (_elementBase) {
      babelHelpers.inherits(Dir, _elementBase);

      var _super = _createSuper(Dir);

      function Dir() {
        var _this;

        babelHelpers.classCallCheck(this, Dir);
        _this = _super.call(this);
        /** @type {boolean} */

        _this.__autoDirOptOut = false;
        return _this;
      }
      /**
       * @override
       * @suppress {invalidCasts} Closure doesn't understand that `this` is an
       *     HTMLElement
       * @return {void}
       */


      babelHelpers.createClass(Dir, [{
        key: "ready",
        value: function ready() {
          babelHelpers.get(babelHelpers.getPrototypeOf(Dir.prototype), "ready", this).call(this);
          this.__autoDirOptOut =
          /** @type {!HTMLElement} */
          this.hasAttribute('dir');
        }
        /**
         * @override
         * @suppress {missingProperties} If it exists on elementBase, it can be
         *   super'd
         * @return {void}
         */

      }, {
        key: "connectedCallback",
        value: function connectedCallback() {
          if (elementBase.prototype.connectedCallback) {
            babelHelpers.get(babelHelpers.getPrototypeOf(Dir.prototype), "connectedCallback", this).call(this);
          }

          if (this.constructor.__activateDir) {
            takeRecords();
            DIR_INSTANCES.push(this);
            setRTL(this);
          }
        }
        /**
         * @override
         * @suppress {missingProperties} If it exists on elementBase, it can be
         *   super'd
         * @return {void}
         */

      }, {
        key: "disconnectedCallback",
        value: function disconnectedCallback() {
          if (elementBase.prototype.disconnectedCallback) {
            babelHelpers.get(babelHelpers.getPrototypeOf(Dir.prototype), "disconnectedCallback", this).call(this);
          }

          if (this.constructor.__activateDir) {
            var idx = DIR_INSTANCES.indexOf(this);

            if (idx > -1) {
              DIR_INSTANCES.splice(idx, 1);
            }
          }
        }
      }], [{
        key: "_processStyleText",
        value:
        /**
         * @param {string} cssText .
         * @param {string} baseURI .
         * @return {string} .
         * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
         * @nocollapse
         */
        function _processStyleText(cssText, baseURI) {
          // TODO(https://github.com/google/closure-compiler/issues/3240):
          //     Change back to just super.methodCall()
          cssText = elementBase._processStyleText.call(this, cssText, baseURI);

          if (!SHIM_SHADOW && DIR_CHECK.test(cssText)) {
            cssText = this._replaceDirInCssText(cssText);
            this.__activateDir = true;
          }

          return cssText;
        }
        /**
         * Replace `:dir` in the given CSS text
         *
         * @param {string} text CSS text to replace DIR
         * @return {string} Modified CSS
         * @nocollapse
         */

      }, {
        key: "_replaceDirInCssText",
        value: function _replaceDirInCssText(text) {
          var replacedText = text;
          replacedText = replacedText.replace(HOST_DIR, HOST_DIR_REPLACMENT);
          replacedText = replacedText.replace(EL_DIR, EL_DIR_REPLACMENT);
          return replacedText;
        }
      }]);
      return Dir;
    }(elementBase);

    Dir.__activateDir = false;
    return Dir;
  });
  _exports.DirMixin = DirMixin;
});