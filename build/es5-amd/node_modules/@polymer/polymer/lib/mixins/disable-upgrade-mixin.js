define(["exports", "./element-mixin.js", "../utils/mixin.js", "../utils/wrap.js"], function (_exports, _elementMixin, _mixin, _wrap) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.findObservedAttributesGetter = _exports.DisableUpgradeMixin = void 0;

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var DISABLED_ATTR = 'disable-upgrade';

  var findObservedAttributesGetter = function findObservedAttributesGetter(ctor) {
    while (ctor) {
      var desc = Object.getOwnPropertyDescriptor(ctor, 'observedAttributes');

      if (desc) {
        return desc.get;
      }

      ctor = Object.getPrototypeOf(ctor.prototype).constructor;
    }

    return function () {
      return [];
    };
  };
  /**
   * Element class mixin that allows the element to boot up in a non-enabled
   * state when the `disable-upgrade` attribute is present. This mixin is
   * designed to be used with element classes like PolymerElement that perform
   * initial startup work when they are first connected. When the
   * `disable-upgrade` attribute is removed, if the element is connected, it
   * boots up and "enables" as it otherwise would; if it is not connected, the
   * element boots up when it is next connected.
   *
   * Using `disable-upgrade` with PolymerElement prevents any data propagation
   * to the element, any element DOM from stamping, or any work done in
   * connected/disconnctedCallback from occuring, but it does not prevent work
   * done in the element constructor.
   *
   * Note, this mixin must be applied on top of any element class that
   * itself implements a `connectedCallback` so that it can control the work
   * done in `connectedCallback`. For example,
   *
   *     MyClass = DisableUpgradeMixin(class extends BaseClass {...});
   *
   * @mixinFunction
   * @polymer
   * @appliesMixin ElementMixin
   * @template T
   * @param {function(new:T)} superClass Class to apply mixin to.
   * @return {function(new:T)} superClass with mixin applied.
   */


  _exports.findObservedAttributesGetter = findObservedAttributesGetter;
  var DisableUpgradeMixin = (0, _mixin.dedupingMixin)(function (base) {
    /**
     * @constructor
     * @implements {Polymer_ElementMixin}
     * @extends {HTMLElement}
     * @private
     */
    var superClass = (0, _elementMixin.ElementMixin)(base); // Work around for closure bug #126934458. Using `super` in a property
    // getter does not work so instead we search the Base prototype for an
    // implementation of observedAttributes so that we can override and call
    // the `super` getter. Note, this is done one time ever because we assume
    // that `Base` is always comes from `Polymer.LegacyElementMixn`.

    var observedAttributesGetter = findObservedAttributesGetter(superClass);
    /**
     * @polymer
     * @mixinClass
     * @implements {Polymer_DisableUpgradeMixin}
     */

    var DisableUpgradeClass = /*#__PURE__*/function (_superClass) {
      babelHelpers.inherits(DisableUpgradeClass, _superClass);

      var _super = _createSuper(DisableUpgradeClass);

      function DisableUpgradeClass() {
        var _this;

        babelHelpers.classCallCheck(this, DisableUpgradeClass);
        _this = _super.call(this);
        /** @type {boolean|undefined} */

        _this.__isUpgradeDisabled;
        return _this;
      }

      babelHelpers.createClass(DisableUpgradeClass, [{
        key: "_initializeProperties",
        value: // Prevent element from initializing properties when it's upgrade disabled.

        /** @override */
        function _initializeProperties() {
          if (this.hasAttribute(DISABLED_ATTR)) {
            this.__isUpgradeDisabled = true;
          } else {
            babelHelpers.get(babelHelpers.getPrototypeOf(DisableUpgradeClass.prototype), "_initializeProperties", this).call(this);
          }
        } // Prevent element from enabling properties when it's upgrade disabled.
        // Normally overriding connectedCallback would be enough, but dom-* elements

        /** @override */

      }, {
        key: "_enableProperties",
        value: function _enableProperties() {
          if (!this.__isUpgradeDisabled) {
            babelHelpers.get(babelHelpers.getPrototypeOf(DisableUpgradeClass.prototype), "_enableProperties", this).call(this);
          }
        } // If the element starts upgrade-disabled and a property is set for
        // which an accessor exists, the default should not be applied.
        // This additional check is needed because defaults are applied via
        // `_initializeProperties` which is called after initial properties
        // have been set when the element starts upgrade-disabled.

        /** @override */

      }, {
        key: "_canApplyPropertyDefault",
        value: function _canApplyPropertyDefault(property) {
          return babelHelpers.get(babelHelpers.getPrototypeOf(DisableUpgradeClass.prototype), "_canApplyPropertyDefault", this).call(this, property) && !(this.__isUpgradeDisabled && this._isPropertyPending(property));
        }
        /**
         * @override
         * @param {string} name Attribute name.
         * @param {?string} old The previous value for the attribute.
         * @param {?string} value The new value for the attribute.
         * @param {?string} namespace The XML namespace for the attribute.
         * @return {void}
         */

      }, {
        key: "attributeChangedCallback",
        value: function attributeChangedCallback(name, old, value, namespace) {
          if (name == DISABLED_ATTR) {
            // When disable-upgrade is removed, intialize properties and
            // provoke connectedCallback if the element is already connected.
            if (this.__isUpgradeDisabled && value == null) {
              babelHelpers.get(babelHelpers.getPrototypeOf(DisableUpgradeClass.prototype), "_initializeProperties", this).call(this);
              this.__isUpgradeDisabled = false;

              if ((0, _wrap.wrap)(this).isConnected) {
                babelHelpers.get(babelHelpers.getPrototypeOf(DisableUpgradeClass.prototype), "connectedCallback", this).call(this);
              }
            }
          } else {
            babelHelpers.get(babelHelpers.getPrototypeOf(DisableUpgradeClass.prototype), "attributeChangedCallback", this).call(this, name, old, value,
            /** @type {null|string} */
            namespace);
          }
        } // Prevent element from connecting when it's upgrade disabled.
        // This prevents user code in `attached` from being called.

        /** @override */

      }, {
        key: "connectedCallback",
        value: function connectedCallback() {
          if (!this.__isUpgradeDisabled) {
            babelHelpers.get(babelHelpers.getPrototypeOf(DisableUpgradeClass.prototype), "connectedCallback", this).call(this);
          }
        } // Prevent element from disconnecting when it's upgrade disabled.
        // This avoids allowing user code `detached` from being called without a
        // paired call to `attached`.

        /** @override */

      }, {
        key: "disconnectedCallback",
        value: function disconnectedCallback() {
          if (!this.__isUpgradeDisabled) {
            babelHelpers.get(babelHelpers.getPrototypeOf(DisableUpgradeClass.prototype), "disconnectedCallback", this).call(this);
          }
        }
      }], [{
        key: "observedAttributes",
        get: function get() {
          return observedAttributesGetter.call(this).concat(DISABLED_ATTR);
        }
      }]);
      return DisableUpgradeClass;
    }(superClass);

    return DisableUpgradeClass;
  });
  _exports.DisableUpgradeMixin = DisableUpgradeMixin;
});