define(["exports", "../../../../@webcomponents/shadycss/entrypoints/apply-shim.js", "../mixins/element-mixin.js", "../mixins/gesture-event-listeners.js", "../mixins/dir-mixin.js", "../utils/mixin.js", "../utils/render-status.js", "../utils/unresolved.js", "./polymer.dom.js", "../utils/gestures.js", "../utils/debounce.js", "../utils/async.js", "../utils/path.js", "../utils/wrap.js", "../utils/scope-subtree.js", "../utils/settings.js", "../mixins/disable-upgrade-mixin.js", "../utils/telemetry.js"], function (_exports, _applyShim, _elementMixin, _gestureEventListeners, _dirMixin, _mixin, _renderStatus, _unresolved, _polymerDom, _gestures, _debounce, _async, _path, _wrap, _scopeSubtree2, _settings, _disableUpgradeMixin, _telemetry) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.LegacyElementMixin = void 0;

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var DISABLED_ATTR = 'disable-upgrade';
  var styleInterface = window.ShadyCSS;
  /**
   * Element class mixin that provides Polymer's "legacy" API intended to be
   * backward-compatible to the greatest extent possible with the API
   * found on the Polymer 1.x `Polymer.Base` prototype applied to all elements
   * defined using the `Polymer({...})` function.
   *
   * @mixinFunction
   * @polymer
   * @appliesMixin ElementMixin
   * @appliesMixin GestureEventListeners
   * @appliesMixin DirMixin
   * @property isAttached {boolean} Set to `true` in this element's
   *   `connectedCallback` and `false` in `disconnectedCallback`
   * @summary Element class mixin that provides Polymer's "legacy" API
   */

  var LegacyElementMixin = (0, _mixin.dedupingMixin)(function (base) {
    // TODO(kschaaf): Note, the `@implements {Polymer_DirMixin}` is required here
    // (rather than on legacyElementBase) for unknown reasons.

    /**
     * @constructor
     * @implements {Polymer_ElementMixin}
     * @implements {Polymer_GestureEventListeners}
     * @implements {Polymer_DirMixin}
     * @extends {HTMLElement}
     * @private
     */
    var GesturesElement = (0, _gestureEventListeners.GestureEventListeners)((0, _elementMixin.ElementMixin)(base)); // Note, the DirMixin does nothing if css is built so avoid including it
    // in that case.

    /**
     * @constructor
     * @extends {GesturesElement}
     * @private
     */

    var legacyElementBase = _elementMixin.builtCSS ? GesturesElement : (0, _dirMixin.DirMixin)(GesturesElement);
    var observedAttributesGetter = (0, _disableUpgradeMixin.findObservedAttributesGetter)(legacyElementBase);
    /**
     * Map of simple names to touch action names
     * @dict
     */

    var DIRECTION_MAP = {
      'x': 'pan-x',
      'y': 'pan-y',
      'none': 'none',
      'all': 'auto'
    };
    /**
     * @polymer
     * @mixinClass
     * @extends {legacyElementBase}
     * @implements {Polymer_LegacyElementMixin}
     * @unrestricted
     */

    var LegacyElement = /*#__PURE__*/function (_legacyElementBase) {
      babelHelpers.inherits(LegacyElement, _legacyElementBase);

      var _super = _createSuper(LegacyElement);

      function LegacyElement() {
        var _this;

        babelHelpers.classCallCheck(this, LegacyElement);
        _this = _super.call(this);
        /** @type {boolean} */

        _this.isAttached;
        /** @type {?WeakMap<!Element, !Object<string, !Function>>} */

        _this.__boundListeners;
        /** @type {?Object<string, ?Function>} */

        _this._debouncers; // NOTE: Inlined for perf from version of DisableUpgradeMixin.

        /** @type {boolean|undefined} */

        _this.__isUpgradeDisabled;
        /** @type {boolean|undefined} */

        _this.__needsAttributesAtConnected;
        /** @type {boolean|undefined} */

        _this._legacyForceObservedAttributes;
        return _this;
      }
      /**
       * Forwards `importMeta` from the prototype (i.e. from the info object
       * passed to `Polymer({...})`) to the static API.
       *
       * @return {!Object} The `import.meta` object set on the prototype
       * @suppress {missingProperties} `this` is always in the instance in
       *  closure for some reason even in a static method, rather than the class
       * @nocollapse
       */


      babelHelpers.createClass(LegacyElement, [{
        key: "created",
        value:
        /**
         * Legacy callback called during the `constructor`, for overriding
         * by the user.
         * @override
         * @return {void}
         */
        function created() {}
        /**
         * Processes an attribute reaction when the `legacyNoObservedAttributes`
         * setting is in use.
         * @param {string} name Name of attribute that changed
         * @param {?string} old Old attribute value
         * @param {?string} value New attribute value
         * @return {void}
         */

      }, {
        key: "__attributeReaction",
        value: function __attributeReaction(name, old, value) {
          if (this.__dataAttributes && this.__dataAttributes[name] || name === DISABLED_ATTR) {
            this.attributeChangedCallback(name, old, value, null);
          }
        }
        /**
         * Sets the value of an attribute.
         * @override
         * @param {string} name The name of the attribute to change.
         * @param {string|number|boolean|!TrustedHTML|!TrustedScriptURL|!TrustedURL} value The new attribute value.
         */

      }, {
        key: "setAttribute",
        value: function setAttribute(name, value) {
          if (_settings.legacyNoObservedAttributes && !this._legacyForceObservedAttributes) {
            var oldValue = this.getAttribute(name);
            babelHelpers.get(babelHelpers.getPrototypeOf(LegacyElement.prototype), "setAttribute", this).call(this, name, value); // value coerced to String for closure's benefit

            this.__attributeReaction(name, oldValue, String(value));
          } else {
            babelHelpers.get(babelHelpers.getPrototypeOf(LegacyElement.prototype), "setAttribute", this).call(this, name, value);
          }
        }
        /**
         * Removes an attribute.
         * @override
         * @param {string} name The name of the attribute to remove.
         */

      }, {
        key: "removeAttribute",
        value: function removeAttribute(name) {
          if (_settings.legacyNoObservedAttributes && !this._legacyForceObservedAttributes) {
            var oldValue = this.getAttribute(name);
            babelHelpers.get(babelHelpers.getPrototypeOf(LegacyElement.prototype), "removeAttribute", this).call(this, name);

            this.__attributeReaction(name, oldValue, null);
          } else {
            babelHelpers.get(babelHelpers.getPrototypeOf(LegacyElement.prototype), "removeAttribute", this).call(this, name);
          }
        } // NOTE: Inlined for perf from version of DisableUpgradeMixin.

      }, {
        key: "_enableProperties",
        value: // NOTE: Inlined for perf from version of DisableUpgradeMixin.
        // Prevent element from enabling properties when it's upgrade disabled.
        // Normally overriding connectedCallback would be enough, but dom-* elements

        /** @override */
        function _enableProperties() {
          if (!this.__isUpgradeDisabled) {
            babelHelpers.get(babelHelpers.getPrototypeOf(LegacyElement.prototype), "_enableProperties", this).call(this);
          }
        } // NOTE: Inlined for perf from version of DisableUpgradeMixin.
        // If the element starts upgrade-disabled and a property is set for
        // which an accessor exists, the default should not be applied.
        // This additional check is needed because defaults are applied via
        // `_initializeProperties` which is called after initial properties
        // have been set when the element starts upgrade-disabled.

        /** @override */

      }, {
        key: "_canApplyPropertyDefault",
        value: function _canApplyPropertyDefault(property) {
          return babelHelpers.get(babelHelpers.getPrototypeOf(LegacyElement.prototype), "_canApplyPropertyDefault", this).call(this, property) && !(this.__isUpgradeDisabled && this._isPropertyPending(property));
        }
        /**
         * Provides an implementation of `connectedCallback`
         * which adds Polymer legacy API's `attached` method.
         * @return {void}
         * @override
         */

      }, {
        key: "connectedCallback",
        value: function connectedCallback() {
          if (this.__needsAttributesAtConnected) {
            this._takeAttributes();
          } // NOTE: Inlined for perf from version of DisableUpgradeMixin.


          if (!this.__isUpgradeDisabled) {
            babelHelpers.get(babelHelpers.getPrototypeOf(LegacyElement.prototype), "connectedCallback", this).call(this);
            this.isAttached = true;
            this.attached();
          }
        }
        /**
         * Legacy callback called during `connectedCallback`, for overriding
         * by the user.
         * @override
         * @return {void}
         */

      }, {
        key: "attached",
        value: function attached() {}
        /**
         * Provides an implementation of `disconnectedCallback`
         * which adds Polymer legacy API's `detached` method.
         * @return {void}
         * @override
         */

      }, {
        key: "disconnectedCallback",
        value: function disconnectedCallback() {
          // NOTE: Inlined for perf from version of DisableUpgradeMixin.
          if (!this.__isUpgradeDisabled) {
            babelHelpers.get(babelHelpers.getPrototypeOf(LegacyElement.prototype), "disconnectedCallback", this).call(this);
            this.isAttached = false;
            this.detached();
          }
        }
        /**
         * Legacy callback called during `disconnectedCallback`, for overriding
         * by the user.
         * @override
         * @return {void}
         */

      }, {
        key: "detached",
        value: function detached() {}
        /**
         * Provides an override implementation of `attributeChangedCallback`
         * which adds the Polymer legacy API's `attributeChanged` method.
         * @param {string} name Name of attribute.
         * @param {?string} old Old value of attribute.
         * @param {?string} value Current value of attribute.
         * @param {?string} namespace Attribute namespace.
         * @return {void}
         * @override
         */

      }, {
        key: "attributeChangedCallback",
        value: function attributeChangedCallback(name, old, value, namespace) {
          if (old !== value) {
            // NOTE: Inlined for perf from version of DisableUpgradeMixin.
            if (name == DISABLED_ATTR) {
              // When disable-upgrade is removed, intialize properties and
              // provoke connectedCallback if the element is already connected.
              if (this.__isUpgradeDisabled && value == null) {
                this._initializeProperties();

                this.__isUpgradeDisabled = false;

                if ((0, _wrap.wrap)(this).isConnected) {
                  this.connectedCallback();
                }
              }
            } else {
              babelHelpers.get(babelHelpers.getPrototypeOf(LegacyElement.prototype), "attributeChangedCallback", this).call(this, name, old, value, namespace);
              this.attributeChanged(name, old, value);
            }
          }
        }
        /**
         * Legacy callback called during `attributeChangedChallback`, for overriding
         * by the user.
         * @param {string} name Name of attribute.
         * @param {?string} old Old value of attribute.
         * @param {?string} value Current value of attribute.
         * @return {void}
         * @override
         */

      }, {
        key: "attributeChanged",
        value: function attributeChanged(name, old, value) {} // eslint-disable-line no-unused-vars

        /**
         * Overrides the default `Polymer.PropertyEffects` implementation to
         * add support for class initialization via the `_registered` callback.
         * This is called only when the first instance of the element is created.
         *
         * @return {void}
         * @override
         * @suppress {invalidCasts}
         */

      }, {
        key: "_initializeProperties",
        value: function _initializeProperties() {
          // NOTE: Inlined for perf from version of DisableUpgradeMixin.
          // Only auto-use disable-upgrade if legacyOptimizations is set.
          if (_settings.legacyOptimizations && this.hasAttribute(DISABLED_ATTR)) {
            this.__isUpgradeDisabled = true;
          } else {
            var proto = Object.getPrototypeOf(this);

            if (!proto.hasOwnProperty(JSCompiler_renameProperty('__hasRegisterFinished', proto))) {
              this._registered(); // backstop in case the `_registered` implementation does not set this


              proto.__hasRegisterFinished = true;
            }

            babelHelpers.get(babelHelpers.getPrototypeOf(LegacyElement.prototype), "_initializeProperties", this).call(this);
            this.root =
            /** @type {HTMLElement} */
            this;
            this.created(); // Pull all attribute values 1x if `legacyNoObservedAttributes` is set.

            if (_settings.legacyNoObservedAttributes && !this._legacyForceObservedAttributes) {
              if (this.hasAttributes()) {
                this._takeAttributes(); // Element created from scratch or parser generated

              } else if (!this.parentNode) {
                this.__needsAttributesAtConnected = true;
              }
            } // Ensure listeners are applied immediately so that they are
            // added before declarative event listeners. This allows an element to
            // decorate itself via an event prior to any declarative listeners
            // seeing the event. Note, this ensures compatibility with 1.x ordering.


            this._applyListeners();
          }
        }
      }, {
        key: "_takeAttributes",
        value: function _takeAttributes() {
          var a = this.attributes;

          for (var i = 0, l = a.length; i < l; i++) {
            var attr = a[i];

            this.__attributeReaction(attr.name, null, attr.value);
          }
        }
        /**
         * Called automatically when an element is initializing.
         * Users may override this method to perform class registration time
         * work. The implementation should ensure the work is performed
         * only once for the class.
         * @protected
         * @return {void}
         * @override
         */

      }, {
        key: "_registered",
        value: function _registered() {}
        /**
         * Overrides the default `Polymer.PropertyEffects` implementation to
         * add support for installing `hostAttributes` and `listeners`.
         *
         * @return {void}
         * @override
         */

      }, {
        key: "ready",
        value: function ready() {
          this._ensureAttributes();

          babelHelpers.get(babelHelpers.getPrototypeOf(LegacyElement.prototype), "ready", this).call(this);
        }
        /**
         * Ensures an element has required attributes. Called when the element
         * is being readied via `ready`. Users should override to set the
         * element's required attributes. The implementation should be sure
         * to check and not override existing attributes added by
         * the user of the element. Typically, setting attributes should be left
         * to the element user and not done here; reasonable exceptions include
         * setting aria roles and focusability.
         * @protected
         * @return {void}
         * @override
         */

      }, {
        key: "_ensureAttributes",
        value: function _ensureAttributes() {}
        /**
         * Adds element event listeners. Called when the element
         * is being readied via `ready`. Users should override to
         * add any required element event listeners.
         * In performance critical elements, the work done here should be kept
         * to a minimum since it is done before the element is rendered. In
         * these elements, consider adding listeners asynchronously so as not to
         * block render.
         * @protected
         * @return {void}
         * @override
         */

      }, {
        key: "_applyListeners",
        value: function _applyListeners() {}
        /**
         * Converts a typed JavaScript value to a string.
         *
         * Note this method is provided as backward-compatible legacy API
         * only.  It is not directly called by any Polymer features. To customize
         * how properties are serialized to attributes for attribute bindings and
         * `reflectToAttribute: true` properties as well as this method, override
         * the `_serializeValue` method provided by `Polymer.PropertyAccessors`.
         *
         * @param {*} value Value to deserialize
         * @return {string | undefined} Serialized value
         * @override
         */

      }, {
        key: "serialize",
        value: function serialize(value) {
          return this._serializeValue(value);
        }
        /**
         * Converts a string to a typed JavaScript value.
         *
         * Note this method is provided as backward-compatible legacy API
         * only.  It is not directly called by any Polymer features.  To customize
         * how attributes are deserialized to properties for in
         * `attributeChangedCallback`, override `_deserializeValue` method
         * provided by `Polymer.PropertyAccessors`.
         *
         * @param {string} value String to deserialize
         * @param {*} type Type to deserialize the string to
         * @return {*} Returns the deserialized value in the `type` given.
         * @override
         */

      }, {
        key: "deserialize",
        value: function deserialize(value, type) {
          return this._deserializeValue(value, type);
        }
        /**
         * Serializes a property to its associated attribute.
         *
         * Note this method is provided as backward-compatible legacy API
         * only.  It is not directly called by any Polymer features.
         *
         * @param {string} property Property name to reflect.
         * @param {string=} attribute Attribute name to reflect.
         * @param {*=} value Property value to reflect.
         * @return {void}
         * @override
         */

      }, {
        key: "reflectPropertyToAttribute",
        value: function reflectPropertyToAttribute(property, attribute, value) {
          this._propertyToAttribute(property, attribute, value);
        }
        /**
         * Sets a typed value to an HTML attribute on a node.
         *
         * Note this method is provided as backward-compatible legacy API
         * only.  It is not directly called by any Polymer features.
         *
         * @param {*} value Value to serialize.
         * @param {string} attribute Attribute name to serialize to.
         * @param {Element} node Element to set attribute to.
         * @return {void}
         * @override
         */

      }, {
        key: "serializeValueToAttribute",
        value: function serializeValueToAttribute(value, attribute, node) {
          this._valueToNodeAttribute(
          /** @type {Element} */
          node || this, value, attribute);
        }
        /**
         * Copies own properties (including accessor descriptors) from a source
         * object to a target object.
         *
         * @param {Object} prototype Target object to copy properties to.
         * @param {Object} api Source object to copy properties from.
         * @return {Object} prototype object that was passed as first argument.
         * @override
         */

      }, {
        key: "extend",
        value: function extend(prototype, api) {
          if (!(prototype && api)) {
            return prototype || api;
          }

          var n$ = Object.getOwnPropertyNames(api);

          for (var i = 0, n; i < n$.length && (n = n$[i]); i++) {
            var pd = Object.getOwnPropertyDescriptor(api, n);

            if (pd) {
              Object.defineProperty(prototype, n, pd);
            }
          }

          return prototype;
        }
        /**
         * Copies props from a source object to a target object.
         *
         * Note, this method uses a simple `for...in` strategy for enumerating
         * properties.  To ensure only `ownProperties` are copied from source
         * to target and that accessor implementations are copied, use `extend`.
         *
         * @param {!Object} target Target object to copy properties to.
         * @param {!Object} source Source object to copy properties from.
         * @return {!Object} Target object that was passed as first argument.
         * @override
         */

      }, {
        key: "mixin",
        value: function mixin(target, source) {
          for (var i in source) {
            target[i] = source[i];
          }

          return target;
        }
        /**
         * Sets the prototype of an object.
         *
         * Note this method is provided as backward-compatible legacy API
         * only.  It is not directly called by any Polymer features.
         * @param {Object} object The object on which to set the prototype.
         * @param {Object} prototype The prototype that will be set on the given
         * `object`.
         * @return {Object} Returns the given `object` with its prototype set
         * to the given `prototype` object.
         * @override
         */

      }, {
        key: "chainObject",
        value: function chainObject(object, prototype) {
          if (object && prototype && object !== prototype) {
            object.__proto__ = prototype;
          }

          return object;
        }
        /* **** Begin Template **** */

        /**
         * Calls `importNode` on the `content` of the `template` specified and
         * returns a document fragment containing the imported content.
         *
         * @param {HTMLTemplateElement} template HTML template element to instance.
         * @return {!DocumentFragment} Document fragment containing the imported
         *   template content.
         * @override
         * @suppress {missingProperties} go/missingfnprops
         */

      }, {
        key: "instanceTemplate",
        value: function instanceTemplate(template) {
          var content = this.constructor._contentForTemplate(template);

          var dom =
          /** @type {!DocumentFragment} */
          document.importNode(content, true);
          return dom;
        }
        /* **** Begin Events **** */

        /**
         * Dispatches a custom event with an optional detail value.
         *
         * @param {string} type Name of event type.
         * @param {*=} detail Detail value containing event-specific
         *   payload.
         * @param {{ bubbles: (boolean|undefined), cancelable: (boolean|undefined),
         *     composed: (boolean|undefined) }=}
         *  options Object specifying options.  These may include:
         *  `bubbles` (boolean, defaults to `true`),
         *  `cancelable` (boolean, defaults to false), and
         *  `node` on which to fire the event (HTMLElement, defaults to `this`).
         * @return {!Event} The new event that was fired.
         * @override
         */

      }, {
        key: "fire",
        value: function fire(type, detail, options) {
          options = options || {};
          detail = detail === null || detail === undefined ? {} : detail;
          var event = new Event(type, {
            bubbles: options.bubbles === undefined ? true : options.bubbles,
            cancelable: Boolean(options.cancelable),
            composed: options.composed === undefined ? true : options.composed
          });
          event.detail = detail;
          var node = options.node || this;
          (0, _wrap.wrap)(node).dispatchEvent(event);
          return event;
        }
        /**
         * Convenience method to add an event listener on a given element,
         * late bound to a named method on this element.
         *
         * @param {?EventTarget} node Element to add event listener to.
         * @param {string} eventName Name of event to listen for.
         * @param {string} methodName Name of handler method on `this` to call.
         * @return {void}
         * @override
         */

      }, {
        key: "listen",
        value: function listen(node, eventName, methodName) {
          node =
          /** @type {!EventTarget} */
          node || this;
          var hbl = this.__boundListeners || (this.__boundListeners = new WeakMap());
          var bl = hbl.get(node);

          if (!bl) {
            bl = {};
            hbl.set(node, bl);
          }

          var key = eventName + methodName;

          if (!bl[key]) {
            bl[key] = this._addMethodEventListenerToNode(
            /** @type {!Node} */
            node, eventName, methodName, this);
          }
        }
        /**
         * Convenience method to remove an event listener from a given element,
         * late bound to a named method on this element.
         *
         * @param {?EventTarget} node Element to remove event listener from.
         * @param {string} eventName Name of event to stop listening to.
         * @param {string} methodName Name of handler method on `this` to not call
         anymore.
         * @return {void}
         * @override
         */

      }, {
        key: "unlisten",
        value: function unlisten(node, eventName, methodName) {
          node =
          /** @type {!EventTarget} */
          node || this;

          var bl = this.__boundListeners && this.__boundListeners.get(
          /** @type {!Element} */
          node);

          var key = eventName + methodName;
          var handler = bl && bl[key];

          if (handler) {
            this._removeEventListenerFromNode(
            /** @type {!Node} */
            node, eventName, handler);

            bl[key] =
            /** @type {?} */
            null;
          }
        }
        /**
         * Override scrolling behavior to all direction, one direction, or none.
         *
         * Valid scroll directions:
         *   - 'all': scroll in any direction
         *   - 'x': scroll only in the 'x' direction
         *   - 'y': scroll only in the 'y' direction
         *   - 'none': disable scrolling for this node
         *
         * @param {string=} direction Direction to allow scrolling
         * Defaults to `all`.
         * @param {Element=} node Element to apply scroll direction setting.
         * Defaults to `this`.
         * @return {void}
         * @override
         */

      }, {
        key: "setScrollDirection",
        value: function setScrollDirection(direction, node) {
          (0, _gestures.setTouchAction)(
          /** @type {!Element} */
          node || this, DIRECTION_MAP[direction] || 'auto');
        }
        /* **** End Events **** */

        /**
         * Convenience method to run `querySelector` on this local DOM scope.
         *
         * This function calls `Polymer.dom(this.root).querySelector(slctr)`.
         *
         * @param {string} slctr Selector to run on this local DOM scope
         * @return {Element} Element found by the selector, or null if not found.
         * @override
         */

      }, {
        key: "$$",
        value: function $$(slctr) {
          // Note, no need to `wrap` this because root is always patched
          return this.root.querySelector(slctr);
        }
        /**
         * Return the element whose local dom within which this element
         * is contained. This is a shorthand for
         * `this.getRootNode().host`.
         * @this {Element}
         * @return {?Node} The element whose local dom within which this element is
         * contained.
         * @override
         */

      }, {
        key: "domHost",
        get: function get() {
          var root = (0, _wrap.wrap)(this).getRootNode();
          return babelHelpers.instanceof(root, DocumentFragment) ?
          /** @type {ShadowRoot} */
          root.host : root;
        }
        /**
         * Force this element to distribute its children to its local dom.
         * This should not be necessary as of Polymer 2.0.2 and is provided only
         * for backwards compatibility.
         * @return {void}
         * @override
         */

      }, {
        key: "distributeContent",
        value: function distributeContent() {
          var thisEl =
          /** @type {Element} */
          this;
          var domApi =
          /** @type {PolymerDomApi} */
          (0, _polymerDom.dom)(thisEl);

          if (window.ShadyDOM && domApi.shadowRoot) {
            ShadyDOM.flush();
          }
        }
        /**
         * Returns a list of nodes that are the effective childNodes. The effective
         * childNodes list is the same as the element's childNodes except that
         * any `<content>` elements are replaced with the list of nodes distributed
         * to the `<content>`, the result of its `getDistributedNodes` method.
         * @return {!Array<!Node>} List of effective child nodes.
         * @suppress {invalidCasts} LegacyElementMixin must be applied to an
         *     HTMLElement
         * @override
         */

      }, {
        key: "getEffectiveChildNodes",
        value: function getEffectiveChildNodes() {
          var thisEl =
          /** @type {Element} */
          this;
          var domApi =
          /** @type {PolymerDomApi} */
          (0, _polymerDom.dom)(thisEl);
          return domApi.getEffectiveChildNodes();
        }
        /**
         * Returns a list of nodes distributed within this element that match
         * `selector`. These can be dom children or elements distributed to
         * children that are insertion points.
         * @param {string} selector Selector to run.
         * @return {!Array<!Node>} List of distributed elements that match selector.
         * @suppress {invalidCasts} LegacyElementMixin must be applied to an
         * HTMLElement
         * @override
         */

      }, {
        key: "queryDistributedElements",
        value: function queryDistributedElements(selector) {
          var thisEl =
          /** @type {Element} */
          this;
          var domApi =
          /** @type {PolymerDomApi} */
          (0, _polymerDom.dom)(thisEl);
          return domApi.queryDistributedElements(selector);
        }
        /**
         * Returns a list of elements that are the effective children. The effective
         * children list is the same as the element's children except that
         * any `<content>` elements are replaced with the list of elements
         * distributed to the `<content>`.
         *
         * @return {!Array<!Node>} List of effective children.
         * @override
         */

      }, {
        key: "getEffectiveChildren",
        value: function getEffectiveChildren() {
          var list = this.getEffectiveChildNodes();
          return list.filter(function (
          /** @type {!Node} */
          n) {
            return n.nodeType === Node.ELEMENT_NODE;
          });
        }
        /**
         * Returns a string of text content that is the concatenation of the
         * text content's of the element's effective childNodes (the elements
         * returned by <a href="#getEffectiveChildNodes>getEffectiveChildNodes</a>.
         *
         * @return {string} List of effective children.
         * @override
         */

      }, {
        key: "getEffectiveTextContent",
        value: function getEffectiveTextContent() {
          var cn = this.getEffectiveChildNodes();
          var tc = [];

          for (var i = 0, c; c = cn[i]; i++) {
            if (c.nodeType !== Node.COMMENT_NODE) {
              tc.push(c.textContent);
            }
          }

          return tc.join('');
        }
        /**
         * Returns the first effective childNode within this element that
         * match `selector`. These can be dom child nodes or elements distributed
         * to children that are insertion points.
         * @param {string} selector Selector to run.
         * @return {Node} First effective child node that matches selector.
         * @override
         */

      }, {
        key: "queryEffectiveChildren",
        value: function queryEffectiveChildren(selector) {
          var e$ = this.queryDistributedElements(selector);
          return e$ && e$[0];
        }
        /**
         * Returns a list of effective childNodes within this element that
         * match `selector`. These can be dom child nodes or elements distributed
         * to children that are insertion points.
         * @param {string} selector Selector to run.
         * @return {!Array<!Node>} List of effective child nodes that match
         *     selector.
         * @override
         */

      }, {
        key: "queryAllEffectiveChildren",
        value: function queryAllEffectiveChildren(selector) {
          return this.queryDistributedElements(selector);
        }
        /**
         * Returns a list of nodes distributed to this element's `<slot>`.
         *
         * If this element contains more than one `<slot>` in its local DOM,
         * an optional selector may be passed to choose the desired content.
         *
         * @param {string=} slctr CSS selector to choose the desired
         *   `<slot>`.  Defaults to `content`.
         * @return {!Array<!Node>} List of distributed nodes for the `<slot>`.
         * @override
         */

      }, {
        key: "getContentChildNodes",
        value: function getContentChildNodes(slctr) {
          // Note, no need to `wrap` this because root is always
          var content = this.root.querySelector(slctr || 'slot');
          return content ?
          /** @type {PolymerDomApi} */
          (0, _polymerDom.dom)(content).getDistributedNodes() : [];
        }
        /**
         * Returns a list of element children distributed to this element's
         * `<slot>`.
         *
         * If this element contains more than one `<slot>` in its
         * local DOM, an optional selector may be passed to choose the desired
         * content.  This method differs from `getContentChildNodes` in that only
         * elements are returned.
         *
         * @param {string=} slctr CSS selector to choose the desired
         *   `<content>`.  Defaults to `content`.
         * @return {!Array<!HTMLElement>} List of distributed nodes for the
         *   `<slot>`.
         * @suppress {invalidCasts}
         * @override
         */

      }, {
        key: "getContentChildren",
        value: function getContentChildren(slctr) {
          var children =
          /** @type {!Array<!HTMLElement>} */
          this.getContentChildNodes(slctr).filter(function (n) {
            return n.nodeType === Node.ELEMENT_NODE;
          });
          return children;
        }
        /**
         * Checks whether an element is in this element's light DOM tree.
         *
         * @param {?Node} node The element to be checked.
         * @return {boolean} true if node is in this element's light DOM tree.
         * @suppress {invalidCasts} LegacyElementMixin must be applied to an
         * HTMLElement
         * @override
         */

      }, {
        key: "isLightDescendant",
        value: function isLightDescendant(node) {
          var thisNode =
          /** @type {Node} */
          this;
          return thisNode !== node && (0, _wrap.wrap)(thisNode).contains(node) && (0, _wrap.wrap)(thisNode).getRootNode() === (0, _wrap.wrap)(node).getRootNode();
        }
        /**
         * Checks whether an element is in this element's local DOM tree.
         *
         * @param {!Element} node The element to be checked.
         * @return {boolean} true if node is in this element's local DOM tree.
         * @override
         */

      }, {
        key: "isLocalDescendant",
        value: function isLocalDescendant(node) {
          return this.root === (0, _wrap.wrap)(node).getRootNode();
        }
        /**
         * No-op for backwards compatibility. This should now be handled by
         * ShadyCss library.
         * @param  {!Element} container Container element to scope
         * @param  {boolean=} shouldObserve if true, start a mutation observer for added nodes to the container
         * @return {?MutationObserver} Returns a new MutationObserver on `container` if `shouldObserve` is true.
         * @override
         */

      }, {
        key: "scopeSubtree",
        value: function scopeSubtree(container) {
          var shouldObserve = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
          return (0, _scopeSubtree2.scopeSubtree)(container, shouldObserve);
        }
        /**
         * Returns the computed style value for the given property.
         * @param {string} property The css property name.
         * @return {string} Returns the computed css property value for the given
         * `property`.
         * @suppress {invalidCasts} LegacyElementMixin must be applied to an
         *     HTMLElement
         * @override
         */

      }, {
        key: "getComputedStyleValue",
        value: function getComputedStyleValue(property) {
          return styleInterface.getComputedStyleValue(
          /** @type {!Element} */
          this, property);
        } // debounce

        /**
         * Call `debounce` to collapse multiple requests for a named task into
         * one invocation which is made after the wait time has elapsed with
         * no new request.  If no wait time is given, the callback will be called
         * at microtask timing (guaranteed before paint).
         *
         *     debouncedClickAction(e) {
         *       // will not call `processClick` more than once per 100ms
         *       this.debounce('click', function() {
         *        this.processClick();
         *       } 100);
         *     }
         *
         * @param {string} jobName String to identify the debounce job.
         * @param {function():void} callback Function that is called (with `this`
         *   context) when the wait time elapses.
         * @param {number=} wait Optional wait time in milliseconds (ms) after the
         *   last signal that must elapse before invoking `callback`
         * @return {!Object} Returns a debouncer object on which exists the
         * following methods: `isActive()` returns true if the debouncer is
         * active; `cancel()` cancels the debouncer if it is active;
         * `flush()` immediately invokes the debounced callback if the debouncer
         * is active.
         * @override
         */

      }, {
        key: "debounce",
        value: function debounce(jobName, callback, wait) {
          this._debouncers = this._debouncers || {};
          return this._debouncers[jobName] = _debounce.Debouncer.debounce(this._debouncers[jobName], wait > 0 ? _async.timeOut.after(wait) : _async.microTask, callback.bind(this));
        }
        /**
         * Returns whether a named debouncer is active.
         *
         * @param {string} jobName The name of the debouncer started with `debounce`
         * @return {boolean} Whether the debouncer is active (has not yet fired).
         * @override
         */

      }, {
        key: "isDebouncerActive",
        value: function isDebouncerActive(jobName) {
          this._debouncers = this._debouncers || {};
          var debouncer = this._debouncers[jobName];
          return !!(debouncer && debouncer.isActive());
        }
        /**
         * Immediately calls the debouncer `callback` and inactivates it.
         *
         * @param {string} jobName The name of the debouncer started with `debounce`
         * @return {void}
         * @override
         */

      }, {
        key: "flushDebouncer",
        value: function flushDebouncer(jobName) {
          this._debouncers = this._debouncers || {};
          var debouncer = this._debouncers[jobName];

          if (debouncer) {
            debouncer.flush();
          }
        }
        /**
         * Cancels an active debouncer.  The `callback` will not be called.
         *
         * @param {string} jobName The name of the debouncer started with `debounce`
         * @return {void}
         * @override
         */

      }, {
        key: "cancelDebouncer",
        value: function cancelDebouncer(jobName) {
          this._debouncers = this._debouncers || {};
          var debouncer = this._debouncers[jobName];

          if (debouncer) {
            debouncer.cancel();
          }
        }
        /**
         * Runs a callback function asynchronously.
         *
         * By default (if no waitTime is specified), async callbacks are run at
         * microtask timing, which will occur before paint.
         *
         * @param {!Function} callback The callback function to run, bound to
         *     `this`.
         * @param {number=} waitTime Time to wait before calling the
         *   `callback`.  If unspecified or 0, the callback will be run at microtask
         *   timing (before paint).
         * @return {number} Handle that may be used to cancel the async job.
         * @override
         */

      }, {
        key: "async",
        value: function async(callback, waitTime) {
          return waitTime > 0 ? _async.timeOut.run(callback.bind(this), waitTime) : ~_async.microTask.run(callback.bind(this));
        }
        /**
         * Cancels an async operation started with `async`.
         *
         * @param {number} handle Handle returned from original `async` call to
         *   cancel.
         * @return {void}
         * @override
         */

      }, {
        key: "cancelAsync",
        value: function cancelAsync(handle) {
          handle < 0 ? _async.microTask.cancel(~handle) : _async.timeOut.cancel(handle);
        } // other

        /**
         * Convenience method for creating an element and configuring it.
         *
         * @param {string} tag HTML element tag to create.
         * @param {Object=} props Object of properties to configure on the
         *    instance.
         * @return {!Element} Newly created and configured element.
         * @override
         */

      }, {
        key: "create",
        value: function create(tag, props) {
          var elt = document.createElement(tag);

          if (props) {
            if (elt.setProperties) {
              elt.setProperties(props);
            } else {
              for (var n in props) {
                elt[n] = props[n];
              }
            }
          }

          return elt;
        }
        /**
         * Polyfill for Element.prototype.matches, which is sometimes still
         * prefixed.
         *
         * @param {string} selector Selector to test.
         * @param {!Element=} node Element to test the selector against.
         * @return {boolean} Whether the element matches the selector.
         * @override
         */

      }, {
        key: "elementMatches",
        value: function elementMatches(selector, node) {
          return (0, _polymerDom.matchesSelector)(node || this, selector);
        }
        /**
         * Toggles an HTML attribute on or off.
         *
         * @param {string} name HTML attribute name
         * @param {boolean=} bool Boolean to force the attribute on or off.
         *    When unspecified, the state of the attribute will be reversed.
         * @return {boolean} true if the attribute now exists
         * @override
         */

      }, {
        key: "toggleAttribute",
        value: function toggleAttribute(name, bool) {
          var node =
          /** @type {Element} */
          this;

          if (arguments.length === 3) {
            node =
            /** @type {Element} */
            arguments[2];
          }

          if (arguments.length == 1) {
            bool = !node.hasAttribute(name);
          }

          if (bool) {
            (0, _wrap.wrap)(node).setAttribute(name, '');
            return true;
          } else {
            (0, _wrap.wrap)(node).removeAttribute(name);
            return false;
          }
        }
        /**
         * Toggles a CSS class on or off.
         *
         * @param {string} name CSS class name
         * @param {boolean=} bool Boolean to force the class on or off.
         *    When unspecified, the state of the class will be reversed.
         * @param {Element=} node Node to target.  Defaults to `this`.
         * @return {void}
         * @override
         */

      }, {
        key: "toggleClass",
        value: function toggleClass(name, bool, node) {
          node =
          /** @type {Element} */
          node || this;

          if (arguments.length == 1) {
            bool = !node.classList.contains(name);
          }

          if (bool) {
            node.classList.add(name);
          } else {
            node.classList.remove(name);
          }
        }
        /**
         * Cross-platform helper for setting an element's CSS `transform` property.
         *
         * @param {string} transformText Transform setting.
         * @param {Element=} node Element to apply the transform to.
         * Defaults to `this`
         * @return {void}
         * @override
         */

      }, {
        key: "transform",
        value: function transform(transformText, node) {
          node =
          /** @type {Element} */
          node || this;
          node.style.webkitTransform = transformText;
          node.style.transform = transformText;
        }
        /**
         * Cross-platform helper for setting an element's CSS `translate3d`
         * property.
         *
         * @param {number|string} x X offset.
         * @param {number|string} y Y offset.
         * @param {number|string} z Z offset.
         * @param {Element=} node Element to apply the transform to.
         * Defaults to `this`.
         * @return {void}
         * @override
         */

      }, {
        key: "translate3d",
        value: function translate3d(x, y, z, node) {
          node =
          /** @type {Element} */
          node || this;
          this.transform('translate3d(' + x + ',' + y + ',' + z + ')', node);
        }
        /**
         * Removes an item from an array, if it exists.
         *
         * If the array is specified by path, a change notification is
         * generated, so that observers, data bindings and computed
         * properties watching that path can update.
         *
         * If the array is passed directly, **no change
         * notification is generated**.
         *
         * @param {string | !Array<number|string>} arrayOrPath Path to array from
         *     which to remove the item
         *   (or the array itself).
         * @param {*} item Item to remove.
         * @return {Array} Array containing item removed.
         * @override
         */

      }, {
        key: "arrayDelete",
        value: function arrayDelete(arrayOrPath, item) {
          var index;

          if (Array.isArray(arrayOrPath)) {
            index = arrayOrPath.indexOf(item);

            if (index >= 0) {
              return arrayOrPath.splice(index, 1);
            }
          } else {
            var arr = (0, _path.get)(this, arrayOrPath);
            index = arr.indexOf(item);

            if (index >= 0) {
              return this.splice(arrayOrPath, index, 1);
            }
          }

          return null;
        } // logging

        /**
         * Facades `console.log`/`warn`/`error` as override point.
         *
         * @param {string} level One of 'log', 'warn', 'error'
         * @param {Array} args Array of strings or objects to log
         * @return {void}
         * @override
         */

      }, {
        key: "_logger",
        value: function _logger(level, args) {
          var _console;

          // accept ['foo', 'bar'] and [['foo', 'bar']]
          if (Array.isArray(args) && args.length === 1 && Array.isArray(args[0])) {
            args = args[0];
          }

          switch (level) {
            case 'log':
            case 'warn':
            case 'error':
              (_console = console)[level].apply(_console, babelHelpers.toConsumableArray(args));

          }
        }
        /**
         * Facades `console.log` as an override point.
         *
         * @param {...*} args Array of strings or objects to log
         * @return {void}
         * @override
         */

      }, {
        key: "_log",
        value: function _log() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          this._logger('log', args);
        }
        /**
         * Facades `console.warn` as an override point.
         *
         * @param {...*} args Array of strings or objects to log
         * @return {void}
         * @override
         */

      }, {
        key: "_warn",
        value: function _warn() {
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }

          this._logger('warn', args);
        }
        /**
         * Facades `console.error` as an override point.
         *
         * @param {...*} args Array of strings or objects to log
         * @return {void}
         * @override
         */

      }, {
        key: "_error",
        value: function _error() {
          for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            args[_key3] = arguments[_key3];
          }

          this._logger('error', args);
        }
        /**
         * Formats a message using the element type an a method name.
         *
         * @param {string} methodName Method name to associate with message
         * @param {...*} args Array of strings or objects to log
         * @return {!Array} Array with formatting information for `console`
         *   logging.
         * @override
         */

      }, {
        key: "_logf",
        value: function _logf(methodName) {
          for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
            args[_key4 - 1] = arguments[_key4];
          }

          return ['[%s::%s]', this.is, methodName].concat(args);
        }
      }], [{
        key: "importMeta",
        get: function get() {
          return this.prototype.importMeta;
        }
      }, {
        key: "observedAttributes",
        get: function get() {
          if (_settings.legacyNoObservedAttributes && !this.prototype._legacyForceObservedAttributes) {
            // Ensure this element is property registered with the telemetry system.
            if (!this.hasOwnProperty(JSCompiler_renameProperty('__observedAttributes', this))) {
              this.__observedAttributes = [];
              (0, _telemetry.register)(this.prototype);
            }

            return this.__observedAttributes;
          } else {
            return observedAttributesGetter.call(this).concat(DISABLED_ATTR);
          }
        }
      }]);
      return LegacyElement;
    }(legacyElementBase);

    LegacyElement.prototype.is = '';
    return LegacyElement;
  });
  _exports.LegacyElementMixin = LegacyElementMixin;
});