define(["exports", "./class.js", "../../polymer-legacy.js", "../utils/mixin.js", "../utils/templatize.js"], function (_exports, _class, _polymerLegacy, _mixin, _templatize) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.LegacyDataMixin = void 0;

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var UndefinedArgumentError = /*#__PURE__*/function (_Error) {
    babelHelpers.inherits(UndefinedArgumentError, _Error);

    var _super = _createSuper(UndefinedArgumentError);

    function UndefinedArgumentError(message, arg) {
      var _this;

      babelHelpers.classCallCheck(this, UndefinedArgumentError);
      _this = _super.call(this, message);
      _this.arg = arg;
      _this.name = _this.constructor.name; // Affordances for ensuring instanceof works after babel ES5 compilation
      // TODO(kschaaf): Remove after polymer CLI updates to newer Babel that
      // sets the constructor/prototype correctly for subclassed builtins

      _this.constructor = UndefinedArgumentError;
      _this.__proto__ = UndefinedArgumentError.prototype;
      return _this;
    }

    return babelHelpers.createClass(UndefinedArgumentError);
  }( /*#__PURE__*/babelHelpers.wrapNativeSuper(Error));
  /**
   * Wraps effect functions to catch `UndefinedArgumentError`s and warn.
   *
   * @param {Object=} effect Effect metadata object
   * @param {Object=} fnName Name of user function, if known
   * @return {?Object|undefined} Effect metadata object
   */


  function wrapEffect(effect, fnName) {
    if (effect && effect.fn) {
      var fn = effect.fn;

      effect.fn = function () {
        try {
          fn.apply(this, arguments);
        } catch (e) {
          if (babelHelpers.instanceof(e, UndefinedArgumentError)) {
            console.warn("Argument '".concat(e.arg, "'").concat(fnName ? " for method '".concat(fnName, "'") : '', " was undefined. Ensure it has a default value, or else ensure the method handles the argument being undefined."));
          } else {
            throw e;
          }
        }
      };
    }

    return effect;
  }
  /**
   * Mixin to selectively add back Polymer 1.x's `undefined` rules
   * governing when observers & computing functions run based
   * on all arguments being defined (reference https://www.polymer-project.org/1.0/docs/devguide/observers#multi-property-observers).
   *
   * When loaded, all legacy elements (defined with `Polymer({...})`)
   * will have the mixin applied. The mixin only restores legacy data handling
   * if `_legacyUndefinedCheck: true` is set on the element's prototype.
   *
   * This mixin is intended for use to help migration from Polymer 1.x to
   * 2.x+ by allowing legacy code to work while identifying observers and
   * computing functions that need undefined checks to work without
   * the mixin in Polymer 2.
   *
   * @mixinFunction
   * @polymer
   * @summary Mixin to selectively add back Polymer 1.x's `undefined` rules
   * governing when observers & computing functions run.
   */


  var LegacyDataMixin = (0, _mixin.dedupingMixin)(function (superClass) {
    /**
     * @unrestricted
     * @private
     */
    var LegacyDataMixin = /*#__PURE__*/function (_superClass) {
      babelHelpers.inherits(LegacyDataMixin, _superClass);

      var _super2 = _createSuper(LegacyDataMixin);

      function LegacyDataMixin() {
        babelHelpers.classCallCheck(this, LegacyDataMixin);
        return _super2.apply(this, arguments);
      }

      babelHelpers.createClass(LegacyDataMixin, [{
        key: "_marshalArgs",
        value:
        /**
         * Overrides `Polymer.PropertyEffects` to add `undefined` argument
         * checking to match Polymer 1.x style rules
         *
         * @param {!Array<!MethodArg>} args Array of argument metadata
         * @param {string} path Property/path name that triggered the method effect
         * @param {Object} props Bag of current property changes
         * @return {Array<*>} Array of argument values
         * @private
         */
        function _marshalArgs(args, path, props) {
          var vals = babelHelpers.get(babelHelpers.getPrototypeOf(LegacyDataMixin.prototype), "_marshalArgs", this).call(this, args, path, props); // Per legacy data rules, single-property observers (whether in `properties`
          // and in `observers`) are called regardless of whether their argument is
          // undefined or not. Multi-property observers must have all arguments defined

          if (this._legacyUndefinedCheck && vals.length > 1) {
            for (var i = 0; i < vals.length; i++) {
              if (vals[i] === undefined || args[i].wildcard && vals[i].base === undefined) {
                // Break out of effect's control flow; will be caught in
                // wrapped property effect function below
                var name = args[i].name;
                throw new UndefinedArgumentError("Argument '".concat(name, "' is undefined."), name);
              }
            }
          }

          return vals;
        }
        /**
         * Overrides `Polyer.PropertyEffects` to wrap effect functions to
         * catch `UndefinedArgumentError`s and warn.
         *
         * @param {string} property Property that should trigger the effect
         * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES
         * @param {Object=} effect Effect metadata object
         * @return {void}
         * @protected
         */

      }, {
        key: "_addPropertyEffect",
        value: function _addPropertyEffect(property, type, effect) {
          return babelHelpers.get(babelHelpers.getPrototypeOf(LegacyDataMixin.prototype), "_addPropertyEffect", this).call(this, property, type, wrapEffect(effect, effect && effect.info && effect.info.methodName));
        }
        /**
         * Overrides `Polyer.PropertyEffects` to wrap effect functions to
         * catch `UndefinedArgumentError`s and warn.
         *
         * @param {Object} templateInfo Template metadata to add effect to
         * @param {string} prop Property that should trigger the effect
         * @param {Object=} effect Effect metadata object
         * @return {void}
         * @protected
         * @nocollapse
         */

      }], [{
        key: "_addTemplatePropertyEffect",
        value: function _addTemplatePropertyEffect(templateInfo, prop, effect) {
          // TODO(https://github.com/google/closure-compiler/issues/3240):
          //     Change back to just super.methodCall()
          return superClass._addTemplatePropertyEffect.call(this, templateInfo, prop, wrapEffect(effect));
        }
      }]);
      return LegacyDataMixin;
    }(superClass);

    return LegacyDataMixin;
  }); // LegacyDataMixin is applied to base class _before_ metaprogramming, to
  // ensure override of _addPropertyEffect et.al. are used by metaprogramming
  // performed in _finalizeClass

  _exports.LegacyDataMixin = LegacyDataMixin;

  _polymerLegacy.Polymer.Class = function (info, mixin) {
    return (0, _class.Class)(info, function (superClass) {
      return mixin ? mixin(LegacyDataMixin(superClass)) : LegacyDataMixin(superClass);
    });
  }; // Apply LegacyDataMixin to Templatizer instances as well, and defer
  // runtime switch to the root's host (_methodHost)

  /**
   * @mixinFunction
   * @polymer
   */


  var TemplatizeMixin = (0, _mixin.dedupingMixin)(function (superClass) {
    /**
     * @constructor
     * @extends {HTMLElement}
     */
    var legacyBase = LegacyDataMixin(superClass);
    /**
     * @private
     */

    var TemplateLegacy = /*#__PURE__*/function (_legacyBase) {
      babelHelpers.inherits(TemplateLegacy, _legacyBase);

      var _super3 = _createSuper(TemplateLegacy);

      function TemplateLegacy() {
        babelHelpers.classCallCheck(this, TemplateLegacy);
        return _super3.apply(this, arguments);
      }

      babelHelpers.createClass(TemplateLegacy, [{
        key: "_legacyUndefinedCheck",
        get: function get() {
          return this._methodHost && this._methodHost._legacyUndefinedCheck;
        }
      }]);
      return TemplateLegacy;
    }(legacyBase);
    /** @type {!Polymer_PropertyEffects} */


    TemplateLegacy.prototype._methodHost;
    return TemplateLegacy;
  });
  _templatize.templatize.mixin = TemplatizeMixin;
  console.info('LegacyDataMixin will be applied to all legacy elements.\n' + 'Set `_legacyUndefinedCheck: true` on element class to enable.');
});