define(["exports", "../utils/boot.js", "../utils/wrap.js", "../utils/settings.js", "../utils/flattened-nodes-observer.js", "../utils/flush.js", "../utils/debounce.js"], function (_exports, _boot, _wrap, _settings, _flattenedNodesObserver, _flush, _debounce) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.EventApi = _exports.DomApi = void 0;
  Object.defineProperty(_exports, "addDebouncer", {
    enumerable: true,
    get: function get() {
      return _flush.enqueueDebouncer;
    }
  });
  _exports.dom = void 0;
  Object.defineProperty(_exports, "flush", {
    enumerable: true,
    get: function get() {
      return _flush.flush;
    }
  });
  _exports.matchesSelector = void 0;

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  // used in type annotations

  /* eslint-enable no-unused-vars */
  var p = Element.prototype;
  /**
   * @const {function(this:Node, string): boolean}
   */

  var normalizedMatchesSelector = p.matches || p.matchesSelector || p.mozMatchesSelector || p.msMatchesSelector || p.oMatchesSelector || p.webkitMatchesSelector;
  /**
   * Cross-platform `element.matches` shim.
   *
   * @function matchesSelector
   * @param {!Node} node Node to check selector against
   * @param {string} selector Selector to match
   * @return {boolean} True if node matched selector
   */

  var matchesSelector = function matchesSelector(node, selector) {
    return normalizedMatchesSelector.call(node, selector);
  };
  /**
   * Node API wrapper class returned from `Polymer.dom.(target)` when
   * `target` is a `Node`.
   * @implements {PolymerDomApi}
   * @unrestricted
   */


  _exports.matchesSelector = matchesSelector;

  var DomApiNative = /*#__PURE__*/function () {
    /**
     * @param {!Node} node Node for which to create a Polymer.dom helper object.
     */
    function DomApiNative(node) {
      babelHelpers.classCallCheck(this, DomApiNative);

      if (window['ShadyDOM'] && window['ShadyDOM']['inUse']) {
        window['ShadyDOM']['patch'](node);
      }

      this.node = node;
    }
    /**
     * Returns an instance of `FlattenedNodesObserver` that
     * listens for node changes on this element.
     *
     * @param {function(this:HTMLElement, { target: !HTMLElement, addedNodes: !Array<!Element>, removedNodes: !Array<!Element> }):void} callback Called when direct or distributed children
     *   of this element changes
     * @return {!PolymerDomApi.ObserveHandle} Observer instance
     * @override
     */


    babelHelpers.createClass(DomApiNative, [{
      key: "observeNodes",
      value: function observeNodes(callback) {
        return new _flattenedNodesObserver.FlattenedNodesObserver(
        /** @type {!HTMLElement} */
        this.node, callback);
      }
      /**
       * Disconnects an observer previously created via `observeNodes`
       *
       * @param {!PolymerDomApi.ObserveHandle} observerHandle Observer instance
       *   to disconnect.
       * @return {void}
       * @override
       */

    }, {
      key: "unobserveNodes",
      value: function unobserveNodes(observerHandle) {
        observerHandle.disconnect();
      }
      /**
       * Provided as a backwards-compatible API only.  This method does nothing.
       * @return {void}
       */

    }, {
      key: "notifyObserver",
      value: function notifyObserver() {}
      /**
       * Returns true if the provided node is contained with this element's
       * light-DOM children or shadow root, including any nested shadow roots
       * of children therein.
       *
       * @param {Node} node Node to test
       * @return {boolean} Returns true if the given `node` is contained within
       *   this element's light or shadow DOM.
       * @override
       */

    }, {
      key: "deepContains",
      value: function deepContains(node) {
        if ((0, _wrap.wrap)(this.node).contains(node)) {
          return true;
        }

        var n = node;
        var doc = node.ownerDocument; // walk from node to `this` or `document`

        while (n && n !== doc && n !== this.node) {
          // use logical parentnode, or native ShadowRoot host
          n = (0, _wrap.wrap)(n).parentNode || (0, _wrap.wrap)(n).host;
        }

        return n === this.node;
      }
      /**
       * Returns the root node of this node.  Equivalent to `getRootNode()`.
       *
       * @return {!Node} Top most element in the dom tree in which the node
       * exists. If the node is connected to a document this is either a
       * shadowRoot or the document; otherwise, it may be the node
       * itself or a node or document fragment containing it.
       * @override
       */

    }, {
      key: "getOwnerRoot",
      value: function getOwnerRoot() {
        return (0, _wrap.wrap)(this.node).getRootNode();
      }
      /**
       * For slot elements, returns the nodes assigned to the slot; otherwise
       * an empty array. It is equivalent to `<slot>.addignedNodes({flatten:true})`.
       *
       * @return {!Array<!Node>} Array of assigned nodes
       * @override
       */

    }, {
      key: "getDistributedNodes",
      value: function getDistributedNodes() {
        return this.node.localName === 'slot' ? (0, _wrap.wrap)(this.node).assignedNodes({
          flatten: true
        }) : [];
      }
      /**
       * Returns an array of all slots this element was distributed to.
       *
       * @return {!Array<!HTMLSlotElement>} Description
       * @override
       */

    }, {
      key: "getDestinationInsertionPoints",
      value: function getDestinationInsertionPoints() {
        var ip$ = [];
        var n = (0, _wrap.wrap)(this.node).assignedSlot;

        while (n) {
          ip$.push(n);
          n = (0, _wrap.wrap)(n).assignedSlot;
        }

        return ip$;
      }
      /**
       * Calls `importNode` on the `ownerDocument` for this node.
       *
       * @param {!Node} node Node to import
       * @param {boolean} deep True if the node should be cloned deeply during
       *   import
       * @return {Node} Clone of given node imported to this owner document
       */

    }, {
      key: "importNode",
      value: function importNode(node, deep) {
        var doc = babelHelpers.instanceof(this.node, Document) ? this.node : this.node.ownerDocument;
        return (0, _wrap.wrap)(doc).importNode(node, deep);
      }
      /**
       * @return {!Array<!Node>} Returns a flattened list of all child nodes and
       * nodes assigned to child slots.
       * @override
       */

    }, {
      key: "getEffectiveChildNodes",
      value: function getEffectiveChildNodes() {
        return _flattenedNodesObserver.FlattenedNodesObserver.getFlattenedNodes(
        /** @type {!HTMLElement} */
        this.node);
      }
      /**
       * Returns a filtered list of flattened child elements for this element based
       * on the given selector.
       *
       * @param {string} selector Selector to filter nodes against
       * @return {!Array<!HTMLElement>} List of flattened child elements
       * @override
       */

    }, {
      key: "queryDistributedElements",
      value: function queryDistributedElements(selector) {
        var c$ = this.getEffectiveChildNodes();
        var list = [];

        for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
          if (c.nodeType === Node.ELEMENT_NODE && matchesSelector(c, selector)) {
            list.push(c);
          }
        }

        return list;
      }
      /**
       * For shadow roots, returns the currently focused element within this
       * shadow root.
       *
       * return {Node|undefined} Currently focused element
       * @override
       */

    }, {
      key: "activeElement",
      get: function get() {
        var node = this.node;
        return node._activeElement !== undefined ? node._activeElement : node.activeElement;
      }
    }]);
    return DomApiNative;
  }();

  function forwardMethods(proto, methods) {
    var _loop = function _loop(i) {
      var method = methods[i];
      /* eslint-disable valid-jsdoc */

      proto[method] =
      /** @this {DomApiNative} */
      function () {
        return this.node[method].apply(this.node, arguments);
      };
      /* eslint-enable */

    };

    for (var i = 0; i < methods.length; i++) {
      _loop(i);
    }
  }

  function forwardReadOnlyProperties(proto, properties) {
    var _loop2 = function _loop2(i) {
      var name = properties[i];
      Object.defineProperty(proto, name, {
        get: function get() {
          var domApi =
          /** @type {DomApiNative} */
          this;
          return domApi.node[name];
        },
        configurable: true
      });
    };

    for (var i = 0; i < properties.length; i++) {
      _loop2(i);
    }
  }

  function forwardProperties(proto, properties) {
    var _loop3 = function _loop3(i) {
      var name = properties[i];
      Object.defineProperty(proto, name, {
        /**
         * @this {DomApiNative}
         * @return {*} .
         */
        get: function get() {
          return this.node[name];
        },

        /**
         * @this {DomApiNative}
         * @param {*} value .
         */
        set: function set(value) {
          this.node[name] = value;
        },
        configurable: true
      });
    };

    for (var i = 0; i < properties.length; i++) {
      _loop3(i);
    }
  }
  /**
   * Event API wrapper class returned from `dom.(target)` when
   * `target` is an `Event`.
   */


  var EventApi = /*#__PURE__*/function () {
    function EventApi(event) {
      babelHelpers.classCallCheck(this, EventApi);
      this.event = event;
    }
    /**
     * Returns the first node on the `composedPath` of this event.
     *
     * @return {!EventTarget} The node this event was dispatched to
     */


    babelHelpers.createClass(EventApi, [{
      key: "rootTarget",
      get: function get() {
        return this.path[0];
      }
      /**
       * Returns the local (re-targeted) target for this event.
       *
       * @return {!EventTarget} The local (re-targeted) target for this event.
       */

    }, {
      key: "localTarget",
      get: function get() {
        return this.event.target;
      }
      /**
       * Returns the `composedPath` for this event.
       * @return {!Array<!EventTarget>} The nodes this event propagated through
       */

    }, {
      key: "path",
      get: function get() {
        return this.event.composedPath();
      }
    }]);
    return EventApi;
  }();
  /**
   * @function
   * @param {boolean=} deep
   * @return {!Node}
   */


  _exports.EventApi = EventApi;
  DomApiNative.prototype.cloneNode;
  /**
   * @function
   * @param {!Node} node
   * @return {!Node}
   */

  DomApiNative.prototype.appendChild;
  /**
   * @function
   * @param {!Node} newChild
   * @param {Node} refChild
   * @return {!Node}
   */

  DomApiNative.prototype.insertBefore;
  /**
   * @function
   * @param {!Node} node
   * @return {!Node}
   */

  DomApiNative.prototype.removeChild;
  /**
   * @function
   * @param {!Node} oldChild
   * @param {!Node} newChild
   * @return {!Node}
   */

  DomApiNative.prototype.replaceChild;
  /**
   * @function
   * @param {string} name
   * @param {string} value
   * @return {void}
   */

  DomApiNative.prototype.setAttribute;
  /**
   * @function
   * @param {string} name
   * @return {void}
   */

  DomApiNative.prototype.removeAttribute;
  /**
   * @function
   * @param {string} selector
   * @return {?Element}
   */

  DomApiNative.prototype.querySelector;
  /**
   * @function
   * @param {string} selector
   * @return {!NodeList<!Element>}
   */

  DomApiNative.prototype.querySelectorAll;
  /** @type {?Node} */

  DomApiNative.prototype.parentNode;
  /** @type {?Node} */

  DomApiNative.prototype.firstChild;
  /** @type {?Node} */

  DomApiNative.prototype.lastChild;
  /** @type {?Node} */

  DomApiNative.prototype.nextSibling;
  /** @type {?Node} */

  DomApiNative.prototype.previousSibling;
  /** @type {?HTMLElement} */

  DomApiNative.prototype.firstElementChild;
  /** @type {?HTMLElement} */

  DomApiNative.prototype.lastElementChild;
  /** @type {?HTMLElement} */

  DomApiNative.prototype.nextElementSibling;
  /** @type {?HTMLElement} */

  DomApiNative.prototype.previousElementSibling;
  /** @type {!Array<!Node>} */

  DomApiNative.prototype.childNodes;
  /** @type {!Array<!HTMLElement>} */

  DomApiNative.prototype.children;
  /** @type {?DOMTokenList} */

  DomApiNative.prototype.classList;
  /** @type {string} */

  DomApiNative.prototype.textContent;
  /** @type {string} */

  DomApiNative.prototype.innerHTML;
  var DomApiImpl = DomApiNative;

  if (window['ShadyDOM'] && window['ShadyDOM']['inUse'] && window['ShadyDOM']['noPatch'] && window['ShadyDOM']['Wrapper']) {
    /**
     * @private
     * @extends {HTMLElement}
     */
    var Wrapper = /*#__PURE__*/function (_window$ShadyDOM$Wrap) {
      babelHelpers.inherits(Wrapper, _window$ShadyDOM$Wrap);

      var _super = _createSuper(Wrapper);

      function Wrapper() {
        babelHelpers.classCallCheck(this, Wrapper);
        return _super.apply(this, arguments);
      }

      return babelHelpers.createClass(Wrapper);
    }(window['ShadyDOM']['Wrapper']); // copy bespoke API onto wrapper


    Object.getOwnPropertyNames(DomApiNative.prototype).forEach(function (prop) {
      if (prop != 'activeElement') {
        Wrapper.prototype[prop] = DomApiNative.prototype[prop];
      }
    }); // Note, `classList` is here only for legacy compatibility since it does not
    // trigger distribution in v1 Shadow DOM.

    forwardReadOnlyProperties(Wrapper.prototype, ['classList']);
    DomApiImpl = Wrapper;
    Object.defineProperties(EventApi.prototype, {
      // Returns the "lowest" node in the same root as the event's currentTarget.
      // When in `noPatch` mode, this must be calculated by walking the event's
      // path.
      localTarget: {
        get: function get() {
          var current = this.event.currentTarget;
          var currentRoot = current && dom(current).getOwnerRoot();
          var p$ = this.path;

          for (var i = 0; i < p$.length; i++) {
            var e = p$[i];

            if (dom(e).getOwnerRoot() === currentRoot) {
              return e;
            }
          }
        },
        configurable: true
      },
      path: {
        get: function get() {
          return window['ShadyDOM']['composedPath'](this.event);
        },
        configurable: true
      }
    });
  } else {
    // Methods that can provoke distribution or must return the logical, not
    // composed tree.
    forwardMethods(DomApiNative.prototype, ['cloneNode', 'appendChild', 'insertBefore', 'removeChild', 'replaceChild', 'setAttribute', 'removeAttribute', 'querySelector', 'querySelectorAll']); // Properties that should return the logical, not composed tree. Note, `classList`
    // is here only for legacy compatibility since it does not trigger distribution
    // in v1 Shadow DOM.

    forwardReadOnlyProperties(DomApiNative.prototype, ['parentNode', 'firstChild', 'lastChild', 'nextSibling', 'previousSibling', 'firstElementChild', 'lastElementChild', 'nextElementSibling', 'previousElementSibling', 'childNodes', 'children', 'classList']);
    forwardProperties(DomApiNative.prototype, ['textContent', 'innerHTML', 'className']);
  }

  var DomApi = DomApiImpl;
  /**
   * Legacy DOM and Event manipulation API wrapper factory used to abstract
   * differences between native Shadow DOM and "Shady DOM" when polyfilling on
   * older browsers.
   *
   * Note that in Polymer 2.x use of `Polymer.dom` is no longer required and
   * in the majority of cases simply facades directly to the standard native
   * API.
   *
   * @summary Legacy DOM and Event manipulation API wrapper factory used to
   * abstract differences between native Shadow DOM and "Shady DOM."
   * @param {(Node|Event|DomApiNative|EventApi)=} obj Node or event to operate on
   * @return {!DomApiNative|!EventApi} Wrapper providing either node API or event API
   */

  _exports.DomApi = DomApi;

  var dom = function dom(obj) {
    obj = obj || document;

    if (babelHelpers.instanceof(obj, DomApiImpl)) {
      return (
        /** @type {!DomApi} */
        obj
      );
    }

    if (babelHelpers.instanceof(obj, EventApi)) {
      return (
        /** @type {!EventApi} */
        obj
      );
    }

    var helper = obj['__domApi'];

    if (!helper) {
      if (babelHelpers.instanceof(obj, Event)) {
        helper = new EventApi(obj);
      } else {
        helper = new DomApiImpl(
        /** @type {Node} */
        obj);
      }

      obj['__domApi'] = helper;
    }

    return helper;
  };

  _exports.dom = dom;
});