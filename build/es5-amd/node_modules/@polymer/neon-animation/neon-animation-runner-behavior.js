define(["exports", "../polymer/polymer-legacy.js", "./neon-animatable-behavior.js"], function (_exports, _polymerLegacy, _neonAnimatableBehavior) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.NeonAnimationRunnerBehaviorImpl = _exports.NeonAnimationRunnerBehavior = void 0;

  /**
  @license
  Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at
  http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
  http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
  found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
  part of the polymer project is also subject to an additional IP rights grant
  found at http://polymer.github.io/PATENTS.txt
  */

  /**
   * `NeonAnimationRunnerBehavior` adds a method to run animations.
   *
   * @polymerBehavior NeonAnimationRunnerBehavior
   */
  var NeonAnimationRunnerBehaviorImpl = {
    _configureAnimations: function _configureAnimations(configs) {
      var results = [];
      var resultsToPlay = [];

      if (configs.length > 0) {
        for (var config, index = 0; config = configs[index]; index++) {
          var neonAnimation = document.createElement(config.name); // is this element actually a neon animation?

          if (neonAnimation.isNeonAnimation) {
            var result = null; // Closure compiler does not work well with a try / catch here.
            // .configure needs to be explicitly defined

            if (!neonAnimation.configure) {
              /**
               * @param {Object} config
               * @return {AnimationEffectReadOnly}
               */
              neonAnimation.configure = function (config) {
                return null;
              };
            }

            result = neonAnimation.configure(config);
            resultsToPlay.push({
              result: result,
              config: config,
              neonAnimation: neonAnimation
            });
          } else {
            console.warn(this.is + ':', config.name, 'not found!');
          }
        }
      }

      for (var i = 0; i < resultsToPlay.length; i++) {
        var _result = resultsToPlay[i].result;
        var _config = resultsToPlay[i].config;
        var _neonAnimation = resultsToPlay[i].neonAnimation; // configuration or play could fail if polyfills aren't loaded

        try {
          // Check if we have an Effect rather than an Animation
          if (typeof _result.cancel != 'function') {
            _result = document.timeline.play(_result);
          }
        } catch (e) {
          _result = null;
          console.warn('Couldnt play', '(', _config.name, ').', e);
        }

        if (_result) {
          results.push({
            neonAnimation: _neonAnimation,
            config: _config,
            animation: _result
          });
        }
      }

      return results;
    },
    _shouldComplete: function _shouldComplete(activeEntries) {
      var finished = true;

      for (var i = 0; i < activeEntries.length; i++) {
        if (activeEntries[i].animation.playState != 'finished') {
          finished = false;
          break;
        }
      }

      return finished;
    },
    _complete: function _complete(activeEntries) {
      for (var i = 0; i < activeEntries.length; i++) {
        activeEntries[i].neonAnimation.complete(activeEntries[i].config);
      }

      for (var i = 0; i < activeEntries.length; i++) {
        activeEntries[i].animation.cancel();
      }
    },

    /**
     * Plays an animation with an optional `type`.
     * @param {string=} type
     * @param {!Object=} cookie
     */
    playAnimation: function playAnimation(type, cookie) {
      var configs = this.getAnimationConfig(type);

      if (!configs) {
        return;
      }

      this._active = this._active || {};

      if (this._active[type]) {
        this._complete(this._active[type]);

        delete this._active[type];
      }

      var activeEntries = this._configureAnimations(configs);

      if (activeEntries.length == 0) {
        this.fire('neon-animation-finish', cookie, {
          bubbles: false
        });
        return;
      }

      this._active[type] = activeEntries;

      for (var i = 0; i < activeEntries.length; i++) {
        activeEntries[i].animation.onfinish = function () {
          if (this._shouldComplete(activeEntries)) {
            this._complete(activeEntries);

            delete this._active[type];
            this.fire('neon-animation-finish', cookie, {
              bubbles: false
            });
          }
        }.bind(this);
      }
    },

    /**
     * Cancels the currently running animations.
     */
    cancelAnimation: function cancelAnimation() {
      for (var k in this._active) {
        var entries = this._active[k];

        for (var j in entries) {
          entries[j].animation.cancel();
        }
      }

      this._active = {};
    }
  };
  /** @polymerBehavior */

  _exports.NeonAnimationRunnerBehaviorImpl = NeonAnimationRunnerBehaviorImpl;
  var NeonAnimationRunnerBehavior = [_neonAnimatableBehavior.NeonAnimatableBehavior, NeonAnimationRunnerBehaviorImpl];
  _exports.NeonAnimationRunnerBehavior = NeonAnimationRunnerBehavior;
});