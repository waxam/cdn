define(["exports", "../lit-html.js"], function (_exports, _litHtml) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.asyncReplace = void 0;

  /**
   * @license
   * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   */
  var __asyncValues = void 0 && (void 0).__asyncValues || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator],
        i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
      return this;
    }, i);

    function verb(n) {
      i[n] = o[n] && function (v) {
        return new Promise(function (resolve, reject) {
          v = o[n](v), settle(resolve, reject, v.done, v.value);
        });
      };
    }

    function settle(resolve, reject, d, v) {
      Promise.resolve(v).then(function (v) {
        resolve({
          value: v,
          done: d
        });
      }, reject);
    }
  };

  /**
   * A directive that renders the items of an async iterable[1], replacing
   * previous values with new values, so that only one value is ever rendered
   * at a time.
   *
   * Async iterables are objects with a [Symbol.asyncIterator] method, which
   * returns an iterator who's `next()` method returns a Promise. When a new
   * value is available, the Promise resolves and the value is rendered to the
   * Part controlled by the directive. If another value other than this
   * directive has been set on the Part, the iterable will no longer be listened
   * to and new values won't be written to the Part.
   *
   * [1]: https://github.com/tc39/proposal-async-iteration
   *
   * @param value An async iterable
   * @param mapper An optional function that maps from (value, index) to another
   *     value. Useful for generating templates for each item in the iterable.
   */
  var asyncReplace = (0, _litHtml.directive)(function (value, mapper) {
    return (
      /*#__PURE__*/
      function () {
        var _ref = babelHelpers.asyncToGenerator(
        /*#__PURE__*/
        regeneratorRuntime.mark(function _callee(part) {
          var e_1, _a, itemPart, i, value_1, value_1_1, v;

          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  if (babelHelpers.instanceof(part, _litHtml.NodePart)) {
                    _context.next = 2;
                    break;
                  }

                  throw new Error('asyncReplace can only be used in text bindings');

                case 2:
                  if (!(value === part.value)) {
                    _context.next = 4;
                    break;
                  }

                  return _context.abrupt("return");

                case 4:
                  // We nest a new part to keep track of previous item values separately
                  // of the iterable as a value itself.
                  itemPart = new _litHtml.NodePart(part.options);
                  part.value = value;
                  i = 0;
                  _context.prev = 7;
                  value_1 = __asyncValues(value);

                case 9:
                  _context.next = 11;
                  return value_1.next();

                case 11:
                  value_1_1 = _context.sent;

                  if (value_1_1.done) {
                    _context.next = 23;
                    break;
                  }

                  v = value_1_1.value; // Check to make sure that value is the still the current value of
                  // the part, and if not bail because a new value owns this part

                  if (!(part.value !== value)) {
                    _context.next = 16;
                    break;
                  }

                  return _context.abrupt("break", 23);

                case 16:
                  // When we get the first value, clear the part. This let's the
                  // previous value display until we can replace it.
                  if (i === 0) {
                    part.clear();
                    itemPart.appendIntoPart(part);
                  } // As a convenience, because functional-programming-style
                  // transforms of iterables and async iterables requires a library,
                  // we accept a mapper function. This is especially convenient for
                  // rendering a template for each item.


                  if (mapper !== undefined) {
                    // This is safe because T must otherwise be treated as unknown by
                    // the rest of the system.
                    v = mapper(v, i);
                  }

                  itemPart.setValue(v);
                  itemPart.commit();
                  i++;

                case 21:
                  _context.next = 9;
                  break;

                case 23:
                  _context.next = 28;
                  break;

                case 25:
                  _context.prev = 25;
                  _context.t0 = _context["catch"](7);
                  e_1 = {
                    error: _context.t0
                  };

                case 28:
                  _context.prev = 28;
                  _context.prev = 29;

                  if (!(value_1_1 && !value_1_1.done && (_a = value_1.return))) {
                    _context.next = 33;
                    break;
                  }

                  _context.next = 33;
                  return _a.call(value_1);

                case 33:
                  _context.prev = 33;

                  if (!e_1) {
                    _context.next = 36;
                    break;
                  }

                  throw e_1.error;

                case 36:
                  return _context.finish(33);

                case 37:
                  return _context.finish(28);

                case 38:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, null, [[7, 25, 28, 38], [29,, 33, 37]]);
        }));

        return function (_x) {
          return _ref.apply(this, arguments);
        };
      }()
    );
  });
  _exports.asyncReplace = asyncReplace;
});