define(["exports"],function(_exports){"use strict";Object.defineProperty(_exports,"__esModule",{value:!0});_exports.lastAttributeNameRegex=_exports.createMarker=_exports.isTemplatePartActive=_exports.Template=_exports.boundAttributeSuffix=_exports.markerRegex=_exports.nodeMarker=_exports.marker=void 0;/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */ /**
 * An expression marker with embedded unique key to avoid collision with
 * possible text in templates.
 */var marker="{{lit-".concat((Math.random()+"").slice(2),"}}");/**
 * An expression marker used text-positions, multi-binding attributes, and
 * attributes with markup-like text values.
 */_exports.marker=marker;var nodeMarker="<!--".concat(marker,"-->");_exports.nodeMarker=nodeMarker;var markerRegex=new RegExp("".concat(marker,"|").concat(nodeMarker));/**
 * Suffix appended to all bound attribute names.
 */_exports.markerRegex=markerRegex;var boundAttributeSuffix="$lit$";/**
 * An updateable Template that tracks the location of dynamic parts.
 */_exports.boundAttributeSuffix=boundAttributeSuffix;var Template=function Template(result,element){var _this=this;babelHelpers.classCallCheck(this,Template);this.parts=[];this.element=element;var index=-1,partIndex=0,nodesToRemove=[],_prepareTemplate=function _prepareTemplate(template){var content=template.content,walker=document.createTreeWalker(content,133/* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */,null,!1),lastPartIndex=0;// Edge needs all 4 parameters present; IE11 needs 3rd parameter to be
// null
while(walker.nextNode()){index++;var node=walker.currentNode;if(1===node.nodeType/* Node.ELEMENT_NODE */){if(node.hasAttributes()){for(var attributes=node.attributes,count=0,i=0;i<attributes.length;i++){if(0<=attributes[i].value.indexOf(marker)){count++}}while(0<count--){// Get the template literal section leading up to the first
// expression in this attribute
var stringForPart=result.strings[partIndex],name=lastAttributeNameRegex.exec(stringForPart)[2],attributeLookupName=name.toLowerCase()+boundAttributeSuffix,attributeValue=node.getAttribute(attributeLookupName),strings=attributeValue.split(markerRegex);// Find the attribute name
_this.parts.push({type:"attribute",index:index,name:name,strings:strings});node.removeAttribute(attributeLookupName);partIndex+=strings.length-1}}if("TEMPLATE"===node.tagName){_prepareTemplate(node)}}else if(3===node.nodeType/* Node.TEXT_NODE */){var data=node.data;if(0<=data.indexOf(marker)){// Generate a new text node for each literal section
// These nodes are also used as the markers for node parts
for(var parent=node.parentNode,_strings=data.split(markerRegex),lastIndex=_strings.length-1,_i=0;_i<lastIndex;_i++){parent.insertBefore(""===_strings[_i]?createMarker():document.createTextNode(_strings[_i]),node);_this.parts.push({type:"node",index:++index})}// If there's no text, we must insert a comment to mark our place.
// Else, we can trust it will stick around after cloning.
if(""===_strings[lastIndex]){parent.insertBefore(createMarker(),node);nodesToRemove.push(node)}else{node.data=_strings[lastIndex]}// We have a part for each match found
partIndex+=lastIndex}}else if(8===node.nodeType/* Node.COMMENT_NODE */){if(node.data===marker){var _parent=node.parentNode;// Add a new marker node to be the startNode of the Part if any of
// the following are true:
//  * We don't have a previousSibling
//  * The previousSibling is already the start of a previous part
if(null===node.previousSibling||index===lastPartIndex){index++;_parent.insertBefore(createMarker(),node)}lastPartIndex=index;_this.parts.push({type:"node",index:index});// If we don't have a nextSibling, keep this node so we have an end.
// Else, we can remove it to save future costs.
if(null===node.nextSibling){node.data=""}else{nodesToRemove.push(node);index--}partIndex++}else{var _i2=-1;while(-1!==(_i2=node.data.indexOf(marker,_i2+1))){// Comment node has a binding marker inside, make an inactive part
// The binding won't work, but subsequent bindings will
// TODO (justinfagnani): consider whether it's even worth it to
// make bindings in comments work
_this.parts.push({type:"node",index:-1})}}}}};_prepareTemplate(element);// Remove text binding nodes after the walk to not disturb the TreeWalker
for(var _i3=0,_nodesToRemove=nodesToRemove,n;_i3<_nodesToRemove.length;_i3++){n=_nodesToRemove[_i3];n.parentNode.removeChild(n)}};_exports.Template=Template;var isTemplatePartActive=function isTemplatePartActive(part){return-1!==part.index};// Allows `document.createComment('')` to be renamed for a
// small manual size-savings.
_exports.isTemplatePartActive=isTemplatePartActive;var createMarker=function createMarker(){return document.createComment("")};/**
 * This regex extracts the attribute name preceding an attribute-position
 * expression. It does this by matching the syntax allowed for attributes
 * against the string literal directly preceding the expression, assuming that
 * the expression is in an attribute-value position.
 *
 * See attributes in the HTML spec:
 * https://www.w3.org/TR/html5/syntax.html#attributes-0
 *
 * "\0-\x1F\x7F-\x9F" are Unicode control characters
 *
 * " \x09\x0a\x0c\x0d" are HTML space characters:
 * https://www.w3.org/TR/html5/infrastructure.html#space-character
 *
 * So an attribute is:
 *  * The name: any character except a control character, space character, ('),
 *    ("), ">", "=", or "/"
 *  * Followed by zero or more space characters
 *  * Followed by "="
 *  * Followed by zero or more space characters
 *  * Followed by:
 *    * Any character except space, ('), ("), "<", ">", "=", (`), or
 *    * (") then any non-("), or
 *    * (') then any non-(')
 */_exports.createMarker=createMarker;var lastAttributeNameRegex=/([ \x09\x0a\x0c\x0d])([^\0-\x1F\x7F-\x9F \x09\x0a\x0c\x0d"'>=/]+)([ \x09\x0a\x0c\x0d]*=[ \x09\x0a\x0c\x0d]*(?:[^ \x09\x0a\x0c\x0d"'`<>=]*|"[^"]*|'[^']*))$/;//# sourceMappingURL=template.js.map
_exports.lastAttributeNameRegex=lastAttributeNameRegex});