define(["exports", "./lit-html.js"], function (_exports, _litHtml) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.setCommittedValue = _exports.setChildPartValue = _exports.removePart = _exports.isTemplateResult = _exports.isSingleExpression = _exports.isPrimitive = _exports.isDirectiveResult = _exports.insertPart = _exports.getDirectiveClass = _exports.getCommittedValue = _exports.clearPart = _exports.TemplateResultType = void 0;

  /**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   */
  var _a, _b;

  var ChildPart = _litHtml._$LH._ChildPart;
  var ENABLE_SHADYDOM_NOPATCH = true;
  var wrap = ENABLE_SHADYDOM_NOPATCH && ((_a = window.ShadyDOM) === null || _a === void 0 ? void 0 : _a.inUse) && ((_b = window.ShadyDOM) === null || _b === void 0 ? void 0 : _b.noPatch) === true ? window.ShadyDOM.wrap : function (node) {
    return node;
  };
  /**
   * Tests if a value is a primitive value.
   *
   * See https://tc39.github.io/ecma262/#sec-typeof-operator
   */

  var isPrimitive = function isPrimitive(value) {
    return value === null || babelHelpers.typeof(value) != 'object' && typeof value != 'function';
  };

  _exports.isPrimitive = isPrimitive;
  var TemplateResultType = {
    HTML: 1,
    SVG: 2
  };
  /**
   * Tests if a value is a TemplateResult.
   */

  _exports.TemplateResultType = TemplateResultType;

  var isTemplateResult = function isTemplateResult(value, type) {
    var _a, _b;

    return type === undefined ? // This property needs to remain unminified.
    ((_a = value) === null || _a === void 0 ? void 0 : _a['_$litType$']) !== undefined : ((_b = value) === null || _b === void 0 ? void 0 : _b['_$litType$']) === type;
  };
  /**
   * Tests if a value is a DirectiveResult.
   */


  _exports.isTemplateResult = isTemplateResult;

  var isDirectiveResult = function isDirectiveResult(value) {
    var _a; // This property needs to remain unminified.


    return ((_a = value) === null || _a === void 0 ? void 0 : _a['_$litDirective$']) !== undefined;
  };
  /**
   * Retrieves the Directive class for a DirectiveResult
   */


  _exports.isDirectiveResult = isDirectiveResult;

  var getDirectiveClass = function getDirectiveClass(value) {
    var _a; // This property needs to remain unminified.


    return (_a = value) === null || _a === void 0 ? void 0 : _a['_$litDirective$'];
  };
  /**
   * Tests whether a part has only a single-expression with no strings to
   * interpolate between.
   *
   * Only AttributePart and PropertyPart can have multiple expressions.
   * Multi-expression parts have a `strings` property and single-expression
   * parts do not.
   */


  _exports.getDirectiveClass = getDirectiveClass;

  var isSingleExpression = function isSingleExpression(part) {
    return part.strings === undefined;
  };

  _exports.isSingleExpression = isSingleExpression;

  var createMarker = function createMarker() {
    return document.createComment('');
  };
  /**
   * Inserts a ChildPart into the given container ChildPart's DOM, either at the
   * end of the container ChildPart, or before the optional `refPart`.
   *
   * This does not add the part to the containerPart's committed value. That must
   * be done by callers.
   *
   * @param containerPart Part within which to add the new ChildPart
   * @param refPart Part before which to add the new ChildPart; when omitted the
   *     part added to the end of the `containerPart`
   * @param part Part to insert, or undefined to create a new part
   */


  var insertPart = function insertPart(containerPart, refPart, part) {
    var _a;

    var container = wrap(containerPart._$startNode).parentNode;
    var refNode = refPart === undefined ? containerPart._$endNode : refPart._$startNode;

    if (part === undefined) {
      var startNode = wrap(container).insertBefore(createMarker(), refNode);
      var endNode = wrap(container).insertBefore(createMarker(), refNode);
      part = new ChildPart(startNode, endNode, containerPart, containerPart.options);
    } else {
      var _endNode = wrap(part._$endNode).nextSibling;
      var oldParent = part._$parent;
      var parentChanged = oldParent !== containerPart;

      if (parentChanged) {
        (_a = part._$reparentDisconnectables) === null || _a === void 0 ? void 0 : _a.call(part, containerPart); // Note that although `_$reparentDisconnectables` updates the part's
        // `_$parent` reference after unlinking from its current parent, that
        // method only exists if Disconnectables are present, so we need to
        // unconditionally set it here

        part._$parent = containerPart; // Since the _$isConnected getter is somewhat costly, only
        // read it once we know the subtree has directives that need
        // to be notified

        var newConnectionState;

        if (part._$notifyConnectionChanged !== undefined && (newConnectionState = containerPart._$isConnected) !== oldParent._$isConnected) {
          part._$notifyConnectionChanged(newConnectionState);
        }
      }

      if (_endNode !== refNode || parentChanged) {
        var start = part._$startNode;

        while (start !== _endNode) {
          var n = wrap(start).nextSibling;
          wrap(container).insertBefore(start, refNode);
          start = n;
        }
      }
    }

    return part;
  };
  /**
   * Sets the value of a Part.
   *
   * Note that this should only be used to set/update the value of user-created
   * parts (i.e. those created using `insertPart`); it should not be used
   * by directives to set the value of the directive's container part. Directives
   * should return a value from `update`/`render` to update their part state.
   *
   * For directives that require setting their part value asynchronously, they
   * should extend `AsyncDirective` and call `this.setValue()`.
   *
   * @param part Part to set
   * @param value Value to set
   * @param index For `AttributePart`s, the index to set
   * @param directiveParent Used internally; should not be set by user
   */


  _exports.insertPart = insertPart;

  var setChildPartValue = function setChildPartValue(part, value) {
    var directiveParent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : part;

    part._$setValue(value, directiveParent);

    return part;
  }; // A sentinal value that can never appear as a part value except when set by
  // live(). Used to force a dirty-check to fail and cause a re-render.


  _exports.setChildPartValue = setChildPartValue;
  var RESET_VALUE = {};
  /**
   * Sets the committed value of a ChildPart directly without triggering the
   * commit stage of the part.
   *
   * This is useful in cases where a directive needs to update the part such
   * that the next update detects a value change or not. When value is omitted,
   * the next update will be guaranteed to be detected as a change.
   *
   * @param part
   * @param value
   */

  var setCommittedValue = function setCommittedValue(part) {
    var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : RESET_VALUE;
    return part._$committedValue = value;
  };
  /**
   * Returns the committed value of a ChildPart.
   *
   * The committed value is used for change detection and efficient updates of
   * the part. It can differ from the value set by the template or directive in
   * cases where the template value is transformed before being commited.
   *
   * - `TemplateResult`s are committed as a `TemplateInstance`
   * - Iterables are committed as `Array<ChildPart>`
   * - All other types are committed as the template value or value returned or
   *   set by a directive.
   *
   * @param part
   */


  _exports.setCommittedValue = setCommittedValue;

  var getCommittedValue = function getCommittedValue(part) {
    return part._$committedValue;
  };
  /**
   * Removes a ChildPart from the DOM, including any of its content.
   *
   * @param part The Part to remove
   */


  _exports.getCommittedValue = getCommittedValue;

  var removePart = function removePart(part) {
    var _a;

    (_a = part._$notifyConnectionChanged) === null || _a === void 0 ? void 0 : _a.call(part, false, true);
    var start = part._$startNode;
    var end = wrap(part._$endNode).nextSibling;

    while (start !== end) {
      var n = wrap(start).nextSibling;
      wrap(start).remove();
      start = n;
    }
  };

  _exports.removePart = removePart;

  var clearPart = function clearPart(part) {
    part._$clear();
  };

  _exports.clearPart = clearPart;
});