define(["exports", "./lit-html.js"], function (_exports, _litHtml) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.withStatic = _exports.unsafeStatic = _exports.svg = _exports.literal = _exports.html = void 0;

  /**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   */
  // Any new exports need to be added to the export statement in
  // `packages/lit/src/index.all.ts`.

  /**
   * Wraps a string so that it behaves like part of the static template
   * strings instead of a dynamic value.
   *
   * Users must take care to ensure that adding the static string to the template
   * results in well-formed HTML, or else templates may break unexpectedly.
   *
   * Note that this function is unsafe to use on untrusted content, as it will be
   * directly parsed into HTML. Do not pass user input to this function
   * without sanitizing it.
   *
   * Static values can be changed, but they will cause a complete re-render
   * since they effectively create a new template.
   */
  var unsafeStatic = function unsafeStatic(value) {
    return babelHelpers.defineProperty({}, '_$litStatic$', value);
  };

  _exports.unsafeStatic = unsafeStatic;

  var textFromStatic = function textFromStatic(value) {
    if (value['_$litStatic$'] !== undefined) {
      return value['_$litStatic$'];
    } else {
      throw new Error("Value passed to 'literal' function must be a 'literal' result: ".concat(value, ". Use 'unsafeStatic' to pass non-literal values, but\n            take care to ensure page security."));
    }
  };
  /**
   * Tags a string literal so that it behaves like part of the static template
   * strings instead of a dynamic value.
   *
   * The only values that may be used in template expressions are other tagged
   * `literal` results or `unsafeStatic` values (note that untrusted content
   * should never be passed to `unsafeStatic`).
   *
   * Users must take care to ensure that adding the static string to the template
   * results in well-formed HTML, or else templates may break unexpectedly.
   *
   * Static values can be changed, but they will cause a complete re-render since
   * they effectively create a new template.
   */


  var literal = function literal(strings) {
    for (var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      values[_key - 1] = arguments[_key];
    }

    return babelHelpers.defineProperty({}, '_$litStatic$', values.reduce(function (acc, v, idx) {
      return acc + textFromStatic(v) + strings[idx + 1];
    }, strings[0]));
  };

  _exports.literal = literal;
  var stringsCache = new Map();
  /**
   * Wraps a lit-html template tag (`html` or `svg`) to add static value support.
   */

  var withStatic = function withStatic(coreTag) {
    return function (strings) {
      for (var _len2 = arguments.length, values = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        values[_key2 - 1] = arguments[_key2];
      }

      var _a;

      var l = values.length;
      var staticValue;
      var dynamicValue;
      var staticStrings = [];
      var dynamicValues = [];
      var i = 0;
      var hasStatics = false;
      var s;

      while (i < l) {
        s = strings[i]; // Collect any unsafeStatic values, and their following template strings
        // so that we treat a run of template strings and unsafe static values as
        // a single template string.

        while (i < l && (dynamicValue = values[i], staticValue = (_a = dynamicValue) === null || _a === void 0 ? void 0 : _a['_$litStatic$']) !== undefined) {
          s += staticValue + strings[++i];
          hasStatics = true;
        }

        dynamicValues.push(dynamicValue);
        staticStrings.push(s);
        i++;
      } // If the last value isn't static (which would have consumed the last
      // string), then we need to add the last string.


      if (i === l) {
        staticStrings.push(strings[l]);
      }

      if (hasStatics) {
        var key = staticStrings.join('$$lit$$');
        strings = stringsCache.get(key);

        if (strings === undefined) {
          // Beware: in general this pattern is unsafe, and doing so may bypass
          // lit's security checks and allow an attacker to execute arbitrary
          // code and inject arbitrary content.
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          staticStrings.raw = staticStrings;
          stringsCache.set(key, strings = staticStrings);
        }

        values = dynamicValues;
      }

      return coreTag.apply(void 0, [strings].concat(babelHelpers.toConsumableArray(values)));
    };
  };
  /**
   * Interprets a template literal as an HTML template that can efficiently
   * render to and update a container.
   *
   * Includes static value support from `lit-html/static.js`.
   */


  _exports.withStatic = withStatic;
  var html = withStatic(_litHtml.html);
  /**
   * Interprets a template literal as an SVG template that can efficiently
   * render to and update a container.
   *
   * Includes static value support from `lit-html/static.js`.
   */

  _exports.html = html;
  var svg = withStatic(_litHtml.svg);
  _exports.svg = svg;
});