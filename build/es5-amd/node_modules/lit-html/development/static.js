define(["exports", "./lit-html.js"], function (_exports, _litHtml) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.withStatic = _exports.unsafeStatic = _exports.svg = _exports.literal = _exports.html = void 0;

  /**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   */
  // Any new exports need to be added to the export statement in
  // `packages/lit/src/index.all.ts`.

  /**
   * Prevents JSON injection attacks.
   *
   * The goals of this brand:
   *   1) fast to check
   *   2) code is small on the wire
   *   3) multiple versions of Lit in a single page will all produce mutually
   *      interoperable StaticValues
   *   4) normal JSON.parse (without an unusual reviver) can not produce a
   *      StaticValue
   *
   * Symbols satisfy (1), (2), and (4). We use Symbol.for to satisfy (3), but
   * we don't care about the key, so we break ties via (2) and use the empty
   * string.
   */
  var brand = Symbol.for('');
  /** Safely extracts the string part of a StaticValue. */

  var unwrapStaticValue = function unwrapStaticValue(value) {
    var _a, _b;

    if (((_a = value) === null || _a === void 0 ? void 0 : _a.r) !== brand) {
      return undefined;
    }

    return (_b = value) === null || _b === void 0 ? void 0 : _b['_$litStatic$'];
  };
  /**
   * Wraps a string so that it behaves like part of the static template
   * strings instead of a dynamic value.
   *
   * Users must take care to ensure that adding the static string to the template
   * results in well-formed HTML, or else templates may break unexpectedly.
   *
   * Note that this function is unsafe to use on untrusted content, as it will be
   * directly parsed into HTML. Do not pass user input to this function
   * without sanitizing it.
   *
   * Static values can be changed, but they will cause a complete re-render
   * since they effectively create a new template.
   */


  var unsafeStatic = function unsafeStatic(value) {
    var _ref;

    return _ref = {}, babelHelpers.defineProperty(_ref, '_$litStatic$', value), babelHelpers.defineProperty(_ref, "r", brand), _ref;
  };

  _exports.unsafeStatic = unsafeStatic;

  var textFromStatic = function textFromStatic(value) {
    if (value['_$litStatic$'] !== undefined) {
      return value['_$litStatic$'];
    } else {
      throw new Error("Value passed to 'literal' function must be a 'literal' result: ".concat(value, ". Use 'unsafeStatic' to pass non-literal values, but\n            take care to ensure page security."));
    }
  };
  /**
   * Tags a string literal so that it behaves like part of the static template
   * strings instead of a dynamic value.
   *
   * The only values that may be used in template expressions are other tagged
   * `literal` results or `unsafeStatic` values (note that untrusted content
   * should never be passed to `unsafeStatic`).
   *
   * Users must take care to ensure that adding the static string to the template
   * results in well-formed HTML, or else templates may break unexpectedly.
   *
   * Static values can be changed, but they will cause a complete re-render since
   * they effectively create a new template.
   */


  var literal = function literal(strings) {
    var _ref2;

    for (var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      values[_key - 1] = arguments[_key];
    }

    return _ref2 = {}, babelHelpers.defineProperty(_ref2, '_$litStatic$', values.reduce(function (acc, v, idx) {
      return acc + textFromStatic(v) + strings[idx + 1];
    }, strings[0])), babelHelpers.defineProperty(_ref2, "r", brand), _ref2;
  };

  _exports.literal = literal;
  var stringsCache = new Map();
  /**
   * Wraps a lit-html template tag (`html` or `svg`) to add static value support.
   */

  var withStatic = function withStatic(coreTag) {
    return function (strings) {
      for (var _len2 = arguments.length, values = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        values[_key2 - 1] = arguments[_key2];
      }

      var l = values.length;
      var staticValue;
      var dynamicValue;
      var staticStrings = [];
      var dynamicValues = [];
      var i = 0;
      var hasStatics = false;
      var s;

      while (i < l) {
        s = strings[i]; // Collect any unsafeStatic values, and their following template strings
        // so that we treat a run of template strings and unsafe static values as
        // a single template string.

        while (i < l && (dynamicValue = values[i], staticValue = unwrapStaticValue(dynamicValue)) !== undefined) {
          s += staticValue + strings[++i];
          hasStatics = true;
        }

        dynamicValues.push(dynamicValue);
        staticStrings.push(s);
        i++;
      } // If the last value isn't static (which would have consumed the last
      // string), then we need to add the last string.


      if (i === l) {
        staticStrings.push(strings[l]);
      }

      if (hasStatics) {
        var key = staticStrings.join('$$lit$$');
        strings = stringsCache.get(key);

        if (strings === undefined) {
          // Beware: in general this pattern is unsafe, and doing so may bypass
          // lit's security checks and allow an attacker to execute arbitrary
          // code and inject arbitrary content.
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          staticStrings.raw = staticStrings;
          stringsCache.set(key, strings = staticStrings);
        }

        values = dynamicValues;
      }

      return coreTag.apply(void 0, [strings].concat(babelHelpers.toConsumableArray(values)));
    };
  };
  /**
   * Interprets a template literal as an HTML template that can efficiently
   * render to and update a container.
   *
   * Includes static value support from `lit-html/static.js`.
   */


  _exports.withStatic = withStatic;
  var html = withStatic(_litHtml.html);
  /**
   * Interprets a template literal as an SVG template that can efficiently
   * render to and update a container.
   *
   * Includes static value support from `lit-html/static.js`.
   */

  _exports.html = html;
  var svg = withStatic(_litHtml.svg);
  _exports.svg = svg;
});