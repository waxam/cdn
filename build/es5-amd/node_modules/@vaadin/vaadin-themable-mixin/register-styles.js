define(["exports", "../../@polymer/polymer/lib/elements/dom-module.js", "../../lit-element/index.js"], function (_exports, _domModule, _index) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  Object.defineProperty(_exports, "css", {
    enumerable: true,
    get: function get() {
      return _index.css;
    }
  });
  _exports.registerStyles = void 0;
  Object.defineProperty(_exports, "unsafeCSS", {
    enumerable: true,
    get: function get() {
      return _index.unsafeCSS;
    }
  });
  var moduleIdIndex = 0; // Map of <CSSResult, Polymer.DomModule> pairs.

  var styleMap = {};
  /**
   * Registers CSS styles for a component type. Make sure to register the styles before
   * the first instance of a component of the type is attached to DOM.
   *
   * @param {String} themeFor The local/tag name of the component type to register the styles for
   * @param {CSSResult | CSSResult[]} styles The CSS style rules to be registered for the component type
   * matching themeFor and included in the local scope of each component instance
   * @param {Object=} options Additional options
   * @return {void}
   */

  var registerStyles = function registerStyles(themeFor, styles, options) {
    var themeId = options && options.moduleId || "custom-style-module-".concat(moduleIdIndex++);

    if (!Array.isArray(styles)) {
      styles = styles ? [styles] : [];
    }

    styles.forEach(function (cssResult) {
      if (!babelHelpers.instanceof(cssResult, _index.CSSResult)) {
        throw new Error('An item in styles is not of type CSSResult. Use `unsafeCSS` or `css`.');
      }

      if (!styleMap[cssResult]) {
        var styleModuleElement = document.createElement('dom-module');
        styleModuleElement.innerHTML = "\n        <template>\n          <style>".concat(cssResult.toString(), "</style>\n        </template>\n      ");
        var styleId = "custom-style-module-".concat(moduleIdIndex++);
        styleModuleElement.register(styleId);
        styleMap[cssResult] = styleId;
      }
    });
    var themeModuleElement = document.createElement('dom-module');

    if (themeFor) {
      var elementClass = window.customElements && window.customElements.get(themeFor);

      if (elementClass && elementClass.hasOwnProperty('__finalized')) {
        console.warn("The custom element definition for \"".concat(themeFor, "\"\n      was finalized before a style module was registered.\n      Make sure to add component specific style modules before\n      importing the corresponding custom element."));
      }

      themeModuleElement.setAttribute('theme-for', themeFor);
    }

    var moduleIncludes = options && options.include || [];
    themeModuleElement.innerHTML = "\n    <template>\n      ".concat(moduleIncludes.map(function (include) {
      return "<style include=".concat(include, "></style>");
    }), "\n      ").concat(styles.map(function (style) {
      return "<style include=".concat(styleMap[style], "></style>");
    }), "\n    </template>\n  ");
    themeModuleElement.register(themeId);
  };

  _exports.registerStyles = registerStyles;
});