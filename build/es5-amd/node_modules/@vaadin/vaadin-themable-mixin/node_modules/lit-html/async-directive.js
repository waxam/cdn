define(["exports", "./directive.js", "./lit-html.js"], function (_exports, _directive, _litHtml) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.AsyncDirective = void 0;

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  /**
   * A superclass for directives that need to asynchronously update.
   */
  var AsyncDirective = /*#__PURE__*/function (_Directive) {
    babelHelpers.inherits(AsyncDirective, _Directive);

    var _super = _createSuper(AsyncDirective);

    function AsyncDirective(partInfo) {
      var _this;

      babelHelpers.classCallCheck(this, AsyncDirective);
      _this = _super.call(this, partInfo);
      _this._renderedYet = false;
      _this._legacyPart = partInfo.legacyPart;
      return _this;
    }

    babelHelpers.createClass(AsyncDirective, [{
      key: "_legacyGetNode",
      value: function _legacyGetNode() {
        if (babelHelpers.instanceof(this._legacyPart, _litHtml.NodePart)) {
          return this._legacyPart.startNode;
        } else if (babelHelpers.instanceof(this._legacyPart, _litHtml.EventPart)) {
          return this._legacyPart.element;
        } else if (babelHelpers.instanceof(this._legacyPart, _litHtml.BooleanAttributePart)) {
          return this._legacyPart.element;
        } else if (babelHelpers.instanceof(this._legacyPart, _litHtml.PropertyPart) || babelHelpers.instanceof(this._legacyPart, _litHtml.AttributePart)) {
          return this._legacyPart.committer.element;
        }

        return undefined;
      }
    }, {
      key: "_shouldRender",
      value: function _shouldRender() {
        if (!this._renderedYet) {
          this._renderedYet = true;
          return true;
        }

        var node = this._legacyGetNode();

        return !!(node === null || node === void 0 ? void 0 : node.isConnected);
      }
    }, {
      key: "setValue",
      value: function setValue(value) {
        if (!this._shouldRender()) {
          // node is disconnected, do nothing.
          return;
        }

        this._legacyPart.setValue(value);

        this._legacyPart.commit();
      }
      /**
       * User callback for implementing logic to release any
       * resources/subscriptions that may have been retained by this directive.
       * Since directives may also be re-connected, `reconnected` should also be
       * implemented to restore the working state of the directive prior to the next
       * render.
       *
       * NOTE: In lit-html 1.x, the `disconnected` and `reconnected` callbacks WILL
       * NOT BE CALLED. The interface is provided here for forward-compatible
       * directive authoring only.
       */
      // eslint-disable-next-line @typescript-eslint/no-empty-function

    }, {
      key: "disconnected",
      value: function disconnected() {}
      /**
       * User callback to restore the working state of the directive prior to the
       * next render. This should generally re-do the work that was undone in
       * `disconnected`.
       *
       * NOTE: In lit-html 1.x, the `disconnected` and `reconnected` callbacks WILL
       * NOT BE CALLED. The interface is provided here for forward-compatible
       * directive authoring only.
       */
      // eslint-disable-next-line @typescript-eslint/no-empty-function

    }, {
      key: "reconnected",
      value: function reconnected() {}
    }]);
    return AsyncDirective;
  }(_directive.Directive);

  _exports.AsyncDirective = AsyncDirective;
});