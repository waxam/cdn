define(["exports", "./lib/directive.js", "./lit-html.js"], function (_exports, _directive, legacyLit) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.directive = directive;
  _exports.Directive = _exports.PartType = void 0;
  legacyLit = _interopRequireWildcard(legacyLit);

  function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

  function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || babelHelpers.typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  /**
   * @license
   * Copyright (c) 2021 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   */
  var PartType = {
    ATTRIBUTE: 1,
    CHILD: 2,
    PROPERTY: 3,
    BOOLEAN_ATTRIBUTE: 4,
    EVENT: 5,
    ELEMENT: 6
  };
  _exports.PartType = PartType;

  var ChildPart = /*#__PURE__*/function () {
    function ChildPart(legacyPart) {
      babelHelpers.classCallCheck(this, ChildPart);
      this.type = PartType.CHILD;
      this.options = legacyPart.options;
      this.legacyPart = legacyPart;
    }

    babelHelpers.createClass(ChildPart, [{
      key: "parentNode",
      get: function get() {
        return this.legacyPart.startNode.parentNode;
      }
    }, {
      key: "startNode",
      get: function get() {
        return this.legacyPart.startNode;
      }
    }, {
      key: "endNode",
      get: function get() {
        return this.legacyPart.endNode;
      }
    }]);
    return ChildPart;
  }();

  var AttributePart = /*#__PURE__*/function () {
    function AttributePart(legacyPart) {
      babelHelpers.classCallCheck(this, AttributePart);
      this.legacyPart = legacyPart;
      this.type = babelHelpers.instanceof(legacyPart, legacyLit.PropertyPart) ? PartType.PROPERTY : PartType.ATTRIBUTE;
    }

    babelHelpers.createClass(AttributePart, [{
      key: "options",
      get: function get() {
        return undefined;
      }
    }, {
      key: "name",
      get: function get() {
        return this.legacyPart.committer.name;
      }
    }, {
      key: "element",
      get: function get() {
        return this.legacyPart.committer.element;
      }
      /**
       * If this attribute part represents an interpolation, this contains the
       * static strings of the interpolation. For single-value, complete bindings,
       * this is undefined.
       */

    }, {
      key: "strings",
      get: function get() {
        return this.legacyPart.committer.strings;
      }
    }, {
      key: "tagName",
      get: function get() {
        return this.element.tagName;
      }
    }]);
    return AttributePart;
  }();

  var BooleanAttributePart = /*#__PURE__*/function () {
    function BooleanAttributePart(legacyPart) {
      babelHelpers.classCallCheck(this, BooleanAttributePart);
      this.type = PartType.BOOLEAN_ATTRIBUTE;
      this.legacyPart = legacyPart;
    }

    babelHelpers.createClass(BooleanAttributePart, [{
      key: "options",
      get: function get() {
        return undefined;
      }
    }, {
      key: "name",
      get: function get() {
        return this.legacyPart.name;
      }
    }, {
      key: "element",
      get: function get() {
        return this.legacyPart.element;
      }
      /**
       * If this attribute part represents an interpolation, this contains the
       * static strings of the interpolation. For single-value, complete bindings,
       * this is undefined.
       */

    }, {
      key: "strings",
      get: function get() {
        return this.legacyPart.strings;
      }
    }, {
      key: "tagName",
      get: function get() {
        return this.element.tagName;
      }
    }]);
    return BooleanAttributePart;
  }();

  var EventPart = /*#__PURE__*/function () {
    function EventPart(legacyPart) {
      babelHelpers.classCallCheck(this, EventPart);
      this.type = PartType.EVENT;
      this.legacyPart = legacyPart;
    }

    babelHelpers.createClass(EventPart, [{
      key: "options",
      get: function get() {
        return undefined;
      }
    }, {
      key: "name",
      get: function get() {
        return this.legacyPart.eventName;
      }
    }, {
      key: "element",
      get: function get() {
        return this.legacyPart.element;
      }
      /**
       * If this attribute part represents an interpolation, this contains the
       * static strings of the interpolation. For single-value, complete bindings,
       * this is undefined.
       */

    }, {
      key: "strings",
      get: function get() {
        return undefined;
      }
    }, {
      key: "tagName",
      get: function get() {
        return this.element.tagName;
      }
    }, {
      key: "handleEvent",
      value: function handleEvent(event) {
        this.legacyPart.handleEvent(event);
      }
    }]);
    return EventPart;
  }(); // no equivalent for ElementPart in v1


  function legacyPartToPart(part) {
    if (babelHelpers.instanceof(part, legacyLit.NodePart)) {
      return new ChildPart(part);
    } else if (babelHelpers.instanceof(part, legacyLit.EventPart)) {
      return new EventPart(part);
    } else if (babelHelpers.instanceof(part, legacyLit.BooleanAttributePart)) {
      return new BooleanAttributePart(part);
    } else if (babelHelpers.instanceof(part, legacyLit.PropertyPart) || babelHelpers.instanceof(part, legacyLit.AttributePart)) {
      return new AttributePart(part);
    } // ElementPartInfo doesn't exist in lit-html v1


    throw new Error("Unknown part type");
  }
  /**
   * Base class for creating custom directives. Users should extend this class,
   * implement `render` and/or `update`, and then pass their subclass to
   * `directive`.
   */


  var Directive = /*#__PURE__*/function () {
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    function Directive(_partInfo) {
      babelHelpers.classCallCheck(this, Directive);
    }

    babelHelpers.createClass(Directive, [{
      key: "update",
      value: function update(_part, args) {
        return this.render.apply(this, babelHelpers.toConsumableArray(args));
      }
    }]);
    return Directive;
  }();
  /**
   * Creates a user-facing directive function from a Directive class. This
   * function has the same parameters as the directive's render() method.
   *
   * N.B. In Lit 2, the directive will lose state if another directive is
   * executed on the same part as the directive instance is destroyed. This
   * version deviates from this behavior and will keep its state.
   */


  _exports.Directive = Directive;

  function directive(directiveClass) {
    var partToInstance = new WeakMap();
    var result = (0, _directive.directive)(function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return function (part) {
        var cached = partToInstance.get(part);
        var modernPart, instance;

        if (cached === undefined) {
          modernPart = legacyPartToPart(part);
          instance = new directiveClass(modernPart);
          partToInstance.set(part, [modernPart, instance]);
        } else {
          modernPart = cached[0];
          instance = cached[1];
        }

        part.setValue(instance.update(modernPart, args));
        part.commit();
      };
    });
    return result;
  }
});