define(["exports", "../lib/dom.js", "../lib/parts.js", "../lit-html.js"], function (_exports, _dom, _parts, _litHtml) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.unsafeSVG = void 0;

  /**
   * @license
   * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
   * This code may only be used under the BSD style license found at
   * http://polymer.github.io/LICENSE.txt
   * The complete set of authors may be found at
   * http://polymer.github.io/AUTHORS.txt
   * The complete set of contributors may be found at
   * http://polymer.github.io/CONTRIBUTORS.txt
   * Code distributed by Google as part of the polymer project is also
   * subject to an additional IP rights grant found at
   * http://polymer.github.io/PATENTS.txt
   */
  // For each part, remember the value that was last rendered to the part by the
  // unsafeSVG directive, and the DocumentFragment that was last set as a value.
  // The DocumentFragment is used as a unique key to check if the last value
  // rendered to the part was with unsafeSVG. If not, we'll always re-render the
  // value passed to unsafeSVG.
  var previousValues = new WeakMap();
  var isIe = window.navigator.userAgent.indexOf('Trident/') > 0;
  /**
   * Renders the result as SVG, rather than text.
   *
   * Note, this is unsafe to use with any user-provided input that hasn't been
   * sanitized or escaped, as it may lead to cross-site-scripting
   * vulnerabilities.
   */

  var unsafeSVG = (0, _litHtml.directive)(function (value) {
    return function (part) {
      if (!babelHelpers.instanceof(part, _litHtml.NodePart)) {
        throw new Error('unsafeSVG can only be used in text bindings');
      }

      var previousValue = previousValues.get(part);

      if (previousValue !== undefined && (0, _parts.isPrimitive)(value) && value === previousValue.value && part.value === previousValue.fragment) {
        return;
      }

      var template = document.createElement('template');
      var content = template.content;
      var svgElement;

      if (isIe) {
        // IE can't set innerHTML of an svg element. However, it also doesn't
        // support Trusted Types, so it's ok for us to use a string when setting
        // innerHTML.
        template.innerHTML = "<svg>".concat(value, "</svg>");
        svgElement = content.firstChild;
      } else {
        svgElement = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        content.appendChild(svgElement);
        svgElement.innerHTML = value;
      }

      content.removeChild(svgElement);
      (0, _dom.reparentNodes)(content, svgElement.firstChild);
      var fragment = document.importNode(content, true);
      part.setValue(fragment);
      previousValues.set(part, {
        value: value,
        fragment: fragment
      });
    };
  });
  _exports.unsafeSVG = unsafeSVG;
});