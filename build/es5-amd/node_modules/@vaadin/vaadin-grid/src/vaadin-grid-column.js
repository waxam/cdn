define(["exports", "../../../@polymer/polymer/polymer-element.js", "../../../@polymer/polymer/lib/utils/flattened-nodes-observer.js", "../../vaadin-element-mixin/vaadin-dir-mixin.js", "./vaadin-grid-templatizer.js", "../../../@polymer/polymer/lib/utils/debounce.js", "../../../@polymer/polymer/lib/utils/async.js"], function (_exports, _polymerElement, _flattenedNodesObserver, _vaadinDirMixin, _vaadinGridTemplatizer, _debounce, _async) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.GridColumnElement = _exports.ColumnBaseMixin = void 0;

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  /**
   * @polymerMixin
   */
  var ColumnBaseMixin = function ColumnBaseMixin(superClass) {
    return /*#__PURE__*/function (_superClass) {
      babelHelpers.inherits(ColumnBaseMixin, _superClass);

      var _super = _createSuper(ColumnBaseMixin);

      function ColumnBaseMixin() {
        var _this;

        babelHelpers.classCallCheck(this, ColumnBaseMixin);
        _this = _super.call(this);
        _this._templateObserver = new _flattenedNodesObserver.FlattenedNodesObserver(babelHelpers.assertThisInitialized(_this), function (info) {
          _this._headerTemplate = _this._prepareHeaderTemplate();
          _this._footerTemplate = _this._prepareFooterTemplate();
          _this._bodyTemplate = _this._prepareBodyTemplate();
        });
        return _this;
      }
      /**
       * @return {HTMLTemplateElement}
       * @protected
       */


      babelHelpers.createClass(ColumnBaseMixin, [{
        key: "connectedCallback",
        value:
        /** @protected */
        function connectedCallback() {
          var _this2 = this;

          babelHelpers.get(babelHelpers.getPrototypeOf(ColumnBaseMixin.prototype), "connectedCallback", this).call(this);
          this._bodyTemplate && (this._bodyTemplate.templatizer._grid = this._grid);
          this._headerTemplate && (this._headerTemplate.templatizer._grid = this._grid);
          this._footerTemplate && (this._footerTemplate.templatizer._grid = this._grid);

          this._templateObserver.flush();

          if (!this._bodyTemplate) {
            // The observer might not have triggered if the tag is empty. Run manually.
            this._templateObserver.callback();
          }

          requestAnimationFrame(function () {
            _this2._allCells.forEach(function (cell) {
              if (!cell._content.parentNode) {
                _this2._grid && _this2._grid.appendChild(cell._content);
              }
            });
          });
        }
        /** @protected */

      }, {
        key: "disconnectedCallback",
        value: function disconnectedCallback() {
          var _this3 = this;

          babelHelpers.get(babelHelpers.getPrototypeOf(ColumnBaseMixin.prototype), "disconnectedCallback", this).call(this);
          requestAnimationFrame(function () {
            if (!_this3._findHostGrid()) {
              _this3._allCells.forEach(function (cell) {
                if (cell._content.parentNode) {
                  cell._content.parentNode.removeChild(cell._content);
                }
              });
            }
          });
          this._gridValue = undefined;
        }
        /**
         * @return {!GridElement | undefined}
         * @protected
         */

      }, {
        key: "_findHostGrid",
        value: function _findHostGrid() {
          var el = this; // Custom elements extending grid must have a specific localName

          while (el && !/^vaadin.*grid(-pro)?$/.test(el.localName)) {
            el = el.assignedSlot ? el.assignedSlot.parentNode : el.parentNode;
          }

          return el || undefined;
        }
        /**
         * @return {!GridElement | undefined}
         * @protected
         */

      }, {
        key: "_grid",
        get: function get() {
          if (!this._gridValue) {
            this._gridValue = this._findHostGrid();
          }

          return this._gridValue;
        }
        /**
         * @return {!Array<!HTMLElement>}
         * @protected
         */

      }, {
        key: "_allCells",
        get: function get() {
          return [].concat(this._cells || []).concat(this._emptyCells || []).concat(this._headerCell).concat(this._footerCell).filter(function (cell) {
            return cell;
          });
        }
      }, {
        key: "_prepareHeaderTemplate",
        value: function _prepareHeaderTemplate() {
          return this._prepareTemplatizer(this._findTemplate(true) || null, {});
        }
        /**
         * @return {HTMLTemplateElement}
         * @protected
         */

      }, {
        key: "_prepareFooterTemplate",
        value: function _prepareFooterTemplate() {
          return this._prepareTemplatizer(this._findTemplate(false, true) || null, {});
        }
        /**
         * @return {HTMLTemplateElement}
         * @protected
         */

      }, {
        key: "_prepareBodyTemplate",
        value: function _prepareBodyTemplate() {
          return this._prepareTemplatizer(this._findTemplate() || null);
        }
        /**
         * @param {HTMLTemplateElement} template
         * @param {object} instanceProps
         * @return {HTMLTemplateElement}
         * @protected
         */

      }, {
        key: "_prepareTemplatizer",
        value: function _prepareTemplatizer(template, instanceProps) {
          if (template && !template.templatizer) {
            var templatizer = new _vaadinGridTemplatizer.Templatizer();
            templatizer._grid = this._grid;
            templatizer.dataHost = this.dataHost;
            templatizer._instanceProps = instanceProps || templatizer._instanceProps;
            templatizer.template = template;
            template.templatizer = templatizer;
          }

          return template;
        }
        /** @protected */

      }, {
        key: "_renderHeaderAndFooter",
        value: function _renderHeaderAndFooter() {
          if (this.headerRenderer && this._headerCell) {
            this.__runRenderer(this.headerRenderer, this._headerCell);
          }

          if (this.footerRenderer && this._footerCell) {
            this.__runRenderer(this.footerRenderer, this._footerCell);
          }
        }
        /** @private */

      }, {
        key: "__runRenderer",
        value: function __runRenderer(renderer, cell, model) {
          var args = [cell._content, this];

          if (model && model.item) {
            args.push(model);
          }

          renderer.apply(this, args);
        }
        /** @private */

      }, {
        key: "__setColumnTemplateOrRenderer",
        value: function __setColumnTemplateOrRenderer(template, renderer, cells) {
          var _this4 = this;

          // no renderer or template needed in a hidden column
          if (this.hidden) {
            return;
          }

          if (template && renderer) {
            throw new Error('You should only use either a renderer or a template');
          }

          cells.forEach(function (cell) {
            var parent = cell.parentElement; // When a column is made hidden and shown again, in some instances it breaks rendering of rows for grid
            // this happens when parent element of cell is null, which might not be set correctly during rendering
            // the newly shown column, this check simply avoid that case

            if (!parent) {
              return;
            }

            var model = _this4._grid.__getRowModel(parent);

            if (renderer) {
              cell._renderer = renderer;

              if (model.item || renderer === _this4.headerRenderer || renderer === _this4.footerRenderer) {
                _this4.__runRenderer(renderer, cell, model);
              }
            } else if (cell._template !== template) {
              cell._template = template;
              cell._content.innerHTML = '';
              template.templatizer._grid = template.templatizer._grid || _this4._grid;
              var inst = template.templatizer.createInstance();

              cell._content.appendChild(inst.root);

              cell._instance = inst;

              if (model.item) {
                cell._instance.setProperties(model);
              }
            }
          });
        }
        /** @private */

      }, {
        key: "_setBodyTemplateOrRenderer",
        value: function _setBodyTemplateOrRenderer(template, renderer, cells, splices) {
          if ((template || renderer) && cells) {
            this.__setColumnTemplateOrRenderer(template, renderer, cells);
          }
        }
        /** @private */

      }, {
        key: "_setHeaderTemplateOrRenderer",
        value: function _setHeaderTemplateOrRenderer(headerTemplate, headerRenderer, headerCell) {
          if ((headerTemplate || headerRenderer) && headerCell) {
            this.__setColumnTemplateOrRenderer(headerTemplate, headerRenderer, [headerCell]);
          }
        }
        /** @private */

      }, {
        key: "_setFooterTemplateOrRenderer",
        value: function _setFooterTemplateOrRenderer(footerTemplate, footerRenderer, footerCell) {
          if ((footerTemplate || footerRenderer) && footerCell) {
            this.__setColumnTemplateOrRenderer(footerTemplate, footerRenderer, [footerCell]);

            if (this._grid) {
              this._grid.__updateHeaderFooterRowVisibility(footerCell.parentElement);
            }
          }
        }
        /**
         * @param {boolean} header
         * @param {boolean} footer
         * @return {HTMLTemplateElement}
         * @protected
         */

      }, {
        key: "_selectFirstTemplate",
        value: function _selectFirstTemplate() {
          var header = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
          var footer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
          return _flattenedNodesObserver.FlattenedNodesObserver.getFlattenedNodes(this).filter(function (node) {
            return node.localName === 'template' && node.classList.contains('header') === header && node.classList.contains('footer') === footer;
          })[0];
        }
        /**
         * @param {boolean} header
         * @param {boolean} footer
         * @return {HTMLTemplateElement}
         * @protected
         */

      }, {
        key: "_findTemplate",
        value: function _findTemplate(header, footer) {
          var template = this._selectFirstTemplate(header, footer);

          if (template) {
            if (this.dataHost) {
              // set dataHost to the context where template has been defined
              template._rootDataHost = this.dataHost._rootDataHost || this.dataHost;
            }
          }

          return template;
        }
        /** @private */

      }, {
        key: "_flexGrowChanged",
        value: function _flexGrowChanged(flexGrow, headerCell, footerCell, cells) {
          if (this.parentElement && this.parentElement._columnPropChanged) {
            this.parentElement._columnPropChanged('flexGrow');
          }

          this._allCells.forEach(function (cell) {
            return cell.style.flexGrow = flexGrow;
          });
        }
        /** @private */

      }, {
        key: "_orderChanged",
        value: function _orderChanged(order, headerCell, footerCell, cells) {
          this._allCells.forEach(function (cell) {
            return cell.style.order = order;
          });
        }
        /** @private */

      }, {
        key: "_widthChanged",
        value: function _widthChanged(width, headerCell, footerCell, cells) {
          if (this.parentElement && this.parentElement._columnPropChanged) {
            this.parentElement._columnPropChanged('width');
          }

          this._allCells.forEach(function (cell) {
            return cell.style.width = width;
          }); // Force a reflow to workaround browser issues causing double scrollbars to grid
          // https://github.com/vaadin/vaadin-grid/issues/1586


          if (this._grid && this._grid.__forceReflow) {
            this._grid.__forceReflow();
          }
        }
        /** @private */

      }, {
        key: "_frozenChanged",
        value: function _frozenChanged(frozen, headerCell, footerCell, cells) {
          var _this5 = this;

          if (this.parentElement && this.parentElement._columnPropChanged) {
            this.parentElement._columnPropChanged('frozen', frozen);
          }

          this._allCells.forEach(function (cell) {
            return _this5._toggleAttribute('frozen', frozen, cell);
          });

          this._grid && this._grid._frozenCellsChanged && this._grid._frozenCellsChanged();
        }
        /** @private */

      }, {
        key: "_lastFrozenChanged",
        value: function _lastFrozenChanged(lastFrozen) {
          var _this6 = this;

          this._allCells.forEach(function (cell) {
            return _this6._toggleAttribute('last-frozen', lastFrozen, cell);
          });

          if (this.parentElement && this.parentElement._columnPropChanged) {
            this.parentElement._lastFrozen = lastFrozen;
          }
        }
        /**
         * @param {string | undefined} path
         * @param {string | undefined} header
         * @param {!HTMLTableCellElement | undefined} headerCell
         * @param {!HTMLTableCellElement | undefined} footerCell
         * @param {!object | undefined} cells
         * @param {GridBodyRenderer | undefined} renderer
         * @param {GridHeaderFooterRenderer | undefined} headerRenderer
         * @param {HTMLTemplateElement | undefined} bodyTemplate
         * @param {HTMLTemplateElement | undefined} headerTemplate
         * @protected
         */

      }, {
        key: "_pathOrHeaderChanged",
        value: function _pathOrHeaderChanged(path, header, headerCell, footerCell, cells, renderer, headerRenderer, bodyTemplate, headerTemplate) {
          var _this7 = this;

          var hasHeaderText = header !== undefined;

          if (!headerRenderer && !headerTemplate && hasHeaderText && headerCell) {
            this.__setTextContent(headerCell._content, header);
          }

          if (path && cells.value) {
            if (!renderer && !bodyTemplate) {
              var pathRenderer = function pathRenderer(root, owner, _ref) {
                var item = _ref.item;
                return _this7.__setTextContent(root, _this7.get(path, item));
              };

              this.__setColumnTemplateOrRenderer(undefined, pathRenderer, cells.value);
            }

            if (!headerRenderer && !headerTemplate && !hasHeaderText && headerCell && header !== null) {
              this.__setTextContent(headerCell._content, this._generateHeader(path));
            }
          }

          if (headerCell && this._grid) {
            this._grid.__updateHeaderFooterRowVisibility(headerCell.parentElement);
          }
        }
        /** @private */

      }, {
        key: "__setTextContent",
        value: function __setTextContent(node, textContent) {
          node.textContent !== textContent && (node.textContent = textContent);
        }
        /**
         * @param {string} path
         * @return {string}
         * @protected
         */

      }, {
        key: "_generateHeader",
        value: function _generateHeader(path) {
          return path.substr(path.lastIndexOf('.') + 1).replace(/([A-Z])/g, '-$1').toLowerCase().replace(/-/g, ' ').replace(/^./, function (match) {
            return match.toUpperCase();
          });
        }
        /**
         * @param {string} name
         * @param {boolean} bool
         * @param {!Element} node
         * @protected
         */

      }, {
        key: "_toggleAttribute",
        value: function _toggleAttribute(name, bool, node) {
          if (node.hasAttribute(name) === !bool) {
            if (bool) {
              node.setAttribute(name, '');
            } else {
              node.removeAttribute(name);
            }
          }
        }
        /** @private */

      }, {
        key: "_reorderStatusChanged",
        value: function _reorderStatusChanged(reorderStatus, headerCell, footerCell, cells) {
          this._allCells.forEach(function (cell) {
            return cell.setAttribute('reorder-status', reorderStatus);
          });
        }
        /** @private */

      }, {
        key: "_resizableChanged",
        value: function _resizableChanged(resizable, headerCell) {
          if (resizable === undefined || headerCell === undefined) {
            return;
          }

          if (headerCell) {
            [headerCell].concat(this._emptyCells).forEach(function (cell) {
              if (cell) {
                var existingHandle = cell.querySelector('[part~="resize-handle"]');

                if (existingHandle) {
                  cell.removeChild(existingHandle);
                }

                if (resizable) {
                  var handle = document.createElement('div');
                  handle.setAttribute('part', 'resize-handle');
                  cell.appendChild(handle);
                }
              }
            });
          }
        }
        /** @private */

      }, {
        key: "_textAlignChanged",
        value: function _textAlignChanged(textAlign, _cells, _headerCell, _footerCell) {
          if (textAlign === undefined) {
            return;
          }

          if (['start', 'end', 'center'].indexOf(textAlign) === -1) {
            console.warn('textAlign can only be set as "start", "end" or "center"');
            return;
          }

          var textAlignFallback;

          if (getComputedStyle(this._grid).direction === 'ltr') {
            if (textAlign === 'start') {
              textAlignFallback = 'left';
            } else if (textAlign === 'end') {
              textAlignFallback = 'right';
            }
          } else {
            if (textAlign === 'start') {
              textAlignFallback = 'right';
            } else if (textAlign === 'end') {
              textAlignFallback = 'left';
            }
          }

          this._allCells.forEach(function (cell) {
            cell._content.style.textAlign = textAlign;

            if (getComputedStyle(cell._content).textAlign !== textAlign) {
              cell._content.style.textAlign = textAlignFallback;
            }
          });
        }
        /** @private */

      }, {
        key: "_hiddenChanged",
        value: function _hiddenChanged(hidden, headerCell, footerCell, cells) {
          var _this8 = this;

          if (this.parentElement && this.parentElement._columnPropChanged) {
            this.parentElement._columnPropChanged('hidden', hidden);
          }

          if (!!hidden !== !!this._previousHidden && this._grid) {
            if (hidden === true) {
              this._allCells.forEach(function (cell) {
                if (cell._content.parentNode) {
                  cell._content.parentNode.removeChild(cell._content);
                }
              });
            }

            this._grid._debouncerHiddenChanged = _debounce.Debouncer.debounce(this._grid._debouncerHiddenChanged, _async.animationFrame, function () {
              if (_this8._grid && _this8._grid._renderColumnTree) {
                _this8._grid._renderColumnTree(_this8._grid._columnTree);
              }
            });
            this._grid._updateLastFrozen && this._grid._updateLastFrozen();
            this._grid.notifyResize && this._grid.notifyResize();
            this._grid._resetKeyboardNavigation && this._grid._resetKeyboardNavigation();
          }

          this._previousHidden = hidden;
        }
      }], [{
        key: "properties",
        get: function get() {
          return {
            /**
             * When set to true, the column is user-resizable.
             * @default false
             */
            resizable: {
              type: Boolean,
              value: function value() {
                if (this.localName === 'vaadin-grid-column-group') {
                  return;
                }

                var parent = this.parentNode;

                if (parent && parent.localName === 'vaadin-grid-column-group') {
                  return parent.resizable || false;
                } else {
                  return false;
                }
              }
            },

            /**
             * @type {HTMLTemplateElement}
             * @protected
             */
            _headerTemplate: {
              type: Object
            },

            /**
             * @type {HTMLTemplateElement}
             * @protected
             */
            _footerTemplate: {
              type: Object
            },

            /**
             * When true, the column is frozen. When a column inside of a column group is frozen,
             * all of the sibling columns inside the group will get frozen also.
             * @type {boolean}
             */
            frozen: {
              type: Boolean,
              value: false
            },

            /**
             * When set to true, the cells for this column are hidden.
             */
            hidden: {
              type: Boolean
            },

            /**
             * Text content to display in the header cell of the column.
             */
            header: {
              type: String
            },

            /**
             * Aligns the columns cell content horizontally.
             * Supported values: "start", "center" and "end".
             * @attr {start|center|end} text-align
             * @type {GridColumnTextAlign | null | undefined}
             */
            textAlign: {
              type: String
            },

            /**
             * @type {boolean}
             * @protected
             */
            _lastFrozen: {
              type: Boolean,
              value: false
            },

            /** @protected */
            _order: Number,

            /** @private */
            _reorderStatus: Boolean,

            /**
             * @type {Array<!HTMLElement>}
             * @protected
             */
            _emptyCells: Array,

            /** @private */
            _headerCell: Object,

            /** @private */
            _footerCell: Object,

            /** @protected */
            _grid: Object,

            /**
             * Custom function for rendering the header content.
             * Receives two arguments:
             *
             * - `root` The header cell content DOM element. Append your content to it.
             * - `column` The `<vaadin-grid-column>` element.
             *
             * @type {GridHeaderFooterRenderer | null | undefined}
             */
            headerRenderer: Function,

            /**
             * Custom function for rendering the footer content.
             * Receives two arguments:
             *
             * - `root` The footer cell content DOM element. Append your content to it.
             * - `column` The `<vaadin-grid-column>` element.
             *
             * @type {GridHeaderFooterRenderer | null | undefined}
             */
            footerRenderer: Function
          };
        }
      }, {
        key: "observers",
        get: function get() {
          return ['_widthChanged(width, _headerCell, _footerCell, _cells.*)', '_frozenChanged(frozen, _headerCell, _footerCell, _cells.*)', '_flexGrowChanged(flexGrow, _headerCell, _footerCell, _cells.*)', '_pathOrHeaderChanged(path, header, _headerCell, _footerCell, _cells.*, renderer, headerRenderer, _bodyTemplate, _headerTemplate)', '_textAlignChanged(textAlign, _cells.*, _headerCell, _footerCell)', '_orderChanged(_order, _headerCell, _footerCell, _cells.*)', '_lastFrozenChanged(_lastFrozen)', '_setBodyTemplateOrRenderer(_bodyTemplate, renderer, _cells, _cells.*)', '_setHeaderTemplateOrRenderer(_headerTemplate, headerRenderer, _headerCell)', '_setFooterTemplateOrRenderer(_footerTemplate, footerRenderer, _footerCell)', '_resizableChanged(resizable, _headerCell)', '_reorderStatusChanged(_reorderStatus, _headerCell, _footerCell, _cells.*)', '_hiddenChanged(hidden, _headerCell, _footerCell, _cells.*)'];
        }
      }]);
      return ColumnBaseMixin;
    }(superClass);
  };
  /**
   * A `<vaadin-grid-column>` is used to configure how a column in `<vaadin-grid>`
   * should look like.
   *
   * See `<vaadin-grid>` documentation and demos for instructions and examples on how
   * to configure the `<vaadin-grid-column>`.
   * ```
   *
   * @extends PolymerElement
   * @mixes ColumnBaseMixin
   */


  _exports.ColumnBaseMixin = ColumnBaseMixin;

  var GridColumnElement = /*#__PURE__*/function (_ColumnBaseMixin) {
    babelHelpers.inherits(GridColumnElement, _ColumnBaseMixin);

    var _super2 = _createSuper(GridColumnElement);

    function GridColumnElement() {
      babelHelpers.classCallCheck(this, GridColumnElement);
      return _super2.apply(this, arguments);
    }

    babelHelpers.createClass(GridColumnElement, null, [{
      key: "is",
      get: function get() {
        return 'vaadin-grid-column';
      }
    }, {
      key: "properties",
      get: function get() {
        return {
          /**
           * Width of the cells for this column.
           */
          width: {
            type: String,
            value: '100px'
          },

          /**
           * Flex grow ratio for the cell widths. When set to 0, cell width is fixed.
           * @attr {number} flex-grow
           * @type {number}
           */
          flexGrow: {
            type: Number,
            value: 1
          },

          /**
           * Custom function for rendering the cell content.
           * Receives three arguments:
           *
           * - `root` The cell content DOM element. Append your content to it.
           * - `column` The `<vaadin-grid-column>` element.
           * - `model` The object with the properties related with
           *   the rendered item, contains:
           *   - `model.index` The index of the item.
           *   - `model.item` The item.
           *   - `model.expanded` Sublevel toggle state.
           *   - `model.level` Level of the tree represented with a horizontal offset of the toggle button.
           *   - `model.selected` Selected state.
           *
           * @type {GridBodyRenderer | null | undefined}
           */
          renderer: Function,

          /**
           * Path to an item sub-property whose value gets displayed in the column body cells.
           * The property name is also shown in the column header if an explicit header or renderer isn't defined.
           */
          path: {
            type: String
          },

          /**
           * Automatically sets the width of the column based on the column contents when this is set to `true`.
           *
           * For performance reasons the column width is calculated automatically only once when the grid items
           * are rendered for the first time and the calculation only considers the rows which are currently
           * rendered in DOM (a bit more than what is currently visible). If the grid is scrolled, or the cell
           * content changes, the column width might not match the contents anymore.
           *
           * Hidden columns are ignored in the calculation and their widths are not automatically updated when
           * you show a column that was initially hidden.
           *
           * You can manually trigger the auto sizing behavior again by calling `grid.recalculateColumnWidths()`.
           *
           * The column width may still grow larger when `flexGrow` is not 0.
           * @attr {boolean} auto-width
           * @type {boolean}
           */
          autoWidth: {
            type: Boolean,
            value: false
          },

          /**
           * @type {HTMLTemplateElement}
           * @protected
           */
          _bodyTemplate: {
            type: Object
          },

          /**
           * @type {Array<!HTMLElement>}
           * @protected
           */
          _cells: Array
        };
      }
    }]);
    return GridColumnElement;
  }(ColumnBaseMixin((0, _vaadinDirMixin.DirMixin)(_polymerElement.PolymerElement)));

  _exports.GridColumnElement = GridColumnElement;
  customElements.define(GridColumnElement.is, GridColumnElement);
});