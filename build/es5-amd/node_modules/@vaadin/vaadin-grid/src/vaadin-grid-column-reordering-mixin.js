define(["exports", "../../../@polymer/polymer/lib/mixins/gesture-event-listeners.js", "./vaadin-grid-helpers.js", "../../../@polymer/polymer/lib/utils/gestures.js", "../../../@polymer/polymer/lib/legacy/polymer.dom.js"], function (_exports, _gestureEventListeners, _vaadinGridHelpers, _gestures, _polymerDom) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.ColumnReorderingMixin = void 0;

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  /**
   * @polymerMixin
   */
  var ColumnReorderingMixin = function ColumnReorderingMixin(superClass) {
    return /*#__PURE__*/function (_GestureEventListener) {
      babelHelpers.inherits(ColumnReorderingMixin, _GestureEventListener);

      var _super = _createSuper(ColumnReorderingMixin);

      function ColumnReorderingMixin() {
        babelHelpers.classCallCheck(this, ColumnReorderingMixin);
        return _super.apply(this, arguments);
      }

      babelHelpers.createClass(ColumnReorderingMixin, [{
        key: "ready",
        value: function ready() {
          babelHelpers.get(babelHelpers.getPrototypeOf(ColumnReorderingMixin.prototype), "ready", this).call(this);
          (0, _gestures.addListener)(this, 'track', this._onTrackEvent);
          this._reorderGhost = this.shadowRoot.querySelector('[part="reorder-ghost"]');
          this.addEventListener('touchstart', this._onTouchStart.bind(this));
          this.addEventListener('touchmove', this._onTouchMove.bind(this));
          this.addEventListener('touchend', this._onTouchEnd.bind(this));
          this.addEventListener('contextmenu', this._onContextMenu.bind(this));
        }
        /** @private */

      }, {
        key: "_onContextMenu",
        value: function _onContextMenu(e) {
          if (this.hasAttribute('reordering')) {
            e.preventDefault();
          }
        }
        /** @private */

      }, {
        key: "_onTouchStart",
        value: function _onTouchStart(e) {
          var _this = this;

          // Touch event, delay activation by 100ms
          this._startTouchReorderTimeout = setTimeout(function () {
            _this._onTrackStart({
              detail: {
                x: e.touches[0].clientX,
                y: e.touches[0].clientY
              }
            });
          }, 100);
        }
        /** @private */

      }, {
        key: "_onTouchMove",
        value: function _onTouchMove(e) {
          if (this._draggedColumn) {
            e.preventDefault();
          }

          clearTimeout(this._startTouchReorderTimeout);
        }
        /** @private */

      }, {
        key: "_onTouchEnd",
        value: function _onTouchEnd() {
          clearTimeout(this._startTouchReorderTimeout);

          this._onTrackEnd();
        }
        /** @private */

      }, {
        key: "_onTrackEvent",
        value: function _onTrackEvent(e) {
          if (e.detail.state === 'start') {
            var path = e.composedPath();
            var headerCell = path[path.indexOf(this.$.header) - 2];

            if (!headerCell || !headerCell._content) {
              // Not a header column
              return;
            }

            var activeElement = this.getRootNode().activeElement;

            if (headerCell._content.contains(this.getRootNode().activeElement) && (!this._ie || !this._isFocusable(activeElement))) {
              // Something was focused inside the cell
              return;
            }

            if (this.$.scroller.hasAttribute('column-resizing')) {
              // Resizing is in progress
              return;
            }

            if (!this._touchDevice) {
              // Not a touch device
              this._onTrackStart(e);
            }
          } else if (e.detail.state === 'track') {
            this._onTrack(e);
          } else if (e.detail.state === 'end') {
            this._onTrackEnd(e);
          }
        }
        /** @private */

      }, {
        key: "_onTrackStart",
        value: function _onTrackStart(e) {
          if (!this.columnReorderingAllowed) {
            return;
          } // Cancel reordering if there are draggable nodes on the event path


          var path = e.path || (0, _polymerDom.dom)(e).path;

          if (path && path.filter(function (node) {
            return node.hasAttribute && node.hasAttribute('draggable');
          })[0]) {
            return;
          }

          var headerCell = this._cellFromPoint(e.detail.x, e.detail.y);

          if (!headerCell || headerCell.getAttribute('part').indexOf('header-cell') === -1) {
            return;
          }

          this._toggleAttribute('reordering', true, this);

          this._draggedColumn = headerCell._column;

          while (this._draggedColumn.parentElement.childElementCount === 1) {
            // This is the only column in the group, drag the whole group instead
            this._draggedColumn = this._draggedColumn.parentElement;
          }

          this._setSiblingsReorderStatus(this._draggedColumn, 'allowed');

          this._draggedColumn._reorderStatus = 'dragging';

          this._updateGhost(headerCell);

          this._reorderGhost.style.visibility = 'visible';

          this._updateGhostPosition(e.detail.x, this._touchDevice ? e.detail.y - 50 : e.detail.y);

          this._autoScroller();
        }
        /** @private */

      }, {
        key: "_onTrack",
        value: function _onTrack(e) {
          if (!this._draggedColumn) {
            // Reordering didn’t start. Skip this event.
            return;
          }

          var targetCell = this._cellFromPoint(e.detail.x, e.detail.y);

          if (!targetCell) {
            return;
          }

          var targetColumn = this._getTargetColumn(targetCell, this._draggedColumn);

          if (this._isSwapAllowed(this._draggedColumn, targetColumn) && this._isSwappableByPosition(targetColumn, e.detail.x)) {
            this._swapColumnOrders(this._draggedColumn, targetColumn);
          }

          this._updateGhostPosition(e.detail.x, this._touchDevice ? e.detail.y - 50 : e.detail.y);

          this._lastDragClientX = e.detail.x;
        }
        /** @private */

      }, {
        key: "_onTrackEnd",
        value: function _onTrackEnd() {
          if (!this._draggedColumn) {
            // Reordering didn’t start. Skip this event.
            return;
          }

          this._toggleAttribute('reordering', false, this);

          this._draggedColumn._reorderStatus = '';

          this._setSiblingsReorderStatus(this._draggedColumn, '');

          this._draggedColumn = null;
          this._lastDragClientX = null;
          this._reorderGhost.style.visibility = 'hidden';
          this.dispatchEvent(new CustomEvent('column-reorder', {
            detail: {
              columns: this._getColumnsInOrder()
            }
          }));
        }
        /**
         * @return {!Array<!GridColumnElement>}
         * @protected
         */

      }, {
        key: "_getColumnsInOrder",
        value: function _getColumnsInOrder() {
          return this._columnTree.slice(0).pop().filter(function (c) {
            return !c.hidden;
          }).sort(function (b, a) {
            return b._order - a._order;
          });
        }
        /**
         * @param {number} x
         * @param {number} y
         * @return {HTMLElement | undefined}
         * @protected
         */

      }, {
        key: "_cellFromPoint",
        value: function _cellFromPoint(x, y) {
          x = x || 0;
          y = y || 0;

          if (!this._draggedColumn) {
            this._toggleAttribute('no-content-pointer-events', true, this.$.scroller);
          } // Workaround a ShadyDOM bug


          this._reorderGhost.hidden = true;
          var cell;

          if (this.shadowRoot.elementFromPoint) {
            cell = this.shadowRoot.elementFromPoint(x, y);
          } else {
            cell = document.elementFromPoint(x, y);
          }

          this._reorderGhost.hidden = false; // Workaround FF58/ShadyDOM bugs

          while (!cell._column && cell.parentElement) {
            if (cell.localName === 'vaadin-grid-cell-content') {
              cell = cell.assignedSlot.parentNode;
            } else {
              cell = cell.parentElement;
            }
          }

          this._toggleAttribute('no-content-pointer-events', false, this.$.scroller); // Make sure the element is actually a cell


          if (cell && cell._column) {
            return cell;
          }
        }
        /**
         * @param {number} eventClientX
         * @param {number} eventClientY
         * @protected
         */

      }, {
        key: "_updateGhostPosition",
        value: function _updateGhostPosition(eventClientX, eventClientY) {
          var ghostRect = this._reorderGhost.getBoundingClientRect(); // // This is where we want to position the ghost


          var targetLeft = eventClientX - ghostRect.width / 2;
          var targetTop = eventClientY - ghostRect.height / 2; // Current position

          var _left = parseInt(this._reorderGhost._left || 0);

          var _top = parseInt(this._reorderGhost._top || 0); // Reposition the ghost


          this._reorderGhost._left = _left - (ghostRect.left - targetLeft);
          this._reorderGhost._top = _top - (ghostRect.top - targetTop);
          this._reorderGhost.style.transform = "translate(".concat(this._reorderGhost._left, "px, ").concat(this._reorderGhost._top, "px)");
        }
        /**
         * @param {!Element} e
         * @return {string}
         * @protected
         */

      }, {
        key: "_getInnerText",
        value: function _getInnerText(e) {
          var _this2 = this;

          if (e.localName) {
            // Custom implementation needed since IE11 doesn't respect the spec in case of hidden elements
            if (getComputedStyle(e).display === 'none') {
              return '';
            } else {
              return Array.from(e.childNodes).map(function (n) {
                return _this2._getInnerText(n);
              }).join('');
            }
          } else {
            return e.textContent;
          }
        }
        /**
         * @param {!HTMLElement} cell
         * @return {!HTMLElement}
         * @protected
         */

      }, {
        key: "_updateGhost",
        value: function _updateGhost(cell) {
          var ghost = this._reorderGhost;
          ghost.textContent = this._getInnerText(cell._content);
          var style = window.getComputedStyle(cell);
          ['boxSizing', 'display', 'width', 'height', 'background', 'alignItems', 'padding', 'border', 'flex-direction', 'overflow'].forEach(function (propertyName) {
            return ghost.style[propertyName] = style[propertyName];
          });
          return ghost;
        }
        /** @private */

      }, {
        key: "_updateOrders",
        value: function _updateOrders(columnTree, splices) {
          if (columnTree === undefined || splices === undefined) {
            return;
          } // Reset all column orders


          columnTree[0].forEach(function (column, index) {
            return column._order = 0;
          }); // Set order numbers to top-level columns

          _vaadinGridHelpers.GridHelper._updateColumnOrders(columnTree[0], this._orderBaseScope, 0);
        }
        /**
         * @param {!GridColumnElement} column
         * @param {string} status
         * @protected
         */

      }, {
        key: "_setSiblingsReorderStatus",
        value: function _setSiblingsReorderStatus(column, status) {
          var _this3 = this;

          Array.from(column.parentNode.children).filter(function (child) {
            return /column/.test(child.localName) && _this3._isSwapAllowed(child, column);
          }).forEach(function (sibling) {
            return sibling._reorderStatus = status;
          });
        }
        /** @protected */

      }, {
        key: "_autoScroller",
        value: function _autoScroller() {
          if (this._lastDragClientX) {
            var rightDiff = this._lastDragClientX - this.getBoundingClientRect().right + 50;
            var leftDiff = this.getBoundingClientRect().left - this._lastDragClientX + 50;

            if (rightDiff > 0) {
              this.$.table.scrollLeft += rightDiff / 10;
            } else if (leftDiff > 0) {
              this.$.table.scrollLeft -= leftDiff / 10;
            }

            this._scrollHandler();
          }

          if (this._draggedColumn) {
            this.async(this._autoScroller, 10);
          }
        }
        /**
         * @param {GridColumnElement | undefined} column1
         * @param {GridColumnElement | undefined} column2
         * @return {boolean | undefined}
         * @protected
         */

      }, {
        key: "_isSwapAllowed",
        value: function _isSwapAllowed(column1, column2) {
          if (column1 && column2) {
            var differentColumns = column1 !== column2;
            var sameParent = column1.parentElement === column2.parentElement;
            var sameFrozen = column1.frozen === column2.frozen;
            return differentColumns && sameParent && sameFrozen;
          }
        }
        /**
         * @param {!GridColumnElement} targetColumn
         * @param {number} clientX
         * @return {boolean}
         * @protected
         */

      }, {
        key: "_isSwappableByPosition",
        value: function _isSwappableByPosition(targetColumn, clientX) {
          var targetCell = Array.from(this.$.header.querySelectorAll('tr:not([hidden]) [part~="cell"]')).filter(function (cell) {
            return targetColumn.contains(cell._column);
          })[0];
          var sourceCellRect = this.$.header.querySelector('tr:not([hidden]) [reorder-status=dragging]').getBoundingClientRect();
          var targetRect = targetCell.getBoundingClientRect();

          if (targetRect.left > sourceCellRect.left) {
            return clientX > targetRect.right - sourceCellRect.width;
          } else {
            return clientX < targetRect.left + sourceCellRect.width;
          }
        }
        /**
         * @param {!GridColumnElement} column1
         * @param {!GridColumnElement} column2
         * @protected
         */

      }, {
        key: "_swapColumnOrders",
        value: function _swapColumnOrders(column1, column2) {
          var _order = column1._order;
          column1._order = column2._order;
          column2._order = _order;

          this._updateLastFrozen();

          this._updateFirstAndLastColumn();
        }
        /**
         * @param {HTMLElement | undefined} targetCell
         * @param {GridColumnElement} draggedColumn
         * @return {GridColumnElement | undefined}
         * @protected
         */

      }, {
        key: "_getTargetColumn",
        value: function _getTargetColumn(targetCell, draggedColumn) {
          if (targetCell && draggedColumn) {
            var candidate = targetCell._column;

            while (candidate.parentElement !== draggedColumn.parentElement && candidate !== this) {
              candidate = candidate.parentElement;
            }

            if (candidate.parentElement === draggedColumn.parentElement) {
              return candidate;
            } else {
              return targetCell._column;
            }
          }
        }
        /**
         * Fired when the columns in the grid are reordered.
         *
         * @event column-reorder
         * @param {Object} detail
         * @param {Object} detail.columns the columns in the new order
         */

      }], [{
        key: "properties",
        get: function get() {
          return {
            /**
             * Set to true to allow column reordering.
             * @attr {boolean} column-reordering-allowed
             * @type {boolean}
             */
            columnReorderingAllowed: {
              type: Boolean,
              value: false
            },

            /** @private */
            _orderBaseScope: {
              type: Number,
              value: 10000000
            }
          };
        }
      }, {
        key: "observers",
        get: function get() {
          return ['_updateOrders(_columnTree, _columnTree.*)'];
        }
      }]);
      return ColumnReorderingMixin;
    }((0, _gestureEventListeners.GestureEventListeners)(superClass));
  };

  _exports.ColumnReorderingMixin = ColumnReorderingMixin;
});