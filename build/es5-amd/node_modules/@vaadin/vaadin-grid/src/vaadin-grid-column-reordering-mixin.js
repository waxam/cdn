define(["exports", "../../../@polymer/polymer/lib/mixins/gesture-event-listeners.js", "../../../@polymer/polymer/lib/utils/gestures.js", "../../../@polymer/polymer/lib/legacy/polymer.dom.js", "../../../@polymer/polymer/lib/utils/settings.js"], function (_exports, _gestureEventListeners, _gestures, _polymerDom, _settings) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.ColumnReorderingMixin = void 0;

  /**
  @license
  Copyright (c) 2017 Vaadin Ltd.
  This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
  */

  /**
   * @polymerMixin
   */
  var ColumnReorderingMixin = function ColumnReorderingMixin(superClass) {
    return (
      /*#__PURE__*/
      function (_GestureEventListener) {
        babelHelpers.inherits(ColumnReorderingMixin, _GestureEventListener);

        function ColumnReorderingMixin() {
          babelHelpers.classCallCheck(this, ColumnReorderingMixin);
          return babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(ColumnReorderingMixin).apply(this, arguments));
        }

        babelHelpers.createClass(ColumnReorderingMixin, [{
          key: "ready",
          value: function ready() {
            babelHelpers.get(babelHelpers.getPrototypeOf(ColumnReorderingMixin.prototype), "ready", this).call(this);
            (0, _gestures.addListener)(this, 'track', this._onTrackEvent);
            this._reorderGhost = this.shadowRoot.querySelector('[part="reorder-ghost"]');
            this.addEventListener('touchstart', this._onTouchStart.bind(this));
            this.addEventListener('touchmove', this._onTouchMove.bind(this));
            this.addEventListener('touchend', this._onTouchEnd.bind(this));
            this.addEventListener('contextmenu', this._onContextMenu.bind(this));
          }
        }, {
          key: "_onContextMenu",
          value: function _onContextMenu(e) {
            if (this.hasAttribute('reordering')) {
              e.preventDefault();
            }
          }
        }, {
          key: "_onTouchStart",
          value: function _onTouchStart(e) {
            var _this = this;

            // Touch event, delay activation by 100ms
            this._startTouchReorderTimeout = setTimeout(function () {
              _this._onTrackStart({
                detail: {
                  x: e.touches[0].clientX,
                  y: e.touches[0].clientY
                }
              });
            }, 100);
          }
        }, {
          key: "_onTouchMove",
          value: function _onTouchMove(e) {
            if (this._draggedColumn) {
              e.preventDefault();
            }

            clearTimeout(this._startTouchReorderTimeout);
          }
        }, {
          key: "_onTouchEnd",
          value: function _onTouchEnd() {
            clearTimeout(this._startTouchReorderTimeout);

            this._onTrackEnd();
          }
        }, {
          key: "_onTrackEvent",
          value: function _onTrackEvent(e) {
            if (e.detail.state === 'start') {
              var path = e.composedPath();
              var headerCell = path[path.indexOf(this.$.header) - 2];

              if (!headerCell || !headerCell._content) {
                // Not a header column
                return;
              }

              var activeElement = this.getRootNode().activeElement;

              if (headerCell._content.contains(this.getRootNode().activeElement) && (!this._ie || !this._isFocusable(activeElement))) {
                // Something was focused inside the cell
                return;
              }

              if (this.$.scroller.hasAttribute('column-resizing')) {
                // Resizing is in progress
                return;
              }

              if (!this._touchDevice) {
                // Not a touch device
                this._onTrackStart(e);
              }
            } else if (e.detail.state === 'track') {
              this._onTrack(e);
            } else if (e.detail.state === 'end') {
              this._onTrackEnd(e);
            }
          }
        }, {
          key: "_onTrackStart",
          value: function _onTrackStart(e) {
            if (!this.columnReorderingAllowed) {
              return;
            } // Cancel reordering if there are draggable nodes on the event path


            var path = e.path || (0, _polymerDom.dom)(e).path;

            if (path && path.filter(function (node) {
              return node.hasAttribute && node.hasAttribute('draggable');
            })[0]) {
              return;
            }

            var headerCell = this._cellFromPoint(e.detail.x, e.detail.y);

            if (!headerCell || headerCell.getAttribute('part').indexOf('header-cell') === -1) {
              return;
            }

            this._toggleAttribute('reordering', true, this);

            this._draggedColumn = headerCell._column;

            while (this._draggedColumn.parentElement.childElementCount === 1) {
              // This is the only column in the group, drag the whole group instead
              this._draggedColumn = this._draggedColumn.parentElement;
            }

            this._setSiblingsReorderStatus(this._draggedColumn, 'allowed');

            this._draggedColumn._reorderStatus = 'dragging';

            this._updateGhost(headerCell);

            this._reorderGhost.style.visibility = 'visible';

            this._updateGhostPosition(e.detail.x, this._touchDevice ? e.detail.y - 50 : e.detail.y);

            this._autoScroller();
          }
        }, {
          key: "_onTrack",
          value: function _onTrack(e) {
            if (!this._draggedColumn) {
              // Reordering didn’t start. Skip this event.
              return;
            }

            var targetCell = this._cellFromPoint(e.detail.x, e.detail.y);

            if (!targetCell) {
              return;
            }

            var targetColumn = this._getTargetColumn(targetCell, this._draggedColumn);

            if (this._isSwapAllowed(this._draggedColumn, targetColumn) && this._isSwappableByPosition(targetColumn, e.detail.x)) {
              this._swapColumnOrders(this._draggedColumn, targetColumn);
            }

            this._updateGhostPosition(e.detail.x, this._touchDevice ? e.detail.y - 50 : e.detail.y);

            this._lastDragClientX = e.detail.x;
          }
        }, {
          key: "_onTrackEnd",
          value: function _onTrackEnd() {
            if (!this._draggedColumn) {
              // Reordering didn’t start. Skip this event.
              return;
            }

            this._toggleAttribute('reordering', false, this);

            this._draggedColumn._reorderStatus = '';

            this._setSiblingsReorderStatus(this._draggedColumn, '');

            this._draggedColumn = null;
            this._lastDragClientX = null;
            this._reorderGhost.style.visibility = 'hidden';
            this.dispatchEvent(new CustomEvent('column-reorder', {
              detail: {
                columns: this._getColumnsInOrder()
              }
            }));
          }
        }, {
          key: "_getColumnsInOrder",
          value: function _getColumnsInOrder() {
            return this._columnTree.slice(0).pop().filter(function (c) {
              return !c.hidden;
            }).sort(function (b, a) {
              return b._order - a._order;
            });
          }
        }, {
          key: "_cellFromPoint",
          value: function _cellFromPoint(x, y) {
            x = x || 0;
            y = y || 0;

            if (!this._draggedColumn) {
              this._toggleAttribute('no-content-pointer-events', true, this.$.scroller);
            }

            var cell;

            if (_settings.useShadow) {
              cell = this.shadowRoot.elementFromPoint(x, y);
            } else {
              cell = document.elementFromPoint(x, y); // Workaround a FF58 bug

              if (cell.localName === 'vaadin-grid-cell-content') {
                cell = cell.assignedSlot.parentNode;
              }
            }

            this._toggleAttribute('no-content-pointer-events', false, this.$.scroller); // Make sure the element is actually a cell


            if (cell && cell._column) {
              return cell;
            }
          }
        }, {
          key: "_updateGhostPosition",
          value: function _updateGhostPosition(eventClientX, eventClientY) {
            var ghostRect = this._reorderGhost.getBoundingClientRect(); // // This is where we want to position the ghost


            var targetLeft = eventClientX - ghostRect.width / 2;
            var targetTop = eventClientY - ghostRect.height / 2; // Current position

            var _left = parseInt(this._reorderGhost._left || 0);

            var _top = parseInt(this._reorderGhost._top || 0); // Reposition the ghost


            this._reorderGhost._left = _left - (ghostRect.left - targetLeft);
            this._reorderGhost._top = _top - (ghostRect.top - targetTop);
            this._reorderGhost.style.transform = "translate(".concat(this._reorderGhost._left, "px, ").concat(this._reorderGhost._top, "px)");
          }
        }, {
          key: "_getInnerText",
          value: function _getInnerText(e) {
            var _this2 = this;

            if (e.localName) {
              // Custom implementation needed since IE11 doesn't respect the spec in case of hidden elements
              if (getComputedStyle(e).display === 'none') {
                return '';
              } else {
                return Array.from(e.childNodes).map(function (n) {
                  return _this2._getInnerText(n);
                }).join('');
              }
            } else {
              return e.textContent;
            }
          }
        }, {
          key: "_updateGhost",
          value: function _updateGhost(cell) {
            var ghost = this._reorderGhost;
            ghost.textContent = this._getInnerText(cell._content);
            var style = window.getComputedStyle(cell);
            ['boxSizing', 'display', 'width', 'height', 'background', 'alignItems', 'padding', 'border', 'flex-direction', 'overflow'].forEach(function (propertyName) {
              return ghost.style[propertyName] = style[propertyName];
            });
            return ghost;
          }
        }, {
          key: "_updateOrders",
          value: function _updateOrders(columnTree, splices) {
            var _this3 = this;

            if (columnTree === undefined || splices === undefined) {
              return;
            } // Reset all column orders


            columnTree[0].forEach(function (column, index) {
              return column._order = 0;
            }); // Set order numbers to top-level columns

            columnTree[0].forEach(function (column, index) {
              return column._order = (index + 1) * _this3._orderBaseScope;
            });
          }
        }, {
          key: "_setSiblingsReorderStatus",
          value: function _setSiblingsReorderStatus(column, status) {
            var _this4 = this;

            Array.from(column.parentNode.children).filter(function (child) {
              return /column/.test(child.localName) && _this4._isSwapAllowed(child, column);
            }).forEach(function (sibling) {
              return sibling._reorderStatus = status;
            });
          }
        }, {
          key: "_autoScroller",
          value: function _autoScroller() {
            if (this._lastDragClientX) {
              var rightDiff = this._lastDragClientX - this.getBoundingClientRect().right + 50;
              var leftDiff = this.getBoundingClientRect().left - this._lastDragClientX + 50;

              if (rightDiff > 0) {
                this.$.table.scrollLeft += rightDiff / 10;
              } else if (leftDiff > 0) {
                this.$.table.scrollLeft -= leftDiff / 10;
              }

              this._scrollHandler();
            }

            if (this._draggedColumn) {
              this.async(this._autoScroller, 10);
            }
          }
        }, {
          key: "_isSwapAllowed",
          value: function _isSwapAllowed(column1, column2) {
            if (column1 && column2) {
              var differentColumns = column1 !== column2;
              var sameParent = column1.parentElement === column2.parentElement;
              var sameFrozen = column1.frozen === column2.frozen;
              return differentColumns && sameParent && sameFrozen;
            }
          }
        }, {
          key: "_isSwappableByPosition",
          value: function _isSwappableByPosition(targetColumn, clientX) {
            var targetCell = Array.from(this.$.header.querySelectorAll('tr:not([hidden]) [part~="cell"]')).filter(function (cell) {
              return targetColumn.contains(cell._column);
            })[0];
            var sourceCellRect = this.$.header.querySelector('tr:not([hidden]) [reorder-status=dragging]').getBoundingClientRect();
            var targetRect = targetCell.getBoundingClientRect();

            if (targetRect.left > sourceCellRect.left) {
              return clientX > targetRect.right - sourceCellRect.width;
            } else {
              return clientX < targetRect.left + sourceCellRect.width;
            }
          }
        }, {
          key: "_swapColumnOrders",
          value: function _swapColumnOrders(column1, column2) {
            var _order = column1._order;
            column1._order = column2._order;
            column2._order = _order;

            this._updateLastFrozen();

            this._updateFirstAndLastColumn();
          }
        }, {
          key: "_getTargetColumn",
          value: function _getTargetColumn(targetCell, draggedColumn) {
            if (targetCell && draggedColumn) {
              var candidate = targetCell._column;

              while (candidate.parentElement !== draggedColumn.parentElement && candidate !== this) {
                candidate = candidate.parentElement;
              }

              if (candidate.parentElement === draggedColumn.parentElement) {
                return candidate;
              } else {
                return targetCell._column;
              }
            }
          }
          /**
           * Fired when the columns in the grid are reordered.
           *
           * @event column-reorder
           * @param {Object} detail
           * @param {Object} detail.columns the columns in the new order
           */

        }], [{
          key: "properties",
          get: function get() {
            return {
              /**
               * Set to true to allow column reordering.
               */
              columnReorderingAllowed: {
                type: Boolean,
                value: false
              },
              _orderBaseScope: {
                type: Number,
                value: 10000000
              }
            };
          }
        }, {
          key: "observers",
          get: function get() {
            return ['_updateOrders(_columnTree, _columnTree.*)'];
          }
        }]);
        return ColumnReorderingMixin;
      }((0, _gestureEventListeners.GestureEventListeners)(superClass))
    );
  };

  _exports.ColumnReorderingMixin = ColumnReorderingMixin;
});