define(["exports"], function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.KeyboardNavigationMixin = void 0;

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  /**
  @license
  Copyright (c) 2017 Vaadin Ltd.
  This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
  */

  /**
   * @polymerMixin
   */
  var KeyboardNavigationMixin = function KeyboardNavigationMixin(superClass) {
    return /*#__PURE__*/function (_superClass) {
      babelHelpers.inherits(KeyboardNavigationMixin, _superClass);

      var _super = _createSuper(KeyboardNavigationMixin);

      function KeyboardNavigationMixin() {
        babelHelpers.classCallCheck(this, KeyboardNavigationMixin);
        return _super.apply(this, arguments);
      }

      babelHelpers.createClass(KeyboardNavigationMixin, [{
        key: "ready",
        value:
        /** @protected */
        function ready() {
          var _this = this;

          babelHelpers.get(babelHelpers.getPrototypeOf(KeyboardNavigationMixin.prototype), "ready", this).call(this);

          if (this._ios || this._android) {
            // Disable keyboard navigation on mobile devices
            return;
          }

          this.addEventListener('keydown', this._onKeyDown);
          this.addEventListener('keyup', this._onKeyUp);
          this.addEventListener('focusin', this._onFocusIn);
          this.addEventListener('focusout', this._onFocusOut); // When focus goes from cell to another cell, focusin/focusout events do
          // not escape the grid’s shadowRoot, thus listening inside the shadowRoot.

          this.$.table.addEventListener('focusin', this._onCellFocusIn.bind(this));
          this.$.table.addEventListener('focusout', this._onCellFocusOut.bind(this));
          this.addEventListener('mousedown', function () {
            _this._toggleAttribute('navigating', false, _this);

            _this._isMousedown = true;
          });
          this.addEventListener('mouseup', function () {
            return _this._isMousedown = false;
          });
        }
        /** @private */

      }, {
        key: "_focusableChanged",
        value: function _focusableChanged(focusable, oldFocusable) {
          if (oldFocusable) {
            oldFocusable.setAttribute('tabindex', '-1');
          }

          if (focusable) {
            this._updateGridSectionFocusTarget(focusable);
          }
        }
        /** @private */

      }, {
        key: "_interactingChanged",
        value: function _interactingChanged() {
          // Update focus targets when entering / exiting interaction mode
          this._updateGridSectionFocusTarget(this._headerFocusable);

          this._updateGridSectionFocusTarget(this._itemsFocusable);

          this._updateGridSectionFocusTarget(this._footerFocusable);
        }
        /**
         * @param {!KeyboardEvent} e
         * @protected
         */

      }, {
        key: "_onKeyDown",
        value: function _onKeyDown(e) {
          // Ensure standard key value, unified across browsers
          var key = e.key;

          if (key === 'Up' || key === 'Down' || key === 'Left' || key === 'Right') {
            // MSIE & Edge
            key = 'Arrow' + key;
          }

          if (key === 'Esc') {
            // MSIE & Edge
            key = 'Escape';
          }

          if (key === 'Spacebar') {
            // MSIE
            key = ' ';
          }

          var keyGroup;

          switch (key) {
            case 'ArrowUp':
            case 'ArrowDown':
            case 'ArrowLeft':
            case 'ArrowRight':
            case 'PageUp':
            case 'PageDown':
            case 'Home':
            case 'End':
              keyGroup = 'Navigation';
              break;

            case 'Enter':
            case 'Escape':
            case 'F2':
              keyGroup = 'Interaction';
              break;

            case 'Tab':
              keyGroup = 'Tab';
              break;

            case ' ':
              keyGroup = 'Space';
              break;
          }

          this._detectInteracting(e);

          if (this.interacting && keyGroup !== 'Interaction') {
            // When in the interacting mode, only the “Interaction” keys are handled.
            keyGroup = undefined;
          }

          if (keyGroup) {
            this["_on".concat(keyGroup, "KeyDown")](e, key);
          }
        }
        /** @private */

      }, {
        key: "_ensureScrolledToIndex",
        value: function _ensureScrolledToIndex(index) {
          var targetRowInDom = Array.from(this.$.items.children).filter(function (child) {
            return child.index === index;
          })[0];

          if (!targetRowInDom) {
            this._scrollToIndex(index);
          }
        }
        /** @private */

      }, {
        key: "_onNavigationKeyDown",
        value: function _onNavigationKeyDown(e, key) {
          var _this2 = this;

          this._scrollHandler();

          e.preventDefault();

          function indexOfChildElement(el) {
            return Array.prototype.indexOf.call(el.parentNode.children, el);
          }

          var visibleItemsCount = this._lastVisibleIndex - this._firstVisibleIndex - 1;
          var dx = 0,
              dy = 0;

          switch (key) {
            case 'ArrowRight':
              dx = this.__isRTL ? -1 : 1;
              break;

            case 'ArrowLeft':
              dx = this.__isRTL ? 1 : -1;
              break;

            case 'Home':
              dx = -Infinity;
              e.ctrlKey && (dy = -Infinity);
              break;

            case 'End':
              dx = Infinity;
              e.ctrlKey && (dy = Infinity);
              break;

            case 'ArrowDown':
              dy = 1;
              break;

            case 'ArrowUp':
              dy = -1;
              break;

            case 'PageDown':
              dy = visibleItemsCount;
              break;

            case 'PageUp':
              dy = -visibleItemsCount;
              break;
          }

          var activeCell = e.composedPath()[0];
          var columnIndex = indexOfChildElement(activeCell);

          var isRowDetails = this._elementMatches(activeCell, '[part~="details-cell"]');

          var activeRow = activeCell.parentNode;
          var activeRowGroup = activeRow.parentNode;
          var maxRowIndex = (activeRowGroup === this.$.items ? this._effectiveSize : activeRowGroup.children.length) - 1; // Body rows have index property, otherwise DOM child index of the row is used.

          var rowIndex = activeRowGroup === this.$.items ? this._focusedItemIndex !== undefined ? this._focusedItemIndex : activeRow.index : indexOfChildElement(activeRow); // Index of the destination row

          var dstRowIndex = Math.max(0, Math.min(rowIndex + dy, maxRowIndex)); // Row details navigation logic

          var dstIsRowDetails = false;

          if (activeRowGroup === this.$.items) {
            var item = activeRow._item;

            var dstItem = this._cache.getItemForIndex(dstRowIndex); // Should we navigate to row details?


            if (isRowDetails) {
              dstIsRowDetails = dy === 0;
            } else {
              dstIsRowDetails = dy === 1 && this._isDetailsOpened(item) || dy === -1 && dstRowIndex !== rowIndex && this._isDetailsOpened(dstItem);
            } // Should we navigate between details and regular cells of the same row?


            if (dstIsRowDetails !== isRowDetails && (dy === 1 && dstIsRowDetails || dy === -1 && !dstIsRowDetails)) {
              dstRowIndex = rowIndex;
            }
          } // Header and footer could have hidden rows, e. g., if none of the columns
          // or groups on the given column tree level define template. Skip them
          // in vertical keyboard navigation.


          if (activeRowGroup !== this.$.items) {
            if (dstRowIndex > rowIndex) {
              while (dstRowIndex < maxRowIndex && activeRowGroup.children[dstRowIndex].hidden) {
                dstRowIndex++;
              }
            } else if (dstRowIndex < rowIndex) {
              while (dstRowIndex > 0 && activeRowGroup.children[dstRowIndex].hidden) {
                dstRowIndex--;
              }
            }
          } // _focusedColumnOrder is memoized — this is to ensure predictable
          // navigation when entering and leaving detail and column group cells.


          if (this._focusedColumnOrder === undefined) {
            if (isRowDetails) {
              this._focusedColumnOrder = 0;
            } else {
              this._focusedColumnOrder = this._getColumns(activeRowGroup, rowIndex).filter(function (c) {
                return !c.hidden;
              })[columnIndex]._order;
            }
          } // Find orderedColumnIndex — the index of order closest matching the
          // original _focusedColumnOrder in the sorted array of orders
          // of the visible columns on the destination row.


          var dstColumns = this._getColumns(activeRowGroup, dstRowIndex).filter(function (c) {
            return !c.hidden;
          });

          var dstSortedColumnOrders = dstColumns.map(function (c) {
            return c._order;
          }).sort(function (b, a) {
            return b - a;
          });
          var maxOrderedColumnIndex = dstSortedColumnOrders.length - 1;
          var orderedColumnIndex = dstSortedColumnOrders.indexOf(dstSortedColumnOrders.slice(0).sort(function (b, a) {
            return Math.abs(b - _this2._focusedColumnOrder) - Math.abs(a - _this2._focusedColumnOrder);
          })[0]); // Index of the destination column order

          var dstOrderedColumnIndex = dy === 0 && isRowDetails ? orderedColumnIndex : Math.max(0, Math.min(orderedColumnIndex + dx, maxOrderedColumnIndex));

          if (dstOrderedColumnIndex !== orderedColumnIndex) {
            // Horizontal movement invalidates stored _focusedColumnOrder
            this._focusedColumnOrder = undefined;
          } // Ensure correct vertical scroll position, destination row is visible


          if (activeRowGroup === this.$.items) {
            this._ensureScrolledToIndex(dstRowIndex);
          } // This has to be set after scrolling, otherwise it can be removed by
          // `_preventScrollerRotatingCellFocus(row, index)` during scrolling.


          this._toggleAttribute('navigating', true, this);

          var columnIndexByOrder = dstColumns.reduce(function (acc, col, i) {
            return acc[col._order] = i, acc;
          }, {});
          var dstColumnIndex = columnIndexByOrder[dstSortedColumnOrders[dstOrderedColumnIndex]]; // For body rows, use index property to find destination row, otherwise use DOM child index

          var dstRow = activeRowGroup === this.$.items ? Array.from(activeRowGroup.children).filter(function (el) {
            return el.index === dstRowIndex;
          })[0] : activeRowGroup.children[dstRowIndex];

          if (!dstRow) {
            return;
          } // Here we go!


          var dstCell = dstIsRowDetails ? Array.from(dstRow.children).filter(function (el) {
            return _this2._elementMatches(el, '[part~="details-cell"]');
          })[0] : dstRow.children[dstColumnIndex];

          this._scrollHorizontallyToCell(dstCell);

          if (activeRowGroup === this.$.items) {
            // When scrolling with repeated keydown, sometimes FocusEvent listeners
            // are too late to update _focusedItemIndex. Ensure next keydown
            // listener invocation gets updated _focusedItemIndex value.
            this._focusedItemIndex = dstRowIndex;
          }

          if (activeRowGroup === this.$.items) {
            var dstRect = dstCell.getBoundingClientRect();
            var footerTop = this.$.footer.getBoundingClientRect().top;
            var headerBottom = this.$.header.getBoundingClientRect().bottom;

            if (dstRect.bottom > footerTop) {
              this.$.table.scrollTop += dstRect.bottom - footerTop;

              this._scrollHandler();
            } else if (dstRect.top < headerBottom) {
              this.$.table.scrollTop -= headerBottom - dstRect.top;

              this._scrollHandler();
            }
          }

          dstCell.focus();
        }
        /** @private */

      }, {
        key: "_onInteractionKeyDown",
        value: function _onInteractionKeyDown(e, key) {
          var localTarget = e.composedPath()[0];
          var localTargetIsTextInput = localTarget.localName === 'input' && !/^(button|checkbox|color|file|image|radio|range|reset|submit)$/i.test(localTarget.type);
          var wantInteracting;

          switch (key) {
            case 'Enter':
              wantInteracting = this.interacting ? !localTargetIsTextInput : true;
              break;

            case 'Escape':
              wantInteracting = false;
              break;

            case 'F2':
              wantInteracting = !this.interacting;
              break;
          }

          var _this$_getGridEventLo = this._getGridEventLocation(e),
              cell = _this$_getGridEventLo.cell;

          if (this.interacting !== wantInteracting && cell !== null) {
            if (wantInteracting) {
              var focusTarget = cell._content.querySelector('[focus-target]') || cell._content.firstElementChild;

              if (focusTarget) {
                e.preventDefault();
                focusTarget.focus();

                this._setInteracting(true);

                this._toggleAttribute('navigating', false, this);
              }
            } else {
              e.preventDefault();
              this._focusedColumnOrder = undefined;
              cell.focus();

              this._setInteracting(false);

              this._toggleAttribute('navigating', true, this);
            }
          }
        }
        /** @private */

      }, {
        key: "_predictFocusStepTarget",
        value: function _predictFocusStepTarget(srcElement, step) {
          var tabOrder = [this.$.table, this._headerFocusable, this._itemsFocusable, this._footerFocusable, this.$.focusexit];
          var index = tabOrder.indexOf(srcElement);
          index += step;

          while (index >= 0 && index <= tabOrder.length - 1 && (!tabOrder[index] || tabOrder[index].parentNode.hidden)) {
            index += step;
          }

          return tabOrder[index];
        }
        /** @private */

      }, {
        key: "_onTabKeyDown",
        value: function _onTabKeyDown(e) {
          var _this3 = this;

          var focusTarget = this._predictFocusStepTarget(e.composedPath()[0], e.shiftKey ? -1 : 1);

          if (focusTarget === this.$.table) {
            // The focus is about to exit the grid to the top.
            this.$.table.focus();
          } else if (focusTarget === this.$.focusexit) {
            // The focus is about to exit the grid to the bottom.
            this.$.focusexit.focus();
          } else if (focusTarget === this._itemsFocusable) {
            var itemsFocusTarget = focusTarget;
            var targetRow = this._itemsFocusable.parentNode;

            this._ensureScrolledToIndex(this._focusedItemIndex);

            if (targetRow.index !== this._focusedItemIndex) {
              // The target row, which is about to be focused next, has been
              // assigned with a new index since last focus, probably because of
              // scrolling. Focus the row for the stored focused item index instead.
              var columnIndex = Array.from(targetRow.children).indexOf(this._itemsFocusable);
              var focusedItemRow = Array.from(this.$.items.children).filter(function (row) {
                return row.index === _this3._focusedItemIndex;
              })[0];

              if (focusedItemRow) {
                itemsFocusTarget = focusedItemRow.children[columnIndex];
              }
            }

            e.preventDefault();
            itemsFocusTarget.focus();
          } else {
            e.preventDefault();
            focusTarget.focus();
          }

          this._toggleAttribute('navigating', true, this);
        }
        /** @private */

      }, {
        key: "_onSpaceKeyDown",
        value: function _onSpaceKeyDown(e) {
          e.preventDefault();
          var cell = e.composedPath()[0];

          if (!cell._content || !cell._content.firstElementChild) {
            this.dispatchEvent(new CustomEvent('cell-activate', {
              detail: {
                model: this.__getRowModel(cell.parentElement)
              }
            }));
          }
        }
        /** @private */

      }, {
        key: "_onKeyUp",
        value: function _onKeyUp(e) {
          if (!/^( |SpaceBar)$/.test(e.key)) {
            return;
          }

          e.preventDefault();
          var cell = e.composedPath()[0];

          if (cell._content && cell._content.firstElementChild) {
            var wasNavigating = this.hasAttribute('navigating');

            cell._content.firstElementChild.click();

            this._toggleAttribute('navigating', wasNavigating, this);
          }
        }
        /**
         * @param {!FocusEvent} e
         * @protected
         */

      }, {
        key: "_onFocusIn",
        value: function _onFocusIn(e) {
          if (!this._isMousedown) {
            this._toggleAttribute('navigating', true, this);
          }

          var rootTarget = e.composedPath()[0];

          if (rootTarget === this.$.table || rootTarget === this.$.focusexit) {
            // The focus enters the top (bottom) of the grid, meaning that user has
            // tabbed (shift-tabbed) into the grid. Move the focus to
            // the first (the last) focusable.
            this._predictFocusStepTarget(rootTarget, rootTarget === this.$.table ? 1 : -1).focus();

            this._setInteracting(false);
          } else {
            this._detectInteracting(e);
          }
        }
        /**
         * @param {!FocusEvent} e
         * @protected
         */

      }, {
        key: "_onFocusOut",
        value: function _onFocusOut(e) {
          this._toggleAttribute('navigating', false, this);

          this._detectInteracting(e);
        }
        /** @private */

      }, {
        key: "_onCellFocusIn",
        value: function _onCellFocusIn(e) {
          var _this$_getGridEventLo2 = this._getGridEventLocation(e),
              section = _this$_getGridEventLo2.section,
              cell = _this$_getGridEventLo2.cell;

          this._detectInteracting(e);

          if (section && cell) {
            this._activeRowGroup = section;

            if (this.$.header === section) {
              this._headerFocusable = cell;
            } else if (this.$.items === section) {
              this._itemsFocusable = cell;
            } else if (this.$.footer === section) {
              this._footerFocusable = cell;
            } // Inform cell content of the focus (used in <vaadin-grid-sorter>)


            cell._content.dispatchEvent(new CustomEvent('cell-focusin', {
              bubbles: false
            })); // Fire a public event for cell focus.


            var context = this.getEventContext(e);
            cell.dispatchEvent(new CustomEvent('cell-focus', {
              bubbles: true,
              composed: true,
              detail: {
                context: context
              }
            }));
          }

          this._detectFocusedItemIndex(e);
        }
        /** @private */

      }, {
        key: "_onCellFocusOut",
        value: function _onCellFocusOut(e) {
          if (e.composedPath().indexOf(this.$.table) === 3) {
            var cell = e.composedPath()[0]; // Inform cell content of the focus (used in <vaadin-grid-sorter>)

            cell._content.dispatchEvent(new CustomEvent('cell-focusout', {
              bubbles: false
            }));
          }
        }
        /** @private
         * Enables interaction mode if a cells descendant receives focus or keyboard
         * input. Disables it if the event is not related to cell content.
         * @param {!KeyboardEvent|!FocusEvent} e
         */

      }, {
        key: "_detectInteracting",
        value: function _detectInteracting(e) {
          var isInteracting = e.composedPath().some(function (el) {
            return el.localName === 'vaadin-grid-cell-content';
          });

          this._setInteracting(isInteracting);
        }
        /** @private */

      }, {
        key: "_detectFocusedItemIndex",
        value: function _detectFocusedItemIndex(e) {
          var _this$_getGridEventLo3 = this._getGridEventLocation(e),
              section = _this$_getGridEventLo3.section,
              row = _this$_getGridEventLo3.row;

          if (section === this.$.items) {
            this._focusedItemIndex = row.index;
          }
        }
        /** @private
         * Enables or disables the focus target cell of the containing section of the
         * grid from receiving focus, based on whether the user is interacting with
         * that section of the grid.
         * @param {HTMLTableCellElement} focusTargetCell
         */

      }, {
        key: "_updateGridSectionFocusTarget",
        value: function _updateGridSectionFocusTarget(focusTargetCell) {
          if (!focusTargetCell) {
            return;
          }

          var section = this._getGridSectionFromFocusTarget(focusTargetCell);

          var isInteractingWithinActiveSection = this.interacting && section === this._activeRowGroup;
          focusTargetCell.tabIndex = isInteractingWithinActiveSection ? -1 : 0;
        }
        /**
         * @param {!HTMLTableRowElement} row
         * @param {number} index
         * @protected
         */

      }, {
        key: "_preventScrollerRotatingCellFocus",
        value: function _preventScrollerRotatingCellFocus(row, index) {
          if (row.index === this._focusedItemIndex && this.hasAttribute('navigating') && this._activeRowGroup === this.$.items) {
            // Focused item has went, hide navigation mode
            this._navigatingIsHidden = true;

            this._toggleAttribute('navigating', false, this);
          }

          if (index === this._focusedItemIndex && this._navigatingIsHidden) {
            // Focused item is back, restore navigation mode
            this._navigatingIsHidden = false;

            this._toggleAttribute('navigating', true, this);
          }
        }
        /**
         * @param {HTMLTableSectionElement=} rowGroup
         * @param {number=} rowIndex
         * @return {!Array<!GridColumnElement>}
         * @protected
         */

      }, {
        key: "_getColumns",
        value: function _getColumns(rowGroup, rowIndex) {
          var columnTreeLevel = this._columnTree.length - 1;

          if (rowGroup === this.$.header) {
            columnTreeLevel = rowIndex;
          } else if (rowGroup === this.$.footer) {
            columnTreeLevel = this._columnTree.length - 1 - rowIndex;
          }

          return this._columnTree[columnTreeLevel];
        }
        /** @protected */

      }, {
        key: "_resetKeyboardNavigation",
        value: function _resetKeyboardNavigation() {
          var _this4 = this;

          if (this.$.header.firstElementChild) {
            this._headerFocusable = Array.from(this.$.header.firstElementChild.children).filter(function (el) {
              return !el.hidden;
            })[0];
          }

          if (this.$.items.firstElementChild) {
            var firstVisibleIndexRow = this._iterateItems(function (pidx, vidx) {
              if (_this4._firstVisibleIndex === vidx) {
                return _this4.$.items.children[pidx];
              }
            });

            if (firstVisibleIndexRow) {
              this._itemsFocusable = Array.from(firstVisibleIndexRow.children).filter(function (el) {
                return !el.hidden;
              })[0];
            }
          }

          if (this.$.footer.firstElementChild) {
            this._footerFocusable = Array.from(this.$.footer.firstElementChild.children).filter(function (el) {
              return !el.hidden;
            })[0];
          }
        }
        /**
         * @param {!HTMLElement} dstCell
         * @protected
         */

      }, {
        key: "_scrollHorizontallyToCell",
        value: function _scrollHorizontallyToCell(dstCell) {
          if (dstCell.hasAttribute('frozen') || this._elementMatches(dstCell, '[part~="details-cell"]')) {
            // These cells are, by design, always visible, no need to scroll.
            return;
          }

          var dstCellRect = dstCell.getBoundingClientRect();
          var dstRow = dstCell.parentNode;
          var dstCellIndex = Array.from(dstRow.children).indexOf(dstCell);
          var tableRect = this.$.table.getBoundingClientRect();
          var leftBoundary = tableRect.left,
              rightBoundary = tableRect.right;

          for (var i = dstCellIndex - 1; i >= 0; i--) {
            var cell = dstRow.children[i];

            if (cell.hasAttribute('hidden') || this._elementMatches(cell, '[part~="details-cell"]')) {
              continue;
            }

            if (cell.hasAttribute('frozen')) {
              leftBoundary = cell.getBoundingClientRect().right;
              break;
            }
          }

          for (var _i = dstCellIndex + 1; _i < dstRow.children.length; _i++) {
            var _cell = dstRow.children[_i];

            if (_cell.hasAttribute('hidden') || this._elementMatches(_cell, '[part~="details-cell"]')) {
              continue;
            }

            if (_cell.hasAttribute('frozen')) {
              rightBoundary = _cell.getBoundingClientRect().left;
              break;
            }
          }

          if (dstCellRect.left < leftBoundary) {
            this.$.table.scrollLeft += Math.round(dstCellRect.left - leftBoundary);
          }

          if (dstCellRect.right > rightBoundary) {
            this.$.table.scrollLeft += Math.round(dstCellRect.right - rightBoundary);
          }
        }
        /** @private */

      }, {
        key: "_elementMatches",
        value: function _elementMatches(el, query) {
          return el.matches ? el.matches(query) : Array.from(el.parentNode.querySelectorAll(query)).indexOf(el) !== -1;
        }
        /**
         * @typedef {Object} GridEventLocation
         * @property {HTMLTableSectionElement | null} section - The table section element that the event occurred in (header, body, or footer),
         * or null if the event did not occur in a section
         * @property {HTMLTableRowElement | null} row - The row element that the event occurred in, or null if the event did not occur in a row
         * @property {HTMLTableCellElement | null} cell - The cell element that the event occurred in, or null if the event did not occur in a
         * cell
         * @private
         */

        /**
         * Takes an event and returns a location object describing in which part of the grid the event occurred.
         * The event may either target table section, a row, a cell or contents of a cell.
         * @param {Event} e
         * @returns {GridEventLocation}
         * @private
         */

      }, {
        key: "_getGridEventLocation",
        value: function _getGridEventLocation(e) {
          var path = e.composedPath();
          var tableIndex = path.indexOf(this.$.table); // Assuming ascending path to table is: [...,] th|td, tr, thead|tbody, table [,...]

          var section = tableIndex >= 1 ? path[tableIndex - 1] : null;
          var row = tableIndex >= 2 ? path[tableIndex - 2] : null;
          var cell = tableIndex >= 3 ? path[tableIndex - 3] : null;
          return {
            section: section,
            row: row,
            cell: cell
          };
        }
        /**
         * Helper method that maps a focus target cell to the containing grid section
         * @param {HTMLTableCellElement} focusTargetCell
         * @returns {HTMLTableSectionElement | null}
         * @private
         */

      }, {
        key: "_getGridSectionFromFocusTarget",
        value: function _getGridSectionFromFocusTarget(focusTargetCell) {
          if (focusTargetCell === this._headerFocusable) {
            return this.$.header;
          }

          if (focusTargetCell === this._itemsFocusable) {
            return this.$.items;
          }

          if (focusTargetCell === this._footerFocusable) {
            return this.$.footer;
          }

          return null;
        }
        /**
         * Fired when a cell is focused with click or keyboard navigation.
         *
         * Use context property of @see {@link GridCellFocusEvent} to get detail information about the event.
         *
         * @event cell-focus
         */

      }], [{
        key: "properties",
        get: function get() {
          return {
            /** @private */
            _headerFocusable: {
              type: Object,
              observer: '_focusableChanged'
            },

            /**
             * @type {!HTMLElement | undefined}
             * @protected
             */
            _itemsFocusable: {
              type: Object,
              observer: '_focusableChanged'
            },

            /** @private */
            _footerFocusable: {
              type: Object,
              observer: '_focusableChanged'
            },

            /** @private */
            _navigatingIsHidden: Boolean,

            /**
             * @type {number}
             * @protected
             */
            _focusedItemIndex: {
              type: Number,
              value: 0
            },

            /** @private */
            _focusedColumnOrder: Number,

            /**
             * Indicates whether the grid is currently in interaction mode.
             * In interaction mode the user is currently interacting with a control,
             * such as an input or a select, within a cell.
             * In interaction mode keyboard navigation between cells is disabled.
             * Interaction mode also prevents the focus target cell of that section of
             * the grid from receiving focus, allowing the user to switch focus to
             * controls in adjacent cells, rather than focussing the outer cell
             * itself.
             * @type {boolean}
             * @private
             */
            interacting: {
              type: Boolean,
              value: false,
              reflectToAttribute: true,
              readOnly: true,
              observer: '_interactingChanged'
            }
          };
        }
      }]);
      return KeyboardNavigationMixin;
    }(superClass);
  };

  _exports.KeyboardNavigationMixin = KeyboardNavigationMixin;
});