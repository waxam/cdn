define(["exports"], function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.KeyboardNavigationMixin = void 0;

  /**
  @license
  Copyright (c) 2017 Vaadin Ltd.
  This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
  */

  /**
   * @polymerMixin
   */
  var KeyboardNavigationMixin = function KeyboardNavigationMixin(superClass) {
    return (
      /*#__PURE__*/
      function (_superClass) {
        babelHelpers.inherits(KeyboardNavigationMixin, _superClass);

        function KeyboardNavigationMixin() {
          babelHelpers.classCallCheck(this, KeyboardNavigationMixin);
          return babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(KeyboardNavigationMixin).apply(this, arguments));
        }

        babelHelpers.createClass(KeyboardNavigationMixin, [{
          key: "ready",
          value: function ready() {
            var _this = this;

            babelHelpers.get(babelHelpers.getPrototypeOf(KeyboardNavigationMixin.prototype), "ready", this).call(this);

            if (this._ios || this._android) {
              // Disable keyboard navigation on mobile devices
              return;
            }

            this.addEventListener('keydown', this._onKeyDown);
            this.addEventListener('focusin', this._onFocusIn);
            this.addEventListener('focusout', this._onFocusOut); // When focus goes from cell to another cell, focusin/focusout events do
            // not escape the grid’s shadowRoot, thus listening inside the shadowRoot.

            this.$.table.addEventListener('focusin', this._onCellFocusIn.bind(this));
            this.$.table.addEventListener('focusout', this._onCellFocusOut.bind(this));
            this.addEventListener('mousedown', function () {
              _this._toggleAttribute('navigating', false, _this);

              _this._isMousedown = true;
            });
            this.addEventListener('mouseup', function () {
              return _this._isMousedown = false;
            });
          }
        }, {
          key: "_focusableChanged",
          value: function _focusableChanged(focusable, oldFocusable) {
            if (oldFocusable) {
              oldFocusable.setAttribute('tabindex', '-1');
            }

            if (focusable) {
              focusable.setAttribute('tabindex', '0');
            }
          }
        }, {
          key: "_onKeyDown",
          value: function _onKeyDown(e) {
            // Ensure standard key value, unified across browsers
            var key = e.key;

            if (key === 'Up' || key === 'Down' || key === 'Left' || key === 'Right') {
              // MSIE & Edge
              key = 'Arrow' + key;
            }

            if (key === 'Esc') {
              // MSIE & Edge
              key = 'Escape';
            }

            if (key === 'Spacebar') {
              // MSIE
              key = ' ';
            }

            var keyGroup;

            switch (key) {
              case 'ArrowUp':
              case 'ArrowDown':
              case 'ArrowLeft':
              case 'ArrowRight':
              case 'PageUp':
              case 'PageDown':
              case 'Home':
              case 'End':
                keyGroup = 'Navigation';
                break;

              case 'Enter':
              case 'Escape':
              case 'F2':
                keyGroup = 'Interaction';
                break;

              case 'Tab':
                keyGroup = 'Tab';
                break;

              case ' ':
                keyGroup = 'Space';
                break;
            }

            this._detectInteracting(e);

            if (this.hasAttribute('interacting') && keyGroup !== 'Interaction') {
              // When in the interacting mode, only the “Interaction” keys are handled.
              keyGroup = undefined;
            }

            if (keyGroup) {
              this["_on".concat(keyGroup, "KeyDown")](e, key);
            }
          }
        }, {
          key: "_ensureScrolledToIndex",
          value: function _ensureScrolledToIndex(index) {
            var targetRowInDom = Array.from(this.$.items.children).filter(function (child) {
              return child.index === index;
            })[0];

            if (!targetRowInDom) {
              this._scrollToIndex(index);
            }
          }
        }, {
          key: "_onNavigationKeyDown",
          value: function _onNavigationKeyDown(e, key) {
            var _this2 = this;

            e.preventDefault();

            function indexOfChildElement(el) {
              return Array.prototype.indexOf.call(el.parentNode.children, el);
            }

            var visibleItemsCount = this._lastVisibleIndex - this._firstVisibleIndex - 1;
            var dx = 0,
                dy = 0;

            switch (key) {
              case 'ArrowRight':
                dx = 1;
                break;

              case 'ArrowLeft':
                dx = -1;
                break;

              case 'Home':
                dx = -Infinity;
                e.ctrlKey && (dy = -Infinity);
                break;

              case 'End':
                dx = Infinity;
                e.ctrlKey && (dy = Infinity);
                break;

              case 'ArrowDown':
                dy = 1;
                break;

              case 'ArrowUp':
                dy = -1;
                break;

              case 'PageDown':
                dy = visibleItemsCount;
                break;

              case 'PageUp':
                dy = -visibleItemsCount;
                break;
            }

            var activeCell = e.composedPath()[0];
            var columnIndex = indexOfChildElement(activeCell);

            var isRowDetails = this._elementMatches(activeCell, '[part~="details-cell"]');

            var activeRow = activeCell.parentNode;
            var activeRowGroup = activeRow.parentNode;
            var maxRowIndex = (activeRowGroup === this.$.items ? this._effectiveSize : activeRowGroup.children.length) - 1; // Body rows have index property, otherwise DOM child index of the row is used.

            var rowIndex = activeRowGroup === this.$.items ? this._focusedItemIndex !== undefined ? this._focusedItemIndex : activeRow.index : indexOfChildElement(activeRow); // Index of the destination row

            var dstRowIndex = Math.max(0, Math.min(rowIndex + dy, maxRowIndex)); // Row details navigation logic

            var dstIsRowDetails = false;

            if (activeRowGroup === this.$.items) {
              var item = activeRow._item;

              var dstItem = this._cache.getItemForIndex(dstRowIndex); // Should we navigate to row details?


              if (isRowDetails) {
                dstIsRowDetails = dy === 0;
              } else {
                dstIsRowDetails = dy === 1 && this._isDetailsOpened(item) || dy === -1 && dstRowIndex !== rowIndex && this._isDetailsOpened(dstItem);
              } // Should we navigate between details and regular cells of the same row?


              if (dstIsRowDetails !== isRowDetails && (dy === 1 && dstIsRowDetails || dy === -1 && !dstIsRowDetails)) {
                dstRowIndex = rowIndex;
              }
            } // Header and footer could have hidden rows, e. g., if none of the columns
            // or groups on the given column tree level define template. Skip them
            // in vertical keyboard navigation.


            if (activeRowGroup !== this.$.items) {
              if (dstRowIndex > rowIndex) {
                while (dstRowIndex < maxRowIndex && activeRowGroup.children[dstRowIndex].hidden) {
                  dstRowIndex++;
                }
              } else if (dstRowIndex < rowIndex) {
                while (dstRowIndex > 0 && activeRowGroup.children[dstRowIndex].hidden) {
                  dstRowIndex--;
                }
              }
            } // _focusedColumnOrder is memoized — this is to ensure predictable
            // navigation when entering and leaving detail and column group cells.


            if (this._focusedColumnOrder === undefined) {
              if (isRowDetails) {
                this._focusedColumnOrder = 0;
              } else {
                this._focusedColumnOrder = this._getColumns(activeRowGroup, rowIndex)[columnIndex]._order;
              }
            } // Find orderedColumnIndex — the index of order closest matching the
            // original _focusedColumnOrder in the sorted array of orders
            // of the visible columns on the destination row.


            var dstColumns = this._getColumns(activeRowGroup, dstRowIndex);

            var dstSortedColumnOrders = dstColumns.filter(function (c) {
              return !c.hidden;
            }).map(function (c) {
              return c._order;
            }).sort(function (b, a) {
              return b - a;
            });
            var maxOrderedColumnIndex = dstSortedColumnOrders.length - 1;
            var orderedColumnIndex = dstSortedColumnOrders.indexOf(dstSortedColumnOrders.slice(0).sort(function (b, a) {
              return Math.abs(b - _this2._focusedColumnOrder) - Math.abs(a - _this2._focusedColumnOrder);
            })[0]); // Index of the destination column order

            var dstOrderedColumnIndex = dy === 0 && isRowDetails ? orderedColumnIndex : Math.max(0, Math.min(orderedColumnIndex + dx, maxOrderedColumnIndex));

            if (dstOrderedColumnIndex !== orderedColumnIndex) {
              // Horizontal movement invalidates stored _focusedColumnOrder
              this._focusedColumnOrder = undefined;
            } // Ensure correct vertical scroll position, destination row is visible


            if (activeRowGroup === this.$.items) {
              this._ensureScrolledToIndex(dstRowIndex);
            } // This has to be set after scrolling, otherwise it can be removed by
            // `_preventScrollerRotatingCellFocus(item, index)` during scrolling.


            this._toggleAttribute('navigating', true, this);

            var columnIndexByOrder = dstColumns.reduce(function (acc, col, i) {
              return acc[col._order] = i, acc;
            }, {});
            var dstColumnIndex = columnIndexByOrder[dstSortedColumnOrders[dstOrderedColumnIndex]]; // For body rows, use index property to find destination row, otherwise use DOM child index

            var dstRow = activeRowGroup === this.$.items ? Array.from(activeRowGroup.children).filter(function (el) {
              return el.index === dstRowIndex;
            })[0] : activeRowGroup.children[dstRowIndex];

            if (!dstRow) {
              return;
            } // Here we go!


            var dstCell = dstIsRowDetails ? Array.from(dstRow.children).filter(function (el) {
              return _this2._elementMatches(el, '[part~="details-cell"]');
            })[0] : dstRow.children[dstColumnIndex];

            this._scrollHorizontallyToCell(dstCell);

            if (activeRowGroup === this.$.items) {
              // When scrolling with repeated keydown, sometimes FocusEvent listeners
              // are too late to update _focusedItemIndex. Ensure next keydown
              // listener invocation gets updated _focusedItemIndex value.
              this._focusedItemIndex = dstRowIndex;
            }

            if (activeRowGroup === this.$.items) {
              var dstRect = dstCell.getBoundingClientRect();
              var footerTop = this.$.footer.getBoundingClientRect().top;
              var headerBottom = this.$.header.getBoundingClientRect().bottom;

              if (dstRect.bottom > footerTop) {
                this.$.table.scrollTop += dstRect.bottom - footerTop;

                this._scrollHandler();
              } else if (dstRect.top < headerBottom) {
                this.$.table.scrollTop -= headerBottom - dstRect.top;

                this._scrollHandler();
              }
            }

            dstCell.focus();
          }
        }, {
          key: "_parseEventPath",
          value: function _parseEventPath(path) {
            var tableIndex = path.indexOf(this.$.table);
            return {
              rowGroup: path[tableIndex - 1],
              row: path[tableIndex - 2],
              cell: path[tableIndex - 3]
            };
          }
        }, {
          key: "_onInteractionKeyDown",
          value: function _onInteractionKeyDown(e, key) {
            var localTarget = e.composedPath()[0];
            var localTargetIsTextInput = localTarget.localName === 'input' && !/^(button|checkbox|color|file|image|radio|range|reset|submit)$/i.test(localTarget.type);
            var wantInteracting;

            switch (key) {
              case 'Enter':
                wantInteracting = this.hasAttribute('interacting') ? !localTargetIsTextInput : true;
                break;

              case 'Escape':
                wantInteracting = false;
                break;

              case 'F2':
                wantInteracting = !this.hasAttribute('interacting');
                break;
            }

            var _this$_parseEventPath = this._parseEventPath(e.composedPath()),
                cell = _this$_parseEventPath.cell;

            if (this.hasAttribute('interacting') !== wantInteracting) {
              if (wantInteracting) {
                var focusTarget = cell._content.querySelector('[focus-target]') || cell._content.firstElementChild;

                if (focusTarget) {
                  e.preventDefault();
                  focusTarget.focus();

                  this._toggleAttribute('interacting', true, this);

                  this._toggleAttribute('navigating', false, this);
                }
              } else {
                e.preventDefault();
                this._focusedColumnOrder = undefined;
                cell.focus();

                this._toggleAttribute('interacting', false, this);

                this._toggleAttribute('navigating', true, this);
              }
            }
          }
        }, {
          key: "_predictFocusStepTarget",
          value: function _predictFocusStepTarget(srcElement, step) {
            var tabOrder = [this.$.table, this._headerFocusable, this._itemsFocusable, this._footerFocusable, this.$.focusexit];
            var index = tabOrder.indexOf(srcElement);
            index += step;

            while (index >= 0 && index <= tabOrder.length - 1 && (!tabOrder[index] || tabOrder[index].parentNode.hidden)) {
              index += step;
            }

            return tabOrder[index];
          }
        }, {
          key: "_onTabKeyDown",
          value: function _onTabKeyDown(e) {
            var _this3 = this;

            var focusTarget = this._predictFocusStepTarget(e.composedPath()[0], e.shiftKey ? -1 : 1);

            if (focusTarget === this.$.table) {
              // The focus is about to exit the grid to the top.
              this.$.table.focus();
            } else if (focusTarget === this.$.focusexit) {
              // The focus is about to exit the grid to the bottom.
              this.$.focusexit.focus();
            } else if (focusTarget === this._itemsFocusable) {
              var itemsFocusTarget = focusTarget;
              var targetRow = this._itemsFocusable.parentNode;

              this._ensureScrolledToIndex(this._focusedItemIndex);

              if (targetRow.index !== this._focusedItemIndex) {
                // The target row, which is about to be focused next, has been
                // assigned with a new index since last focus, probably because of
                // scrolling. Focus the row for the stored focused item index instead.
                var columnIndex = Array.from(targetRow.children).indexOf(this._itemsFocusable);
                var focusedItemRow = Array.from(this.$.items.children).filter(function (row) {
                  return row.index === _this3._focusedItemIndex;
                })[0];

                if (focusedItemRow) {
                  itemsFocusTarget = focusedItemRow.children[columnIndex];
                }
              }

              e.preventDefault();
              itemsFocusTarget.focus();
            } else {
              e.preventDefault();
              focusTarget.focus();
            }

            this._toggleAttribute('navigating', true, this);
          }
        }, {
          key: "_onSpaceKeyDown",
          value: function _onSpaceKeyDown(e) {
            e.preventDefault();
            var cell = e.composedPath()[0];

            if (cell._content && cell._content.firstElementChild) {
              var wasNavigating = this.hasAttribute('navigating');

              cell._content.firstElementChild.click();

              this._toggleAttribute('navigating', wasNavigating, this);
            } else {
              this.dispatchEvent(new CustomEvent('cell-activate', {
                detail: {
                  model: this.__getRowModel(cell.parentElement)
                }
              }));
            }
          }
        }, {
          key: "_onFocusIn",
          value: function _onFocusIn(e) {
            if (!this._isMousedown) {
              this._toggleAttribute('navigating', true, this);
            }

            var rootTarget = e.composedPath()[0];

            if (rootTarget === this.$.table || rootTarget === this.$.focusexit) {
              // The focus enters the top (bottom) of the grid, meaning that user has
              // tabbed (shift-tabbed) into the grid. Move the focus to
              // the first (the last) focusable.
              this._predictFocusStepTarget(rootTarget, rootTarget === this.$.table ? 1 : -1).focus();

              this._toggleAttribute('interacting', false, this);
            } else {
              this._detectInteracting(e);
            }
          }
        }, {
          key: "_onFocusOut",
          value: function _onFocusOut(e) {
            this._toggleAttribute('navigating', false, this);

            this._detectInteracting(e);
          }
        }, {
          key: "_onCellFocusIn",
          value: function _onCellFocusIn(e) {
            this._detectInteracting(e);

            if (e.composedPath().indexOf(this.$.table) === 3) {
              var cell = e.composedPath()[0];
              this._activeRowGroup = cell.parentNode.parentNode;

              if (this._activeRowGroup === this.$.header) {
                this._headerFocusable = cell;
              } else if (this._activeRowGroup === this.$.items) {
                this._itemsFocusable = cell;
              } else if (this._activeRowGroup === this.$.footer) {
                this._footerFocusable = cell;
              } // Inform cell content of the focus (used in <vaadin-grid-sorter>)


              cell._content.dispatchEvent(new CustomEvent('cell-focusin', {
                bubbles: false
              }));
            }

            this._detectFocusedItemIndex(e);
          }
        }, {
          key: "_onCellFocusOut",
          value: function _onCellFocusOut(e) {
            if (e.composedPath().indexOf(this.$.table) === 3) {
              var cell = e.composedPath()[0]; // Inform cell content of the focus (used in <vaadin-grid-sorter>)

              cell._content.dispatchEvent(new CustomEvent('cell-focusout', {
                bubbles: false
              }));
            }
          }
        }, {
          key: "_detectInteracting",
          value: function _detectInteracting(e) {
            this._toggleAttribute('interacting', e.composedPath().some(function (el) {
              return el.localName === 'vaadin-grid-cell-content';
            }), this);
          }
        }, {
          key: "_detectFocusedItemIndex",
          value: function _detectFocusedItemIndex(e) {
            var _this$_parseEventPath2 = this._parseEventPath(e.composedPath()),
                rowGroup = _this$_parseEventPath2.rowGroup,
                row = _this$_parseEventPath2.row;

            if (rowGroup === this.$.items) {
              this._focusedItemIndex = row.index;
            }
          }
        }, {
          key: "_preventScrollerRotatingCellFocus",
          value: function _preventScrollerRotatingCellFocus(item, index) {
            if (item.index === this._focusedItemIndex && this.hasAttribute('navigating') && this._activeRowGroup === this.$.items) {
              // Focused item has went, hide navigation mode
              this._navigatingIsHidden = true;

              this._toggleAttribute('navigating', false, this);
            }

            if (index === this._focusedItemIndex && this._navigatingIsHidden) {
              // Focused item is back, restore navigation mode
              this._navigatingIsHidden = false;

              this._toggleAttribute('navigating', true, this);
            }
          }
        }, {
          key: "_getColumns",
          value: function _getColumns(rowGroup, rowIndex) {
            var columnTreeLevel = this._columnTree.length - 1;

            if (rowGroup === this.$.header) {
              columnTreeLevel = rowIndex;
            } else if (rowGroup === this.$.footer) {
              columnTreeLevel = this._columnTree.length - 1 - rowIndex;
            }

            return this._columnTree[columnTreeLevel];
          }
        }, {
          key: "_resetKeyboardNavigation",
          value: function _resetKeyboardNavigation() {
            var _this4 = this;

            if (this.$.header.firstElementChild) {
              this._headerFocusable = Array.from(this.$.header.firstElementChild.children).filter(function (el) {
                return !el.hidden;
              })[0];
            }

            if (this.$.items.firstElementChild) {
              var firstVisibleIndexRow = this._iterateItems(function (pidx, vidx) {
                if (_this4._firstVisibleIndex === vidx) {
                  return _this4.$.items.children[pidx];
                }
              });

              if (firstVisibleIndexRow) {
                this._itemsFocusable = Array.from(firstVisibleIndexRow.children).filter(function (el) {
                  return !el.hidden;
                })[0];
              }
            }

            if (this.$.footer.firstElementChild) {
              this._footerFocusable = Array.from(this.$.footer.firstElementChild.children).filter(function (el) {
                return !el.hidden;
              })[0];
            }
          }
        }, {
          key: "_scrollHorizontallyToCell",
          value: function _scrollHorizontallyToCell(dstCell) {
            if (dstCell.hasAttribute('frozen') || this._elementMatches(dstCell, '[part~="details-cell"]')) {
              // These cells are, by design, always visible, no need to scroll.
              return;
            }

            var dstCellRect = dstCell.getBoundingClientRect();
            var dstRow = dstCell.parentNode;
            var dstCellIndex = Array.from(dstRow.children).indexOf(dstCell);
            var tableRect = this.$.table.getBoundingClientRect();
            var leftBoundary = tableRect.left,
                rightBoundary = tableRect.right;

            for (var i = dstCellIndex - 1; i >= 0; i--) {
              var cell = dstRow.children[i];

              if (cell.hasAttribute('hidden') || this._elementMatches(cell, '[part~="details-cell"]')) {
                continue;
              }

              if (cell.hasAttribute('frozen')) {
                leftBoundary = cell.getBoundingClientRect().right;
                break;
              }
            }

            for (var _i = dstCellIndex + 1; _i < dstRow.children.length; _i++) {
              var _cell = dstRow.children[_i];

              if (_cell.hasAttribute('hidden') || this._elementMatches(_cell, '[part~="details-cell"]')) {
                continue;
              }

              if (_cell.hasAttribute('frozen')) {
                rightBoundary = _cell.getBoundingClientRect().left;
                break;
              }
            }

            if (dstCellRect.left < leftBoundary) {
              this.$.table.scrollLeft += Math.round(dstCellRect.left - leftBoundary);
            }

            if (dstCellRect.right > rightBoundary) {
              this.$.table.scrollLeft += Math.round(dstCellRect.right - rightBoundary);
            }
          }
        }, {
          key: "_elementMatches",
          value: function _elementMatches(el, query) {
            return el.matches ? el.matches(query) : Array.from(el.parentNode.querySelectorAll(query)).indexOf(el) !== -1;
          }
        }], [{
          key: "properties",
          get: function get() {
            return {
              _headerFocusable: {
                type: Object,
                observer: '_focusableChanged'
              },
              _itemsFocusable: {
                type: Object,
                observer: '_focusableChanged'
              },
              _footerFocusable: {
                type: Object,
                observer: '_focusableChanged'
              },
              _navigatingIsHidden: Boolean,
              _focusedItemIndex: {
                type: Number,
                value: 0
              },
              _focusedColumnOrder: Number
            };
          }
        }]);
        return KeyboardNavigationMixin;
      }(superClass)
    );
  };

  _exports.KeyboardNavigationMixin = KeyboardNavigationMixin;
});