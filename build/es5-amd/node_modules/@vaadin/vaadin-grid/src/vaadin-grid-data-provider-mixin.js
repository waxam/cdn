define(["exports", "../../../@polymer/polymer/lib/utils/debounce.js", "../../../@polymer/polymer/lib/utils/async.js"], function (_exports, _debounce, _async) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.DataProviderMixin = _exports.ItemCache = void 0;

  /**
  @license
  Copyright (c) 2017 Vaadin Ltd.
  This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
  */
  var ItemCache =
  /*#__PURE__*/
  function () {
    function ItemCache(grid, parentCache, parentItem) {
      babelHelpers.classCallCheck(this, ItemCache);
      this.grid = grid;
      this.parentCache = parentCache;
      this.parentItem = parentItem;
      this.itemCaches = {};
      this.items = {};
      this.effectiveSize = 0;
      this.size = 0;
      this.pendingRequests = {};
    }

    babelHelpers.createClass(ItemCache, [{
      key: "isLoading",
      value: function isLoading() {
        var _this = this;

        return Object.keys(this.pendingRequests).length || Object.keys(this.itemCaches).filter(function (index) {
          return _this.itemCaches[index].isLoading();
        })[0];
      }
    }, {
      key: "getItemForIndex",
      value: function getItemForIndex(index) {
        var _this$getCacheAndInde = this.getCacheAndIndex(index),
            cache = _this$getCacheAndInde.cache,
            scaledIndex = _this$getCacheAndInde.scaledIndex;

        return cache.items[scaledIndex];
      }
    }, {
      key: "updateSize",
      value: function updateSize() {
        var _this2 = this;

        this.effectiveSize = !this.parentItem || this.grid._isExpanded(this.parentItem) ? this.size + Object.keys(this.itemCaches).reduce(function (prev, curr) {
          var subCache = _this2.itemCaches[curr];
          subCache.updateSize();
          return prev + subCache.effectiveSize;
        }, 0) : 0;
      }
    }, {
      key: "ensureSubCacheForScaledIndex",
      value: function ensureSubCacheForScaledIndex(scaledIndex) {
        if (!this.itemCaches[scaledIndex]) {
          var subCache = new ItemCache(this.grid, this, this.items[scaledIndex]);
          this.itemCaches[scaledIndex] = subCache;

          this.grid._loadPage(0, subCache);
        }
      }
    }, {
      key: "getCacheAndIndex",
      value: function getCacheAndIndex(index) {
        var thisLevelIndex = index;
        var keys = Object.keys(this.itemCaches);

        for (var i = 0; i < keys.length; i++) {
          var expandedIndex = Number(keys[i]);
          var subCache = this.itemCaches[expandedIndex];

          if (thisLevelIndex <= expandedIndex) {
            return {
              cache: this,
              scaledIndex: thisLevelIndex
            };
          } else if (thisLevelIndex <= expandedIndex + subCache.effectiveSize) {
            return subCache.getCacheAndIndex(thisLevelIndex - expandedIndex - 1);
          }

          thisLevelIndex -= subCache.effectiveSize;
        }

        return {
          cache: this,
          scaledIndex: thisLevelIndex
        };
      }
    }]);
    return ItemCache;
  }();
  /**
   * @polymerMixin
   */


  _exports.ItemCache = ItemCache;

  var DataProviderMixin = function DataProviderMixin(superClass) {
    return (
      /*#__PURE__*/
      function (_superClass) {
        babelHelpers.inherits(DataProviderMixin, _superClass);

        function DataProviderMixin() {
          babelHelpers.classCallCheck(this, DataProviderMixin);
          return babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(DataProviderMixin).apply(this, arguments));
        }

        babelHelpers.createClass(DataProviderMixin, [{
          key: "_sizeChanged",
          value: function _sizeChanged(size) {
            var delta = size - this._cache.size;
            this._cache.size += delta;
            this._cache.effectiveSize += delta;
            this._effectiveSize = this._cache.effectiveSize;
          }
        }, {
          key: "_updateRowItem",
          value: function _updateRowItem(item, el) {
            el.children.forEach(function (cell) {
              cell._instance && (cell._instance.item = item);
            });
          }
        }, {
          key: "_getItem",
          value: function _getItem(index, el) {
            if (index >= this._effectiveSize) {
              return;
            }

            el.index = index;

            var _this$_cache$getCache = this._cache.getCacheAndIndex(index),
                cache = _this$_cache$getCache.cache,
                scaledIndex = _this$_cache$getCache.scaledIndex;

            var item = cache.items[scaledIndex];

            if (item) {
              this._toggleAttribute('loading', false, el);

              this._updateItem(el, item);

              if (this._isExpanded(item)) {
                cache.ensureSubCacheForScaledIndex(scaledIndex);
              }
            } else {
              this._toggleAttribute('loading', true, el);

              this._loadPage(this._getPageForIndex(scaledIndex), cache);
            }
          }
        }, {
          key: "_pagesForPhysicalItems",
          value: function _pagesForPhysicalItems() {
            var _this3 = this;

            // TODO: potentially heavy operation to run first visible index,
            // reconsider if performance issues occur on data binding / scrolling.
            // TODO: _vidxOffset shouldn't be read from here.
            var firstVisiblePage = this._getPageForIndex(this._firstVisibleIndex + this._vidxOffset);

            return [firstVisiblePage].concat(this._physicalItems.filter(function (row) {
              return row.index;
            }).items(function (row) {
              return _this3._getPageForIndex(row.index);
            })).reduce(function (prev, curr) {
              if (prev.indexOf(curr) === -1) {
                prev.push(curr);
              }

              return prev;
            }, []);
          }
        }, {
          key: "_expandedInstanceChangedCallback",
          value: function _expandedInstanceChangedCallback(inst, value) {
            if (inst.item === undefined) {
              return;
            }

            if (value) {
              this.expandItem(inst.item);
            } else {
              this.collapseItem(inst.item);
            }
          }
          /**
           * Returns a value that identifies the item. Uses `itemIdPath` if available.
           * Can be customized by overriding.
           */

        }, {
          key: "getItemId",
          value: function getItemId(item) {
            return this.itemIdPath ? this.get(this.itemIdPath, item) : item;
          }
        }, {
          key: "_isExpanded",
          value: function _isExpanded(item) {
            return this.expandedItems && this._getItemIndexInArray(item, this.expandedItems) > -1;
          }
        }, {
          key: "_expandedItemsChanged",
          value: function _expandedItemsChanged(e) {
            this._cache.updateSize();

            this._effectiveSize = this._cache.effectiveSize;

            this._assignModels();
          }
          /**
           * Expands the given item tree.
           */

        }, {
          key: "expandItem",
          value: function expandItem(item) {
            if (!this._isExpanded(item)) {
              this.push('expandedItems', item);
            }
          }
          /**
           * Collapses the given item tree.
           */

        }, {
          key: "collapseItem",
          value: function collapseItem(item) {
            if (this._isExpanded(item)) {
              this.splice('expandedItems', this._getItemIndexInArray(item, this.expandedItems), 1);
            }
          }
        }, {
          key: "_getIndexLevel",
          value: function _getIndexLevel(index) {
            var _this$_cache$getCache2 = this._cache.getCacheAndIndex(index),
                cache = _this$_cache$getCache2.cache;

            var level = 0;

            while (cache.parentCache) {
              cache = cache.parentCache;
              level++;
            }

            return level;
          }
        }, {
          key: "_canPopulate",
          value: function _canPopulate() {
            return this._hasData && this._columnTree;
          }
        }, {
          key: "_loadPage",
          value: function _loadPage(page, cache) {
            var _this4 = this;

            // make sure same page isn't requested multiple times.
            if (!cache.pendingRequests[page] && this.dataProvider) {
              this._setLoading(true);

              cache.pendingRequests[page] = true;
              var params = {
                page: page,
                pageSize: this.pageSize,
                sortOrders: this._mapSorters(),
                filters: this._mapFilters(),
                parentItem: cache.parentItem
              };
              this.dataProvider(params, function (items, size) {
                if (size !== undefined) {
                  cache.size = size;
                } else {
                  if (params.parentItem) {
                    cache.size = items.length;
                  }
                } // Populate the cache with new items


                items.forEach(function (item, itemsIndex) {
                  var itemIndex = page * _this4.pageSize + itemsIndex;
                  cache.items[itemIndex] = item;

                  if (_this4._isExpanded(item)) {
                    // Force synchronous data request for expanded item sub-cache
                    cache.ensureSubCacheForScaledIndex(itemIndex);
                  }
                });
                _this4._hasData = true;
                delete cache.pendingRequests[page];

                if (!_this4._cache.isLoading()) {
                  // All active requests have finished, update the effective size and rows
                  _this4._setLoading(false);

                  _this4._cache.updateSize();

                  _this4._effectiveSize = _this4._cache.effectiveSize;
                  Array.from(_this4.$.items.children).filter(function (row) {
                    return !row.hidden;
                  }).forEach(function (row) {
                    var cachedItem = _this4._cache.getItemForIndex(row.index);

                    if (cachedItem) {
                      _this4._toggleAttribute('loading', false, row);

                      _this4._updateItem(row, cachedItem);
                    }
                  });

                  _this4._increasePoolIfNeeded(0);
                }

                _this4.__itemsReceived();
              });
            }
          }
        }, {
          key: "_getPageForIndex",
          value: function _getPageForIndex(index) {
            return Math.floor(index / this.pageSize);
          }
          /**
           * Clears the cached pages and reloads data from dataprovider when needed.
           */

        }, {
          key: "clearCache",
          value: function clearCache() {
            this._cache = new ItemCache(this);
            Array.from(this.$.items.children).forEach(function (row) {
              Array.from(row.children).forEach(function (cell) {
                // Force data system to pick up subproperty changes
                cell._instance && cell._instance._setPendingProperty('item', {}, false);
              });
            });
            this._cache.size = this.size || 0;

            this._cache.updateSize();

            this._hasData = false;

            this._assignModels();

            if (!this._effectiveSize) {
              this._loadPage(0, this._cache);
            }
          }
        }, {
          key: "_flushItemsDebouncer",
          value: function _flushItemsDebouncer() {
            if (this._debouncerLoad) {
              this._debouncerLoad.flush();
            }
          }
        }, {
          key: "_pageSizeChanged",
          value: function _pageSizeChanged(pageSize, oldPageSize) {
            if (oldPageSize !== undefined && pageSize !== oldPageSize) {
              this.clearCache();
            }
          }
        }, {
          key: "_checkSize",
          value: function _checkSize() {
            if (this.size === undefined && this._effectiveSize === 0) {
              console.warn('The <vaadin-grid> needs the total number of items' + ' in order to display rows. Set the total number of items' + ' to the `size` property, or provide the total number of items' + ' in the second argument of the `dataProvider`’s `callback` call.');
            }
          }
        }, {
          key: "_dataProviderChanged",
          value: function _dataProviderChanged(dataProvider, oldDataProvider) {
            if (oldDataProvider !== undefined) {
              this.clearCache();
            }

            if (dataProvider && this.items && this.items.length) {
              // Fixes possibly invalid cached lastVisibleIndex value in <iron-list>
              this._scrollToIndex(this._firstVisibleIndex);
            }

            this._ensureFirstPageLoaded();

            this._debouncerCheckSize = _debounce.Debouncer.debounce(this._debouncerCheckSize, _async.timeOut.after(2000), this._checkSize.bind(this));

            this._scrollHandler();
          }
        }, {
          key: "_ensureFirstPageLoaded",
          value: function _ensureFirstPageLoaded() {
            var _this5 = this;

            if (!this._hasData) {
              // load data before adding rows to make sure they have content when
              // rendered for the first time.
              this._loadPage(0, this._cache, function () {
                var hadData = _this5._hasData;
                _this5._hasData = true;

                if (!hadData) {
                  _this5.notifyResize();
                }
              });
            }
          }
        }, {
          key: "_itemsEqual",
          value: function _itemsEqual(item1, item2) {
            return this.getItemId(item1) === this.getItemId(item2);
          }
        }, {
          key: "_getItemIndexInArray",
          value: function _getItemIndexInArray(item, array) {
            var _this6 = this;

            var result = -1;
            array.forEach(function (i, idx) {
              if (_this6._itemsEqual(i, item)) {
                result = idx;
              }
            });
            return result;
          }
        }], [{
          key: "properties",
          get: function get() {
            return {
              /**
               * Number of items fetched at a time from the dataprovider.
               */
              pageSize: {
                type: Number,
                value: 50,
                observer: '_pageSizeChanged'
              },

              /**
               * Function that provides items lazily. Receives arguments `params`, `callback`
               *
               * `params.page` Requested page index
               *
               * `params.pageSize` Current page size
               *
               * `params.filters` Currently applied filters
               *
               * `params.sortOrders` Currently applied sorting orders
               *
               * `params.parentItem` When tree is used, and sublevel items
               * are requested, reference to parent item of the requested sublevel.
               * Otherwise `undefined`.
               *
               * `callback(items, size)` Callback function with arguments:
               *   - `items` Current page of items
               *   - `size` Total number of items. When tree sublevel items
               *     are requested, total number of items in the requested sublevel.
               *     Optional when tree is not used, required for tree.
               */
              dataProvider: {
                type: Object,
                notify: true,
                observer: '_dataProviderChanged'
              },

              /**
               * `true` while data is being requested from the data provider.
               */
              loading: {
                type: Boolean,
                notify: true,
                readOnly: true,
                reflectToAttribute: true
              },
              _cache: {
                type: Object,
                value: function value() {
                  var cache = new ItemCache(this);
                  return cache;
                }
              },

              /**
               * Path to an item sub-property that identifies the item.
               */
              itemIdPath: {
                type: String,
                value: null
              },

              /**
               * An array that contains the expanded items.
               */
              expandedItems: {
                type: Object,
                notify: true,
                value: function value() {
                  return [];
                }
              }
            };
          }
        }, {
          key: "observers",
          get: function get() {
            return ['_sizeChanged(size)', '_expandedItemsChanged(expandedItems.*)'];
          }
        }]);
        return DataProviderMixin;
      }(superClass)
    );
  };

  _exports.DataProviderMixin = DataProviderMixin;
});