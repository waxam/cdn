define(["exports", "../../../@polymer/polymer/polymer-legacy.js", "../../../@polymer/polymer/lib/utils/async.js", "../../../@polymer/polymer/lib/utils/flattened-nodes-observer.js", "./vaadin-grid-column.js", "../../../@polymer/polymer/polymer-element.js"], function (_exports, _polymerLegacy, _async, _flattenedNodesObserver, _vaadinGridColumn, _polymerElement) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.GridColumnGroupElement = void 0;

  /**
  @license
  Copyright (c) 2017 Vaadin Ltd.
  This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
  */

  /**
   * A `<vaadin-grid-column-group>` is used to make groups of columns in `<vaadin-grid>` and
   * to configure additional headers and footers.
   *
   * Groups can be nested to create complex header and footer configurations.
   *
   * The `class` attribute is used to differentiate header and footer templates.
   *
   * #### Example:
   * ```html
   * <vaadin-grid-column-group resizable>
   *  <template class="header">Name</template>
   *
   *  <vaadin-grid-column>
   *    <template class="header">First</template>
   *    <template>[[item.name.first]]</template>
   *  </vaadin-grid-column>
   *  <vaadin-grid-column>
   *    <template class="header">Last</template>
   *    <template>[[item.name.last]]</template>
   *  </vaadin-grid-column>
   * </vaadin-grid-column-group>
   * ```
   *
   * @memberof Vaadin
   * @mixes Vaadin.Grid.ColumnBaseMixin
   */
  var GridColumnGroupElement =
  /*#__PURE__*/
  function (_ColumnBaseMixin) {
    babelHelpers.inherits(GridColumnGroupElement, _ColumnBaseMixin);

    function GridColumnGroupElement() {
      babelHelpers.classCallCheck(this, GridColumnGroupElement);
      return babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(GridColumnGroupElement).apply(this, arguments));
    }

    babelHelpers.createClass(GridColumnGroupElement, [{
      key: "connectedCallback",

      /** @protected */
      value: function connectedCallback() {
        babelHelpers.get(babelHelpers.getPrototypeOf(GridColumnGroupElement.prototype), "connectedCallback", this).call(this);

        this._addNodeObserver();

        this._updateFlexAndWidth();
      }
      /** @protected */

    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        babelHelpers.get(babelHelpers.getPrototypeOf(GridColumnGroupElement.prototype), "disconnectedCallback", this).call(this);
        this._observer && this._observer.disconnect();
      }
    }, {
      key: "_columnPropChanged",
      value: function _columnPropChanged(path, value) {
        if (path === 'hidden') {
          this._preventHiddenCascade = true;

          this._updateVisibleChildColumns(this._childColumns);

          this._preventHiddenCascade = false;
        }

        if (/flexGrow|width|hidden|_childColumns/.test(path)) {
          this._updateFlexAndWidth();
        }

        if (path === 'frozen') {
          // Don’t unfreeze the frozen group because of a non-frozen child
          this.frozen = this.frozen || value;
        }

        if (path === 'lastFrozen') {
          // Don’t unfreeze the frozen group because of a non-frozen child
          this._lastFrozen = this._lastFrozen || value;
        }
      }
    }, {
      key: "_groupOrderChanged",
      value: function _groupOrderChanged(order, rootColumns) {
        if (rootColumns) {
          var _rootColumns = rootColumns.slice(0);

          if (!order) {
            _rootColumns.forEach(function (column) {
              return column._order = 0;
            });

            return;
          } // The parent column order number cascades downwards to it's children
          // so that the resulting order numbering constructs as follows:
          // [             1000              ]
          // [     1100    ] | [     1200    ]
          // [1110] | [1120] | [1210] | [1220]
          // Trailing zeros are counted so we know the level on which we're working on.


          var trailingZeros = /(0+)$/.exec(order).pop().length; // In an unlikely situation where a group has more than 9 child columns,
          // the child scope must have 1 digit less...

          var childCountDigits = ~~(Math.log(rootColumns.length) / Math.log(Math.LN10)) + 1; // Final scope for the child columns needs to mind both factors.

          var scope = Math.pow(10, trailingZeros - childCountDigits);

          if (_rootColumns[0] && _rootColumns[0]._order) {
            _rootColumns.sort(function (a, b) {
              return a._order - b._order;
            });
          }

          _rootColumns.forEach(function (column, index) {
            return column._order = order + (index + 1) * scope;
          });
        }
      }
    }, {
      key: "_groupReorderStatusChanged",
      value: function _groupReorderStatusChanged(reorderStatus, rootColumns) {
        if (reorderStatus === undefined || rootColumns === undefined) {
          return;
        }

        rootColumns.forEach(function (column) {
          return column._reorderStatus = reorderStatus;
        });
      }
    }, {
      key: "_groupResizableChanged",
      value: function _groupResizableChanged(resizable, rootColumns) {
        if (resizable === undefined || rootColumns === undefined) {
          return;
        }

        rootColumns.forEach(function (column) {
          return column.resizable = resizable;
        });
      }
    }, {
      key: "_updateVisibleChildColumns",
      value: function _updateVisibleChildColumns(childColumns) {
        this._visibleChildColumns = Array.prototype.filter.call(childColumns, function (col) {
          return !col.hidden;
        });
      }
    }, {
      key: "_childColumnsChanged",
      value: function _childColumnsChanged(childColumns) {
        if (!this._autoHidden && this.hidden) {
          Array.prototype.forEach.call(childColumns, function (column) {
            return column.hidden = true;
          });

          this._updateVisibleChildColumns(childColumns);
        }
      }
    }, {
      key: "_updateFlexAndWidth",
      value: function _updateFlexAndWidth() {
        if (!this._visibleChildColumns) {
          return;
        }

        if (this._visibleChildColumns.length) {
          this._setWidth('calc(' + Array.prototype.reduce.call(this._visibleChildColumns, function (prev, curr) {
            return prev += ' + ' + (curr.width || '0px').replace('calc', '');
          }, '').substring(3) + ')');
        } else {
          this._setWidth('0px');
        }

        this._setFlexGrow(Array.prototype.reduce.call(this._visibleChildColumns, function (prev, curr) {
          return prev + curr.flexGrow;
        }, 0));
      }
    }, {
      key: "_groupFrozenChanged",
      value: function _groupFrozenChanged(frozen, rootColumns) {
        if (rootColumns === undefined || frozen === undefined) {
          return;
        } // Don’t propagate the default `false` value.


        if (frozen !== false) {
          Array.from(rootColumns).forEach(function (col) {
            return col.frozen = frozen;
          });
        }
      }
    }, {
      key: "_groupHiddenChanged",
      value: function _groupHiddenChanged(hidden, rootColumns) {
        if (rootColumns && !this._preventHiddenCascade) {
          this._ignoreVisibleChildColumns = true;
          rootColumns.forEach(function (column) {
            return column.hidden = hidden;
          });
          this._ignoreVisibleChildColumns = false;
        }

        this._columnPropChanged('hidden');
      }
    }, {
      key: "_visibleChildColumnsChanged",
      value: function _visibleChildColumnsChanged(visibleChildColumns) {
        this._colSpan = visibleChildColumns.length;

        if (!this._ignoreVisibleChildColumns) {
          if (visibleChildColumns.length === 0) {
            this._autoHidden = this.hidden = true;
          } else if (this.hidden && this._autoHidden) {
            this._autoHidden = this.hidden = false;
          }
        }
      }
    }, {
      key: "_colSpanChanged",
      value: function _colSpanChanged(colSpan, headerCell, footerCell) {
        if (headerCell) {
          headerCell.setAttribute('colspan', colSpan);
          this._grid && this._grid._a11yUpdateCellColspan(headerCell, colSpan);
        }

        if (footerCell) {
          footerCell.setAttribute('colspan', colSpan);
          this._grid && this._grid._a11yUpdateCellColspan(footerCell, colSpan);
        }
      }
    }, {
      key: "_getChildColumns",
      value: function _getChildColumns(el) {
        return _flattenedNodesObserver.FlattenedNodesObserver.getFlattenedNodes(el).filter(this._isColumnElement);
      }
    }, {
      key: "_addNodeObserver",
      value: function _addNodeObserver() {
        var _this = this;

        this._observer = new _flattenedNodesObserver.FlattenedNodesObserver(this, function (info) {
          if (info.addedNodes.filter(_this._isColumnElement).length > 0 || info.removedNodes.filter(_this._isColumnElement).length > 0) {
            _this._preventHiddenCascade = true;
            _this._rootColumns = _this._getChildColumns(_this);
            _this._childColumns = _this._rootColumns;
            _this._preventHiddenCascade = false; // Update the column tree with microtask timing to avoid shady style scope issues

            _async.microTask.run(function () {
              _this._grid && _this._grid._updateColumnTree && _this._grid._updateColumnTree();
            });
          }
        });

        this._observer.flush();
      }
    }, {
      key: "_isColumnElement",
      value: function _isColumnElement(node) {
        return node.nodeType === Node.ELEMENT_NODE && /\bcolumn\b/.test(node.localName);
      }
    }], [{
      key: "is",
      get: function get() {
        return 'vaadin-grid-column-group';
      }
    }, {
      key: "properties",
      get: function get() {
        return {
          _childColumns: {
            value: function value() {
              return this._getChildColumns(this);
            }
          },

          /**
           * Flex grow ratio for the column group as the sum of the ratios of its child columns.
           */
          flexGrow: {
            type: Number,
            readOnly: true
          },

          /**
           * Width of the column group as the sum of the widths of its child columns.
           */
          width: {
            type: String,
            readOnly: true
          },
          _visibleChildColumns: Array,
          _colSpan: Number,
          _rootColumns: Array
        };
      }
    }, {
      key: "observers",
      get: function get() {
        return ['_updateVisibleChildColumns(_childColumns)', '_childColumnsChanged(_childColumns)', '_groupFrozenChanged(frozen, _rootColumns)', '_groupHiddenChanged(hidden, _rootColumns)', '_visibleChildColumnsChanged(_visibleChildColumns)', '_colSpanChanged(_colSpan, _headerCell, _footerCell)', '_groupOrderChanged(_order, _rootColumns)', '_groupReorderStatusChanged(_reorderStatus, _rootColumns)', '_groupResizableChanged(resizable, _rootColumns)'];
      }
    }]);
    return GridColumnGroupElement;
  }((0, _vaadinGridColumn.ColumnBaseMixin)(_polymerElement.PolymerElement));

  _exports.GridColumnGroupElement = GridColumnGroupElement;
  customElements.define(GridColumnGroupElement.is, GridColumnGroupElement);
});