define(["exports", "../../../@polymer/polymer/lib/mixins/gesture-event-listeners.js", "../../../@polymer/polymer/lib/utils/gestures.js"], function (_exports, _gestureEventListeners, _gestures) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.ColumnResizingMixin = void 0;

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  /**
   * @polymerMixin
   */
  var ColumnResizingMixin = function ColumnResizingMixin(superClass) {
    return /*#__PURE__*/function (_GestureEventListener) {
      babelHelpers.inherits(ColumnResizingMixin, _GestureEventListener);

      var _super = _createSuper(ColumnResizingMixin);

      function ColumnResizingMixin() {
        babelHelpers.classCallCheck(this, ColumnResizingMixin);
        return _super.apply(this, arguments);
      }

      babelHelpers.createClass(ColumnResizingMixin, [{
        key: "ready",
        value: function ready() {
          babelHelpers.get(babelHelpers.getPrototypeOf(ColumnResizingMixin.prototype), "ready", this).call(this);
          var scroller = this.$.scroller;
          (0, _gestures.addListener)(scroller, 'track', this._onHeaderTrack.bind(this)); // Disallow scrolling while resizing

          scroller.addEventListener('touchmove', function (e) {
            return scroller.hasAttribute('column-resizing') && e.preventDefault();
          }); // Disable contextmenu on any resize separator.

          scroller.addEventListener('contextmenu', function (e) {
            return e.target.getAttribute('part') == 'resize-handle' && e.preventDefault();
          }); // Disable native cell focus when resizing

          scroller.addEventListener('mousedown', function (e) {
            return e.target.getAttribute('part') === 'resize-handle' && e.preventDefault();
          });
        }
        /** @private */

      }, {
        key: "_onHeaderTrack",
        value: function _onHeaderTrack(e) {
          var handle = e.target;

          if (handle.getAttribute('part') === 'resize-handle') {
            var cell = handle.parentElement;
            var column = cell._column;

            this._toggleAttribute('column-resizing', true, this.$.scroller); // Get the target column to resize


            while (column.localName === 'vaadin-grid-column-group') {
              column = Array.prototype.slice.call(column._childColumns, 0).sort(function (a, b) {
                return a._order - b._order;
              }).filter(function (column) {
                return !column.hidden;
              }).pop();
            }

            var columnRowCells = Array.from(this.$.header.querySelectorAll('[part~="row"]:last-child [part~="cell"]'));
            var targetCell = columnRowCells.filter(function (cell) {
              return cell._column === column;
            })[0]; // Resize the target column

            if (targetCell.offsetWidth) {
              var style = window.getComputedStyle(targetCell);
              var minWidth = 10 + parseInt(style.paddingLeft) + parseInt(style.paddingRight) + parseInt(style.borderLeftWidth) + parseInt(style.borderRightWidth) + parseInt(style.marginLeft) + parseInt(style.marginRight);
              var maxWidth = targetCell.offsetWidth + (this.__isRTL ? targetCell.getBoundingClientRect().left - e.detail.x : e.detail.x - targetCell.getBoundingClientRect().right);
              column.width = Math.max(minWidth, maxWidth) + 'px';
              column.flexGrow = 0;
            } // Fix width and flex-grow for all preceding columns


            columnRowCells.sort(function (a, b) {
              return a._column._order - b._column._order;
            }).forEach(function (cell, index, array) {
              if (index < array.indexOf(targetCell)) {
                cell._column.width = cell.offsetWidth + 'px';
                cell._column.flexGrow = 0;
              }
            });

            if (e.detail.state === 'end') {
              this._toggleAttribute('column-resizing', false, this.$.scroller);

              this.dispatchEvent(new CustomEvent('column-resize', {
                detail: {
                  resizedColumn: column
                }
              }));
            } // Notify resize


            this._resizeHandler();
          }
        }
        /**
        * Fired when a column in the grid is resized by the user.
        *
        * @event column-resize
        * @param {Object} detail
        * @param {Object} detail.resizedColumn the column that was resized
        */

      }]);
      return ColumnResizingMixin;
    }((0, _gestureEventListeners.GestureEventListeners)(superClass));
  };

  _exports.ColumnResizingMixin = ColumnResizingMixin;
});