define(["exports", "./vaadin-grid-templatizer.js", "../../../@polymer/polymer/lib/utils/flush.js"], function (_exports, _vaadinGridTemplatizer, _flush) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.RowDetailsMixin = void 0;

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  /**
   * @polymerMixin
   */
  var RowDetailsMixin = function RowDetailsMixin(superClass) {
    return /*#__PURE__*/function (_superClass) {
      babelHelpers.inherits(RowDetailsMixin, _superClass);

      var _super = _createSuper(RowDetailsMixin);

      function RowDetailsMixin() {
        babelHelpers.classCallCheck(this, RowDetailsMixin);
        return _super.apply(this, arguments);
      }

      babelHelpers.createClass(RowDetailsMixin, [{
        key: "_rowDetailsTemplateOrRendererChanged",
        value:
        /** @private */
        function _rowDetailsTemplateOrRendererChanged(rowDetailsTemplate, rowDetailsRenderer) {
          var _this = this;

          if (rowDetailsTemplate && rowDetailsRenderer) {
            throw new Error('You should only use either a renderer or a template for row details');
          }

          if (rowDetailsTemplate || rowDetailsRenderer) {
            if (rowDetailsTemplate && !rowDetailsTemplate.templatizer) {
              var templatizer = new _vaadinGridTemplatizer.Templatizer();
              templatizer._grid = this;
              templatizer.dataHost = this.dataHost;
              templatizer.template = rowDetailsTemplate;
              rowDetailsTemplate.templatizer = templatizer;
            }

            if (this._columnTree) {
              // Only update the rows if the column tree has already been initialized
              Array.from(this.$.items.children).forEach(function (row) {
                if (!row.querySelector('[part~=details-cell]')) {
                  _this._updateRow(row, _this._columnTree[_this._columnTree.length - 1]);

                  _this._a11yUpdateRowDetailsOpened(row, false);
                } // Clear any old template instances


                delete row.querySelector('[part~=details-cell]')._instance;
              });
            }

            if (this.detailsOpenedItems.length) {
              Array.from(this.$.items.children).forEach(this._toggleDetailsCell, this);

              this._update();
            }
          }
        }
        /** @private */

      }, {
        key: "_detailsOpenedItemsChanged",
        value: function _detailsOpenedItemsChanged(changeRecord, rowDetailsTemplate, rowDetailsRenderer) {
          var _this2 = this;

          if (changeRecord.path === 'detailsOpenedItems.length' || !changeRecord.value) {
            // Let’s avoid duplicate work of both “.splices” and “.length” updates.
            return;
          }

          Array.from(this.$.items.children).forEach(function (row) {
            _this2._toggleDetailsCell(row, row._item);

            _this2._a11yUpdateRowDetailsOpened(row, _this2._isDetailsOpened(row._item));

            _this2._toggleAttribute('details-opened', _this2._isDetailsOpened(row._item), row);
          });
        }
        /**
         * @param {!HTMLElement} cell
         * @protected
         */

      }, {
        key: "_configureDetailsCell",
        value: function _configureDetailsCell(cell) {
          cell.setAttribute('part', 'cell details-cell'); // Freeze the details cell, so that it does not scroll horizontally
          // with the normal cells. This way it looks less weird.

          this._toggleAttribute('frozen', true, cell);
        }
        /**
         * @param {!HTMLElement} row
         * @param {!GridItem} item
         * @protected
         */

      }, {
        key: "_toggleDetailsCell",
        value: function _toggleDetailsCell(row, item) {
          var _this3 = this;

          var cell = row.querySelector('[part~="details-cell"]');

          if (!cell) {
            return;
          }

          var detailsHidden = !this._isDetailsOpened(item);
          var hiddenChanged = !!cell.hidden !== detailsHidden;

          if (!cell._instance && !cell._renderer || cell.hidden !== detailsHidden) {
            cell.hidden = detailsHidden;

            if (detailsHidden) {
              row.style.removeProperty('padding-bottom');
            } else {
              if (this.rowDetailsRenderer) {
                cell._renderer = this.rowDetailsRenderer;

                cell._renderer.call(this, cell._content, this, {
                  index: row.index,
                  item: item
                });
              } else if (this._rowDetailsTemplate && !cell._instance) {
                // Stamp the template
                cell._instance = this._rowDetailsTemplate.templatizer.createInstance();
                cell._content.innerHTML = '';

                cell._content.appendChild(cell._instance.root);

                this._updateItem(row, item);
              }

              (0, _flush.flush)();
              row.style.setProperty('padding-bottom', "".concat(cell.offsetHeight, "px"));
              requestAnimationFrame(function () {
                return _this3.notifyResize();
              });
            }
          }

          if (hiddenChanged) {
            this._updateMetrics();

            this._positionItems();
          }
        }
        /** @protected */

      }, {
        key: "_updateDetailsCellHeights",
        value: function _updateDetailsCellHeights() {
          Array.from(this.$.items.querySelectorAll('[part~="details-cell"]:not([hidden])')).forEach(function (cell) {
            cell.parentElement.style.setProperty('padding-bottom', "".concat(cell.offsetHeight, "px"));
          });
        }
        /**
         * @param {!GridItem} item
         * @return {boolean}
         * @protected
         */

      }, {
        key: "_isDetailsOpened",
        value: function _isDetailsOpened(item) {
          return this.detailsOpenedItems && this._getItemIndexInArray(item, this.detailsOpenedItems) !== -1;
        }
        /**
         * Open the details row of a given item.
         * @param {!GridItem} item
         */

      }, {
        key: "openItemDetails",
        value: function openItemDetails(item) {
          if (!this._isDetailsOpened(item)) {
            this.push('detailsOpenedItems', item);
          }
        }
        /**
         * Close the details row of a given item.
         * @param {!GridItem} item
         */

      }, {
        key: "closeItemDetails",
        value: function closeItemDetails(item) {
          if (this._isDetailsOpened(item)) {
            this.splice('detailsOpenedItems', this._getItemIndexInArray(item, this.detailsOpenedItems), 1);
          }
        }
        /** @private */

      }, {
        key: "_detailsOpenedInstanceChangedCallback",
        value: function _detailsOpenedInstanceChangedCallback(instance, value) {
          if (babelHelpers.get(babelHelpers.getPrototypeOf(RowDetailsMixin.prototype), "_detailsOpenedInstanceChangedCallback", this)) {
            babelHelpers.get(babelHelpers.getPrototypeOf(RowDetailsMixin.prototype), "_detailsOpenedInstanceChangedCallback", this).call(this, instance, value);
          }

          if (value) {
            this.openItemDetails(instance.item);
          } else {
            this.closeItemDetails(instance.item);
          }
        }
      }], [{
        key: "properties",
        get: function get() {
          return {
            /**
             * An array containing references to items with open row details.
             * @type {Array<GridItem> | null | undefined}
             */
            detailsOpenedItems: {
              type: Array,
              value: function value() {
                return [];
              }
            },

            /**
             * @type {HTMLTemplateElement}
             * @protected
             */
            _rowDetailsTemplate: Object,

            /**
             * Custom function for rendering the content of the row details.
             * Receives three arguments:
             *
             * - `root` The row details content DOM element. Append your content to it.
             * - `grid` The `<vaadin-grid>` element.
             * - `model` The object with the properties related with
             *   the rendered item, contains:
             *   - `model.index` The index of the item.
             *   - `model.item` The item.
             *
             * @type {GridRowDetailsRenderer | null | undefined}
             */
            rowDetailsRenderer: Function,

            /**
             * @type {!Array<!HTMLElement> | undefined}
             * @protected
             */
            _detailsCells: {
              type: Array
            }
          };
        }
      }, {
        key: "observers",
        get: function get() {
          return ['_detailsOpenedItemsChanged(detailsOpenedItems.*, _rowDetailsTemplate, rowDetailsRenderer)', '_rowDetailsTemplateOrRendererChanged(_rowDetailsTemplate, rowDetailsRenderer)'];
        }
      }]);
      return RowDetailsMixin;
    }(superClass);
  };

  _exports.RowDetailsMixin = RowDetailsMixin;
});