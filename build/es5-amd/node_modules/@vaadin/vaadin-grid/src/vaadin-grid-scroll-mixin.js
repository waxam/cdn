define(["exports", "../../../@polymer/polymer/lib/utils/debounce.js", "../../../@polymer/polymer/lib/utils/async.js"], function (_exports, _debounce, _async) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.ScrollMixin = void 0;

  /**
  @license
  Copyright (c) 2017 Vaadin Ltd.
  This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
  */

  /**
   * @polymerMixin
   */
  var ScrollMixin = function ScrollMixin(superClass) {
    return (
      /*#__PURE__*/
      function (_superClass) {
        babelHelpers.inherits(ScrollMixin, _superClass);
        babelHelpers.createClass(ScrollMixin, [{
          key: "_timeouts",
          get: function get() {
            return {
              SCROLL_PERIOD: 1000,
              WHEEL_SCROLLING: 200,
              SCROLLING: 100,
              IGNORE_WHEEL: 500
            };
          }
        }, {
          key: "_scrollTop",
          // Override (from iron-scroll-target-behavior) to avoid document scroll
          set: function set(top) {
            this.$.table.scrollTop = top;
          },
          get: function get() {
            return this.$.table.scrollTop;
          }
        }], [{
          key: "properties",
          get: function get() {
            return {
              // Cached array of frozen cells
              _frozenCells: {
                type: Array,
                value: function value() {
                  return [];
                }
              },
              _scrollbarWidth: {
                type: Number,
                value: function value() {
                  // Create the measurement node
                  var scrollDiv = document.createElement('div');
                  scrollDiv.style.width = '100px';
                  scrollDiv.style.height = '100px';
                  scrollDiv.style.overflow = 'scroll';
                  scrollDiv.style.position = 'absolute';
                  scrollDiv.style.top = '-9999px';
                  document.body.appendChild(scrollDiv); // Get the scrollbar width

                  var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth; // Delete the DIV

                  document.body.removeChild(scrollDiv);
                  return scrollbarWidth;
                }
              },
              _rowWithFocusedElement: Element,
              _deltaYAcc: {
                type: Number,
                value: 0
              }
            };
          }
        }, {
          key: "observers",
          get: function get() {
            return ['_scrollHeightUpdated(_estScrollHeight)', '_scrollViewportHeightUpdated(_viewportHeight)'];
          }
        }]);

        function ScrollMixin() {
          var _this;

          babelHelpers.classCallCheck(this, ScrollMixin);
          _this = babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(ScrollMixin).call(this));
          _this._scrollLineHeight = _this._getScrollLineHeight();
          return _this;
        }
        /**
         * @returns {Number|undefined} - The browser's default font-size in pixels
         */


        babelHelpers.createClass(ScrollMixin, [{
          key: "_getScrollLineHeight",
          value: function _getScrollLineHeight() {
            var el = document.createElement('div');
            el.style.fontSize = 'initial';
            el.style.display = 'none';
            document.body.appendChild(el);
            var fontSize = window.getComputedStyle(el).fontSize;
            document.body.removeChild(el);
            return fontSize ? window.parseInt(fontSize) : undefined;
          }
        }, {
          key: "_scrollViewportHeightUpdated",
          value: function _scrollViewportHeightUpdated(_viewportHeight) {
            this._scrollPageHeight = _viewportHeight - this.$.header.clientHeight - this.$.footer.clientHeight - this._scrollLineHeight;
          }
        }, {
          key: "ready",
          value: function ready() {
            var _this2 = this;

            babelHelpers.get(babelHelpers.getPrototypeOf(ScrollMixin.prototype), "ready", this).call(this);
            this.scrollTarget = this.$.table;
            this.addEventListener('wheel', function (e) {
              _this2._wheelScrolling = true;
              _this2._debouncerWheelScrolling = _debounce.Debouncer.debounce(_this2._debouncerWheelScrolling, _async.timeOut.after(_this2._timeouts.WHEEL_SCROLLING), function () {
                return _this2._wheelScrolling = false;
              });

              _this2._onWheel(e);
            });
            this.$.table.addEventListener('scroll', function (e) {
              if (_this2.$.outerscroller.outerScrolling) {
                e.stopImmediatePropagation();
              }
            }, true);
            this.$.items.addEventListener('focusin', function (e) {
              var itemsIndex = e.composedPath().indexOf(_this2.$.items);
              _this2._rowWithFocusedElement = e.composedPath()[itemsIndex - 1];
            });
            this.$.items.addEventListener('focusout', function () {
              return _this2._rowWithFocusedElement = undefined;
            });
          }
          /**
           * Scroll to a specific row index in the virtual list. Note that the row index is
           * not always the same for any particular item. For example, sorting/filtering/expanding
           * or collapsing hierarchical items can affect the row index related to an item.
           *
           * @param {number} index Row index to scroll to
           */

        }, {
          key: "scrollToIndex",
          value: function scrollToIndex(index) {
            var _this3 = this;

            this._accessIronListAPI(function () {
              return babelHelpers.get(babelHelpers.getPrototypeOf(ScrollMixin.prototype), "scrollToIndex", _this3).call(_this3, index);
            });
          }
        }, {
          key: "_onWheel",
          value: function _onWheel(e) {
            var _this4 = this;

            if (e.ctrlKey || this._hasScrolledAncestor(e.target, e.deltaX, e.deltaY)) {
              return;
            }

            var table = this.$.table;
            var deltaY = e.deltaY;

            if (e.deltaMode === WheelEvent.DOM_DELTA_LINE) {
              // Scrolling by "lines of text" instead of pixels
              deltaY *= this._scrollLineHeight;
            } else if (e.deltaMode === WheelEvent.DOM_DELTA_PAGE) {
              // Scrolling by "pages" instead of pixels
              deltaY *= this._scrollPageHeight;
            }

            if (this._wheelAnimationFrame) {
              // Skip new wheel events while one is being processed
              this._deltaYAcc += deltaY;
              e.preventDefault();
              return;
            }

            deltaY += this._deltaYAcc;
            this._deltaYAcc = 0;
            this._wheelAnimationFrame = true;
            this._debouncerWheelAnimationFrame = _debounce.Debouncer.debounce(this._debouncerWheelAnimationFrame, _async.animationFrame, function () {
              return _this4._wheelAnimationFrame = false;
            });
            var momentum = Math.abs(e.deltaX) + Math.abs(deltaY);

            if (this._canScroll(table, e.deltaX, deltaY)) {
              e.preventDefault();
              table.scrollTop += deltaY;
              table.scrollLeft += e.deltaX;

              this._scrollHandler();

              this._hasResidualMomentum = true;
              this._ignoreNewWheel = true;
              this._debouncerIgnoreNewWheel = _debounce.Debouncer.debounce(this._debouncerIgnoreNewWheel, _async.timeOut.after(this._timeouts.IGNORE_WHEEL), function () {
                return _this4._ignoreNewWheel = false;
              });
            } else if (this._hasResidualMomentum && momentum <= this._previousMomentum || this._ignoreNewWheel) {
              e.preventDefault();
            } else if (momentum > this._previousMomentum) {
              this._hasResidualMomentum = false;
            }

            this._previousMomentum = momentum;
          }
          /**
           * Determines if the element has an ancestor prior to this
           * cell content that handles the scroll delta
           */

        }, {
          key: "_hasScrolledAncestor",
          value: function _hasScrolledAncestor(el, deltaX, deltaY) {
            if (el.localName === 'vaadin-grid-cell-content') {
              return false;
            } else if (this._canScroll(el, deltaX, deltaY) && ['auto', 'scroll'].indexOf(getComputedStyle(el).overflow) !== -1) {
              return true;
            } else if (el !== this && el.parentElement) {
              return this._hasScrolledAncestor(el.parentElement, deltaX, deltaY);
            }
          }
          /**
           * Determines if the the given scroll deltas can be applied to the element
           * (fully or partially)
           */

        }, {
          key: "_canScroll",
          value: function _canScroll(el, deltaX, deltaY) {
            return deltaY > 0 && el.scrollTop < el.scrollHeight - el.offsetHeight || deltaY < 0 && el.scrollTop > 0 || deltaX > 0 && el.scrollLeft < el.scrollWidth - el.offsetWidth || deltaX < 0 && el.scrollLeft > 0;
          }
        }, {
          key: "_scheduleScrolling",
          value: function _scheduleScrolling() {
            var _this5 = this;

            if (!this._scrollingFrame) {
              // Defer setting state attributes to avoid Edge hiccups
              this._scrollingFrame = requestAnimationFrame(function () {
                return _this5._toggleAttribute('scrolling', true, _this5.$.scroller);
              });
            }

            this._debounceScrolling = _debounce.Debouncer.debounce(this._debounceScrolling, _async.timeOut.after(this._timeouts.SCROLLING), function () {
              cancelAnimationFrame(_this5._scrollingFrame);
              delete _this5._scrollingFrame;

              _this5._toggleAttribute('scrolling', false, _this5.$.scroller);

              if (!_this5.$.outerscroller.outerScrolling) {
                _this5._reorderRows();
              }
            });

            if (!this._scrollPeriodFrame) {
              this._scrollPeriodFrame = requestAnimationFrame(function () {
                return _this5._toggleAttribute('scroll-period', true, _this5.$.scroller);
              });
            }

            this._debounceScrollPeriod = _debounce.Debouncer.debounce(this._debounceScrollPeriod, _async.timeOut.after(this._timeouts.SCROLL_PERIOD), function () {
              cancelAnimationFrame(_this5._scrollPeriodFrame);
              delete _this5._scrollPeriodFrame;

              _this5._toggleAttribute('scroll-period', false, _this5.$.scroller);
            });
          }
        }, {
          key: "_afterScroll",
          value: function _afterScroll() {
            this._translateStationaryElements();

            if (!this.hasAttribute('reordering')) {
              this._scheduleScrolling();
            }

            var os = this.$.outerscroller;

            if (!this._ios && (this._wheelScrolling || os.passthrough)) {
              os.syncOuterScroller();
            }

            if (this._ios) {
              // Enable vertical rubberband feedback
              var overScroll = Math.max(-os.scrollTop, 0) || Math.min(0, os.scrollHeight - os.scrollTop - os.offsetHeight);
              this.$.items.style.transform = "translateY(".concat(overScroll, "px)");
            }

            this._updateOverflow();
          }
        }, {
          key: "_updateOverflow",
          value: function _updateOverflow() {
            var _this6 = this;

            // Set overflow styling attributes
            var overflow = '';
            var table = this.$.table;

            if (table.scrollTop < table.scrollHeight - table.clientHeight) {
              overflow += ' bottom';
            }

            if (table.scrollTop > 0) {
              overflow += ' top';
            }

            if (table.scrollLeft < table.scrollWidth - table.clientWidth) {
              overflow += ' right';
            }

            if (table.scrollLeft > 0) {
              overflow += ' left';
            }

            this._debounceOverflow = _debounce.Debouncer.debounce(this._debounceOverflow, _async.animationFrame, function () {
              var value = overflow.trim();

              if (value.length > 0 && _this6.getAttribute('overflow') !== value) {
                _this6.setAttribute('overflow', value);
              } else if (value.length == 0 && _this6.hasAttribute('overflow')) {
                _this6.removeAttribute('overflow');
              }
            });
          } // correct order needed for preserving correct tab order between cell contents.

        }, {
          key: "_reorderRows",
          value: function _reorderRows() {
            var body = this.$.items;
            var items = body.querySelectorAll('tr');

            if (!items.length) {
              return;
            }

            var adjustedVirtualStart = this._virtualStart + this._vidxOffset; // Which row to use as a target?

            var targetRow = this._rowWithFocusedElement || Array.from(items).filter(function (row) {
              return !row.hidden;
            })[0];

            if (!targetRow) {
              // All rows are hidden, don't reorder
              return;
            } // Where the target row should be?


            var targetPhysicalIndex = targetRow.index - adjustedVirtualStart; // Reodrer the DOM elements to keep the target row at the target physical index

            var delta = Array.from(items).indexOf(targetRow) - targetPhysicalIndex;

            if (delta > 0) {
              for (var i = 0; i < delta; i++) {
                body.appendChild(items[i]);
              }
            } else if (delta < 0) {
              for (var _i = items.length + delta; _i < items.length; _i++) {
                body.insertBefore(items[_i], items[0]);
              }
            }
          }
        }, {
          key: "_frozenCellsChanged",
          value: function _frozenCellsChanged() {
            var _this7 = this;

            this._debouncerCacheElements = _debounce.Debouncer.debounce(this._debouncerCacheElements, _async.microTask, function () {
              Array.from(_this7.root.querySelectorAll('[part~="cell"]')).forEach(function (cell) {
                cell.style.transform = '';
              });
              _this7._frozenCells = Array.prototype.slice.call(_this7.$.table.querySelectorAll('[frozen]'));

              _this7._translateStationaryElements();
            });

            this._updateLastFrozen();
          }
        }, {
          key: "_updateLastFrozen",
          value: function _updateLastFrozen() {
            if (!this._columnTree) {
              return;
            }

            var columnsRow = this._columnTree[this._columnTree.length - 1].slice(0);

            columnsRow.sort(function (a, b) {
              return a._order - b._order;
            });
            var lastFrozen = columnsRow.reduce(function (prev, col, index) {
              col._lastFrozen = false;
              return col.frozen && !col.hidden ? index : prev;
            }, undefined);

            if (lastFrozen !== undefined) {
              columnsRow[lastFrozen]._lastFrozen = true;
            }
          }
        }, {
          key: "_translateStationaryElements",
          value: function _translateStationaryElements() {
            if (this._edge && !this._scrollbarWidth) {
              // Fixed mode (Tablet Edge)
              this.$.items.style.transform = this._getTranslate(-this._scrollLeft || 0, -this._scrollTop || 0);
              this.$.footer.style.transform = this.$.header.style.transform = this._getTranslate(-this._scrollLeft || 0, 0);
            } else {
              this.$.footer.style.transform = this.$.header.style.transform = this._getTranslate(0, this._scrollTop);
            }

            var frozenCellTransform = this._getTranslate(this._scrollLeft, 0);

            for (var i = 0; i < this._frozenCells.length; i++) {
              this._frozenCells[i].style.transform = frozenCellTransform;
            }
          }
        }, {
          key: "_getTranslate",
          value: function _getTranslate(x, y) {
            return 'translate(' + x + 'px,' + y + 'px)';
          }
        }, {
          key: "_scrollHeightUpdated",
          value: function _scrollHeightUpdated(_estScrollHeight) {
            this.$.outersizer.style.top = this.$.fixedsizer.style.top = _estScrollHeight + 'px';
          }
        }]);
        return ScrollMixin;
      }(superClass)
    );
  };

  _exports.ScrollMixin = ScrollMixin;
});