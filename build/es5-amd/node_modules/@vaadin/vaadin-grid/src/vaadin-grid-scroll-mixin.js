define(["exports", "../../../@polymer/polymer/lib/utils/debounce.js", "../../../@polymer/polymer/lib/utils/async.js"], function (_exports, _debounce, _async) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.ScrollMixin = void 0;

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  /**
   * @polymerMixin
   */
  var ScrollMixin = function ScrollMixin(superClass) {
    return /*#__PURE__*/function (_superClass) {
      babelHelpers.inherits(ScrollMixin, _superClass);

      var _super = _createSuper(ScrollMixin);

      function ScrollMixin() {
        var _this;

        babelHelpers.classCallCheck(this, ScrollMixin);
        _this = _super.call(this);
        _this._scrollLineHeight = _this._getScrollLineHeight();
        return _this;
      }
      /**
       * @returns {Number|undefined} - The browser's default font-size in pixels
       * @private
       */


      babelHelpers.createClass(ScrollMixin, [{
        key: "_timeouts",
        get:
        /** @private */
        function get() {
          return {
            SCROLLING: 500,
            IGNORE_WHEEL: 500
          };
        }
      }, {
        key: "_scrollTop",
        get:
        /** @private */
        function get() {
          return this.$.table.scrollTop;
        },
        set:
        /**
         * Override (from iron-scroll-target-behavior) to avoid document scroll
         * @private
         */
        function set(top) {
          this.$.table.scrollTop = top;
        }
      }, {
        key: "_getScrollLineHeight",
        value: function _getScrollLineHeight() {
          var el = document.createElement('div');
          el.style.fontSize = 'initial';
          el.style.display = 'none';
          document.body.appendChild(el);
          var fontSize = window.getComputedStyle(el).fontSize;
          document.body.removeChild(el);
          return fontSize ? window.parseInt(fontSize) : undefined;
        }
        /** @private */

      }, {
        key: "_scrollViewportHeightUpdated",
        value: function _scrollViewportHeightUpdated(_viewportHeight) {
          this._scrollPageHeight = _viewportHeight - this.$.header.clientHeight - this.$.footer.clientHeight - this._scrollLineHeight;
        }
        /** @protected */

      }, {
        key: "ready",
        value: function ready() {
          var _this2 = this;

          babelHelpers.get(babelHelpers.getPrototypeOf(ScrollMixin.prototype), "ready", this).call(this); // Preserve accessor to the legacy scrolling functionality

          this.$.outerscroller = document.createElement('div');
          this.scrollTarget = this.$.table;
          this.addEventListener('wheel', this._onWheel);
          this.$.items.addEventListener('focusin', function (e) {
            var itemsIndex = e.composedPath().indexOf(_this2.$.items);
            _this2._rowWithFocusedElement = e.composedPath()[itemsIndex - 1];
          });
          this.$.items.addEventListener('focusout', function () {
            return _this2._rowWithFocusedElement = undefined;
          }); // Reordering the physical rows cancels the user's grab of the scroll bar handle on Safari.
          // Need to defer reordering until the user lets go of the scroll bar handle.

          this.scrollTarget.addEventListener('mousedown', function () {
            return _this2.__mouseDown = true;
          });
          this.scrollTarget.addEventListener('mouseup', function () {
            _this2.__mouseDown = false;

            if (_this2.__pendingReorder) {
              _this2.__pendingReorder = false;
              setTimeout(function () {
                return _this2._reorderRows();
              }, _this2._timeouts.SCROLLING);
            }
          });
        }
        /**
         * Scroll to a specific row index in the virtual list. Note that the row index is
         * not always the same for any particular item. For example, sorting/filtering/expanding
         * or collapsing hierarchical items can affect the row index related to an item.
         *
         * @param {number} index Row index to scroll to
         */

      }, {
        key: "scrollToIndex",
        value: function scrollToIndex(index) {
          var _this3 = this;

          this._accessIronListAPI(function () {
            return babelHelpers.get(babelHelpers.getPrototypeOf(ScrollMixin.prototype), "scrollToIndex", _this3).call(_this3, index);
          });
        }
        /** @private */

      }, {
        key: "_onWheel",
        value: function _onWheel(e) {
          var _this4 = this;

          if (e.ctrlKey || this._hasScrolledAncestor(e.target, e.deltaX, e.deltaY)) {
            return;
          }

          var table = this.$.table;
          var deltaY = e.deltaY;

          if (e.deltaMode === WheelEvent.DOM_DELTA_LINE) {
            // Scrolling by "lines of text" instead of pixels
            deltaY *= this._scrollLineHeight;
          } else if (e.deltaMode === WheelEvent.DOM_DELTA_PAGE) {
            // Scrolling by "pages" instead of pixels
            deltaY *= this._scrollPageHeight;
          }

          if (this._wheelAnimationFrame) {
            // Skip new wheel events while one is being processed
            this._deltaYAcc += deltaY;
            e.preventDefault();
            return;
          }

          deltaY += this._deltaYAcc;
          this._deltaYAcc = 0;
          this._wheelAnimationFrame = true;
          this._debouncerWheelAnimationFrame = _debounce.Debouncer.debounce(this._debouncerWheelAnimationFrame, _async.animationFrame, function () {
            return _this4._wheelAnimationFrame = false;
          });
          var momentum = Math.abs(e.deltaX) + Math.abs(deltaY);

          if (this._canScroll(table, e.deltaX, deltaY)) {
            e.preventDefault();
            table.scrollTop += deltaY;
            table.scrollLeft += e.deltaX;

            this._scrollHandler();

            this._hasResidualMomentum = true;
            this._ignoreNewWheel = true;
            this._debouncerIgnoreNewWheel = _debounce.Debouncer.debounce(this._debouncerIgnoreNewWheel, _async.timeOut.after(this._timeouts.IGNORE_WHEEL), function () {
              return _this4._ignoreNewWheel = false;
            });
          } else if (this._hasResidualMomentum && momentum <= this._previousMomentum || this._ignoreNewWheel) {
            e.preventDefault();
          } else if (momentum > this._previousMomentum) {
            this._hasResidualMomentum = false;
          }

          this._previousMomentum = momentum;
        }
        /**
         * Determines if the element has an ancestor prior to this
         * cell content that handles the scroll delta
         * @private
         */

      }, {
        key: "_hasScrolledAncestor",
        value: function _hasScrolledAncestor(el, deltaX, deltaY) {
          if (el.localName === 'vaadin-grid-cell-content') {
            return false;
          } else if (this._canScroll(el, deltaX, deltaY) && ['auto', 'scroll'].indexOf(getComputedStyle(el).overflow) !== -1) {
            return true;
          } else if (el !== this && el.parentElement) {
            return this._hasScrolledAncestor(el.parentElement, deltaX, deltaY);
          }
        }
        /**
         * Determines if the the given scroll deltas can be applied to the element
         * (fully or partially)
         * @private
         */

      }, {
        key: "_canScroll",
        value: function _canScroll(el, deltaX, deltaY) {
          return deltaY > 0 && el.scrollTop < el.scrollHeight - el.offsetHeight || deltaY < 0 && el.scrollTop > 0 || deltaX > 0 && el.scrollLeft < el.scrollWidth - el.offsetWidth || deltaX < 0 && el.scrollLeft > 0;
        }
        /** @private */

      }, {
        key: "_scheduleScrolling",
        value: function _scheduleScrolling() {
          var _this5 = this;

          if (!this._scrollingFrame) {
            // Defer setting state attributes to avoid Edge hiccups
            this._scrollingFrame = requestAnimationFrame(function () {
              return _this5._toggleAttribute('scrolling', true, _this5.$.scroller);
            });
          }

          this._debounceScrolling = _debounce.Debouncer.debounce(this._debounceScrolling, _async.timeOut.after(this._timeouts.SCROLLING), function () {
            cancelAnimationFrame(_this5._scrollingFrame);
            delete _this5._scrollingFrame;

            _this5._toggleAttribute('scrolling', false, _this5.$.scroller);

            _this5._reorderRows();
          });
        }
        /** @private */

      }, {
        key: "_afterScroll",
        value: function _afterScroll() {
          this._translateStationaryElements();

          if (!this.hasAttribute('reordering')) {
            this._scheduleScrolling();
          }

          this._updateOverflow();
        }
        /** @private */

      }, {
        key: "_updateOverflow",
        value: function _updateOverflow() {
          var _this6 = this;

          // Set overflow styling attributes
          var overflow = '';
          var table = this.$.table;

          if (table.scrollTop < table.scrollHeight - table.clientHeight) {
            overflow += ' bottom';
          }

          if (table.scrollTop > 0) {
            overflow += ' top';
          }

          if (table.scrollLeft < table.scrollWidth - table.clientWidth) {
            overflow += ' right';
          }

          if (table.scrollLeft > 0) {
            overflow += ' left';
          }

          this._debounceOverflow = _debounce.Debouncer.debounce(this._debounceOverflow, _async.animationFrame, function () {
            var value = overflow.trim();

            if (value.length > 0 && _this6.getAttribute('overflow') !== value) {
              _this6.setAttribute('overflow', value);
            } else if (value.length == 0 && _this6.hasAttribute('overflow')) {
              _this6.removeAttribute('overflow');
            }
          });
        }
        /**
         * Correct order needed for preserving correct tab order between cell contents.
         * @private
         */

      }, {
        key: "_reorderRows",
        value: function _reorderRows() {
          var _this7 = this;

          if (this.__mouseDown) {
            this.__pendingReorder = true;
            return;
          }

          var body = this.$.items;
          var items = body.querySelectorAll('tr');

          if (!items.length) {
            return;
          }

          var adjustedVirtualStart = this._virtualStart + this._vidxOffset; // Which row to use as a target?

          var targetRow = this._rowWithFocusedElement || Array.from(items).filter(function (row) {
            return !row.hidden;
          })[0];

          if (!targetRow) {
            // All rows are hidden, don't reorder
            return;
          } // Where the target row should be?


          var targetPhysicalIndex = targetRow.index - adjustedVirtualStart; // Reodrer the DOM elements to keep the target row at the target physical index

          var delta = Array.from(items).indexOf(targetRow) - targetPhysicalIndex;

          if (delta > 0) {
            for (var i = 0; i < delta; i++) {
              body.appendChild(items[i]);
            }
          } else if (delta < 0) {
            for (var _i = items.length + delta; _i < items.length; _i++) {
              body.insertBefore(items[_i], items[0]);
            }
          } // Due to a rendering bug, reordering the rows can make the sticky header disappear on Safari
          // if the grid is used inside of a flex box. This is a workaround for the issue.


          if (this._safari) {
            var transform = this.$.header.style.transform;
            this.$.header.style.transform = '';
            setTimeout(function () {
              return _this7.$.header.style.transform = transform;
            });
          }
        }
        /** @protected */

      }, {
        key: "_frozenCellsChanged",
        value: function _frozenCellsChanged() {
          var _this8 = this;

          this._debouncerCacheElements = _debounce.Debouncer.debounce(this._debouncerCacheElements, _async.microTask, function () {
            Array.from(_this8.shadowRoot.querySelectorAll('[part~="cell"]')).forEach(function (cell) {
              cell.style.transform = '';
            });
            _this8._frozenCells = Array.prototype.slice.call(_this8.$.table.querySelectorAll('[frozen]'));

            _this8._updateScrollerMeasurements();

            _this8._translateStationaryElements();
          });

          this._updateLastFrozen();
        }
        /** @protected */

      }, {
        key: "_updateScrollerMeasurements",
        value: function _updateScrollerMeasurements() {
          if (this._frozenCells.length > 0 && this.__isRTL) {
            this.__scrollerMetrics = {
              scrollWidth: this.$.table.scrollWidth,
              clientWidth: this.$.table.clientWidth
            };
          }
        }
        /** @protected */

      }, {
        key: "_updateLastFrozen",
        value: function _updateLastFrozen() {
          if (!this._columnTree) {
            return;
          }

          var columnsRow = this._columnTree[this._columnTree.length - 1].slice(0);

          columnsRow.sort(function (a, b) {
            return a._order - b._order;
          });
          var lastFrozen = columnsRow.reduce(function (prev, col, index) {
            col._lastFrozen = false;
            return col.frozen && !col.hidden ? index : prev;
          }, undefined);

          if (lastFrozen !== undefined) {
            columnsRow[lastFrozen]._lastFrozen = true;
          }
        }
        /** @private */

      }, {
        key: "_translateStationaryElements",
        value: function _translateStationaryElements() {
          var scrollLeft = Math.max(0, this._scrollLeft);
          var scrollTop = Math.max(0, this._scrollTop);
          var leftOffset = 0;
          var topOffset = 0;
          var footerOffset = 0;

          if (!this._useSticky) {
            leftOffset = scrollLeft;
            topOffset = scrollTop;
            footerOffset = this.$.table.clientHeight - this.$.footer.offsetHeight - this.$.footer.offsetTop;
          }

          this.$.header.style.transform = this._getTranslate(-scrollLeft + leftOffset, topOffset);
          this.$.footer.style.transform = this._getTranslate(-scrollLeft + leftOffset, topOffset + footerOffset);
          this.$.items.style.transform = this._getTranslate(-scrollLeft + leftOffset, 0);

          if (this._frozenCells.length > 0) {
            var x = this.__isRTL ? this.__getNormalizedScrollLeft(this.$.table) + this.__scrollerMetrics.clientWidth - this.__scrollerMetrics.scrollWidth : this._scrollLeft;

            var frozenCellTransform = this._getTranslate(x, 0);

            for (var i = 0; i < this._frozenCells.length; i++) {
              this._frozenCells[i].style.transform = frozenCellTransform;
            }
          }
        }
        /** @private */

      }, {
        key: "_getTranslate",
        value: function _getTranslate(x, y) {
          return "translate(".concat(x, "px, ").concat(y, "px)");
        }
      }], [{
        key: "properties",
        get: function get() {
          return {
            /**
             * Cached array of frozen cells
             * @private
             */
            _frozenCells: {
              type: Array,
              value: function value() {
                return [];
              }
            },

            /** @private */
            _rowWithFocusedElement: Element,

            /** @private */
            _deltaYAcc: {
              type: Number,
              value: 0
            },

            /** @private */
            _useSticky: {
              type: Boolean,
              value: window.CSS && window.CSS.supports && (window.CSS.supports('position', 'sticky') || window.CSS.supports('position', '-webkit-sticky'))
            }
          };
        }
      }, {
        key: "observers",
        get: function get() {
          return ['_scrollViewportHeightUpdated(_viewportHeight)'];
        }
      }]);
      return ScrollMixin;
    }(superClass);
  };

  _exports.ScrollMixin = ScrollMixin;
});