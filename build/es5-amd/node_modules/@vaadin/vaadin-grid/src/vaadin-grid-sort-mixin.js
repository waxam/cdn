define(["exports", "../../../@polymer/polymer/lib/utils/async.js", "../../../@polymer/polymer/polymer-element.js"], function (_exports, _async, _polymerElement) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.SortMixin = void 0;

  /**
  @license
  Copyright (c) 2017 Vaadin Ltd.
  This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
  */

  /**
   * @polymerMixin
   */
  var SortMixin = function SortMixin(superClass) {
    return (
      /*#__PURE__*/
      function (_superClass) {
        babelHelpers.inherits(SortMixin, _superClass);

        function SortMixin() {
          babelHelpers.classCallCheck(this, SortMixin);
          return babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(SortMixin).apply(this, arguments));
        }

        babelHelpers.createClass(SortMixin, [{
          key: "ready",
          value: function ready() {
            var _this = this;

            babelHelpers.get(babelHelpers.getPrototypeOf(SortMixin.prototype), "ready", this).call(this);
            this.addEventListener('sorter-changed', this._onSorterChanged); // With Polymer 2 & shady the 'sorter-changed' listener isn't guaranteed to be registered
            // before child <vaadin-grid-sorter>'s upgrade and fire the events. The following
            // makes sure that 'sorter-changed' is fired for all <vaadin-grid-sorter> elements
            // after this (<vaadin-grid>) is ready (and the listeners are active).

            if (window.ShadyDOM) {
              _async.microTask.run(function () {
                var sorters = _this.querySelectorAll('vaadin-grid-sorter');

                Array.from(sorters).forEach(function (sorter) {
                  // Don't try to fire if the sorter hasn't been upgraded yet
                  if (babelHelpers.instanceof(sorter, _polymerElement.PolymerElement)) {
                    sorter.dispatchEvent(new CustomEvent('sorter-changed', {
                      bubbles: true,
                      composed: true
                    }));
                  }
                });
              });
            }
          }
        }, {
          key: "_onSorterChanged",
          value: function _onSorterChanged(e) {
            var _this2 = this;

            var sorter = e.target;

            this._removeArrayItem(this._sorters, sorter);

            sorter._order = null;

            if (this.multiSort) {
              if (sorter.direction) {
                this._sorters.unshift(sorter);
              }

              this._sorters.forEach(function (sorter, index) {
                return sorter._order = _this2._sorters.length > 1 ? index : null;
              }, this);
            } else {
              if (sorter.direction) {
                this._sorters.forEach(function (sorter) {
                  sorter._order = null;
                  sorter.direction = null;
                });

                this._sorters = [sorter];
              }
            }

            e.stopPropagation();

            if (this.dataProvider && // No need to clear cache if sorters didn't change
            JSON.stringify(this._previousSorters) !== JSON.stringify(this._mapSorters())) {
              this.clearCache();
            }

            this._a11yUpdateSorters();

            this._previousSorters = this._mapSorters();
          }
        }, {
          key: "_mapSorters",
          value: function _mapSorters() {
            return this._sorters.map(function (sorter) {
              return {
                path: sorter.path,
                direction: sorter.direction
              };
            });
          }
        }, {
          key: "_removeArrayItem",
          value: function _removeArrayItem(array, item) {
            var index = array.indexOf(item);

            if (index > -1) {
              array.splice(index, 1);
            }
          }
        }], [{
          key: "properties",
          get: function get() {
            return {
              /**
               * When `true`, all `<vaadin-grid-sorter>` are applied for sorting.
               */
              multiSort: {
                type: Boolean,
                value: false
              },
              _sorters: {
                type: Array,
                value: function value() {
                  return [];
                }
              },
              _previousSorters: {
                type: Array,
                value: function value() {
                  return [];
                }
              }
            };
          }
        }]);
        return SortMixin;
      }(superClass)
    );
  };

  _exports.SortMixin = SortMixin;
});