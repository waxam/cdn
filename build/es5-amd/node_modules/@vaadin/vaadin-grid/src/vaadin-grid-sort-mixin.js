define(["exports", "../../../@polymer/polymer/lib/utils/async.js", "../../../@polymer/polymer/polymer-element.js"], function (_exports, _async, _polymerElement) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.SortMixin = void 0;

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  /**
   * @polymerMixin
   */
  var SortMixin = function SortMixin(superClass) {
    return /*#__PURE__*/function (_superClass) {
      babelHelpers.inherits(SortMixin, _superClass);

      var _super = _createSuper(SortMixin);

      function SortMixin() {
        babelHelpers.classCallCheck(this, SortMixin);
        return _super.apply(this, arguments);
      }

      babelHelpers.createClass(SortMixin, [{
        key: "ready",
        value:
        /** @protected */
        function ready() {
          var _this = this;

          babelHelpers.get(babelHelpers.getPrototypeOf(SortMixin.prototype), "ready", this).call(this);
          this.addEventListener('sorter-changed', this._onSorterChanged); // With Polymer 2 & shady the 'sorter-changed' listener isn't guaranteed to be registered
          // before child <vaadin-grid-sorter>'s upgrade and fire the events. The following
          // makes sure that 'sorter-changed' is fired for all <vaadin-grid-sorter> elements
          // after this (<vaadin-grid>) is ready (and the listeners are active).

          if (window.ShadyDOM) {
            _async.microTask.run(function () {
              var sorters = _this.querySelectorAll('vaadin-grid-sorter');

              Array.from(sorters).forEach(function (sorter) {
                // Don't try to fire if the sorter hasn't been upgraded yet
                if (babelHelpers.instanceof(sorter, _polymerElement.PolymerElement)) {
                  sorter.dispatchEvent(new CustomEvent('sorter-changed', {
                    bubbles: true,
                    composed: true
                  }));
                }
              });
            });
          }
        }
        /** @private */

      }, {
        key: "_onSorterChanged",
        value: function _onSorterChanged(e) {
          var sorter = e.target;
          e.stopPropagation();

          this.__updateSorter(sorter);

          this.__applySorters();
        }
        /** @private */

      }, {
        key: "__removeSorters",
        value: function __removeSorters(sortersToRemove) {
          if (sortersToRemove.length == 0) {
            return;
          }

          this._sorters = this._sorters.filter(function (sorter) {
            return sortersToRemove.indexOf(sorter) < 0;
          });

          if (this.multiSort) {
            this.__updateSortOrders();
          }

          this.__applySorters();
        }
        /** @private */

      }, {
        key: "__updateSortOrders",
        value: function __updateSortOrders() {
          var _this2 = this;

          this._sorters.forEach(function (sorter, index) {
            return sorter._order = _this2._sorters.length > 1 ? index : null;
          }, this);
        }
        /** @private */

      }, {
        key: "__updateSorter",
        value: function __updateSorter(sorter) {
          var _this3 = this;

          if (!sorter.direction && this._sorters.indexOf(sorter) === -1) {
            return;
          }

          sorter._order = null;

          if (this.multiSort) {
            this._removeArrayItem(this._sorters, sorter);

            if (sorter.direction) {
              this._sorters.unshift(sorter);
            }

            this.__updateSortOrders();

            this._sorters.forEach(function (sorter, index) {
              return sorter._order = _this3._sorters.length > 1 ? index : null;
            }, this);
          } else {
            if (sorter.direction) {
              var otherSorters = this._sorters.filter(function (s) {
                return s != sorter;
              });

              this._sorters = [sorter];
              otherSorters.forEach(function (sorter) {
                sorter._order = null;
                sorter.direction = null;
              });
            }
          }
        }
        /** @private */

      }, {
        key: "__applySorters",
        value: function __applySorters() {
          if (this.dataProvider && // No need to clear cache if sorters didn't change and grid is attached
          this.isAttached && JSON.stringify(this._previousSorters) !== JSON.stringify(this._mapSorters())) {
            this.clearCache();
          }

          this._a11yUpdateSorters();

          this._previousSorters = this._mapSorters();
        }
        /**
         * @return {!Array<!GridSorter>}
         * @protected
         */

      }, {
        key: "_mapSorters",
        value: function _mapSorters() {
          return this._sorters.map(function (sorter) {
            return {
              path: sorter.path,
              direction: sorter.direction
            };
          });
        }
        /** @private */

      }, {
        key: "_removeArrayItem",
        value: function _removeArrayItem(array, item) {
          var index = array.indexOf(item);

          if (index > -1) {
            array.splice(index, 1);
          }
        }
      }], [{
        key: "properties",
        get: function get() {
          return {
            /**
             * When `true`, all `<vaadin-grid-sorter>` are applied for sorting.
             * @attr {boolean} multi-sort
             * @type {boolean}
             */
            multiSort: {
              type: Boolean,
              value: false
            },

            /**
             * @type {!Array<!GridSorter>}
             * @protected
             */
            _sorters: {
              type: Array,
              value: function value() {
                return [];
              }
            },

            /** @private */
            _previousSorters: {
              type: Array,
              value: function value() {
                return [];
              }
            }
          };
        }
      }]);
      return SortMixin;
    }(superClass);
  };

  _exports.SortMixin = SortMixin;
});