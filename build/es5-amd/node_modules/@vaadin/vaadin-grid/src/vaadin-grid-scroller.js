define(["exports", "../../../@polymer/polymer/lib/utils/render-status.js", "../../../@polymer/polymer/lib/utils/async.js", "../../../@polymer/polymer/lib/utils/flush.js", "./iron-list.js", "../../../@polymer/polymer/lib/utils/debounce.js"], function (_exports, _renderStatus, _async, _flush, _ironList, _debounce) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.ScrollerElement = void 0;

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  /**
   * This Element is used internally by vaadin-grid.
   *
   * @implements PolymerIronList
   * @extends HTMLElement
   */
  var GridScrollerElement = /*#__PURE__*/function (_PolymerIronList) {
    babelHelpers.inherits(GridScrollerElement, _PolymerIronList);

    var _super = _createSuper(GridScrollerElement);

    function GridScrollerElement() {
      babelHelpers.classCallCheck(this, GridScrollerElement);
      return _super.apply(this, arguments);
    }

    babelHelpers.createClass(GridScrollerElement, [{
      key: "connectedCallback",
      value:
      /** @protected */
      function connectedCallback() {
        babelHelpers.get(babelHelpers.getPrototypeOf(GridScrollerElement.prototype), "connectedCallback", this).call(this);

        this._scrollHandler();
      }
      /**
       * @param {!HTMLTableRowElement} item
       * @param {number} index
       * @protected
       */

    }, {
      key: "_updateScrollerItem",
      value: function _updateScrollerItem(item, index) {}
      /** @protected */

    }, {
      key: "_afterScroll",
      value: function _afterScroll() {}
      /** @protected */

    }, {
      key: "_getRowTarget",
      value: function _getRowTarget() {}
      /** @protected */

    }, {
      key: "_createScrollerRows",
      value: function _createScrollerRows() {}
      /** @protected */

    }, {
      key: "_canPopulate",
      value: function _canPopulate() {}
      /**
       * @param {number} index
       * @protected
       */

    }, {
      key: "scrollToIndex",
      value: function scrollToIndex(index) {
        var _this = this;

        this._warnPrivateAPIAccess('scrollToIndex');

        this._scrollingToIndex = true;
        index = Math.min(Math.max(index, 0), this._effectiveSize - 1);
        this.$.table.scrollTop = index / this._effectiveSize * (this.$.table.scrollHeight - this.$.table.offsetHeight); // We need to run the iron-list scroll handler here in order to recalculate the scaling from effective size to
        // virtual size after changing the scroll position. However we don't want to trigger updates to the items / rows
        // in this step, which could result in data provider requests for the previous viewport

        this._preventItemUpdates = true;

        this._scrollHandler();

        this._preventItemUpdates = false;

        if (this._accessIronListAPI(function () {
          return _this._maxScrollTop;
        }) && this._virtualCount < this._effectiveSize) {
          this._adjustVirtualIndexOffset(1000000);
        }

        this._accessIronListAPI(function () {
          return babelHelpers.get(babelHelpers.getPrototypeOf(GridScrollerElement.prototype), "scrollToIndex", _this).call(_this, index - _this._vidxOffset);
        });

        this._scrollHandler(); // Ensure scroll position


        var row = Array.from(this.$.items.children).filter(function (child) {
          return child.index === index;
        })[0];

        if (row) {
          var headerOffset = row.getBoundingClientRect().top - this.$.header.getBoundingClientRect().bottom;

          if (Math.abs(headerOffset) > 1) {
            this.$.table.scrollTop += headerOffset;

            this._scrollHandler();
          }
        }

        this._scrollingToIndex = false;
      }
      /** @private */

    }, {
      key: "_effectiveSizeChanged",
      value: function _effectiveSizeChanged(size) {
        var _this2 = this;

        var fvi; // first visible (adjusted) index

        var fviOffset = 0;

        this._iterateItems(function (pidx, vidx) {
          if (vidx === _this2._firstVisibleIndex) {
            var row = _this2._physicalItems[pidx];
            fvi = row.index;
            fviOffset = row.getBoundingClientRect().top;
          }
        });

        if (this.items && size < this.items.length) {
          // Size was reduced, scroll to 0 first
          this._scrollTop = 0;
        }

        if (!Array.isArray(this.items)) {
          // Edge/IE seems to have the lowest maximum
          var maxVirtualItems = this._edge || this._ie ? 30000 : 100000;
          this.items = {
            length: Math.min(size, maxVirtualItems)
          };
        }

        this._accessIronListAPI(function () {
          return babelHelpers.get(babelHelpers.getPrototypeOf(GridScrollerElement.prototype), "_itemsChanged", _this2).call(_this2, {
            path: 'items'
          });
        });

        this._virtualCount = Math.min(this.items.length, size) || 0;

        if (this._scrollTop === 0) {
          this._accessIronListAPI(function () {
            return _this2._scrollToIndex(Math.min(size - 1, fvi));
          });

          this._iterateItems(function (pidx, vidx) {
            var row = _this2._physicalItems[pidx];

            if (row.index === fvi) {
              _this2.$.table.scrollTop += Math.round(row.getBoundingClientRect().top - fviOffset);
            } // Restore keyboard focus to the right cell


            if (row.index === _this2._focusedItemIndex && _this2._itemsFocusable && _this2.$.items.contains(_this2.shadowRoot.activeElement)) {
              var cellIndex = Array.from(_this2._itemsFocusable.parentElement.children).indexOf(_this2._itemsFocusable);
              row.children[cellIndex].focus();
            }
          });
        }

        this._assignModels();

        requestAnimationFrame(function () {
          return _this2._update();
        });

        this.__updateFooterPositioning();

        if (this._ie) {
          // Workaround an IE flexbox bug where the rows would horizontally collapse
          // whenever item count change toggles the scrollbar visibility (is tested)
          this.$.table.style.display = 'block';
          setTimeout(function () {
            _this2.$.table.style.display = 'flex';

            _this2._translateStationaryElements();
          });
        }
      }
      /** @protected */

    }, {
      key: "_positionItems",
      value: function _positionItems() {
        var _this3 = this;

        this._adjustScrollPosition();

        var rePosition;

        if (isNaN(this._physicalTop)) {
          rePosition = true;
          this._physicalTop = 0;
        }

        var y = this._physicalTop;

        this._iterateItems(function (pidx, vidx) {
          _this3._physicalItems[pidx].style.transform = "translateY(".concat(y, "px)");
          y += _this3._physicalSizes[pidx];
        });

        if (rePosition) {
          this._scrollToIndex(0);
        }
      }
      /**
       * @param {number} count
       * @protected
       */

    }, {
      key: "_increasePoolIfNeeded",
      value: function _increasePoolIfNeeded(count) {
        var _this4 = this;

        if (count === 0 && this._scrollingToIndex || !this._canPopulate() || !this._effectiveSize) {
          return;
        }

        if (!this._initialPoolCreated) {
          this._initialPoolCreated = true;
          babelHelpers.get(babelHelpers.getPrototypeOf(GridScrollerElement.prototype), "_increasePoolIfNeeded", this).call(this, 25);
        } else if (this._optPhysicalSize !== Infinity) {
          this._debounceIncreasePool = _debounce.Debouncer.debounce(this._debounceIncreasePool, _async.animationFrame, function () {
            _this4._updateMetrics();

            var remainingPhysicalSize = _this4._optPhysicalSize - _this4._physicalSize;
            var estimatedMissingRowCount = Math.ceil(remainingPhysicalSize / _this4._physicalAverage);

            if (_this4._physicalCount + estimatedMissingRowCount > _this4._effectiveSize) {
              // Do not increase the physical item count above the this._effectiveSize
              estimatedMissingRowCount = Math.max(0, _this4._effectiveSize - _this4._physicalCount);
            }

            if (_this4._physicalSize && estimatedMissingRowCount > 0 && _this4._optPhysicalSize !== Infinity) {
              babelHelpers.get(babelHelpers.getPrototypeOf(GridScrollerElement.prototype), "_increasePoolIfNeeded", _this4).call(_this4, estimatedMissingRowCount); // Ensure the rows are in order after increasing pool

              _this4.__reorderChildNodes();
            }

            _this4.__flushPendingRecalculateColumnWidths();
          });
        }
      }
      /** @private */

    }, {
      key: "__reorderChildNodes",
      value: function __reorderChildNodes() {
        var _this5 = this;

        var childNodes = Array.from(this.$.items.childNodes);
        var rowsInOrder = !!childNodes.reduce(function (inOrder, current, currentIndex, array) {
          if (currentIndex === 0 || array[currentIndex - 1].index === current.index - 1) {
            return inOrder;
          }
        }, true);

        if (!rowsInOrder) {
          childNodes.sort(function (row1, row2) {
            return row1.index - row2.index;
          }).forEach(function (row) {
            return _this5.$.items.appendChild(row);
          });
        }
      }
      /** @private */

    }, {
      key: "_createPool",
      value: function _createPool(size) {
        var _this6 = this;

        var fragment = document.createDocumentFragment();

        var physicalItems = this._createScrollerRows(size);

        physicalItems.forEach(function (inst) {
          return fragment.appendChild(inst);
        });

        this._getRowTarget().appendChild(fragment); // Weird hack needed to get Safari to actually distribute slots


        var content = this.querySelector('[slot]');

        if (content) {
          var slot = content.getAttribute('slot');
          content.setAttribute('slot', 'foo-bar');
          content.setAttribute('slot', slot);
        }

        (0, _renderStatus.afterNextRender)(this, function () {
          return _this6.notifyResize();
        });
        return physicalItems;
      }
      /**
       * Assigns the data models to a given set of items.
       * @param {!Array<number>=} itemSet
       * @protected
       */

    }, {
      key: "_assignModels",
      value: function _assignModels(itemSet) {
        var _this7 = this;

        // Skip here if internal flag for preventing item updates is set
        if (this._preventItemUpdates) {
          return;
        }

        this._iterateItems(function (pidx, vidx) {
          var el = _this7._physicalItems[pidx];

          _this7._toggleAttribute('hidden', vidx >= _this7._effectiveSize, el);

          _this7._updateScrollerItem(el, vidx + (_this7._vidxOffset || 0));
        }, itemSet);
      }
      /** @protected */

    }, {
      key: "_scrollHandler",
      value: function _scrollHandler() {
        var _this8 = this;

        var delta = this.$.table.scrollTop - this._scrollPosition;

        this._accessIronListAPI(babelHelpers.get(babelHelpers.getPrototypeOf(GridScrollerElement.prototype), "_scrollHandler", this));

        var oldOffset = this._vidxOffset;

        if (this._accessIronListAPI(function () {
          return _this8._maxScrollTop;
        }) && this._virtualCount < this._effectiveSize) {
          this._adjustVirtualIndexOffset(delta);
        } else {
          this._vidxOffset = 0;
        }

        if (this._vidxOffset !== oldOffset) {
          this._update();
        }

        this._afterScroll();
      }
      /** @private */

    }, {
      key: "_adjustVirtualIndexOffset",
      value: function _adjustVirtualIndexOffset(delta) {
        if (Math.abs(delta) > 10000) {
          if (this._noScale) {
            this._noScale = false;
            return;
          }

          var scale = this.$.table.scrollTop / (this.$.table.scrollHeight - this.$.table.offsetHeight);
          var offset = scale * this._effectiveSize;
          this._vidxOffset = Math.round(offset - scale * this._virtualCount);
        } else {
          // Make sure user can always swipe/wheel scroll to the start and end
          var oldOffset = this._vidxOffset || 0;
          var threshold = 1000;
          var maxShift = 100; // At start

          if (this._scrollTop === 0) {
            this._vidxOffset = 0;

            if (oldOffset !== this._vidxOffset) {
              babelHelpers.get(babelHelpers.getPrototypeOf(GridScrollerElement.prototype), "scrollToIndex", this).call(this, 0);
            }
          } else if (this.firstVisibleIndex < threshold && this._vidxOffset > 0) {
            this._vidxOffset -= Math.min(this._vidxOffset, maxShift);

            if (oldOffset !== this._vidxOffset) {
              babelHelpers.get(babelHelpers.getPrototypeOf(GridScrollerElement.prototype), "scrollToIndex", this).call(this, this.firstVisibleIndex + (oldOffset - this._vidxOffset));
            }

            this._noScale = true;
          } // At end


          var maxOffset = this._effectiveSize - this._virtualCount;

          if (this._scrollTop >= this._maxScrollTop && this._maxScrollTop > 0) {
            this._vidxOffset = maxOffset;

            if (oldOffset !== this._vidxOffset) {
              babelHelpers.get(babelHelpers.getPrototypeOf(GridScrollerElement.prototype), "scrollToIndex", this).call(this, this._virtualCount);
            }
          } else if (this.firstVisibleIndex > this._virtualCount - threshold && this._vidxOffset < maxOffset) {
            this._vidxOffset += Math.min(maxOffset - this._vidxOffset, maxShift);

            if (oldOffset !== this._vidxOffset) {
              babelHelpers.get(babelHelpers.getPrototypeOf(GridScrollerElement.prototype), "scrollToIndex", this).call(this, this.firstVisibleIndex - (this._vidxOffset - oldOffset));
            }

            this._noScale = true;
          }
        }
      }
      /** @private */

    }, {
      key: "_accessIronListAPI",
      value: function _accessIronListAPI(cb) {
        var _this9 = this;

        this._warnPrivateAPIAccessAsyncEnabled = false;
        var returnValue = cb.apply(this);
        this._debouncerWarnPrivateAPIAccess = _debounce.Debouncer.debounce(this._debouncerWarnPrivateAPIAccess, _async.animationFrame, function () {
          return _this9._warnPrivateAPIAccessAsyncEnabled = true;
        });
        return returnValue;
      }
      /**
       * Allow iron-list to access its APIs from debounced callbacks without warns
       * @private
       */

    }, {
      key: "_debounceRender",
      value: function _debounceRender(cb, asyncModule) {
        var _this10 = this;

        babelHelpers.get(babelHelpers.getPrototypeOf(GridScrollerElement.prototype), "_debounceRender", this).call(this, function () {
          return _this10._accessIronListAPI(cb);
        }, asyncModule);
      }
      /**
       * Warn when iron-list APIs are being accessed directly
       * @private
       */

    }, {
      key: "_warnPrivateAPIAccess",
      value: function _warnPrivateAPIAccess(apiName) {
        if (this._warnPrivateAPIAccessAsyncEnabled) {
          console.warn("Accessing private API (".concat(apiName, ")!"));
        }
      }
      /** @protected */

    }, {
      key: "_render",
      value: function _render() {
        this._accessIronListAPI(babelHelpers.get(babelHelpers.getPrototypeOf(GridScrollerElement.prototype), "_render", this));
      }
      /** @private */

    }, {
      key: "_createFocusBackfillItem",
      value: function _createFocusBackfillItem() {}
      /* Ignore */

      /** @private */

    }, {
      key: "_multiSelectionChanged",
      value: function _multiSelectionChanged() {}
      /* Ignore */

      /** @private */

    }, {
      key: "clearSelection",
      value: function clearSelection() {}
      /* Ignore */

      /** @protected */

    }, {
      key: "_itemsChanged",
      value: function _itemsChanged() {}
      /* Ignore */

      /** @private */

    }, {
      key: "_manageFocus",
      value: function _manageFocus() {}
      /* Ignore */

      /** @private */

    }, {
      key: "_removeFocusedItem",
      value: function _removeFocusedItem() {}
      /* Ignore */

      /**
       * @return {number}
       * @protected
       */

    }, {
      key: "_firstVisibleIndex",
      get: function get() {
        var _this11 = this;

        return this._accessIronListAPI(function () {
          return babelHelpers.get(babelHelpers.getPrototypeOf(GridScrollerElement.prototype), "firstVisibleIndex", _this11);
        });
      }
      /**
       * @return {number}
       * @protected
       */

    }, {
      key: "_lastVisibleIndex",
      get: function get() {
        var _this12 = this;

        return this._accessIronListAPI(function () {
          return babelHelpers.get(babelHelpers.getPrototypeOf(GridScrollerElement.prototype), "lastVisibleIndex", _this12);
        });
      }
      /**
       * @param {number} index
       * @protected
       */

    }, {
      key: "_scrollToIndex",
      value: function _scrollToIndex(index) {
        var _this13 = this;

        this._accessIronListAPI(function () {
          return _this13.scrollToIndex(index);
        });
      }
      /** @private */

    }, {
      key: "firstVisibleIndex",
      get: function get() {
        this._warnPrivateAPIAccess('firstVisibleIndex');

        return babelHelpers.get(babelHelpers.getPrototypeOf(GridScrollerElement.prototype), "firstVisibleIndex", this);
      }
      /** @private */
      ,
      set: function set(value) {
        this._warnPrivateAPIAccess('firstVisibleIndex');

        babelHelpers.set(babelHelpers.getPrototypeOf(GridScrollerElement.prototype), "firstVisibleIndex", value, this, true);
      }
      /** @private */

    }, {
      key: "lastVisibleIndex",
      get: function get() {
        this._warnPrivateAPIAccess('lastVisibleIndex');

        return babelHelpers.get(babelHelpers.getPrototypeOf(GridScrollerElement.prototype), "lastVisibleIndex", this);
      }
      /** @private */
      ,
      set: function set(value) {
        this._warnPrivateAPIAccess('lastVisibleIndex');

        babelHelpers.set(babelHelpers.getPrototypeOf(GridScrollerElement.prototype), "lastVisibleIndex", value, this, true);
      }
      /** @private */

    }, {
      key: "updateViewportBoundaries",
      value: function updateViewportBoundaries() {
        this._warnPrivateAPIAccess('updateViewportBoundaries');

        babelHelpers.get(babelHelpers.getPrototypeOf(GridScrollerElement.prototype), "updateViewportBoundaries", this).apply(this, arguments);
      }
      /** @protected */

    }, {
      key: "_resizeHandler",
      value: function _resizeHandler() {
        babelHelpers.get(babelHelpers.getPrototypeOf(GridScrollerElement.prototype), "_resizeHandler", this).call(this);
        (0, _flush.flush)();
      }
    }, {
      key: "__isCreatingRows",
      value: function __isCreatingRows() {
        // iron-list's _increasePoolIfNeeded function may have scheduled a debouncer
        // that will re-invoke _increasePoolIfNeeded (in vaadin-grid-scroller)
        var schedulingDebounceIncreasePool = this._debouncers && this._debouncers._increasePoolIfNeeded && this._debouncers._increasePoolIfNeeded.isActive(); // vaadin-grid-scroller's overridden _increasePoolIfNeeded may have scheduled a _debounceIncreasePool debouncer


        var debouncingIncreasePoolActive = this._debounceIncreasePool && this._debounceIncreasePool.isActive(); // If either of the conditions are true, we consider the grid is still in the process of creating new rows


        return schedulingDebounceIncreasePool || debouncingIncreasePoolActive;
      }
    }], [{
      key: "is",
      get: function get() {
        return 'vaadin-grid-scroller';
      }
    }, {
      key: "properties",
      get: function get() {
        return {
          size: {
            type: Number,
            notify: true
          },

          /**
           * @type {number}
           * @protected
           */
          _vidxOffset: {
            value: 0
          }
        };
      }
    }, {
      key: "observers",
      get: function get() {
        return ['_effectiveSizeChanged(_effectiveSize)'];
      }
    }]);
    return GridScrollerElement;
  }(_ironList.PolymerIronList);

  _exports.ScrollerElement = GridScrollerElement;
  customElements.define(GridScrollerElement.is, GridScrollerElement);
});