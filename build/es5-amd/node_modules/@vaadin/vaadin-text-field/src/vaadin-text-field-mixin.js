define(["exports", "../../vaadin-themable-mixin/vaadin-themable-mixin.js", "../../vaadin-control-state-mixin/vaadin-control-state-mixin.js", "../../../@polymer/polymer/lib/utils/async.js", "../../../@polymer/polymer/lib/utils/debounce.js"], function (_exports, _vaadinThemableMixin, _vaadinControlStateMixin, _async, _debounce) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.TextFieldMixin = void 0;

  /**
  @license
  Copyright (c) 2017 Vaadin Ltd.
  This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
  */
  var $_documentContainer = document.createElement('template');
  $_documentContainer.innerHTML = "<dom-module id=\"vaadin-text-field-shared-styles\">\n  <template>\n    <style>\n      :host {\n        display: inline-flex;\n        outline: none;\n      }\n\n      :host::before {\n        content: \"\\2003\";\n        width: 0;\n        display: inline-block;\n        /* Size and position this element on the same vertical position as the input-field element\n           to make vertical align for the host element work as expected */\n      }\n\n      :host([hidden]) {\n        display: none !important;\n      }\n\n      .vaadin-text-field-container,\n      .vaadin-text-area-container {\n        display: flex;\n        flex-direction: column;\n        min-width: 100%;\n        max-width: 100%;\n        width: var(--vaadin-text-field-default-width, 12em);\n      }\n\n      [part=\"label\"]:empty {\n        display: none;\n      }\n\n      [part=\"input-field\"] {\n        display: flex;\n        align-items: center;\n        flex: auto;\n      }\n\n      .vaadin-text-field-container [part=\"input-field\"] {\n        flex-grow: 0;\n      }\n\n      /* Reset the native input styles */\n      [part=\"value\"],\n      [part=\"input-field\"] ::slotted(input),\n      [part=\"input-field\"] ::slotted(textarea) {\n        -webkit-appearance: none;\n        -moz-appearance: none;\n        outline: none;\n        margin: 0;\n        padding: 0;\n        border: 0;\n        border-radius: 0;\n        min-width: 0;\n        font: inherit;\n        font-size: 1em;\n        line-height: normal;\n        color: inherit;\n        background-color: transparent;\n        /* Disable default invalid style in Firefox */\n        box-shadow: none;\n      }\n\n      [part=\"input-field\"] ::slotted(*) {\n        flex: none;\n      }\n\n      [part=\"value\"],\n      [part=\"input-field\"] ::slotted(input),\n      [part=\"input-field\"] ::slotted(textarea),\n      /* Slotted by vaadin-select-text-field */\n      [part=\"input-field\"] ::slotted([part=\"value\"]) {\n        flex: auto;\n        white-space: nowrap;\n        overflow: hidden;\n        width: 100%;\n        height: 100%;\n      }\n\n      [part=\"input-field\"] ::slotted(textarea) {\n        resize: none;\n      }\n\n      [part=\"value\"]::-ms-clear,\n      [part=\"input-field\"] ::slotted(input)::-ms-clear {\n        display: none;\n      }\n\n      [part=\"clear-button\"] {\n        cursor: default;\n      }\n\n      [part=\"clear-button\"]::before {\n        content: \"\u2715\";\n      }\n    </style>\n  </template>\n</dom-module>";
  document.head.appendChild($_documentContainer.content);
  var HOST_PROPS = {
    default: ['list', 'autofocus', 'pattern', 'autocapitalize', 'autocorrect', 'maxlength', 'minlength', 'name', 'placeholder', 'autocomplete', 'title'],
    accessible: ['disabled', 'readonly', 'required', 'invalid']
  };
  var PROP_TYPE = {
    DEFAULT: 'default',
    ACCESSIBLE: 'accessible'
  };
  /**
   * @polymerMixin
   * @mixes Vaadin.ControlStateMixin
   */

  var TextFieldMixin = function TextFieldMixin(subclass) {
    return (
      /*#__PURE__*/
      function (_ControlStateMixin) {
        babelHelpers.inherits(VaadinTextFieldMixin, _ControlStateMixin);

        function VaadinTextFieldMixin() {
          babelHelpers.classCallCheck(this, VaadinTextFieldMixin);
          return babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(VaadinTextFieldMixin).apply(this, arguments));
        }

        babelHelpers.createClass(VaadinTextFieldMixin, [{
          key: "_createConstraintsObserver",
          value: function _createConstraintsObserver() {
            // This complex observer needs to be added dynamically here (instead of defining it above in the `get observers()`)
            // so that it runs after complex observers of inheriting classes. Otherwise e.g. `_stepOrMinChanged()` observer of
            // vaadin-number-field would run after this and the `min` and `step` properties would not yet be propagated to
            // the `inputElement` when this runs.
            this._createMethodObserver('_constraintsChanged(required, minlength, maxlength, pattern)');
          }
        }, {
          key: "_onInput",
          value: function _onInput(e) {
            var _this = this;

            if (this.__preventInput) {
              e.stopImmediatePropagation();
              this.__preventInput = false;
              return;
            }

            if (this.preventInvalidInput) {
              var input = this.inputElement;

              if (input.value.length > 0 && !this.checkValidity()) {
                input.value = this.value || ''; // add input-prevented attribute for 200ms

                this.setAttribute('input-prevented', '');
                this._inputDebouncer = _debounce.Debouncer.debounce(this._inputDebouncer, _async.timeOut.after(200), function () {
                  _this.removeAttribute('input-prevented');
                });
                return;
              }
            }

            if (!e.__fromClearButton) {
              this.__userInput = true;
            }

            this.value = e.target.value;
          } // NOTE(yuriy): Workaround needed for IE11 and Edge for proper displaying
          // of the clear button instead of setting display property for it depending on state.

        }, {
          key: "_stateChanged",
          value: function _stateChanged(disabled, readonly, clearButtonVisible, hasValue) {
            if (!disabled && !readonly && clearButtonVisible && hasValue) {
              this.$.clearButton.removeAttribute('hidden');
            } else {
              this.$.clearButton.setAttribute('hidden', true);
            }
          }
        }, {
          key: "_onChange",
          value: function _onChange(e) {
            if (this._valueClearing) {
              return;
            } // In the Shadow DOM, the `change` event is not leaked into the
            // ancestor tree, so we must do this manually.


            var changeEvent = new CustomEvent('change', {
              detail: {
                sourceEvent: e
              },
              bubbles: e.bubbles,
              cancelable: e.cancelable
            });
            this.dispatchEvent(changeEvent);
          }
        }, {
          key: "_valueChanged",
          value: function _valueChanged(newVal, oldVal) {
            // setting initial value to empty string, skip validation
            if (newVal === '' && oldVal === undefined) {
              return;
            }

            if (newVal !== '' && newVal != null) {
              this.hasValue = true;
            } else {
              this.hasValue = false;
            }

            if (this.__userInput) {
              this.__userInput = false;
              return;
            } else if (newVal !== undefined) {
              this.inputElement.value = newVal;
            } else {
              this.value = this.inputElement.value = '';
            }

            if (this.invalid) {
              this.validate();
            }
          }
        }, {
          key: "_labelChanged",
          value: function _labelChanged(label) {
            if (label !== '' && label != null) {
              this.setAttribute('has-label', '');
            } else {
              this.removeAttribute('has-label');
            }
          }
        }, {
          key: "_onSlotChange",
          value: function _onSlotChange() {
            var _this2 = this;

            var slotted = this.querySelector("".concat(this._slottedTagName, "[slot=\"").concat(this._slottedTagName, "\"]"));

            if (this.value) {
              this.inputElement.value = this.value;
              this.validate();
            }

            if (slotted && !this._slottedInput) {
              this._validateSlottedValue(slotted);

              this._addInputListeners(slotted);

              this._addIEListeners(slotted);

              this._slottedInput = slotted;
            } else if (!slotted && this._slottedInput) {
              this._removeInputListeners(this._slottedInput);

              this._removeIEListeners(this._slottedInput);

              this._slottedInput = undefined;
            }

            Object.keys(PROP_TYPE).map(function (key) {
              return PROP_TYPE[key];
            }).forEach(function (type) {
              return _this2._propagateHostAttributes(HOST_PROPS[type].map(function (attr) {
                return _this2[attr];
              }), type);
            });
          }
        }, {
          key: "_hostPropsChanged",
          value: function _hostPropsChanged() {
            for (var _len = arguments.length, attributesValues = new Array(_len), _key = 0; _key < _len; _key++) {
              attributesValues[_key] = arguments[_key];
            }

            this._propagateHostAttributes(attributesValues, PROP_TYPE.DEFAULT);
          }
        }, {
          key: "_hostAccessiblePropsChanged",
          value: function _hostAccessiblePropsChanged() {
            for (var _len2 = arguments.length, attributesValues = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
              attributesValues[_key2] = arguments[_key2];
            }

            this._propagateHostAttributes(attributesValues, PROP_TYPE.ACCESSIBLE);
          }
        }, {
          key: "_validateSlottedValue",
          value: function _validateSlottedValue(slotted) {
            if (slotted.value !== this.value) {
              console.warn('Please define value on the vaadin-text-field component!');
              slotted.value = '';
            }
          }
        }, {
          key: "_propagateHostAttributes",
          value: function _propagateHostAttributes(attributesValues, type) {
            var _this3 = this;

            var input = this.inputElement;
            var attributeNames = HOST_PROPS[type];

            if (type === 'accessible') {
              attributeNames.forEach(function (attr, index) {
                _this3._setOrToggleAttribute(attr, attributesValues[index], input);

                _this3._setOrToggleAttribute("aria-".concat(attr), attributesValues[index], input);
              });
            } else {
              attributeNames.forEach(function (attr, index) {
                _this3._setOrToggleAttribute(attr, attributesValues[index], input);
              });
            }
          }
        }, {
          key: "_setOrToggleAttribute",
          value: function _setOrToggleAttribute(name, value, node) {
            if (!name || !node) {
              return;
            }

            if (value) {
              node.setAttribute(name, typeof value === 'boolean' ? '' : value);
            } else {
              node.removeAttribute(name);
            }
          }
        }, {
          key: "_constraintsChanged",
          value: function _constraintsChanged(required, minlength, maxlength, pattern) {
            if (!this.invalid) {
              return;
            }

            if (!required && !minlength && !maxlength && !pattern) {
              this.invalid = false;
            } else {
              this.validate();
            }
          }
          /**
           * Returns true if the current input value satisfies all constraints (if any)
           * @returns {boolean}
           */

        }, {
          key: "checkValidity",
          value: function checkValidity() {
            // Note (Yuriy): `__forceCheckValidity` is used in containing components (i.e. `vaadin-date-picker`) in order
            // to force the checkValidity instead of returning the previous invalid state.
            if (this.required || this.pattern || this.maxlength || this.minlength || this.__forceCheckValidity) {
              return this.inputElement.checkValidity();
            } else {
              return !this.invalid;
            }
          }
        }, {
          key: "_addInputListeners",
          value: function _addInputListeners(node) {
            node.addEventListener('input', this._boundOnInput);
            node.addEventListener('change', this._boundOnChange);
            node.addEventListener('blur', this._boundOnBlur);
            node.addEventListener('focus', this._boundOnFocus);
            node.addEventListener('paste', this._boundOnPaste);
            node.addEventListener('drop', this._boundOnDrop);
            node.addEventListener('beforeinput', this._boundOnBeforeInput);
          }
        }, {
          key: "_removeInputListeners",
          value: function _removeInputListeners(node) {
            node.removeEventListener('input', this._boundOnInput);
            node.removeEventListener('change', this._boundOnChange);
            node.removeEventListener('blur', this._boundOnBlur);
            node.removeEventListener('focus', this._boundOnFocus);
            node.removeEventListener('paste', this._boundOnPaste);
            node.removeEventListener('drop', this._boundOnDrop);
            node.removeEventListener('beforeinput', this._boundOnBeforeInput);
          }
        }, {
          key: "ready",
          value: function ready() {
            var _this4 = this;

            babelHelpers.get(babelHelpers.getPrototypeOf(VaadinTextFieldMixin.prototype), "ready", this).call(this);

            this._createConstraintsObserver();

            this._boundOnInput = this._onInput.bind(this);
            this._boundOnChange = this._onChange.bind(this);
            this._boundOnBlur = this._onBlur.bind(this);
            this._boundOnFocus = this._onFocus.bind(this);
            this._boundOnPaste = this._onPaste.bind(this);
            this._boundOnDrop = this._onDrop.bind(this);
            this._boundOnBeforeInput = this._onBeforeInput.bind(this);
            var defaultInput = this.shadowRoot.querySelector('[part="value"]');
            this._slottedInput = this.querySelector("".concat(this._slottedTagName, "[slot=\"").concat(this._slottedTagName, "\"]"));

            this._addInputListeners(defaultInput);

            this._addIEListeners(defaultInput);

            if (this._slottedInput) {
              this._addIEListeners(this._slottedInput);

              this._addInputListeners(this._slottedInput);
            }

            this.shadowRoot.querySelector('[name="input"], [name="textarea"]').addEventListener('slotchange', this._onSlotChange.bind(this));

            if (!(window.ShadyCSS && window.ShadyCSS.nativeCss)) {
              this.updateStyles();
            }

            this.$.clearButton.addEventListener('mousedown', function () {
              return _this4._valueClearing = true;
            });
            this.$.clearButton.addEventListener('mouseleave', function () {
              return _this4._valueClearing = false;
            });
            this.$.clearButton.addEventListener('click', this._onClearButtonClick.bind(this));
            this.addEventListener('keydown', this._onKeyDown.bind(this));
            var uniqueId = TextFieldMixin._uniqueId = 1 + TextFieldMixin._uniqueId || 0;
            this._errorId = "".concat(this.constructor.is, "-error-").concat(uniqueId);
            this._labelId = "".concat(this.constructor.is, "-label-").concat(uniqueId);
            this._inputId = "".concat(this.constructor.is, "-input-").concat(uniqueId); // Lumo theme defines a max-height transition for the "error-message"
            // part on invalid state change.

            this.shadowRoot.querySelector('[part="error-message"]').addEventListener('transitionend', function () {
              _this4.__observeOffsetHeight();
            });
          }
          /**
           * Returns true if `value` is valid.
           * `<iron-form>` uses this to check the validity for all its elements.
           *
           * @return {boolean} True if the value is valid.
           */

        }, {
          key: "validate",
          value: function validate() {
            return !(this.invalid = !this.checkValidity());
          }
        }, {
          key: "clear",
          value: function clear() {
            this.value = '';
          }
        }, {
          key: "_onBlur",
          value: function _onBlur() {
            this.validate();
          }
        }, {
          key: "_onFocus",
          value: function _onFocus() {
            var _this5 = this;

            if (this.autoselect) {
              this.inputElement.select(); // iOS 9 workaround: https://stackoverflow.com/a/7436574

              setTimeout(function () {
                try {
                  _this5.inputElement.setSelectionRange(0, 9999);
                } catch (e) {// The workaround may cause errors on different input types.
                  // Needs to be suppressed. See https://github.com/vaadin/flow/issues/6070
                }
              });
            }
          }
        }, {
          key: "_onClearButtonClick",
          value: function _onClearButtonClick(e) {
            e.preventDefault(); // NOTE(yuriy): This line won't affect focus on the host. Cannot be properly tested.

            this.inputElement.focus();
            this.clear();
            this._valueClearing = false;

            if (navigator.userAgent.match(/Trident/)) {
              // Disable IE input" event prevention here, we want the input event from
              // below to propagate normally.
              this.__preventInput = false;
            }

            var inputEvent = new Event('input', {
              bubbles: true,
              composed: true
            });
            inputEvent.__fromClearButton = true;
            var changeEvent = new Event('change', {
              bubbles: !this._slottedInput
            });
            changeEvent.__fromClearButton = true;
            this.inputElement.dispatchEvent(inputEvent);
            this.inputElement.dispatchEvent(changeEvent);
          }
        }, {
          key: "_onKeyDown",
          value: function _onKeyDown(e) {
            if (e.keyCode === 27 && this.clearButtonVisible) {
              var dispatchChange = !!this.value;
              this.clear();
              dispatchChange && this.inputElement.dispatchEvent(new Event('change', {
                bubbles: !this._slottedInput
              }));
            }

            if (this._enabledCharPattern && !this.__shouldAcceptKey(e)) {
              e.preventDefault();
            }
          }
        }, {
          key: "__shouldAcceptKey",
          value: function __shouldAcceptKey(event) {
            return event.metaKey || event.ctrlKey || !event.key // allow typing anything if event.key is not supported
            || event.key.length !== 1 // allow "Backspace", "ArrowLeft" etc.
            || this.__enabledCharRegExp.test(event.key);
          }
        }, {
          key: "_onPaste",
          value: function _onPaste(e) {
            if (this._enabledCharPattern) {
              var pastedText = (e.clipboardData || window.clipboardData).getData('text');

              if (!this.__enabledTextRegExp.test(pastedText)) {
                e.preventDefault();
              }
            }
          }
        }, {
          key: "_onDrop",
          value: function _onDrop(e) {
            if (this._enabledCharPattern) {
              var draggedText = e.dataTransfer.getData('text');

              if (!this.__enabledTextRegExp.test(draggedText)) {
                e.preventDefault();
              }
            }
          }
        }, {
          key: "_onBeforeInput",
          value: function _onBeforeInput(e) {
            // The `beforeinput` event covers all the cases for `_enabledCharPattern`: keyboard, pasting and dropping,
            // but it is still experimental technology so we can't rely on it. It's used here just as an additional check,
            // because it seems to be the only way to detect and prevent specific keys on mobile devices. See issue #429.
            if (this._enabledCharPattern && e.data && !this.__enabledTextRegExp.test(e.data)) {
              e.preventDefault();
            }
          }
        }, {
          key: "__enabledCharPatternChanged",
          value: function __enabledCharPatternChanged(_enabledCharPattern) {
            this.__enabledCharRegExp = _enabledCharPattern && new RegExp('^' + _enabledCharPattern + '$');
            this.__enabledTextRegExp = _enabledCharPattern && new RegExp('^' + _enabledCharPattern + '*$');
          }
        }, {
          key: "_addIEListeners",
          value: function _addIEListeners(node) {
            var _this6 = this;

            /* istanbul ignore if */
            if (navigator.userAgent.match(/Trident/)) {
              // IE11 dispatches `input` event in following cases:
              // - focus or blur, when placeholder attribute is set
              // - placeholder attribute value changed
              // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/101220/
              this._shouldPreventInput = function () {
                _this6.__preventInput = true;
                requestAnimationFrame(function () {
                  _this6.__preventInput = false;
                });
              };

              node.addEventListener('focusin', this._shouldPreventInput);
              node.addEventListener('focusout', this._shouldPreventInput);

              this._createPropertyObserver('placeholder', this._shouldPreventInput);
            }
          }
        }, {
          key: "_removeIEListeners",
          value: function _removeIEListeners(node) {
            /* istanbul ignore if */
            if (navigator.userAgent.match(/Trident/)) {
              node.removeEventListener('focusin', this._shouldPreventInput);
              node.removeEventListener('focusout', this._shouldPreventInput);
            }
          }
        }, {
          key: "_getActiveErrorId",
          value: function _getActiveErrorId(invalid, errorMessage, errorId) {
            this._setOrToggleAttribute('aria-describedby', errorMessage && invalid ? errorId : undefined, this.focusElement);
          }
        }, {
          key: "_getActiveLabelId",
          value: function _getActiveLabelId(label, _labelId, _inputId) {
            var ids = _inputId;

            if (label) {
              ids = "".concat(_labelId, " ").concat(_inputId);
            }

            this.focusElement.setAttribute('aria-labelledby', ids);
          }
        }, {
          key: "_getErrorMessageAriaHidden",
          value: function _getErrorMessageAriaHidden(invalid, errorMessage, errorId) {
            return (!(errorMessage && invalid ? errorId : undefined)).toString();
          }
        }, {
          key: "_dispatchIronResizeEventIfNeeded",
          value: function _dispatchIronResizeEventIfNeeded(sizePropertyName, value) {
            var previousSizePropertyName = '__previous' + sizePropertyName;

            if (this[previousSizePropertyName] !== undefined && this[previousSizePropertyName] !== value) {
              this.dispatchEvent(new CustomEvent('iron-resize', {
                bubbles: true
              }));
            }

            this[previousSizePropertyName] = value;
          }
        }, {
          key: "__observeOffsetHeight",
          value: function __observeOffsetHeight() {
            this._dispatchIronResizeEventIfNeeded('Height', this.offsetHeight);
          }
          /**
           * @protected
           */

        }, {
          key: "attributeChangedCallback",
          value: function attributeChangedCallback(prop, oldVal, newVal) {
            babelHelpers.get(babelHelpers.getPrototypeOf(VaadinTextFieldMixin.prototype), "attributeChangedCallback", this).call(this, prop, oldVal, newVal); // Needed until Edge has CSS Custom Properties (present in Edge Preview)

            /* istanbul ignore if */

            if (!(window.ShadyCSS && window.ShadyCSS.nativeCss) && /^(focused|focus-ring|invalid|disabled|placeholder|has-value)$/.test(prop)) {
              this.updateStyles();
            } // Safari has an issue with repainting shadow root element styles when a host attribute changes.
            // Need this workaround (toggle any inline css property on and off) until the issue gets fixed.


            var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
            /* istanbul ignore if */

            if (isSafari && this.root) {
              var WEBKIT_PROPERTY = '-webkit-backface-visibility';
              this.root.querySelectorAll('*').forEach(function (el) {
                el.style[WEBKIT_PROPERTY] = 'visible';
                el.style[WEBKIT_PROPERTY] = '';
              });
            }
          }
          /**
           * Fired when the user commits a value change.
           *
           * @event change
           */

          /**
           * Fired when the value is changed by the user: on every typing keystroke,
           * and the value is cleared using the clear button.
           *
           * @event input
           */

          /**
           * Fired when the size of the element changes.
           *
           * @event iron-resize
           */

        }, {
          key: "focusElement",
          get: function get() {
            if (!this.shadowRoot) {
              return;
            }

            var slotted = this.querySelector("".concat(this._slottedTagName, "[slot=\"").concat(this._slottedTagName, "\"]"));

            if (slotted) {
              return slotted;
            }

            return this.shadowRoot.querySelector('[part="value"]');
          }
          /**
           * @private
           */

        }, {
          key: "inputElement",
          get: function get() {
            return this.focusElement;
          }
        }, {
          key: "_slottedTagName",
          get: function get() {
            return 'input';
          }
        }], [{
          key: "properties",
          get: function get() {
            return {
              /**
               * Whether the value of the control can be automatically completed by the browser.
               * List of available options at:
               * https://developer.mozilla.org/en/docs/Web/HTML/Element/input#attr-autocomplete
               */
              autocomplete: {
                type: String
              },

              /**
               * This is a property supported by Safari that is used to control whether
               * autocorrection should be enabled when the user is entering/editing the text.
               * Possible values are:
               * on: Enable autocorrection.
               * off: Disable autocorrection.
               */
              autocorrect: {
                type: String
              },

              /**
               * This is a property supported by Safari and Chrome that is used to control whether
               * autocapitalization should be enabled when the user is entering/editing the text.
               * Possible values are:
               * characters: Characters capitalization.
               * words: Words capitalization.
               * sentences: Sentences capitalization.
               * none: No capitalization.
               */
              autocapitalize: {
                type: String
              },

              /**
               * Specify that the value should be automatically selected when the field gains focus.
               */
              autoselect: {
                type: Boolean,
                value: false
              },

              /**
               * Set to true to display the clear icon which clears the input.
               */
              clearButtonVisible: {
                type: Boolean,
                value: false
              },

              /**
               * Error to show when the input value is invalid.
               */
              errorMessage: {
                type: String,
                value: ''
              },

              /**
               * Object with translated strings used for localization. Has
               * the following structure and default values:
               *
               * ```
               * {
               *   // Translation of the clear icon button accessible label
               *   clear: 'Clear'
               * }
               * ```
               */
              i18n: {
                type: Object,
                value: function value() {
                  return {
                    clear: 'Clear'
                  };
                }
              },

              /**
               * String used for the label element.
               */
              label: {
                type: String,
                value: '',
                observer: '_labelChanged'
              },

              /**
               * Maximum number of characters (in Unicode code points) that the user can enter.
               */
              maxlength: {
                type: Number
              },

              /**
               * Minimum number of characters (in Unicode code points) that the user can enter.
               */
              minlength: {
                type: Number
              },

              /**
               * The name of the control, which is submitted with the form data.
               */
              name: {
                type: String
              },

              /**
               * A hint to the user of what can be entered in the control.
               */
              placeholder: {
                type: String
              },

              /**
               * This attribute indicates that the user cannot modify the value of the control.
               */
              readonly: {
                type: Boolean,
                reflectToAttribute: true
              },

              /**
               * Specifies that the user must fill in a value.
               */
              required: {
                type: Boolean,
                reflectToAttribute: true
              },

              /**
               * The initial value of the control.
               * It can be used for two-way data binding.
               */
              value: {
                type: String,
                value: '',
                observer: '_valueChanged',
                notify: true
              },

              /**
               * This property is set to true when the control value is invalid.
               */
              invalid: {
                type: Boolean,
                reflectToAttribute: true,
                notify: true,
                value: false
              },

              /**
               * Specifies that the text field has value.
               */
              hasValue: {
                type: Boolean,
                reflectToAttribute: true
              },

              /**
               * When set to true, user is prevented from typing a value that
               * conflicts with the given `pattern`.
               */
              preventInvalidInput: {
                type: Boolean
              },

              /**
               * A pattern matched against individual characters the user inputs.
               * When set, the field will prevent:
               * - `keyDown` events if the entered key doesn't match `/^_enabledCharPattern$/`
               * - `paste` events if the pasted text doesn't match `/^_enabledCharPattern*$/`
               * - `drop` events if the dropped text doesn't match `/^_enabledCharPattern*$/`
               *
               * For example, to enable entering only numbers and minus signs,
               * `_enabledCharPattern = "[\\d-]"`
               */
              _enabledCharPattern: String,
              _labelId: String,
              _errorId: String,
              _inputId: String
            };
          }
        }, {
          key: "observers",
          get: function get() {
            return ['_stateChanged(disabled, readonly, clearButtonVisible, hasValue)', '_hostPropsChanged(' + HOST_PROPS.default.join(', ') + ')', '_hostAccessiblePropsChanged(' + HOST_PROPS.accessible.join(', ') + ')', '_getActiveErrorId(invalid, errorMessage, _errorId)', '_getActiveLabelId(label, _labelId, _inputId)', '__observeOffsetHeight(errorMessage, invalid, label)', '__enabledCharPatternChanged(_enabledCharPattern)'];
          }
        }]);
        return VaadinTextFieldMixin;
      }((0, _vaadinControlStateMixin.ControlStateMixin)(subclass))
    );
  };

  _exports.TextFieldMixin = TextFieldMixin;
});