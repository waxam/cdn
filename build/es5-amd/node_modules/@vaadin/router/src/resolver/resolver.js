define(["exports", "./path-to-regexp.js", "./matchRoute.js", "./resolveRoute.js", "../utils.js"], function (_exports, _pathToRegexp, _matchRoute, _resolveRoute, _utils) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = void 0;
  _pathToRegexp = babelHelpers.interopRequireDefault(_pathToRegexp);
  _matchRoute = babelHelpers.interopRequireDefault(_matchRoute);
  _resolveRoute = babelHelpers.interopRequireDefault(_resolveRoute);

  /**
   * Universal Router (https://www.kriasoft.com/universal-router/)
   *
   * Copyright (c) 2015-present Kriasoft.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.txt file in the root directory of this source tree.
   */
  function isChildRoute(parentRoute, childRoute) {
    var route = childRoute;

    while (route) {
      route = route.parent;

      if (route === parentRoute) {
        return true;
      }
    }

    return false;
  }

  function generateErrorMessage(currentContext) {
    var errorMessage = "Path '".concat(currentContext.pathname, "' is not properly resolved due to an error.");
    var routePath = (currentContext.route || {}).path;

    if (routePath) {
      errorMessage += " Resolution had failed on route: '".concat(routePath, "'");
    }

    return errorMessage;
  }

  function updateChainForRoute(context, match) {
    var route = match.route,
        path = match.path;

    if (route && !route.__synthetic) {
      var item = {
        path: path,
        route: route
      };

      if (!context.chain) {
        context.chain = [];
      } else {
        // Discard old items
        if (route.parent) {
          var i = context.chain.length;

          while (i-- && context.chain[i].route && context.chain[i].route !== route.parent) {
            context.chain.pop();
          }
        }
      }

      context.chain.push(item);
    }
  }
  /**
   */


  var Resolver = /*#__PURE__*/function () {
    function Resolver(routes) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      babelHelpers.classCallCheck(this, Resolver);

      if (Object(routes) !== routes) {
        throw new TypeError('Invalid routes');
      }

      this.baseUrl = options.baseUrl || '';
      this.errorHandler = options.errorHandler;
      this.resolveRoute = options.resolveRoute || _resolveRoute.default;
      this.context = Object.assign({
        resolver: this
      }, options.context);
      this.root = Array.isArray(routes) ? {
        path: '',
        __children: routes,
        parent: null,
        __synthetic: true
      } : routes;
      this.root.parent = null;
    }
    /**
     * Returns the current list of routes (as a shallow copy). Adding / removing
     * routes to / from the returned array does not affect the routing config,
     * but modifying the route objects does.
     *
     * @return {!Array<!Router.Route>}
     */


    babelHelpers.createClass(Resolver, [{
      key: "getRoutes",
      value: function getRoutes() {
        return babelHelpers.toConsumableArray(this.root.__children);
      }
      /**
       * Sets the routing config (replacing the existing one).
       *
       * @param {!Array<!Router.Route>|!Router.Route} routes a single route or an array of those
       *    (the array is shallow copied)
       */

    }, {
      key: "setRoutes",
      value: function setRoutes(routes) {
        (0, _utils.ensureRoutes)(routes);
        var newRoutes = babelHelpers.toConsumableArray((0, _utils.toArray)(routes));
        this.root.__children = newRoutes;
      }
      /**
       * Appends one or several routes to the routing config and returns the
       * effective routing config after the operation.
       *
       * @param {!Array<!Router.Route>|!Router.Route} routes a single route or an array of those
       *    (the array is shallow copied)
       * @return {!Array<!Router.Route>}
       * @protected
       */

    }, {
      key: "addRoutes",
      value: function addRoutes(routes) {
        var _this$root$__children;

        (0, _utils.ensureRoutes)(routes);

        (_this$root$__children = this.root.__children).push.apply(_this$root$__children, babelHelpers.toConsumableArray((0, _utils.toArray)(routes)));

        return this.getRoutes();
      }
      /**
       * Removes all existing routes from the routing config.
       */

    }, {
      key: "removeRoutes",
      value: function removeRoutes() {
        this.setRoutes([]);
      }
      /**
       * Asynchronously resolves the given pathname, i.e. finds all routes matching
       * the pathname and tries resolving them one after another in the order they
       * are listed in the routes config until the first non-null result.
       *
       * Returns a promise that is fulfilled with the return value of an object that consists of the first
       * route handler result that returns something other than `null` or `undefined` and context used to get this result.
       *
       * If no route handlers return a non-null result, or if no route matches the
       * given pathname the returned promise is rejected with a 'page not found'
       * `Error`.
       *
       * @param {!string|!{pathname: !string}} pathnameOrContext the pathname to
       *    resolve or a context object with a `pathname` property and other
       *    properties to pass to the route resolver functions.
       * @return {!Promise<any>}
       */

    }, {
      key: "resolve",
      value: function resolve(pathnameOrContext) {
        var _this = this;

        var context = Object.assign({}, this.context, (0, _utils.isString)(pathnameOrContext) ? {
          pathname: pathnameOrContext
        } : pathnameOrContext);
        var match = (0, _matchRoute.default)(this.root, this.__normalizePathname(context.pathname), this.baseUrl);
        var resolve = this.resolveRoute;
        var matches = null;
        var nextMatches = null;
        var currentContext = context;

        function next(resume) {
          var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : matches.value.route;
          var prevResult = arguments.length > 2 ? arguments[2] : undefined;
          var routeToSkip = prevResult === null && matches.value.route;
          matches = nextMatches || match.next(routeToSkip);
          nextMatches = null;

          if (!resume) {
            if (matches.done || !isChildRoute(parent, matches.value.route)) {
              nextMatches = matches;
              return Promise.resolve(_utils.notFoundResult);
            }
          }

          if (matches.done) {
            return Promise.reject((0, _utils.getNotFoundError)(context));
          }

          currentContext = Object.assign(currentContext ? {
            chain: currentContext.chain ? currentContext.chain.slice(0) : []
          } : {}, context, matches.value);
          updateChainForRoute(currentContext, matches.value);
          return Promise.resolve(resolve(currentContext)).then(function (resolution) {
            if (resolution !== null && resolution !== undefined && resolution !== _utils.notFoundResult) {
              currentContext.result = resolution.result || resolution;
              return currentContext;
            }

            return next(resume, parent, resolution);
          });
        }

        context.next = next;
        return Promise.resolve().then(function () {
          return next(true, _this.root);
        }).catch(function (error) {
          var errorMessage = generateErrorMessage(currentContext);

          if (!error) {
            error = new Error(errorMessage);
          } else {
            console.warn(errorMessage);
          }

          error.context = error.context || currentContext; // DOMException has its own code which is read-only

          if (!babelHelpers.instanceof(error, DOMException)) {
            error.code = error.code || 500;
          }

          if (_this.errorHandler) {
            currentContext.result = _this.errorHandler(error);
            return currentContext;
          }

          throw error;
        });
      }
      /**
       * URL constructor polyfill hook. Creates and returns an URL instance.
       */

    }, {
      key: "__effectiveBaseUrl",
      get:
      /**
       * If the baseUrl property is set, transforms the baseUrl and returns the full
       * actual `base` string for using in the `new URL(path, base);` and for
       * prepernding the paths with. The returned base ends with a trailing slash.
       *
       * Otherwise, returns empty string.
       */
      function get() {
        return this.baseUrl ? this.constructor.__createUrl(this.baseUrl, document.baseURI || document.URL).href.replace(/[^\/]*$/, '') : '';
      }
      /**
       * If the baseUrl is set, matches the pathname with the routerâ€™s baseUrl,
       * and returns the local pathname with the baseUrl stripped out.
       *
       * If the pathname does not match the baseUrl, returns undefined.
       *
       * If the `baseUrl` is not set, returns the unmodified pathname argument.
       */

    }, {
      key: "__normalizePathname",
      value: function __normalizePathname(pathname) {
        if (!this.baseUrl) {
          // No base URL, no need to transform the pathname.
          return pathname;
        }

        var base = this.__effectiveBaseUrl;

        var normalizedUrl = this.constructor.__createUrl(pathname, base).href;

        if (normalizedUrl.slice(0, base.length) === base) {
          return normalizedUrl.slice(base.length);
        }
      }
    }], [{
      key: "__createUrl",
      value: function __createUrl(url, base) {
        return new URL(url, base);
      }
    }]);
    return Resolver;
  }();

  Resolver.pathToRegexp = _pathToRegexp.default;
  var _default = Resolver;
  _exports.default = _default;
});