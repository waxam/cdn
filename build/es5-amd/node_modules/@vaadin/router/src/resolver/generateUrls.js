define(["exports", "./resolver.js", "../utils.js"], function (_exports, _resolver, _utils) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = void 0;
  _resolver = babelHelpers.interopRequireDefault(_resolver);

  /**
   * Universal Router (https://www.kriasoft.com/universal-router/)
   *
   * Copyright (c) 2015-present Kriasoft.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.txt file in the root directory of this source tree.
   */
  var pathToRegexp = _resolver.default.pathToRegexp;
  var cache = new Map();

  function cacheRoutes(routesByName, route, routes) {
    var name = route.name || route.component;

    if (name) {
      if (routesByName.has(name)) {
        routesByName.get(name).push(route);
      } else {
        routesByName.set(name, [route]);
      }
    }

    if (Array.isArray(routes)) {
      for (var i = 0; i < routes.length; i++) {
        var childRoute = routes[i];
        childRoute.parent = route;
        cacheRoutes(routesByName, childRoute, childRoute.__children || childRoute.children);
      }
    }
  }

  function getRouteByName(routesByName, routeName) {
    var routes = routesByName.get(routeName);

    if (routes && routes.length > 1) {
      throw new Error("Duplicate route with name \"".concat(routeName, "\".") + " Try seting unique 'name' route properties.");
    }

    return routes && routes[0];
  }

  function getRoutePath(route) {
    var path = route.path;
    path = Array.isArray(path) ? path[0] : path;
    return path !== undefined ? path : '';
  }

  function generateUrls(router) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (!babelHelpers.instanceof(router, _resolver.default)) {
      throw new TypeError('An instance of Resolver is expected');
    }

    var routesByName = new Map();
    return function (routeName, params) {
      var route = getRouteByName(routesByName, routeName);

      if (!route) {
        routesByName.clear(); // clear cache

        cacheRoutes(routesByName, router.root, router.root.__children);
        route = getRouteByName(routesByName, routeName);

        if (!route) {
          throw new Error("Route \"".concat(routeName, "\" not found"));
        }
      }

      var regexp = cache.get(route.fullPath);

      if (!regexp) {
        var fullPath = getRoutePath(route);
        var rt = route.parent;

        while (rt) {
          var path = getRoutePath(rt);

          if (path) {
            fullPath = path.replace(/\/$/, '') + '/' + fullPath.replace(/^\//, '');
          }

          rt = rt.parent;
        }

        var tokens = pathToRegexp.parse(fullPath);
        var toPath = pathToRegexp.tokensToFunction(tokens);
        var keys = Object.create(null);

        for (var i = 0; i < tokens.length; i++) {
          if (!(0, _utils.isString)(tokens[i])) {
            keys[tokens[i].name] = true;
          }
        }

        regexp = {
          toPath: toPath,
          keys: keys
        };
        cache.set(fullPath, regexp);
        route.fullPath = fullPath;
      }

      var url = regexp.toPath(params, options) || '/';

      if (options.stringifyQueryParams && params) {
        var queryParams = {};

        var _keys = Object.keys(params);

        for (var _i = 0; _i < _keys.length; _i++) {
          var key = _keys[_i];

          if (!regexp.keys[key]) {
            queryParams[key] = params[key];
          }
        }

        var query = options.stringifyQueryParams(queryParams);

        if (query) {
          url += query.charAt(0) === '?' ? query : "?".concat(query);
        }
      }

      return url;
    };
  }

  var _default = generateUrls;
  _exports.default = _default;
});