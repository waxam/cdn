define(["exports", "./resolver/resolver.js", "./resolver/generateUrls.js", "./triggers/setNavigationTriggers.js", "./transitions/animate.js", "./utils.js"], function (_exports, _resolver, _generateUrls, _setNavigationTriggers, _animate, _utils) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.Router = void 0;
  _resolver = babelHelpers.interopRequireDefault(_resolver);
  _generateUrls = babelHelpers.interopRequireDefault(_generateUrls);
  _setNavigationTriggers = babelHelpers.interopRequireDefault(_setNavigationTriggers);
  _animate = babelHelpers.interopRequireDefault(_animate);
  var MAX_REDIRECT_COUNT = 256;

  function isResultNotEmpty(result) {
    return result !== null && result !== undefined;
  }

  function copyContextWithoutNext(context) {
    var copy = Object.assign({}, context);
    delete copy.next;
    return copy;
  }

  function createLocation(_ref, route) {
    var _ref$pathname = _ref.pathname,
        pathname = _ref$pathname === void 0 ? '' : _ref$pathname,
        _ref$chain = _ref.chain,
        chain = _ref$chain === void 0 ? [] : _ref$chain,
        _ref$params = _ref.params,
        params = _ref$params === void 0 ? {} : _ref$params,
        redirectFrom = _ref.redirectFrom,
        resolver = _ref.resolver;
    var routes = chain.map(function (item) {
      return item.route;
    });
    return {
      baseUrl: resolver && resolver.baseUrl || '',
      pathname: pathname,
      routes: routes,
      route: route || routes.length && routes[routes.length - 1] || null,
      params: params,
      redirectFrom: redirectFrom,
      getUrl: function getUrl() {
        var userParams = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        return getPathnameForRouter(Router.pathToRegexp.compile(getMatchedPath(routes))(Object.assign({}, params, userParams)), resolver);
      }
    };
  }

  function createRedirect(context, pathname) {
    var params = Object.assign({}, context.params);
    return {
      redirect: {
        pathname: pathname,
        from: context.pathname,
        params: params
      }
    };
  }

  function renderComponent(context, component) {
    var element = document.createElement(component);
    element.location = createLocation(context);
    var index = context.chain.map(function (item) {
      return item.route;
    }).indexOf(context.route);
    context.chain[index].element = element;
    return element;
  }

  function runCallbackIfPossible(callback, args, thisArg) {
    if ((0, _utils.isFunction)(callback)) {
      return callback.apply(thisArg, args);
    }
  }

  function amend(amendmentFunction, args, element) {
    return function (amendmentResult) {
      if (amendmentResult && (amendmentResult.cancel || amendmentResult.redirect)) {
        return amendmentResult;
      }

      if (element) {
        return runCallbackIfPossible(element[amendmentFunction], args, element);
      }
    };
  }

  function processNewChildren(newChildren, route) {
    if (!Array.isArray(newChildren) && !(0, _utils.isObject)(newChildren)) {
      throw new Error((0, _utils.log)("Incorrect \"children\" value for the route ".concat(route.path, ": expected array or object, but got ").concat(newChildren)));
    }

    route.__children = [];
    var childRoutes = (0, _utils.toArray)(newChildren);

    for (var i = 0; i < childRoutes.length; i++) {
      (0, _utils.ensureRoute)(childRoutes[i]);

      route.__children.push(childRoutes[i]);
    }
  }

  function removeDomNodes(nodes) {
    if (nodes && nodes.length) {
      var parent = nodes[0].parentNode;

      for (var i = 0; i < nodes.length; i++) {
        parent.removeChild(nodes[i]);
      }
    }
  }

  function getPathnameForRouter(pathname, router) {
    var base = router.__effectiveBaseUrl;
    return base ? router.constructor.__createUrl(pathname.replace(/^\//, ''), base).pathname : pathname;
  }

  function getMatchedPath(chain) {
    return chain.map(function (item) {
      return item.path;
    }).reduce(function (a, b) {
      if (b.length) {
        return a.replace(/\/$/, '') + '/' + b.replace(/^\//, '');
      }

      return a;
    }, '');
  }
  /**
   * A simple client-side router for single-page applications. It uses
   * express-style middleware and has a first-class support for Web Components and
   * lazy-loading. Works great in Polymer and non-Polymer apps.
   *
   * Use `new Router(outlet, options)` to create a new Router instance.
   *
   * * The `outlet` parameter is a reference to the DOM node to render
   *   the content into.
   *
   * * The `options` parameter is an optional object with options. The following
   *   keys are supported:
   *   * `baseUrl` — the initial value for [
   *     the `baseUrl` property
   *   ](#/classes/Vaadin.Router#property-baseUrl)
   *
   * The Router instance is automatically subscribed to navigation events
   * on `window`.
   *
   * See [Live Examples](#/classes/Vaadin.Router/demos/demo/index.html) for the detailed usage demo and code snippets.
   *
   * See also detailed API docs for the following methods, for the advanced usage:
   *
   * * [setOutlet](#/classes/Vaadin.Router#method-setOutlet) – should be used to configure the outlet.
   * * [setTriggers](#/classes/Vaadin.Router#method-setTriggers) – should be used to configure the navigation events.
   * * [setRoutes](#/classes/Vaadin.Router#method-setRoutes) – should be used to configure the routes.
   *
   * Only `setRoutes` has to be called manually, others are automatically invoked when creating a new instance.
   *
   * @memberof Vaadin
   * @extends Vaadin.Resolver
   * @demo demo/index.html
   * @summary JavaScript class that renders different DOM content depending on
   *    a given path. It can re-render when triggered or automatically on
   *    'popstate' and / or 'click' events.
   */


  var Router =
  /*#__PURE__*/
  function (_Resolver) {
    babelHelpers.inherits(Router, _Resolver);

    /**
     * Creates a new Router instance with a given outlet, and
     * automatically subscribes it to navigation events on the `window`.
     * Using a constructor argument or a setter for outlet is equivalent:
     *
     * ```
     * const router = new Vaadin.Router();
     * router.setOutlet(outlet);
     * ```
     * @param {?Node} outlet
     * @param {?RouterOptions} options
     */
    function Router(outlet, options) {
      var _this;

      babelHelpers.classCallCheck(this, Router);
      var baseElement = document.head.querySelector('base');
      _this = babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(Router).call(this, [], Object.assign({
        // Default options
        baseUrl: baseElement && baseElement.getAttribute('href')
      }, options)));

      _this.resolveRoute = function (context) {
        return _this.__resolveRoute(context);
      };

      var triggers = Router.NavigationTrigger;
      Router.setTriggers.apply(Router, Object.keys(triggers).map(function (key) {
        return triggers[key];
      }));
      /**
       * The base URL for all routes in the router instance. By default,
       * takes the `<base href>` attribute value if the base element exists
       * in the `<head>`.
       *
       * @public
       * @type {string}
       */

      _this.baseUrl;
      /**
       * A promise that is settled after the current render cycle completes. If
       * there is no render cycle in progress the promise is immediately settled
       * with the last render cycle result.
       *
       * @public
       * @type {!Promise<!Vaadin.Router.Location>}
       */

      _this.ready;
      _this.ready = Promise.resolve(outlet);
      /**
       * Contains read-only information about the current router location:
       * pathname, active routes, parameters. See the
       * [Location type declaration](#/classes/Vaadin.Router.Location)
       * for more details.
       *
       * @public
       * @type {!Vaadin.Router.Location}
       */

      _this.location;
      _this.location = createLocation({
        resolver: babelHelpers.assertThisInitialized(_this)
      });
      _this.__lastStartedRenderId = 0;
      _this.__navigationEventHandler = _this.__onNavigationEvent.bind(babelHelpers.assertThisInitialized(_this));

      _this.setOutlet(outlet);

      _this.subscribe();

      return _this;
    }

    babelHelpers.createClass(Router, [{
      key: "__resolveRoute",
      value: function __resolveRoute(context) {
        var route = context.route;
        var callbacks = Promise.resolve();

        if ((0, _utils.isFunction)(route.children)) {
          callbacks = callbacks.then(function () {
            return route.children(copyContextWithoutNext(context));
          }).then(function (children) {
            // The route.children() callback might have re-written the
            // route.children property instead of returning a value
            if (!isResultNotEmpty(children) && !(0, _utils.isFunction)(route.children)) {
              children = route.children;
            }

            processNewChildren(children, route);
          });
        }

        var commands = {
          redirect: function redirect(path) {
            return createRedirect(context, path);
          },
          component: function component(_component) {
            return renderComponent(context, _component);
          }
        };
        return callbacks.then(function () {
          return runCallbackIfPossible(route.action, [context, commands], route);
        }).then(function (result) {
          if (isResultNotEmpty(result)) {
            // Actions like `() => import('my-view.js')` are not expected to
            // end the resolution, despite the result is not empty. Checking
            // the result with a whitelist of values that end the resulution.
            if (babelHelpers.instanceof(result, HTMLElement) || result.redirect || result === _utils.notFoundResult) {
              return result;
            }
          }

          if ((0, _utils.isString)(route.redirect)) {
            return commands.redirect(route.redirect);
          }

          if (route.bundle) {
            return (0, _utils.loadBundle)(route.bundle).then(function () {}, function () {
              throw new Error((0, _utils.log)("Bundle not found: ".concat(route.bundle, ". Check if the file name is correct")));
            });
          }
        }).then(function (result) {
          if (isResultNotEmpty(result)) {
            return result;
          }

          if ((0, _utils.isString)(route.component)) {
            return commands.component(route.component);
          }
        });
      }
      /**
       * Sets the router outlet (the DOM node where the content for the current
       * route is inserted). Any content pre-existing in the router outlet is
       * removed at the end of each render pass.
       *
       * NOTE: this method is automatically invoked first time when creating a new Router instance.
       *
       * @param {?Node} outlet the DOM node where the content for the current route
       *     is inserted.
       */

    }, {
      key: "setOutlet",
      value: function setOutlet(outlet) {
        if (outlet) {
          this.__ensureOutlet(outlet);
        }

        this.__outlet = outlet;
      }
      /**
       * Returns the current router outlet. The initial value is `undefined`.
       *
       * @return {?Node} the current router outlet (or `undefined`)
       */

    }, {
      key: "getOutlet",
      value: function getOutlet() {
        return this.__outlet;
      }
      /**
       * Sets the routing config (replacing the existing one) and triggers a
       * navigation event so that the router outlet is refreshed according to the
       * current `window.location` and the new routing config.
       *
       * Each route object may have the following properties, listed here in the processing order:
       * * `path` – the route path (relative to the parent route if any) in the
       * [express.js syntax](https://expressjs.com/en/guide/routing.html#route-paths").
       *
       * * `children` – an array of nested routes or a function that provides this
       * array at the render time. The function can be synchronous or asynchronous:
       * in the latter case the render is delayed until the returned promise is
       * resolved. The `children` function is executed every time when this route is
       * being rendered. This allows for dynamic route structures (e.g. backend-defined),
       * but it might have a performance impact as well. In order to avoid calling
       * the function on subsequent renders, you can override the `children` property
       * of the route object and save the calculated array there
       * (via `context.route.children = [ route1, route2, ...];`).
       * Parent routes are fully resolved before resolving the children. Children
       * 'path' values are relative to the parent ones.
       *
       * * `action` – the action that is executed before the route is resolved.
       * The value for this property should be a function, accepting `context`
       * and `commands` parameters described below. If present, this function is
       * always invoked first, disregarding of the other properties' presence.
       * The action can return a result directly or within a `Promise`, which
       * resolves to the result. If the action result is an `HTMLElement` instance,
       * a `commands.component(name)` result, a `commands.redirect(path)` result,
       * or a `context.next()` result, the current route resolution is finished,
       * and other route config properties are ignored.
       * See also **Route Actions** section in [Live Examples](#/classes/Vaadin.Router/demos/demo/index.html).
       *
       * * `redirect` – other route's path to redirect to. Passes all route parameters to the redirect target.
       * The target route should also be defined.
       * See also **Redirects** section in [Live Examples](#/classes/Vaadin.Router/demos/demo/index.html).
       *
       * * `bundle` – string containing the path to `.js` or `.mjs` bundle to load before resolving the route,
       * or the object with "module" and "nomodule" keys referring to different bundles.
       * Each bundle is only loaded once. If "module" and "nomodule" are set, only one bundle is loaded,
       * depending on whether the browser supports ES modules or not.
       * The property is ignored when either an `action` returns the result or `redirect` property is present.
       * Any error, e.g. 404 while loading bundle will cause route resolution to throw.
       * See also **Code Splitting** section in [Live Examples](#/classes/Vaadin.Router/demos/demo/index.html).
       *
       * * `component` – the tag name of the Web Component to resolve the route to.
       * The property is ignored when either an `action` returns the result or `redirect` property is present.
       * If route contains the `component` property (or an action that return a component)
       * and its child route also contains the `component` property, child route's component
       * will be rendered as a light dom child of a parent component.
       *
       * * `name` – the string name of the route to use in the
       * [`router.urlForName(name, params)`](#/classes/Vaadin.Router#method-urlForName)
       * navigation helper method.
       *
       * For any route function (`action`, `children`) defined, the corresponding `route` object is available inside the callback
       * through the `this` reference. If you need to access it, make sure you define the callback as a non-arrow function
       * because arrow functions do not have their own `this` reference.
       *
       * `context` object that is passed to `action` function holds the following properties:
       * * `context.pathname` – string with the pathname being resolved
       *
       * * `context.params` – object with route parameters
       *
       * * `context.route` – object that holds the route that is currently being rendered.
       *
       * * `context.next()` – function for asynchronously getting the next route
       * contents from the resolution chain (if any)
       *
       * `commands` object that is passed to `action` function has
       * the following methods:
       *
       * * `commands.redirect(path)` – function that creates a redirect data
       * for the path specified.
       *
       * * `commands.component(component)` – function that creates a new HTMLElement
       * with current context
       *
       * @param {!Array<!Object>|!Object} routes a single route or an array of those
       */

    }, {
      key: "setRoutes",
      value: function setRoutes(routes) {
        this.__urlForName = undefined;
        babelHelpers.get(babelHelpers.getPrototypeOf(Router.prototype), "setRoutes", this).call(this, routes);

        this.__onNavigationEvent();
      }
      /**
       * Asynchronously resolves the given pathname and renders the resolved route
       * component into the router outlet. If no router outlet is set at the time of
       * calling this method, or at the time when the route resolution is completed,
       * a `TypeError` is thrown.
       *
       * Returns a promise that is fulfilled with the router outlet DOM Node after
       * the route component is created and inserted into the router outlet, or
       * rejected if no route matches the given path.
       *
       * If another render pass is started before the previous one is completed, the
       * result of the previous render pass is ignored.
       *
       * @param {!string|!{pathname: !string}} pathnameOrContext the pathname to
       *    render or a context object with a `pathname` property and other
       *    properties to pass to the resolver.
       * @return {!Promise<!Node>}
       */

    }, {
      key: "render",
      value: function render(pathnameOrContext, shouldUpdateHistory) {
        var _this2 = this;

        var renderId = ++this.__lastStartedRenderId;
        var pathname = pathnameOrContext.pathname || pathnameOrContext; // Find the first route that resolves to a non-empty result

        this.ready = this.resolve(pathnameOrContext) // Process the result of this.resolve() and handle all special commands:
        // (redirect / prevent / component). If the result is a 'component',
        // then go deeper and build the entire chain of nested components matching
        // the pathname. Also call all 'on before' callbacks along the way.
        .then(function (context) {
          return _this2.__fullyResolveChain(context);
        }).then(function (context) {
          if (renderId === _this2.__lastStartedRenderId) {
            var previousContext = _this2.__previousContext; // Check if the render was prevented and make an early return in that case

            if (context === previousContext) {
              return _this2.location;
            }

            _this2.location = createLocation(context);
            (0, _utils.fireRouterEvent)('location-changed', {
              router: _this2,
              location: _this2.location
            });

            if (shouldUpdateHistory) {
              _this2.__updateBrowserHistory(context.pathname, context.redirectFrom);
            }

            _this2.__addAppearingContent(context, previousContext);

            var animationDone = _this2.__animateIfNeeded(context);

            _this2.__runOnAfterEnterCallbacks(context);

            _this2.__runOnAfterLeaveCallbacks(context, previousContext);

            return animationDone.then(function () {
              if (renderId === _this2.__lastStartedRenderId) {
                // If there is another render pass started after this one,
                // the 'disappearing content' would be removed when the other
                // render pass calls `this.__addAppearingContent()`
                _this2.__removeDisappearingContent();

                _this2.__previousContext = context;
                return _this2.location;
              }
            });
          }
        }).catch(function (error) {
          if (renderId === _this2.__lastStartedRenderId) {
            if (shouldUpdateHistory) {
              _this2.__updateBrowserHistory(pathname);
            }

            removeDomNodes(_this2.__outlet && _this2.__outlet.children);
            _this2.location = createLocation({
              pathname: pathname,
              resolver: _this2
            });
            (0, _utils.fireRouterEvent)('error', {
              router: _this2,
              error: error,
              pathname: pathname
            });
            throw error;
          }
        });
        return this.ready;
      }
    }, {
      key: "__fullyResolveChain",
      value: function __fullyResolveChain(originalContext) {
        var _this3 = this;

        var currentContext = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : originalContext;
        return this.__amendWithResolutionResult(currentContext).then(function (amendedContext) {
          var initialContext = amendedContext !== currentContext ? amendedContext : originalContext;
          return amendedContext.next().then(function (nextContext) {
            if (nextContext === null || nextContext === _utils.notFoundResult) {
              var matchedPath = getPathnameForRouter(getMatchedPath(amendedContext.chain), amendedContext.resolver);

              if (matchedPath !== amendedContext.pathname) {
                throw (0, _utils.getNotFoundError)(initialContext);
              }
            }

            return nextContext && nextContext !== _utils.notFoundResult ? _this3.__fullyResolveChain(initialContext, nextContext) : _this3.__amendWithOnBeforeCallbacks(initialContext);
          });
        });
      }
    }, {
      key: "__amendWithResolutionResult",
      value: function __amendWithResolutionResult(context) {
        var _this4 = this;

        var result = context.result;

        if (babelHelpers.instanceof(result, HTMLElement)) {
          return Promise.resolve(context);
        } else if (result.redirect) {
          return this.__redirect(result.redirect, context.__redirectCount).then(function (context) {
            return _this4.__amendWithResolutionResult(context);
          });
        } else if (babelHelpers.instanceof(result, Error)) {
          return Promise.reject(result);
        } else {
          return Promise.reject(new Error((0, _utils.log)("Invalid route resolution result for path \"".concat(context.pathname, "\". ") + "Expected redirect object or HTML element, but got: \"".concat((0, _utils.logValue)(result), "\". ") + "Double check the action return value for the route.")));
        }
      }
    }, {
      key: "__amendWithOnBeforeCallbacks",
      value: function __amendWithOnBeforeCallbacks(contextWithFullChain) {
        var _this5 = this;

        return this.__runOnBeforeCallbacks(contextWithFullChain).then(function (amendedContext) {
          if (amendedContext === _this5.__previousContext || amendedContext === contextWithFullChain) {
            return amendedContext;
          }

          return _this5.__fullyResolveChain(amendedContext);
        });
      }
    }, {
      key: "__runOnBeforeCallbacks",
      value: function __runOnBeforeCallbacks(newContext) {
        var _this6 = this;

        var previousContext = this.__previousContext || {};
        var previousChain = previousContext.chain || [];
        var newChain = newContext.chain;
        var callbacks = Promise.resolve();

        var prevent = function prevent() {
          return {
            cancel: true
          };
        };

        var redirect = function redirect(pathname) {
          return createRedirect(newContext, pathname);
        };

        newContext.__divergedChainIndex = 0;

        if (previousChain.length) {
          for (var i = 0; i < Math.min(previousChain.length, newChain.length); i = ++newContext.__divergedChainIndex) {
            if (previousChain[i].route !== newChain[i].route || previousChain[i].path !== newChain[i].path || (previousChain[i].element && previousChain[i].element.localName) !== (newChain[i].element && newChain[i].element.localName)) {
              break;
            }
          }

          for (var _i = previousChain.length - 1; _i >= newContext.__divergedChainIndex; _i--) {
            var location = createLocation(newContext);
            callbacks = callbacks.then(amend('onBeforeLeave', [location, {
              prevent: prevent
            }, this], previousChain[_i].element)).then(function (result) {
              if (!(result || {}).redirect) {
                return result;
              }
            });
          }
        }

        for (var _i2 = newContext.__divergedChainIndex; _i2 < newChain.length; _i2++) {
          var _location = createLocation(newContext, newChain[_i2].route);

          callbacks = callbacks.then(amend('onBeforeEnter', [_location, {
            prevent: prevent,
            redirect: redirect
          }, this], newChain[_i2].element));
        }

        return callbacks.then(function (amendmentResult) {
          if (amendmentResult) {
            if (amendmentResult.cancel) {
              return _this6.__previousContext;
            }

            if (amendmentResult.redirect) {
              return _this6.__redirect(amendmentResult.redirect, newContext.__redirectCount);
            }
          }

          return newContext;
        });
      }
    }, {
      key: "__redirect",
      value: function __redirect(redirectData, counter) {
        if (counter > MAX_REDIRECT_COUNT) {
          throw new Error((0, _utils.log)("Too many redirects when rendering ".concat(redirectData.from)));
        }

        return this.resolve({
          pathname: this.urlForPath(redirectData.pathname, redirectData.params),
          redirectFrom: redirectData.from,
          __redirectCount: (counter || 0) + 1
        });
      }
    }, {
      key: "__ensureOutlet",
      value: function __ensureOutlet() {
        var outlet = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.__outlet;

        if (!babelHelpers.instanceof(outlet, Node)) {
          throw new TypeError((0, _utils.log)("Expected router outlet to be a valid DOM Node (but got ".concat(outlet, ")")));
        }
      }
    }, {
      key: "__updateBrowserHistory",
      value: function __updateBrowserHistory(pathname, replace) {
        if (window.location.pathname !== pathname) {
          var changeState = replace ? 'replaceState' : 'pushState';
          window.history[changeState](null, document.title, pathname);
          window.dispatchEvent(new PopStateEvent('popstate', {
            state: 'vaadin-router-ignore'
          }));
        }
      }
    }, {
      key: "__addAppearingContent",
      value: function __addAppearingContent(context, previousContext) {
        this.__ensureOutlet(); // If the previous 'entering' animation has not completed yet,
        // stop it and remove that content from the DOM before adding new one.


        this.__removeAppearingContent(); // Find the deepest common parent between the last and the new component
        // chains. Update references for the unchanged elements in the new chain


        var deepestCommonParent = this.__outlet;

        for (var i = 0; i < context.__divergedChainIndex; i++) {
          var unchangedElement = previousContext && previousContext.chain[i].element;

          if (unchangedElement) {
            if (unchangedElement.parentNode === deepestCommonParent) {
              context.chain[i].element = unchangedElement;
              deepestCommonParent = unchangedElement;
            } else {
              break;
            }
          }
        } // Keep two lists of DOM elements:
        //  - those that should be removed once the transition animation is over
        //  - and those that should remain


        this.__disappearingContent = Array.from(deepestCommonParent.children);
        this.__appearingContent = []; // Add new elements (starting after the deepest common parent) to the DOM.
        // That way only the components that are actually different between the two
        // locations are added to the DOM (and those that are common remain in the
        // DOM without first removing and then adding them again).

        var parentElement = deepestCommonParent;

        for (var _i3 = context.__divergedChainIndex; _i3 < context.chain.length; _i3++) {
          var elementToAdd = context.chain[_i3].element;

          if (elementToAdd) {
            parentElement.appendChild(elementToAdd);

            if (parentElement === deepestCommonParent) {
              this.__appearingContent.push(elementToAdd);
            }

            parentElement = elementToAdd;
          }
        }
      }
    }, {
      key: "__removeDisappearingContent",
      value: function __removeDisappearingContent() {
        if (this.__disappearingContent) {
          removeDomNodes(this.__disappearingContent);
        }

        this.__disappearingContent = null;
        this.__appearingContent = null;
      }
    }, {
      key: "__removeAppearingContent",
      value: function __removeAppearingContent() {
        if (this.__disappearingContent && this.__appearingContent) {
          removeDomNodes(this.__appearingContent);
          this.__disappearingContent = null;
          this.__appearingContent = null;
        }
      }
    }, {
      key: "__runOnAfterLeaveCallbacks",
      value: function __runOnAfterLeaveCallbacks(currentContext, targetContext) {
        if (!targetContext) {
          return;
        } // REVERSE iteration: from Z to A


        for (var i = targetContext.chain.length - 1; i >= currentContext.__divergedChainIndex; i--) {
          var currentComponent = targetContext.chain[i].element;

          if (!currentComponent) {
            continue;
          }

          try {
            var location = createLocation(currentContext);
            runCallbackIfPossible(currentComponent.onAfterLeave, [location, {}, targetContext.resolver], currentComponent);
          } finally {
            removeDomNodes(currentComponent.children);
          }
        }
      }
    }, {
      key: "__runOnAfterEnterCallbacks",
      value: function __runOnAfterEnterCallbacks(currentContext) {
        // forward iteration: from A to Z
        for (var i = currentContext.__divergedChainIndex; i < currentContext.chain.length; i++) {
          var currentComponent = currentContext.chain[i].element || {};
          var location = createLocation(currentContext, currentContext.chain[i].route);
          runCallbackIfPossible(currentComponent.onAfterEnter, [location, {}, currentContext.resolver], currentComponent);
        }
      }
    }, {
      key: "__animateIfNeeded",
      value: function __animateIfNeeded(context) {
        var from = (this.__disappearingContent || [])[0];
        var to = (this.__appearingContent || [])[0];
        var promises = [];
        var chain = context.chain;
        var config;

        for (var i = chain.length; i > 0; i--) {
          if (chain[i - 1].route.animate) {
            config = chain[i - 1].route.animate;
            break;
          }
        }

        if (from && to && config) {
          var leave = (0, _utils.isObject)(config) && config.leave || 'leaving';
          var enter = (0, _utils.isObject)(config) && config.enter || 'entering';
          promises.push((0, _animate.default)(from, leave));
          promises.push((0, _animate.default)(to, enter));
        }

        return Promise.all(promises).then(function () {
          return context;
        });
      }
      /**
       * Subscribes this instance to navigation events on the `window`.
       *
       * NOTE: beware of resource leaks. For as long as a router instance is
       * subscribed to navigation events, it won't be garbage collected.
       */

    }, {
      key: "subscribe",
      value: function subscribe() {
        window.addEventListener('vaadin-router-go', this.__navigationEventHandler);
      }
      /**
       * Removes the subscription to navigation events created in the `subscribe()`
       * method.
       */

    }, {
      key: "unsubscribe",
      value: function unsubscribe() {
        window.removeEventListener('vaadin-router-go', this.__navigationEventHandler);
      }
    }, {
      key: "__onNavigationEvent",
      value: function __onNavigationEvent(event) {
        var pathname = event ? event.detail.pathname : window.location.pathname;

        if ((0, _utils.isString)(this.__normalizePathname(pathname))) {
          if (event && event.preventDefault) {
            event.preventDefault();
          }

          this.render(pathname, true);
        }
      }
      /**
       * Configures what triggers Vaadin.Router navigation events:
       *  - `POPSTATE`: popstate events on the current `window`
       *  - `CLICK`: click events on `<a>` links leading to the current page
       *
       * This method is invoked with the pre-configured values when creating a new Router instance.
       * By default, both `POPSTATE` and `CLICK` are enabled. This setup is expected to cover most of the use cases.
       *
       * See the `router-config.js` for the default navigation triggers config. Based on it, you can
       * create the own one and only import the triggers you need, instead of pulling in all the code,
       * e.g. if you want to handle `click` differently.
       *
       * See also **Navigation Triggers** section in [Live Examples](#/classes/Vaadin.Router/demos/demo/index.html).
       *
       * @param {...NavigationTrigger} triggers
       */

    }, {
      key: "urlForName",

      /**
       * Generates a URL for the route with the given name, optionally performing
       * substitution of parameters.
       *
       * The route is searched in all the Vaadin.Router instances subscribed to
       * navigation events.
       *
       * **Note:** For child route names, only array children are considered.
       * It is not possible to generate URLs using a name for routes set with
       * a children function.
       *
       * @function urlForName
       * @param {!string} name the route name or the route’s `component` name.
       * @param {?Object} params Optional object with route path parameters.
       * Named parameters are passed by name (`params[name] = value`), unnamed
       * parameters are passed by index (`params[index] = value`).
       *
       * @return {string}
       */
      value: function urlForName(name, params) {
        if (!this.__urlForName) {
          this.__urlForName = (0, _generateUrls.default)(this);
        }

        return getPathnameForRouter(this.__urlForName(name, params), this);
      }
      /**
       * Generates a URL for the given route path, optionally performing
       * substitution of parameters.
       *
       * @param {!string} path string route path declared in [express.js syntax](https://expressjs.com/en/guide/routing.html#route-paths").
       * @param {?Object} params Optional object with route path parameters.
       * Named parameters are passed by name (`params[name] = value`), unnamed
       * parameters are passed by index (`params[index] = value`).
       *
       * @return {string}
       */

    }, {
      key: "urlForPath",
      value: function urlForPath(path, params) {
        return getPathnameForRouter(Router.pathToRegexp.compile(path)(params), this);
      }
      /**
       * Triggers navigation to a new path. Returns a boolean without waiting until
       * the navigation is complete. Returns `true` if at least one `Vaadin.Router`
       * has handled the navigation (was subscribed and had `baseUrl` matching
       * the `pathname` argument), otherwise returns `false`.
       *
       * @param {!string} pathname a new in-app path
       * @return {boolean}
       */

    }], [{
      key: "setTriggers",
      value: function setTriggers() {
        for (var _len = arguments.length, triggers = new Array(_len), _key = 0; _key < _len; _key++) {
          triggers[_key] = arguments[_key];
        }

        (0, _setNavigationTriggers.default)(triggers);
      }
    }, {
      key: "go",
      value: function go(pathname) {
        return (0, _utils.fireRouterEvent)('go', {
          pathname: pathname
        });
      }
    }]);
    return Router;
  }(_resolver.default);

  _exports.Router = Router;
});