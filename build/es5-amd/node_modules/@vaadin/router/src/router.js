define(["exports", "./resolver/resolver.js", "./resolver/generateUrls.js", "./triggers/setNavigationTriggers.js", "./transitions/animate.js", "./utils.js"], function (_exports, _resolver, _generateUrls, _setNavigationTriggers, _animate, _utils) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.Router = void 0;
  _resolver = babelHelpers.interopRequireDefault(_resolver);
  _generateUrls = babelHelpers.interopRequireDefault(_generateUrls);
  _setNavigationTriggers = babelHelpers.interopRequireDefault(_setNavigationTriggers);
  _animate = babelHelpers.interopRequireDefault(_animate);

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var MAX_REDIRECT_COUNT = 256;

  function isResultNotEmpty(result) {
    return result !== null && result !== undefined;
  }

  function copyContextWithoutNext(context) {
    var copy = Object.assign({}, context);
    delete copy.next;
    return copy;
  }

  function createLocation(_ref, route) {
    var _ref$pathname = _ref.pathname,
        pathname = _ref$pathname === void 0 ? '' : _ref$pathname,
        _ref$search = _ref.search,
        search = _ref$search === void 0 ? '' : _ref$search,
        _ref$hash = _ref.hash,
        hash = _ref$hash === void 0 ? '' : _ref$hash,
        _ref$chain = _ref.chain,
        chain = _ref$chain === void 0 ? [] : _ref$chain,
        _ref$params = _ref.params,
        params = _ref$params === void 0 ? {} : _ref$params,
        redirectFrom = _ref.redirectFrom,
        resolver = _ref.resolver;
    var routes = chain.map(function (item) {
      return item.route;
    });
    return {
      baseUrl: resolver && resolver.baseUrl || '',
      pathname: pathname,
      search: search,
      hash: hash,
      routes: routes,
      route: route || routes.length && routes[routes.length - 1] || null,
      params: params,
      redirectFrom: redirectFrom,
      getUrl: function getUrl() {
        var userParams = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        return getPathnameForRouter(Router.pathToRegexp.compile(getMatchedPath(routes))(Object.assign({}, params, userParams)), resolver);
      }
    };
  }

  function createRedirect(context, pathname) {
    var params = Object.assign({}, context.params);
    return {
      redirect: {
        pathname: pathname,
        from: context.pathname,
        params: params
      }
    };
  }

  function renderElement(context, element) {
    element.location = createLocation(context);
    var index = context.chain.map(function (item) {
      return item.route;
    }).indexOf(context.route);
    context.chain[index].element = element;
    return element;
  }

  function runCallbackIfPossible(callback, args, thisArg) {
    if ((0, _utils.isFunction)(callback)) {
      return callback.apply(thisArg, args);
    }
  }

  function amend(amendmentFunction, args, element) {
    return function (amendmentResult) {
      if (amendmentResult && (amendmentResult.cancel || amendmentResult.redirect)) {
        return amendmentResult;
      }

      if (element) {
        return runCallbackIfPossible(element[amendmentFunction], args, element);
      }
    };
  }

  function processNewChildren(newChildren, route) {
    if (!Array.isArray(newChildren) && !(0, _utils.isObject)(newChildren)) {
      throw new Error((0, _utils.log)("Incorrect \"children\" value for the route ".concat(route.path, ": expected array or object, but got ").concat(newChildren)));
    }

    route.__children = [];
    var childRoutes = (0, _utils.toArray)(newChildren);

    for (var i = 0; i < childRoutes.length; i++) {
      (0, _utils.ensureRoute)(childRoutes[i]);

      route.__children.push(childRoutes[i]);
    }
  }

  function removeDomNodes(nodes) {
    if (nodes && nodes.length) {
      var parent = nodes[0].parentNode;

      for (var i = 0; i < nodes.length; i++) {
        parent.removeChild(nodes[i]);
      }
    }
  }

  function getPathnameForRouter(pathname, router) {
    var base = router.__effectiveBaseUrl;
    return base ? router.constructor.__createUrl(pathname.replace(/^\//, ''), base).pathname : pathname;
  }

  function getMatchedPath(chain) {
    return chain.map(function (item) {
      return item.path;
    }).reduce(function (a, b) {
      if (b.length) {
        return a.replace(/\/$/, '') + '/' + b.replace(/^\//, '');
      }

      return a;
    }, '');
  }
  /**
   * A simple client-side router for single-page applications. It uses
   * express-style middleware and has a first-class support for Web Components and
   * lazy-loading. Works great in Polymer and non-Polymer apps.
   *
   * Use `new Router(outlet, options)` to create a new Router instance.
   *
   * * The `outlet` parameter is a reference to the DOM node to render
   *   the content into.
   *
   * * The `options` parameter is an optional object with options. The following
   *   keys are supported:
   *   * `baseUrl` — the initial value for [
   *     the `baseUrl` property
   *   ](#/classes/Router#property-baseUrl)
   *
   * The Router instance is automatically subscribed to navigation events
   * on `window`.
   *
   * See [Live Examples](#/classes/Router/demos/demo/index.html) for the detailed usage demo and code snippets.
   *
   * See also detailed API docs for the following methods, for the advanced usage:
   *
   * * [setOutlet](#/classes/Router#method-setOutlet) – should be used to configure the outlet.
   * * [setTriggers](#/classes/Router#method-setTriggers) – should be used to configure the navigation events.
   * * [setRoutes](#/classes/Router#method-setRoutes) – should be used to configure the routes.
   *
   * Only `setRoutes` has to be called manually, others are automatically invoked when creating a new instance.
   *
   * @extends Resolver
   * @demo demo/index.html
   * @summary JavaScript class that renders different DOM content depending on
   *    a given path. It can re-render when triggered or automatically on
   *    'popstate' and / or 'click' events.
   */


  var Router = /*#__PURE__*/function (_Resolver) {
    babelHelpers.inherits(Router, _Resolver);

    var _super = _createSuper(Router);

    /**
     * Creates a new Router instance with a given outlet, and
     * automatically subscribes it to navigation events on the `window`.
     * Using a constructor argument or a setter for outlet is equivalent:
     *
     * ```
     * const router = new Router();
     * router.setOutlet(outlet);
     * ```
     * @param {?Node=} outlet
     * @param {?RouterOptions=} options
     */
    function Router(outlet, options) {
      var _this;

      babelHelpers.classCallCheck(this, Router);
      var baseElement = document.head.querySelector('base');
      var baseHref = baseElement && baseElement.getAttribute('href');
      _this = _super.call(this, [], Object.assign({
        // Default options
        baseUrl: baseHref && _resolver.default.__createUrl(baseHref, document.URL).pathname.replace(/[^\/]*$/, '')
      }, options));

      _this.resolveRoute = function (context) {
        return _this.__resolveRoute(context);
      };

      var triggers = Router.NavigationTrigger;
      Router.setTriggers.apply(Router, Object.keys(triggers).map(function (key) {
        return triggers[key];
      }));
      /**
       * The base URL for all routes in the router instance. By default,
       * if the base element exists in the `<head>`, vaadin-router
       * takes the `<base href>` attribute value, resolves against current `document.URL`
       * and gets the `pathname` from the result.
       *
       * @public
       * @type {string}
       */

      _this.baseUrl;
      /**
       * A promise that is settled after the current render cycle completes. If
       * there is no render cycle in progress the promise is immediately settled
       * with the last render cycle result.
       *
       * @public
       * @type {!Promise<!RouterLocation>}
       */

      _this.ready;
      _this.ready = Promise.resolve(outlet);
      /**
       * Contains read-only information about the current router location:
       * pathname, active routes, parameters. See the
       * [Location type declaration](#/classes/RouterLocation)
       * for more details.
       *
       * @public
       * @type {!RouterLocation}
       */

      _this.location;
      _this.location = createLocation({
        resolver: babelHelpers.assertThisInitialized(_this)
      });
      _this.__lastStartedRenderId = 0;
      _this.__navigationEventHandler = _this.__onNavigationEvent.bind(babelHelpers.assertThisInitialized(_this));

      _this.setOutlet(outlet);

      _this.subscribe(); // Using WeakMap instead of WeakSet because WeakSet is not supported by IE11


      _this.__createdByRouter = new WeakMap();
      _this.__addedByRouter = new WeakMap();
      return _this;
    }

    babelHelpers.createClass(Router, [{
      key: "__resolveRoute",
      value: function __resolveRoute(context) {
        var _this2 = this;

        var route = context.route;
        var callbacks = Promise.resolve();

        if ((0, _utils.isFunction)(route.children)) {
          callbacks = callbacks.then(function () {
            return route.children(copyContextWithoutNext(context));
          }).then(function (children) {
            // The route.children() callback might have re-written the
            // route.children property instead of returning a value
            if (!isResultNotEmpty(children) && !(0, _utils.isFunction)(route.children)) {
              children = route.children;
            }

            processNewChildren(children, route);
          });
        }

        var commands = {
          redirect: function redirect(path) {
            return createRedirect(context, path);
          },
          component: function component(_component) {
            var element = document.createElement(_component);

            _this2.__createdByRouter.set(element, true);

            return element;
          }
        };
        return callbacks.then(function () {
          if (_this2.__isLatestRender(context)) {
            return runCallbackIfPossible(route.action, [context, commands], route);
          }
        }).then(function (result) {
          if (isResultNotEmpty(result)) {
            // Actions like `() => import('my-view.js')` are not expected to
            // end the resolution, despite the result is not empty. Checking
            // the result with a whitelist of values that end the resolution.
            if (babelHelpers.instanceof(result, HTMLElement) || result.redirect || result === _utils.notFoundResult) {
              return result;
            }
          }

          if ((0, _utils.isString)(route.redirect)) {
            return commands.redirect(route.redirect);
          }

          if (route.bundle) {
            return (0, _utils.loadBundle)(route.bundle).then(function () {}, function () {
              throw new Error((0, _utils.log)("Bundle not found: ".concat(route.bundle, ". Check if the file name is correct")));
            });
          }
        }).then(function (result) {
          if (isResultNotEmpty(result)) {
            return result;
          }

          if ((0, _utils.isString)(route.component)) {
            return commands.component(route.component);
          }
        });
      }
      /**
       * Sets the router outlet (the DOM node where the content for the current
       * route is inserted). Any content pre-existing in the router outlet is
       * removed at the end of each render pass.
       *
       * NOTE: this method is automatically invoked first time when creating a new Router instance.
       *
       * @param {?Node} outlet the DOM node where the content for the current route
       *     is inserted.
       */

    }, {
      key: "setOutlet",
      value: function setOutlet(outlet) {
        if (outlet) {
          this.__ensureOutlet(outlet);
        }

        this.__outlet = outlet;
      }
      /**
       * Returns the current router outlet. The initial value is `undefined`.
       *
       * @return {?Node} the current router outlet (or `undefined`)
       */

    }, {
      key: "getOutlet",
      value: function getOutlet() {
        return this.__outlet;
      }
      /**
       * Sets the routing config (replacing the existing one) and triggers a
       * navigation event so that the router outlet is refreshed according to the
       * current `window.location` and the new routing config.
       *
       * Each route object may have the following properties, listed here in the processing order:
       * * `path` – the route path (relative to the parent route if any) in the
       * [express.js syntax](https://expressjs.com/en/guide/routing.html#route-paths").
       *
       * * `children` – an array of nested routes or a function that provides this
       * array at the render time. The function can be synchronous or asynchronous:
       * in the latter case the render is delayed until the returned promise is
       * resolved. The `children` function is executed every time when this route is
       * being rendered. This allows for dynamic route structures (e.g. backend-defined),
       * but it might have a performance impact as well. In order to avoid calling
       * the function on subsequent renders, you can override the `children` property
       * of the route object and save the calculated array there
       * (via `context.route.children = [ route1, route2, ...];`).
       * Parent routes are fully resolved before resolving the children. Children
       * 'path' values are relative to the parent ones.
       *
       * * `action` – the action that is executed before the route is resolved.
       * The value for this property should be a function, accepting `context`
       * and `commands` parameters described below. If present, this function is
       * always invoked first, disregarding of the other properties' presence.
       * The action can return a result directly or within a `Promise`, which
       * resolves to the result. If the action result is an `HTMLElement` instance,
       * a `commands.component(name)` result, a `commands.redirect(path)` result,
       * or a `context.next()` result, the current route resolution is finished,
       * and other route config properties are ignored.
       * See also **Route Actions** section in [Live Examples](#/classes/Router/demos/demo/index.html).
       *
       * * `redirect` – other route's path to redirect to. Passes all route parameters to the redirect target.
       * The target route should also be defined.
       * See also **Redirects** section in [Live Examples](#/classes/Router/demos/demo/index.html).
       *
       * * `bundle` – string containing the path to `.js` or `.mjs` bundle to load before resolving the route,
       * or the object with "module" and "nomodule" keys referring to different bundles.
       * Each bundle is only loaded once. If "module" and "nomodule" are set, only one bundle is loaded,
       * depending on whether the browser supports ES modules or not.
       * The property is ignored when either an `action` returns the result or `redirect` property is present.
       * Any error, e.g. 404 while loading bundle will cause route resolution to throw.
       * See also **Code Splitting** section in [Live Examples](#/classes/Router/demos/demo/index.html).
       *
       * * `component` – the tag name of the Web Component to resolve the route to.
       * The property is ignored when either an `action` returns the result or `redirect` property is present.
       * If route contains the `component` property (or an action that return a component)
       * and its child route also contains the `component` property, child route's component
       * will be rendered as a light dom child of a parent component.
       *
       * * `name` – the string name of the route to use in the
       * [`router.urlForName(name, params)`](#/classes/Router#method-urlForName)
       * navigation helper method.
       *
       * For any route function (`action`, `children`) defined, the corresponding `route` object is available inside the callback
       * through the `this` reference. If you need to access it, make sure you define the callback as a non-arrow function
       * because arrow functions do not have their own `this` reference.
       *
       * `context` object that is passed to `action` function holds the following properties:
       * * `context.pathname` – string with the pathname being resolved
       *
       * * `context.search` – search query string
       *
       * * `context.hash` – hash string
       *
       * * `context.params` – object with route parameters
       *
       * * `context.route` – object that holds the route that is currently being rendered.
       *
       * * `context.next()` – function for asynchronously getting the next route
       * contents from the resolution chain (if any)
       *
       * `commands` object that is passed to `action` function has
       * the following methods:
       *
       * * `commands.redirect(path)` – function that creates a redirect data
       * for the path specified.
       *
       * * `commands.component(component)` – function that creates a new HTMLElement
       * with current context. Note: the component created by this function is reused if visiting the same path twice in row.
       *
       *
       * @param {!Array<!Route>|!Route} routes a single route or an array of those
       * @param {?boolean} skipRender configure the router but skip rendering the
       *     route corresponding to the current `window.location` values
       *
       * @return {!Promise<!Node>}
       */

    }, {
      key: "setRoutes",
      value: function setRoutes(routes) {
        var skipRender = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        this.__previousContext = undefined;
        this.__urlForName = undefined;
        babelHelpers.get(babelHelpers.getPrototypeOf(Router.prototype), "setRoutes", this).call(this, routes);

        if (!skipRender) {
          this.__onNavigationEvent();
        }

        return this.ready;
      }
      /**
       * Asynchronously resolves the given pathname and renders the resolved route
       * component into the router outlet. If no router outlet is set at the time of
       * calling this method, or at the time when the route resolution is completed,
       * a `TypeError` is thrown.
       *
       * Returns a promise that is fulfilled with the router outlet DOM Node after
       * the route component is created and inserted into the router outlet, or
       * rejected if no route matches the given path.
       *
       * If another render pass is started before the previous one is completed, the
       * result of the previous render pass is ignored.
       *
       * @param {!string|!{pathname: !string, search: ?string, hash: ?string}} pathnameOrContext
       *    the pathname to render or a context object with a `pathname` property,
       *    optional `search` and `hash` properties, and other properties
       *    to pass to the resolver.
       * @param {boolean=} shouldUpdateHistory
       *    update browser history with the rendered location
       * @return {!Promise<!Node>}
       */

    }, {
      key: "render",
      value: function render(pathnameOrContext, shouldUpdateHistory) {
        var _this3 = this;

        var renderId = ++this.__lastStartedRenderId;
        var context = Object.assign({
          search: '',
          hash: ''
        }, (0, _utils.isString)(pathnameOrContext) ? {
          pathname: pathnameOrContext
        } : pathnameOrContext, {
          __renderId: renderId
        }); // Find the first route that resolves to a non-empty result

        this.ready = this.resolve(context) // Process the result of this.resolve() and handle all special commands:
        // (redirect / prevent / component). If the result is a 'component',
        // then go deeper and build the entire chain of nested components matching
        // the pathname. Also call all 'on before' callbacks along the way.
        .then(function (context) {
          return _this3.__fullyResolveChain(context);
        }).then(function (context) {
          if (_this3.__isLatestRender(context)) {
            var previousContext = _this3.__previousContext; // Check if the render was prevented and make an early return in that case

            if (context === previousContext) {
              // Replace the history with the previous context
              // to make sure the URL stays the same.
              _this3.__updateBrowserHistory(previousContext, true);

              return _this3.location;
            }

            _this3.location = createLocation(context);

            if (shouldUpdateHistory) {
              // Replace only if first render redirects, so that we don’t leave
              // the redirecting record in the history
              _this3.__updateBrowserHistory(context, renderId === 1);
            }

            (0, _utils.fireRouterEvent)('location-changed', {
              router: _this3,
              location: _this3.location
            }); // Skip detaching/re-attaching there are no render changes

            if (context.__skipAttach) {
              _this3.__copyUnchangedElements(context, previousContext);

              _this3.__previousContext = context;
              return _this3.location;
            }

            _this3.__addAppearingContent(context, previousContext);

            var animationDone = _this3.__animateIfNeeded(context);

            _this3.__runOnAfterEnterCallbacks(context);

            _this3.__runOnAfterLeaveCallbacks(context, previousContext);

            return animationDone.then(function () {
              if (_this3.__isLatestRender(context)) {
                // If there is another render pass started after this one,
                // the 'disappearing content' would be removed when the other
                // render pass calls `this.__addAppearingContent()`
                _this3.__removeDisappearingContent();

                _this3.__previousContext = context;
                return _this3.location;
              }
            });
          }
        }).catch(function (error) {
          if (renderId === _this3.__lastStartedRenderId) {
            if (shouldUpdateHistory) {
              _this3.__updateBrowserHistory(context);
            }

            removeDomNodes(_this3.__outlet && _this3.__outlet.children);
            _this3.location = createLocation(Object.assign(context, {
              resolver: _this3
            }));
            (0, _utils.fireRouterEvent)('error', Object.assign({
              router: _this3,
              error: error
            }, context));
            throw error;
          }
        });
        return this.ready;
      } // `topOfTheChainContextBeforeRedirects` is a context coming from Resolver.resolve().
      // It would contain a 'redirect' route or the first 'component' route that
      // matched the pathname. There might be more child 'component' routes to be
      // resolved and added into the chain. This method would find and add them.
      // `contextBeforeRedirects` is the context containing such a child component
      // route. It's only necessary when this method is called recursively (otherwise
      // it's the same as the 'top of the chain' context).
      //
      // Apart from building the chain of child components, this method would also
      // handle 'redirect' routes, call 'onBefore' callbacks and handle 'prevent'
      // and 'redirect' callback results.

    }, {
      key: "__fullyResolveChain",
      value: function __fullyResolveChain(topOfTheChainContextBeforeRedirects) {
        var _this4 = this;

        var contextBeforeRedirects = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : topOfTheChainContextBeforeRedirects;
        return this.__findComponentContextAfterAllRedirects(contextBeforeRedirects) // `contextAfterRedirects` is always a context with an `HTMLElement` result
        // In other cases the promise gets rejected and .then() is not called
        .then(function (contextAfterRedirects) {
          var redirectsHappened = contextAfterRedirects !== contextBeforeRedirects;
          var topOfTheChainContextAfterRedirects = redirectsHappened ? contextAfterRedirects : topOfTheChainContextBeforeRedirects;
          var matchedPath = getPathnameForRouter(getMatchedPath(contextAfterRedirects.chain), contextAfterRedirects.resolver);
          var isFound = matchedPath === contextAfterRedirects.pathname; // Recursive method to try matching more child and sibling routes

          var findNextContextIfAny = function findNextContextIfAny(context) {
            var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : context.route;
            var prevResult = arguments.length > 2 ? arguments[2] : undefined;
            return context.next(undefined, parent, prevResult).then(function (nextContext) {
              if (nextContext === null || nextContext === _utils.notFoundResult) {
                // Next context is not found in children, ...
                if (isFound) {
                  // ...but original context is already fully matching - use it
                  return context;
                } else if (parent.parent !== null) {
                  // ...and there is no full match yet - step up to check siblings
                  return findNextContextIfAny(context, parent.parent, nextContext);
                } else {
                  return nextContext;
                }
              }

              return nextContext;
            });
          };

          return findNextContextIfAny(contextAfterRedirects).then(function (nextContext) {
            if (nextContext === null || nextContext === _utils.notFoundResult) {
              throw (0, _utils.getNotFoundError)(topOfTheChainContextAfterRedirects);
            }

            return nextContext && nextContext !== _utils.notFoundResult && nextContext !== contextAfterRedirects ? _this4.__fullyResolveChain(topOfTheChainContextAfterRedirects, nextContext) : _this4.__amendWithOnBeforeCallbacks(contextAfterRedirects);
          });
        });
      }
    }, {
      key: "__findComponentContextAfterAllRedirects",
      value: function __findComponentContextAfterAllRedirects(context) {
        var _this5 = this;

        var result = context.result;

        if (babelHelpers.instanceof(result, HTMLElement)) {
          renderElement(context, result);
          return Promise.resolve(context);
        } else if (result.redirect) {
          return this.__redirect(result.redirect, context.__redirectCount, context.__renderId).then(function (context) {
            return _this5.__findComponentContextAfterAllRedirects(context);
          });
        } else if (babelHelpers.instanceof(result, Error)) {
          return Promise.reject(result);
        } else {
          return Promise.reject(new Error((0, _utils.log)("Invalid route resolution result for path \"".concat(context.pathname, "\". ") + "Expected redirect object or HTML element, but got: \"".concat((0, _utils.logValue)(result), "\". ") + "Double check the action return value for the route.")));
        }
      }
    }, {
      key: "__amendWithOnBeforeCallbacks",
      value: function __amendWithOnBeforeCallbacks(contextWithFullChain) {
        var _this6 = this;

        return this.__runOnBeforeCallbacks(contextWithFullChain).then(function (amendedContext) {
          if (amendedContext === _this6.__previousContext || amendedContext === contextWithFullChain) {
            return amendedContext;
          }

          return _this6.__fullyResolveChain(amendedContext);
        });
      }
    }, {
      key: "__runOnBeforeCallbacks",
      value: function __runOnBeforeCallbacks(newContext) {
        var _this7 = this;

        var previousContext = this.__previousContext || {};
        var previousChain = previousContext.chain || [];
        var newChain = newContext.chain;
        var callbacks = Promise.resolve();

        var prevent = function prevent() {
          return {
            cancel: true
          };
        };

        var redirect = function redirect(pathname) {
          return createRedirect(newContext, pathname);
        };

        newContext.__divergedChainIndex = 0;
        newContext.__skipAttach = false;

        if (previousChain.length) {
          for (var i = 0; i < Math.min(previousChain.length, newChain.length); i = ++newContext.__divergedChainIndex) {
            if (previousChain[i].route !== newChain[i].route || previousChain[i].path !== newChain[i].path && previousChain[i].element !== newChain[i].element || !this.__isReusableElement(previousChain[i].element, newChain[i].element)) {
              break;
            }
          } // Skip re-attaching and notifications if element and chain do not change


          newContext.__skipAttach = // Same route chain
          newChain.length === previousChain.length && newContext.__divergedChainIndex == newChain.length && // Same element
          this.__isReusableElement(newContext.result, previousContext.result);

          if (newContext.__skipAttach) {
            // execute onBeforeLeave for changed segment element when skipping attach
            for (var _i = newChain.length - 1; _i >= 0; _i--) {
              callbacks = this.__runOnBeforeLeaveCallbacks(callbacks, newContext, {
                prevent: prevent
              }, previousChain[_i]);
            } // execute onBeforeEnter for changed segment element when skipping attach


            for (var _i2 = 0; _i2 < newChain.length; _i2++) {
              callbacks = this.__runOnBeforeEnterCallbacks(callbacks, newContext, {
                prevent: prevent,
                redirect: redirect
              }, newChain[_i2]);
              previousChain[_i2].element.location = createLocation(newContext, previousChain[_i2].route);
            }
          } else {
            // execute onBeforeLeave when NOT skipping attach
            for (var _i3 = previousChain.length - 1; _i3 >= newContext.__divergedChainIndex; _i3--) {
              callbacks = this.__runOnBeforeLeaveCallbacks(callbacks, newContext, {
                prevent: prevent
              }, previousChain[_i3]);
            }
          }
        } // execute onBeforeEnter when NOT skipping attach


        if (!newContext.__skipAttach) {
          for (var _i4 = 0; _i4 < newChain.length; _i4++) {
            if (_i4 < newContext.__divergedChainIndex) {
              if (_i4 < previousChain.length && previousChain[_i4].element) {
                previousChain[_i4].element.location = createLocation(newContext, previousChain[_i4].route);
              }
            } else {
              callbacks = this.__runOnBeforeEnterCallbacks(callbacks, newContext, {
                prevent: prevent,
                redirect: redirect
              }, newChain[_i4]);

              if (newChain[_i4].element) {
                newChain[_i4].element.location = createLocation(newContext, newChain[_i4].route);
              }
            }
          }
        }

        return callbacks.then(function (amendmentResult) {
          if (amendmentResult) {
            if (amendmentResult.cancel) {
              _this7.__previousContext.__renderId = newContext.__renderId;
              return _this7.__previousContext;
            }

            if (amendmentResult.redirect) {
              return _this7.__redirect(amendmentResult.redirect, newContext.__redirectCount, newContext.__renderId);
            }
          }

          return newContext;
        });
      }
    }, {
      key: "__runOnBeforeLeaveCallbacks",
      value: function __runOnBeforeLeaveCallbacks(callbacks, newContext, commands, chainElement) {
        var _this8 = this;

        var location = createLocation(newContext);
        return callbacks.then(function (result) {
          if (_this8.__isLatestRender(newContext)) {
            var afterLeaveFunction = amend('onBeforeLeave', [location, commands, _this8], chainElement.element);
            return afterLeaveFunction(result);
          }
        }).then(function (result) {
          if (!(result || {}).redirect) {
            return result;
          }
        });
      }
    }, {
      key: "__runOnBeforeEnterCallbacks",
      value: function __runOnBeforeEnterCallbacks(callbacks, newContext, commands, chainElement) {
        var _this9 = this;

        var location = createLocation(newContext, chainElement.route);
        return callbacks.then(function (result) {
          if (_this9.__isLatestRender(newContext)) {
            var beforeEnterFunction = amend('onBeforeEnter', [location, commands, _this9], chainElement.element);
            return beforeEnterFunction(result);
          }
        });
      }
    }, {
      key: "__isReusableElement",
      value: function __isReusableElement(element, otherElement) {
        if (element && otherElement) {
          return this.__createdByRouter.get(element) && this.__createdByRouter.get(otherElement) ? element.localName === otherElement.localName : element === otherElement;
        }

        return false;
      }
    }, {
      key: "__isLatestRender",
      value: function __isLatestRender(context) {
        return context.__renderId === this.__lastStartedRenderId;
      }
    }, {
      key: "__redirect",
      value: function __redirect(redirectData, counter, renderId) {
        if (counter > MAX_REDIRECT_COUNT) {
          throw new Error((0, _utils.log)("Too many redirects when rendering ".concat(redirectData.from)));
        }

        return this.resolve({
          pathname: this.urlForPath(redirectData.pathname, redirectData.params),
          redirectFrom: redirectData.from,
          __redirectCount: (counter || 0) + 1,
          __renderId: renderId
        });
      }
    }, {
      key: "__ensureOutlet",
      value: function __ensureOutlet() {
        var outlet = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.__outlet;

        if (!babelHelpers.instanceof(outlet, Node)) {
          throw new TypeError((0, _utils.log)("Expected router outlet to be a valid DOM Node (but got ".concat(outlet, ")")));
        }
      }
    }, {
      key: "__updateBrowserHistory",
      value: function __updateBrowserHistory(_ref2, replace) {
        var pathname = _ref2.pathname,
            _ref2$search = _ref2.search,
            search = _ref2$search === void 0 ? '' : _ref2$search,
            _ref2$hash = _ref2.hash,
            hash = _ref2$hash === void 0 ? '' : _ref2$hash;

        if (window.location.pathname !== pathname || window.location.search !== search || window.location.hash !== hash) {
          var changeState = replace ? 'replaceState' : 'pushState';
          window.history[changeState](null, document.title, pathname + search + hash);
          window.dispatchEvent(new PopStateEvent('popstate', {
            state: 'vaadin-router-ignore'
          }));
        }
      }
    }, {
      key: "__copyUnchangedElements",
      value: function __copyUnchangedElements(context, previousContext) {
        // Find the deepest common parent between the last and the new component
        // chains. Update references for the unchanged elements in the new chain
        var deepestCommonParent = this.__outlet;

        for (var i = 0; i < context.__divergedChainIndex; i++) {
          var unchangedElement = previousContext && previousContext.chain[i].element;

          if (unchangedElement) {
            if (unchangedElement.parentNode === deepestCommonParent) {
              context.chain[i].element = unchangedElement;
              deepestCommonParent = unchangedElement;
            } else {
              break;
            }
          }
        }

        return deepestCommonParent;
      }
    }, {
      key: "__addAppearingContent",
      value: function __addAppearingContent(context, previousContext) {
        var _this10 = this;

        this.__ensureOutlet(); // If the previous 'entering' animation has not completed yet,
        // stop it and remove that content from the DOM before adding new one.


        this.__removeAppearingContent(); // Copy reusable elements from the previousContext to current


        var deepestCommonParent = this.__copyUnchangedElements(context, previousContext); // Keep two lists of DOM elements:
        //  - those that should be removed once the transition animation is over
        //  - and those that should remain


        this.__appearingContent = [];
        this.__disappearingContent = Array.from(deepestCommonParent.children).filter( // Only remove layout content that was added by router
        function (e) {
          return _this10.__addedByRouter.get(e) && // Do not remove the result element to avoid flickering
          e !== context.result;
        }); // Add new elements (starting after the deepest common parent) to the DOM.
        // That way only the components that are actually different between the two
        // locations are added to the DOM (and those that are common remain in the
        // DOM without first removing and then adding them again).

        var parentElement = deepestCommonParent;

        for (var i = context.__divergedChainIndex; i < context.chain.length; i++) {
          var elementToAdd = context.chain[i].element;

          if (elementToAdd) {
            parentElement.appendChild(elementToAdd);

            this.__addedByRouter.set(elementToAdd, true);

            if (parentElement === deepestCommonParent) {
              this.__appearingContent.push(elementToAdd);
            }

            parentElement = elementToAdd;
          }
        }
      }
    }, {
      key: "__removeDisappearingContent",
      value: function __removeDisappearingContent() {
        if (this.__disappearingContent) {
          removeDomNodes(this.__disappearingContent);
        }

        this.__disappearingContent = null;
        this.__appearingContent = null;
      }
    }, {
      key: "__removeAppearingContent",
      value: function __removeAppearingContent() {
        if (this.__disappearingContent && this.__appearingContent) {
          removeDomNodes(this.__appearingContent);
          this.__disappearingContent = null;
          this.__appearingContent = null;
        }
      }
    }, {
      key: "__runOnAfterLeaveCallbacks",
      value: function __runOnAfterLeaveCallbacks(currentContext, targetContext) {
        if (!targetContext) {
          return;
        } // REVERSE iteration: from Z to A


        for (var i = targetContext.chain.length - 1; i >= currentContext.__divergedChainIndex; i--) {
          if (!this.__isLatestRender(currentContext)) {
            break;
          }

          var currentComponent = targetContext.chain[i].element;

          if (!currentComponent) {
            continue;
          }

          try {
            var location = createLocation(currentContext);
            runCallbackIfPossible(currentComponent.onAfterLeave, [location, {}, targetContext.resolver], currentComponent);
          } finally {
            if (this.__disappearingContent.indexOf(currentComponent) > -1) {
              removeDomNodes(currentComponent.children);
            }
          }
        }
      }
    }, {
      key: "__runOnAfterEnterCallbacks",
      value: function __runOnAfterEnterCallbacks(currentContext) {
        // forward iteration: from A to Z
        for (var i = currentContext.__divergedChainIndex; i < currentContext.chain.length; i++) {
          if (!this.__isLatestRender(currentContext)) {
            break;
          }

          var currentComponent = currentContext.chain[i].element || {};
          var location = createLocation(currentContext, currentContext.chain[i].route);
          runCallbackIfPossible(currentComponent.onAfterEnter, [location, {}, currentContext.resolver], currentComponent);
        }
      }
    }, {
      key: "__animateIfNeeded",
      value: function __animateIfNeeded(context) {
        var from = (this.__disappearingContent || [])[0];
        var to = (this.__appearingContent || [])[0];
        var promises = [];
        var chain = context.chain;
        var config;

        for (var i = chain.length; i > 0; i--) {
          if (chain[i - 1].route.animate) {
            config = chain[i - 1].route.animate;
            break;
          }
        }

        if (from && to && config) {
          var leave = (0, _utils.isObject)(config) && config.leave || 'leaving';
          var enter = (0, _utils.isObject)(config) && config.enter || 'entering';
          promises.push((0, _animate.default)(from, leave));
          promises.push((0, _animate.default)(to, enter));
        }

        return Promise.all(promises).then(function () {
          return context;
        });
      }
      /**
       * Subscribes this instance to navigation events on the `window`.
       *
       * NOTE: beware of resource leaks. For as long as a router instance is
       * subscribed to navigation events, it won't be garbage collected.
       */

    }, {
      key: "subscribe",
      value: function subscribe() {
        window.addEventListener('vaadin-router-go', this.__navigationEventHandler);
      }
      /**
       * Removes the subscription to navigation events created in the `subscribe()`
       * method.
       */

    }, {
      key: "unsubscribe",
      value: function unsubscribe() {
        window.removeEventListener('vaadin-router-go', this.__navigationEventHandler);
      }
    }, {
      key: "__onNavigationEvent",
      value: function __onNavigationEvent(event) {
        var _ref3 = event ? event.detail : window.location,
            pathname = _ref3.pathname,
            search = _ref3.search,
            hash = _ref3.hash;

        if ((0, _utils.isString)(this.__normalizePathname(pathname))) {
          if (event && event.preventDefault) {
            event.preventDefault();
          }

          this.render({
            pathname: pathname,
            search: search,
            hash: hash
          }, true);
        }
      }
      /**
       * Configures what triggers Router navigation events:
       *  - `POPSTATE`: popstate events on the current `window`
       *  - `CLICK`: click events on `<a>` links leading to the current page
       *
       * This method is invoked with the pre-configured values when creating a new Router instance.
       * By default, both `POPSTATE` and `CLICK` are enabled. This setup is expected to cover most of the use cases.
       *
       * See the `router-config.js` for the default navigation triggers config. Based on it, you can
       * create the own one and only import the triggers you need, instead of pulling in all the code,
       * e.g. if you want to handle `click` differently.
       *
       * See also **Navigation Triggers** section in [Live Examples](#/classes/Router/demos/demo/index.html).
       *
       * @param {...NavigationTrigger} triggers
       */

    }, {
      key: "urlForName",
      value:
      /**
       * Generates a URL for the route with the given name, optionally performing
       * substitution of parameters.
       *
       * The route is searched in all the Router instances subscribed to
       * navigation events.
       *
       * **Note:** For child route names, only array children are considered.
       * It is not possible to generate URLs using a name for routes set with
       * a children function.
       *
       * @function urlForName
       * @param {!string} name the route name or the route’s `component` name.
       * @param {Params=} params Optional object with route path parameters.
       * Named parameters are passed by name (`params[name] = value`), unnamed
       * parameters are passed by index (`params[index] = value`).
       *
       * @return {string}
       */
      function urlForName(name, params) {
        if (!this.__urlForName) {
          this.__urlForName = (0, _generateUrls.default)(this);
        }

        return getPathnameForRouter(this.__urlForName(name, params), this);
      }
      /**
       * Generates a URL for the given route path, optionally performing
       * substitution of parameters.
       *
       * @param {!string} path string route path declared in [express.js syntax](https://expressjs.com/en/guide/routing.html#route-paths").
       * @param {Params=} params Optional object with route path parameters.
       * Named parameters are passed by name (`params[name] = value`), unnamed
       * parameters are passed by index (`params[index] = value`).
       *
       * @return {string}
       */

    }, {
      key: "urlForPath",
      value: function urlForPath(path, params) {
        return getPathnameForRouter(Router.pathToRegexp.compile(path)(params), this);
      }
      /**
       * Triggers navigation to a new path. Returns a boolean without waiting until
       * the navigation is complete. Returns `true` if at least one `Router`
       * has handled the navigation (was subscribed and had `baseUrl` matching
       * the `path` argument), otherwise returns `false`.
       *
       * @param {!string|!{pathname: !string, search: (string|undefined), hash: (string|undefined)}} path
       *   a new in-app path string, or an URL-like object with `pathname`
       *   string property, and optional `search` and `hash` string properties.
       * @return {boolean}
       */

    }], [{
      key: "setTriggers",
      value: function setTriggers() {
        for (var _len = arguments.length, triggers = new Array(_len), _key = 0; _key < _len; _key++) {
          triggers[_key] = arguments[_key];
        }

        (0, _setNavigationTriggers.default)(triggers);
      }
    }, {
      key: "go",
      value: function go(path) {
        var _ref4 = (0, _utils.isString)(path) ? this.__createUrl(path, 'http://a') // some base to omit origin
        : // some base to omit origin
        path,
            pathname = _ref4.pathname,
            search = _ref4.search,
            hash = _ref4.hash;

        return (0, _utils.fireRouterEvent)('go', {
          pathname: pathname,
          search: search,
          hash: hash
        });
      }
    }]);
    return Router;
  }(_resolver.default);

  _exports.Router = Router;
});