/**
 * Expose `pathToRegexp`.
 */module.exports=pathToRegexp;module.exports.parse=parse;module.exports.compile=compile;module.exports.tokensToFunction=tokensToFunction;module.exports.tokensToRegExp=tokensToRegExp;/**
 * Default configs.
 */var DEFAULT_DELIMITER="/",DEFAULT_DELIMITERS="./",PATH_REGEXP=new RegExp([// Match escaped characters that would otherwise appear in future matches.
// This allows the user to escape special characters that won't transform.
"(\\\\.)",// Match Express-style parameters and un-named parameters with a prefix
// and optional suffixes. Matches appear as:
//
// ":test(\\d+)?" => ["test", "\d+", undefined, "?"]
// "(\\d+)"  => [undefined, undefined, "\d+", undefined]
"(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?"].join("|"),"g");/**
 * Parse a string for the raw tokens.
 *
 * @param  {string}  str
 * @param  {Object=} options
 * @return {!Array}
 */function parse(str,options){var tokens=[],key=0,index=0,path="",defaultDelimiter=options&&options.delimiter||DEFAULT_DELIMITER,delimiters=options&&options.delimiters||DEFAULT_DELIMITERS,pathEscaped=!1,res;while(null!==(res=PATH_REGEXP.exec(str))){var m=res[0],escaped=res[1],offset=res.index;path+=str.slice(index,offset);index=offset+m.length;// Ignore already escaped sequences.
if(escaped){path+=escaped[1];pathEscaped=!0;continue}var prev="",next=str[index],name=res[2],capture=res[3],group=res[4],modifier=res[5];if(!pathEscaped&&path.length){var k=path.length-1;if(-1<delimiters.indexOf(path[k])){prev=path[k];path=path.slice(0,k)}}// Push the current path onto the tokens.
if(path){tokens.push(path);path="";pathEscaped=!1}var partial=""!==prev&&next!==void 0&&next!==prev,repeat="+"===modifier||"*"===modifier,optional="?"===modifier||"*"===modifier,delimiter=prev||defaultDelimiter,pattern=capture||group;tokens.push({name:name||key++,prefix:prev,delimiter:delimiter,optional:optional,repeat:repeat,partial:partial,pattern:pattern?escapeGroup(pattern):"[^"+escapeString(delimiter)+"]+?"})}// Push any remaining characters.
if(path||index<str.length){tokens.push(path+str.substr(index))}return tokens}/**
 * Compile a string to a template function for the path.
 *
 * @param  {string}             str
 * @param  {Object=}            options
 * @return {!function(Object=, Object=)}
 */function compile(str,options){return tokensToFunction(parse(str,options))}/**
 * Expose a method for transforming tokens into the path function.
 */function tokensToFunction(tokens){// Compile all the tokens into regexps.
// Compile all the patterns before compilation.
for(var matches=Array(tokens.length),i=0;i<tokens.length;i++){if("object"===babelHelpers.typeof(tokens[i])){matches[i]=new RegExp("^(?:"+tokens[i].pattern+")$")}}return function(data,options){for(var path="",encode=options&&options.encode||encodeURIComponent,i=0,token;i<tokens.length;i++){token=tokens[i];if("string"===typeof token){path+=token;continue}var value=data?data[token.name]:void 0,segment;if(Array.isArray(value)){if(!token.repeat){throw new TypeError("Expected \""+token.name+"\" to not repeat, but got array")}if(0===value.length){if(token.optional)continue;throw new TypeError("Expected \""+token.name+"\" to not be empty")}for(var j=0;j<value.length;j++){segment=encode(value[j],token);if(!matches[i].test(segment)){throw new TypeError("Expected all \""+token.name+"\" to match \""+token.pattern+"\"")}path+=(0===j?token.prefix:token.delimiter)+segment}continue}if("string"===typeof value||"number"===typeof value||"boolean"===typeof value){segment=encode(value+"",token);if(!matches[i].test(segment)){throw new TypeError("Expected \""+token.name+"\" to match \""+token.pattern+"\", but got \""+segment+"\"")}path+=token.prefix+segment;continue}if(token.optional){// Prepend partial segment prefixes.
if(token.partial)path+=token.prefix;continue}throw new TypeError("Expected \""+token.name+"\" to be "+(token.repeat?"an array":"a string"))}return path}}/**
 * Escape a regular expression string.
 *
 * @param  {string} str
 * @return {string}
 */function escapeString(str){return str.replace(/([.+*?=^!:${}()[\]|/\\])/g,"\\$1")}/**
 * Escape the capturing group by escaping special characters and meaning.
 *
 * @param  {string} group
 * @return {string}
 */function escapeGroup(group){return group.replace(/([=!:$/()])/g,"\\$1")}/**
 * Get the flags for a regexp from the options.
 *
 * @param  {Object} options
 * @return {string}
 */function flags(options){return options&&options.sensitive?"":"i"}/**
 * Pull out keys from a regexp.
 *
 * @param  {!RegExp} path
 * @param  {Array=}  keys
 * @return {!RegExp}
 */function regexpToRegexp(path,keys){if(!keys)return path;// Use a negative lookahead to match only capturing groups.
var groups=path.source.match(/\((?!\?)/g);if(groups){for(var i=0;i<groups.length;i++){keys.push({name:i,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,pattern:null})}}return path}/**
 * Transform an array into a regexp.
 *
 * @param  {!Array}  path
 * @param  {Array=}  keys
 * @param  {Object=} options
 * @return {!RegExp}
 */function arrayToRegexp(path,keys,options){for(var parts=[],i=0;i<path.length;i++){parts.push(pathToRegexp(path[i],keys,options).source)}return new RegExp("(?:"+parts.join("|")+")",flags(options))}/**
 * Create a path regexp from string input.
 *
 * @param  {string}  path
 * @param  {Array=}  keys
 * @param  {Object=} options
 * @return {!RegExp}
 */function stringToRegexp(path,keys,options){return tokensToRegExp(parse(path,options),keys,options)}/**
 * Expose a function for taking tokens and returning a RegExp.
 *
 * @param  {!Array}  tokens
 * @param  {Array=}  keys
 * @param  {Object=} options
 * @return {!RegExp}
 */function tokensToRegExp(tokens,keys,options){options=options||{};// Iterate over the tokens and create our regexp string.
for(var strict=options.strict,start=!1!==options.start,end=!1!==options.end,delimiter=escapeString(options.delimiter||DEFAULT_DELIMITER),delimiters=options.delimiters||DEFAULT_DELIMITERS,endsWith=[].concat(options.endsWith||[]).map(escapeString).concat("$").join("|"),route=start?"^":"",isEndDelimited=0===tokens.length,i=0,token;i<tokens.length;i++){token=tokens[i];if("string"===typeof token){route+=escapeString(token);isEndDelimited=i===tokens.length-1&&-1<delimiters.indexOf(token[token.length-1])}else{var capture=token.repeat?"(?:"+token.pattern+")(?:"+escapeString(token.delimiter)+"(?:"+token.pattern+"))*":token.pattern;if(keys)keys.push(token);if(token.optional){if(token.partial){route+=escapeString(token.prefix)+"("+capture+")?"}else{route+="(?:"+escapeString(token.prefix)+"("+capture+"))?"}}else{route+=escapeString(token.prefix)+"("+capture+")"}}}if(end){if(!strict)route+="(?:"+delimiter+")?";route+="$"===endsWith?"$":"(?="+endsWith+")"}else{if(!strict)route+="(?:"+delimiter+"(?="+endsWith+"))?";if(!isEndDelimited)route+="(?="+delimiter+"|"+endsWith+")"}return new RegExp(route,flags(options))}/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 *
 * @param  {(string|RegExp|Array)} path
 * @param  {Array=}                keys
 * @param  {Object=}               options
 * @return {!RegExp}
 */function pathToRegexp(path,keys,options){if(babelHelpers.instanceof(path,RegExp)){return regexpToRegexp(path,keys)}if(Array.isArray(path)){return arrayToRegexp(/** @type {!Array} */path,keys,options)}return stringToRegexp(/** @type {string} */path,keys,options)}