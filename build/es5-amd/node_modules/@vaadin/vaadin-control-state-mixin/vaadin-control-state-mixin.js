define(["exports"], function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.ControlStateMixin = void 0;

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = babelHelpers.getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = babelHelpers.getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return babelHelpers.possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  /**
  @license
  Copyright (c) 2017 Vaadin Ltd.
  This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
  */
  // We consider the keyboard to be active if the window has received a keydown
  // event since the last mousedown event.
  var keyboardActive = false; // Listen for top-level keydown and mousedown events.
  // Use capture phase so we detect events even if they're handled.

  window.addEventListener('keydown', function () {
    keyboardActive = true;
  }, {
    capture: true
  });
  window.addEventListener('mousedown', function () {
    keyboardActive = false;
  }, {
    capture: true
  });
  /**
   * A private mixin to avoid problems with dynamic properties and Polymer Analyzer.
   * No need to expose these properties in the API docs.
   * @polymerMixin
   * @private
   */

  var TabIndexMixin = function TabIndexMixin(superClass) {
    return /*#__PURE__*/function (_superClass) {
      babelHelpers.inherits(VaadinTabIndexMixin, _superClass);

      var _super = _createSuper(VaadinTabIndexMixin);

      function VaadinTabIndexMixin() {
        babelHelpers.classCallCheck(this, VaadinTabIndexMixin);
        return _super.apply(this, arguments);
      }

      babelHelpers.createClass(VaadinTabIndexMixin, null, [{
        key: "properties",
        get: function get() {
          var properties = {
            /**
             * Internal property needed to listen to `tabindex` attribute changes.
             *
             * For changing the tabindex of this component use the native `tabIndex` property.
             * @private
             */
            tabindex: {
              type: Number,
              value: 0,
              reflectToAttribute: true,
              observer: '_tabindexChanged'
            }
          };

          if (window.ShadyDOM) {
            // ShadyDOM browsers need the `tabIndex` in order to notify when the user changes it programmatically.
            properties['tabIndex'] = properties.tabindex;
          }

          return properties;
        }
      }]);
      return VaadinTabIndexMixin;
    }(superClass);
  };
  /**
   * Polymer.IronControlState is not a proper 2.0 class, also, its tabindex
   * implementation fails in the shadow dom, so we have this for vaadin elements.
   * @polymerMixin
   */


  var ControlStateMixin = function ControlStateMixin(superClass) {
    return /*#__PURE__*/function (_TabIndexMixin) {
      babelHelpers.inherits(VaadinControlStateMixin, _TabIndexMixin);

      var _super2 = _createSuper(VaadinControlStateMixin);

      function VaadinControlStateMixin() {
        babelHelpers.classCallCheck(this, VaadinControlStateMixin);
        return _super2.apply(this, arguments);
      }

      babelHelpers.createClass(VaadinControlStateMixin, [{
        key: "ready",
        value:
        /**
         * @protected
         */
        function ready() {
          var _this = this;

          this.addEventListener('focusin', function (e) {
            if (e.composedPath()[0] === _this) {
              // Only focus if the focus is received from somewhere outside
              if (!_this.contains(e.relatedTarget)) {
                _this._focus();
              }
            } else if (e.composedPath().indexOf(_this.focusElement) !== -1 && !_this.disabled) {
              _this._setFocused(true);
            }
          });
          this.addEventListener('focusout', function (e) {
            return _this._setFocused(false);
          }); // In super.ready() other 'focusin' and 'focusout' listeners might be
          // added, so we call it after our own ones to ensure they execute first.
          // Issue to watch out: when incorrect, <vaadin-combo-box> refocuses the
          // input field on iOS after “Done” is pressed.

          babelHelpers.get(babelHelpers.getPrototypeOf(VaadinControlStateMixin.prototype), "ready", this).call(this); // This fixes the bug in Firefox 61 (https://bugzilla.mozilla.org/show_bug.cgi?id=1472887)
          // where focusout event does not go out of shady DOM because composed property in the event is not true

          var ensureEventComposed = function ensureEventComposed(e) {
            if (!e.composed) {
              e.target.dispatchEvent(new CustomEvent(e.type, {
                bubbles: true,
                composed: true,
                cancelable: false
              }));
            }
          };

          this.shadowRoot.addEventListener('focusin', ensureEventComposed);
          this.shadowRoot.addEventListener('focusout', ensureEventComposed);
          this.addEventListener('keydown', function (e) {
            if (!e.defaultPrevented && e.keyCode === 9) {
              if (e.shiftKey) {
                // Flag is checked in _focus event handler.
                _this._isShiftTabbing = true;
                HTMLElement.prototype.focus.apply(_this);

                _this._setFocused(false); // Event handling in IE is asynchronous and the flag is removed asynchronously as well


                setTimeout(function () {
                  return _this._isShiftTabbing = false;
                }, 0);
              } else {
                // Workaround for FF63-65 bug that causes the focus to get lost when
                // blurring a slotted component with focusable shadow root content
                // https://bugzilla.mozilla.org/show_bug.cgi?id=1528686
                // TODO: Remove when safe
                var firefox = window.navigator.userAgent.match(/Firefox\/(\d\d\.\d)/);

                if (firefox && parseFloat(firefox[1]) >= 63 && parseFloat(firefox[1]) < 66 && _this.parentNode && _this.nextSibling) {
                  var fakeTarget = document.createElement('input');
                  fakeTarget.style.position = 'absolute';
                  fakeTarget.style.opacity = '0';
                  fakeTarget.tabIndex = _this.tabIndex;

                  _this.parentNode.insertBefore(fakeTarget, _this.nextSibling);

                  fakeTarget.focus();
                  fakeTarget.addEventListener('focusout', function () {
                    return _this.parentNode.removeChild(fakeTarget);
                  });
                }
              }
            }
          });

          if (this.autofocus && !this.disabled) {
            window.requestAnimationFrame(function () {
              _this._focus();

              _this._setFocused(true);

              _this.setAttribute('focus-ring', '');
            });
          }
        }
        /**
         * @protected
         */

      }, {
        key: "disconnectedCallback",
        value: function disconnectedCallback() {
          babelHelpers.get(babelHelpers.getPrototypeOf(VaadinControlStateMixin.prototype), "disconnectedCallback", this).call(this); // in non-Chrome browsers, blur does not fire on the element when it is disconnected.
          // reproducible in `<vaadin-date-picker>` when closing on `Cancel` or `Today` click.

          if (this.hasAttribute('focused')) {
            this._setFocused(false);
          }
        }
        /**
         * @param {boolean} focused
         * @protected
         */

      }, {
        key: "_setFocused",
        value: function _setFocused(focused) {
          if (focused) {
            this.setAttribute('focused', '');
          } else {
            this.removeAttribute('focused');
          } // focus-ring is true when the element was focused from the keyboard.
          // Focus Ring [A11ycasts]: https://youtu.be/ilj2P5-5CjI


          if (focused && keyboardActive) {
            this.setAttribute('focus-ring', '');
          } else {
            this.removeAttribute('focus-ring');
          }
        }
        /**
         * Any element extending this mixin is required to implement this getter.
         * It returns the actual focusable element in the component.
         * @return {Element | null | undefined}
         */

      }, {
        key: "focusElement",
        get: function get() {
          window.console.warn("Please implement the 'focusElement' property in <".concat(this.localName, ">"));
          return this;
        }
        /**
         * @protected
         */

      }, {
        key: "_focus",
        value: function _focus() {
          if (!this.focusElement || this._isShiftTabbing) {
            return;
          }

          this.focusElement.focus();

          this._setFocused(true);
        }
        /**
         * Moving the focus from the host element causes firing of the blur event what leads to problems in IE.
         * @private
         */

      }, {
        key: "focus",
        value: function focus() {
          if (!this.focusElement || this.disabled) {
            return;
          }

          this.focusElement.focus();

          this._setFocused(true);
        }
        /**
         * Native bluring in the host element does nothing because it does not have the focus.
         * In chrome it works, but not in FF.
         * @private
         */

      }, {
        key: "blur",
        value: function blur() {
          if (!this.focusElement) {
            return;
          }

          this.focusElement.blur();

          this._setFocused(false);
        }
        /**
         * @param {boolean} disabled
         * @private
         */

      }, {
        key: "_disabledChanged",
        value: function _disabledChanged(disabled) {
          this.focusElement.disabled = disabled;

          if (disabled) {
            this.blur();
            this._previousTabIndex = this.tabindex;
            this.tabindex = -1;
            this.setAttribute('aria-disabled', 'true');
          } else {
            if (typeof this._previousTabIndex !== 'undefined') {
              this.tabindex = this._previousTabIndex;
            }

            this.removeAttribute('aria-disabled');
          }
        }
        /**
         * @param {number | null | undefined} tabindex
         * @private
         */

      }, {
        key: "_tabindexChanged",
        value: function _tabindexChanged(tabindex) {
          if (tabindex !== undefined) {
            this.focusElement.tabIndex = tabindex;
          }

          if (this.disabled && this.tabindex) {
            // If tabindex attribute was changed while checkbox was disabled
            if (this.tabindex !== -1) {
              this._previousTabIndex = this.tabindex;
            }

            this.tabindex = tabindex = undefined;
          }

          if (window.ShadyDOM) {
            this.setProperties({
              tabIndex: tabindex,
              tabindex: tabindex
            });
          }
        }
        /**
         * @protected
         */

      }, {
        key: "click",
        value: function click() {
          if (!this.disabled) {
            babelHelpers.get(babelHelpers.getPrototypeOf(VaadinControlStateMixin.prototype), "click", this).call(this);
          }
        }
      }], [{
        key: "properties",
        get: function get() {
          return {
            /**
             * Specify that this control should have input focus when the page loads.
             */
            autofocus: {
              type: Boolean
            },

            /**
             * Stores the previous value of tabindex attribute of the disabled element
             * @private
             */
            _previousTabIndex: {
              type: Number
            },

            /**
             * If true, the user cannot interact with this element.
             */
            disabled: {
              type: Boolean,
              observer: '_disabledChanged',
              reflectToAttribute: true
            },

            /**
             * @private
             */
            _isShiftTabbing: {
              type: Boolean
            }
          };
        }
      }]);
      return VaadinControlStateMixin;
    }(TabIndexMixin(superClass));
  };

  _exports.ControlStateMixin = ControlStateMixin;
});