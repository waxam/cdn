define(["exports"], function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.ControlStateMixin = void 0;

  /**
  @license
  Copyright (c) 2017 Vaadin Ltd.
  This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
  */

  /**
   * A private mixin to avoid problems with dynamic properties and Polymer Analyzer.
   * No need to expose these properties in the API docs.
   * @polymerMixin
   */
  var TabIndexMixin = function TabIndexMixin(superClass) {
    return (
      /*#__PURE__*/
      function (_superClass) {
        babelHelpers.inherits(VaadinTabIndexMixin, _superClass);

        function VaadinTabIndexMixin() {
          babelHelpers.classCallCheck(this, VaadinTabIndexMixin);
          return babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(VaadinTabIndexMixin).apply(this, arguments));
        }

        babelHelpers.createClass(VaadinTabIndexMixin, null, [{
          key: "properties",
          get: function get() {
            var properties = {
              /**
               * Internal property needed to listen to `tabindex` attribute changes.
               *
               * For changing the tabindex of this component use the native `tabIndex` property.
               * @private
               */
              tabindex: {
                type: Number,
                value: 0,
                reflectToAttribute: true,
                observer: '_tabindexChanged'
              }
            };

            if (window.ShadyDOM) {
              // ShadyDOM browsers need the `tabIndex` in order to notify when the user changes it programmatically.
              properties['tabIndex'] = properties.tabindex;
            }

            return properties;
          }
        }]);
        return VaadinTabIndexMixin;
      }(superClass)
    );
  };
  /**
   * Polymer.IronControlState is not a proper 2.0 class, also, its tabindex
   * implementation fails in the shadow dom, so we have this for vaadin elements.
   * @polymerMixin
   */


  var ControlStateMixin = function ControlStateMixin(superClass) {
    return (
      /*#__PURE__*/
      function (_TabIndexMixin) {
        babelHelpers.inherits(VaadinControlStateMixin, _TabIndexMixin);

        function VaadinControlStateMixin() {
          babelHelpers.classCallCheck(this, VaadinControlStateMixin);
          return babelHelpers.possibleConstructorReturn(this, babelHelpers.getPrototypeOf(VaadinControlStateMixin).apply(this, arguments));
        }

        babelHelpers.createClass(VaadinControlStateMixin, [{
          key: "ready",
          value: function ready() {
            var _this = this;

            this.addEventListener('focusin', function (e) {
              if (e.composedPath()[0] === _this) {
                _this._focus(e);
              } else if (e.composedPath().indexOf(_this.focusElement) !== -1 && !_this.disabled) {
                _this._setFocused(true);
              }
            });
            this.addEventListener('focusout', function (e) {
              return _this._setFocused(false);
            }); // In super.ready() other 'focusin' and 'focusout' listeners might be
            // added, so we call it after our own ones to ensure they execute first.
            // Issue to watch out: when incorrect, <vaadin-combo-box> refocuses the
            // input field on iOS after “Done” is pressed.

            babelHelpers.get(babelHelpers.getPrototypeOf(VaadinControlStateMixin.prototype), "ready", this).call(this); // This fixes the bug in Firefox 61 (https://bugzilla.mozilla.org/show_bug.cgi?id=1472887)
            // where focusout event does not go out of shady DOM because composed property in the event is not true

            var ensureEventComposed = function ensureEventComposed(e) {
              if (!e.composed) {
                e.target.dispatchEvent(new CustomEvent(e.type, {
                  bubbles: true,
                  composed: true,
                  cancelable: false
                }));
              }
            };

            this.shadowRoot.addEventListener('focusin', ensureEventComposed);
            this.shadowRoot.addEventListener('focusout', ensureEventComposed);
            this.addEventListener('keydown', function (e) {
              if (!e.defaultPrevented && e.keyCode === 9) {
                if (e.shiftKey) {
                  // Flag is checked in _focus event handler.
                  _this._isShiftTabbing = true;
                  HTMLElement.prototype.focus.apply(_this);

                  _this._setFocused(false); // Event handling in IE is asynchronous and the flag is removed asynchronously as well


                  setTimeout(function () {
                    return _this._isShiftTabbing = false;
                  }, 0);
                } else {
                  // Workaround for FF63-65 bug that causes the focus to get lost when
                  // blurring a slotted component with focusable shadow root content
                  // https://bugzilla.mozilla.org/show_bug.cgi?id=1528686
                  // TODO: Remove when safe
                  var firefox = window.navigator.userAgent.match(/Firefox\/(\d\d\.\d)/);

                  if (firefox && parseFloat(firefox[1]) >= 63 && parseFloat(firefox[1]) < 66 && _this.parentNode && _this.nextSibling) {
                    var fakeTarget = document.createElement('input');
                    fakeTarget.style.position = 'absolute';
                    fakeTarget.style.opacity = 0;
                    fakeTarget.tabIndex = _this.tabIndex;

                    _this.parentNode.insertBefore(fakeTarget, _this.nextSibling);

                    fakeTarget.focus();
                    fakeTarget.addEventListener('focusout', function () {
                      return _this.parentNode.removeChild(fakeTarget);
                    });
                  }
                }
              }
            });

            if (this.autofocus && !this.focused && !this.disabled) {
              window.requestAnimationFrame(function () {
                _this._focus();

                _this._setFocused(true);

                _this.setAttribute('focus-ring', '');
              });
            }

            this._boundKeydownListener = this._bodyKeydownListener.bind(this);
            this._boundKeyupListener = this._bodyKeyupListener.bind(this);
          }
          /**
           * @protected
           */

        }, {
          key: "connectedCallback",
          value: function connectedCallback() {
            babelHelpers.get(babelHelpers.getPrototypeOf(VaadinControlStateMixin.prototype), "connectedCallback", this).call(this);
            document.body.addEventListener('keydown', this._boundKeydownListener, true);
            document.body.addEventListener('keyup', this._boundKeyupListener, true);
          }
          /**
           * @protected
           */

        }, {
          key: "disconnectedCallback",
          value: function disconnectedCallback() {
            babelHelpers.get(babelHelpers.getPrototypeOf(VaadinControlStateMixin.prototype), "disconnectedCallback", this).call(this);
            document.body.removeEventListener('keydown', this._boundKeydownListener, true);
            document.body.removeEventListener('keyup', this._boundKeyupListener, true); // in non-Chrome browsers, blur does not fire on the element when it is disconnected.
            // reproducible in `<vaadin-date-picker>` when closing on `Cancel` or `Today` click.

            if (this.hasAttribute('focused')) {
              this._setFocused(false);
            }
          }
        }, {
          key: "_setFocused",
          value: function _setFocused(focused) {
            if (focused) {
              this.setAttribute('focused', '');
            } else {
              this.removeAttribute('focused');
            } // focus-ring is true when the element was focused from the keyboard.
            // Focus Ring [A11ycasts]: https://youtu.be/ilj2P5-5CjI


            if (focused && this._tabPressed) {
              this.setAttribute('focus-ring', '');
            } else {
              this.removeAttribute('focus-ring');
            }
          }
        }, {
          key: "_bodyKeydownListener",
          value: function _bodyKeydownListener(e) {
            this._tabPressed = e.keyCode === 9;
          }
        }, {
          key: "_bodyKeyupListener",
          value: function _bodyKeyupListener() {
            this._tabPressed = false;
          }
          /**
           * Any element extending this mixin is required to implement this getter.
           * It returns the actual focusable element in the component.
           */

        }, {
          key: "_focus",
          value: function _focus(e) {
            if (this._isShiftTabbing) {
              return;
            }

            this.focusElement.focus();

            this._setFocused(true);
          }
          /**
           * Moving the focus from the host element causes firing of the blur event what leads to problems in IE.
           * @private
           */

        }, {
          key: "focus",
          value: function focus() {
            if (!this.focusElement || this.disabled) {
              return;
            }

            this.focusElement.focus();

            this._setFocused(true);
          }
          /**
           * Native bluring in the host element does nothing because it does not have the focus.
           * In chrome it works, but not in FF.
           * @private
           */

        }, {
          key: "blur",
          value: function blur() {
            this.focusElement.blur();

            this._setFocused(false);
          }
        }, {
          key: "_disabledChanged",
          value: function _disabledChanged(disabled) {
            this.focusElement.disabled = disabled;

            if (disabled) {
              this.blur();
              this._previousTabIndex = this.tabindex;
              this.tabindex = -1;
              this.setAttribute('aria-disabled', 'true');
            } else {
              if (typeof this._previousTabIndex !== 'undefined') {
                this.tabindex = this._previousTabIndex;
              }

              this.removeAttribute('aria-disabled');
            }
          }
        }, {
          key: "_tabindexChanged",
          value: function _tabindexChanged(tabindex) {
            if (tabindex !== undefined) {
              this.focusElement.tabIndex = tabindex;
            }

            if (this.disabled && this.tabindex) {
              // If tabindex attribute was changed while checkbox was disabled
              if (this.tabindex !== -1) {
                this._previousTabIndex = this.tabindex;
              }

              this.tabindex = tabindex = undefined;
            }

            if (window.ShadyDOM) {
              this.setProperties({
                tabIndex: tabindex,
                tabindex: tabindex
              });
            }
          }
          /**
           * @protected
           */

        }, {
          key: "click",
          value: function click() {
            if (!this.disabled) {
              babelHelpers.get(babelHelpers.getPrototypeOf(VaadinControlStateMixin.prototype), "click", this).call(this);
            }
          }
        }, {
          key: "focusElement",
          get: function get() {
            window.console.warn("Please implement the 'focusElement' property in <".concat(this.localName, ">"));
            return this;
          }
        }], [{
          key: "properties",
          get: function get() {
            return {
              /**
               * Specify that this control should have input focus when the page loads.
               */
              autofocus: {
                type: Boolean
              },

              /**
               * Stores the previous value of tabindex attribute of the disabled element
               */
              _previousTabIndex: {
                type: Number
              },

              /**
               * If true, the user cannot interact with this element.
               */
              disabled: {
                type: Boolean,
                observer: '_disabledChanged',
                reflectToAttribute: true
              },
              _isShiftTabbing: {
                type: Boolean
              }
            };
          }
        }]);
        return VaadinControlStateMixin;
      }(TabIndexMixin(superClass))
    );
  };

  _exports.ControlStateMixin = ControlStateMixin;
});