define(["exports", "./document-wait.js"], function (_exports, _documentWait) {
  /**
  @license
  Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
  Code distributed by Google as part of the polymer project is also
  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
  */
  'use strict';

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = _exports.CustomStyleProvider = _exports.CustomStyleInterfaceInterface = void 0;
  _documentWait = babelHelpers.interopRequireDefault(_documentWait);

  /**
   * @typedef {HTMLStyleElement | {getStyle: function():HTMLStyleElement}}
   */
  var CustomStyleProvider;
  _exports.CustomStyleProvider = CustomStyleProvider;
  var SEEN_MARKER = '__seenByShadyCSS';
  var CACHED_STYLE = '__shadyCSSCachedStyle';
  /** @type {?function(!HTMLStyleElement)} */

  var transformFn = null;
  /** @type {?function()} */

  var validateFn = null;
  /**
  This interface is provided to add document-level <style> elements to ShadyCSS for processing.
  These styles must be processed by ShadyCSS to simulate ShadowRoot upper-bound encapsulation from outside styles
  In addition, these styles may also need to be processed for @apply rules and CSS Custom Properties
  
  To add document-level styles to ShadyCSS, one can call `ShadyCSS.addDocumentStyle(styleElement)` or `ShadyCSS.addDocumentStyle({getStyle: () => styleElement})`
  
  In addition, if the process used to discover document-level styles can be synchronously flushed, one should set `ShadyCSS.documentStyleFlush`.
  This function will be called when calculating styles.
  
  An example usage of the document-level styling api can be found in `examples/document-style-lib.js`
  
  @unrestricted
  */

  var CustomStyleInterface = /*#__PURE__*/function () {
    function CustomStyleInterface() {
      babelHelpers.classCallCheck(this, CustomStyleInterface);

      /** @type {!Array<!CustomStyleProvider>} */
      this['customStyles'] = [];
      this['enqueued'] = false; // NOTE(dfreedm): use quotes here to prevent closure inlining to `function(){}`;

      (0, _documentWait.default)(function () {
        if (window['ShadyCSS']['flushCustomStyles']) {
          window['ShadyCSS']['flushCustomStyles']();
        }
      });
    }
    /**
     * Queue a validation for new custom styles to batch style recalculations
     */


    babelHelpers.createClass(CustomStyleInterface, [{
      key: "enqueueDocumentValidation",
      value: function enqueueDocumentValidation() {
        if (this['enqueued'] || !validateFn) {
          return;
        }

        this['enqueued'] = true;
        (0, _documentWait.default)(validateFn);
      }
      /**
       * @param {!HTMLStyleElement} style
       */

    }, {
      key: "addCustomStyle",
      value: function addCustomStyle(style) {
        if (!style[SEEN_MARKER]) {
          style[SEEN_MARKER] = true;
          this['customStyles'].push(style);
          this.enqueueDocumentValidation();
        }
      }
      /**
       * @param {!CustomStyleProvider} customStyle
       * @return {HTMLStyleElement}
       */

    }, {
      key: "getStyleForCustomStyle",
      value: function getStyleForCustomStyle(customStyle) {
        if (customStyle[CACHED_STYLE]) {
          return customStyle[CACHED_STYLE];
        }

        var style;

        if (customStyle['getStyle']) {
          style = customStyle['getStyle']();
        } else {
          style = customStyle;
        }

        return style;
      }
      /**
       * @return {!Array<!CustomStyleProvider>}
       */

    }, {
      key: "processStyles",
      value: function processStyles() {
        var cs = this['customStyles'];

        for (var i = 0; i < cs.length; i++) {
          var customStyle = cs[i];

          if (customStyle[CACHED_STYLE]) {
            continue;
          }

          var style = this.getStyleForCustomStyle(customStyle);

          if (style) {
            // HTMLImports polyfill may have cloned the style into the main document,
            // which is referenced with __appliedElement.
            var styleToTransform =
            /** @type {!HTMLStyleElement} */
            style['__appliedElement'] || style;

            if (transformFn) {
              transformFn(styleToTransform);
            }

            customStyle[CACHED_STYLE] = styleToTransform;
          }
        }

        return cs;
      }
    }]);
    return CustomStyleInterface;
  }();
  /* eslint-disable no-self-assign */


  _exports.default = CustomStyleInterface;
  CustomStyleInterface.prototype['addCustomStyle'] = CustomStyleInterface.prototype.addCustomStyle;
  CustomStyleInterface.prototype['getStyleForCustomStyle'] = CustomStyleInterface.prototype.getStyleForCustomStyle;
  CustomStyleInterface.prototype['processStyles'] = CustomStyleInterface.prototype.processStyles;
  /* eslint-enable no-self-assign */

  Object.defineProperties(CustomStyleInterface.prototype, {
    'transformCallback': {
      /** @return {?function(!HTMLStyleElement)} */
      get: function get() {
        return transformFn;
      },

      /** @param {?function(!HTMLStyleElement)} fn */
      set: function set(fn) {
        transformFn = fn;
      }
    },
    'validateCallback': {
      /** @return {?function()} */
      get: function get() {
        return validateFn;
      },

      /**
       * @param {?function()} fn
       * @this {CustomStyleInterface}
       */
      set: function set(fn) {
        var needsEnqueue = false;

        if (!validateFn) {
          needsEnqueue = true;
        }

        validateFn = fn;

        if (needsEnqueue) {
          this.enqueueDocumentValidation();
        }
      }
    }
  });
  /** @typedef {{
   * customStyles: !Array<!CustomStyleProvider>,
   * addCustomStyle: function(!CustomStyleProvider),
   * getStyleForCustomStyle: function(!CustomStyleProvider): HTMLStyleElement,
   * findStyles: function(),
   * transformCallback: ?function(!HTMLStyleElement),
   * validateCallback: ?function()
   * }}
   */

  var CustomStyleInterfaceInterface = {};
  _exports.CustomStyleInterfaceInterface = CustomStyleInterfaceInterface;
});