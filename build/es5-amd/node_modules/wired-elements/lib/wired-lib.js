define(["exports", "../../roughjs/bin/renderer.js", "../../roughjs/bin/fillers/zigzag-filler.js"], function (_exports, _renderer, _zigzagFiller) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.ellipse = ellipse;
  _exports.hachureEllipseFill = hachureEllipseFill;
  _exports.hachureFill = hachureFill;
  _exports.line = line;
  _exports.polygon = polygon;
  _exports.rectangle = rectangle;
  _exports.svgNode = svgNode;

  function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  var fillHelper = {
    randOffset: function randOffset(x, _o) {
      return x;
    },
    randOffsetWithRange: function randOffsetWithRange(min, max, _o) {
      return (min + max) / 2;
    },
    ellipse: function ellipse(x, y, width, height, o) {
      return (0, _renderer.ellipse)(x, y, width, height, o);
    },
    doubleLineOps: function doubleLineOps(x1, y1, x2, y2, o) {
      return (0, _renderer.doubleLineFillOps)(x1, y1, x2, y2, o);
    }
  };

  function options(seed) {
    return {
      maxRandomnessOffset: 2,
      roughness: 1,
      bowing: 0.85,
      stroke: '#000',
      strokeWidth: 1.5,
      curveTightness: 0,
      curveFitting: 0.95,
      curveStepCount: 9,
      fillStyle: 'hachure',
      fillWeight: 3.5,
      hachureAngle: -41,
      hachureGap: 5,
      dashOffset: -1,
      dashGap: -1,
      zigzagOffset: 0,
      combineNestedSvgPaths: false,
      disableMultiStroke: false,
      disableMultiStrokeFill: false,
      seed: seed
    };
  }

  function opsToPath(drawing, joinPaths) {
    var path = '';

    var _iterator = _createForOfIteratorHelper(drawing.ops),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var item = _step.value;
        var data = item.data;

        switch (item.op) {
          case 'move':
            if (joinPaths && path) {
              break;
            }

            path += "M".concat(data[0], " ").concat(data[1], " ");
            break;

          case 'bcurveTo':
            path += "C".concat(data[0], " ").concat(data[1], ", ").concat(data[2], " ").concat(data[3], ", ").concat(data[4], " ").concat(data[5], " ");
            break;

          case 'lineTo':
            path += "L".concat(data[0], " ").concat(data[1], " ");
            break;
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return path.trim();
  }

  function svgNode(tagName, attributes) {
    var n = document.createElementNS('http://www.w3.org/2000/svg', tagName);

    if (attributes) {
      for (var p in attributes) {
        n.setAttributeNS(null, p, attributes[p]);
      }
    }

    return n;
  }

  function createPathNode(ops, parent) {
    var joinPaths = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var path = svgNode('path', {
      d: opsToPath(ops, joinPaths)
    });

    if (parent) {
      parent.appendChild(path);
    }

    return path;
  }

  function rectangle(parent, x, y, width, height, seed) {
    return createPathNode((0, _renderer.rectangle)(x + 2, y + 2, width - 4, height - 4, options(seed)), parent);
  }

  function line(parent, x1, y1, x2, y2, seed) {
    return createPathNode((0, _renderer.line)(x1, y1, x2, y2, options(seed)), parent);
  }

  function polygon(parent, vertices, seed) {
    return createPathNode((0, _renderer.polygon)(vertices, options(seed)), parent, true);
  }

  function ellipse(parent, x, y, width, height, seed) {
    width = Math.max(width > 10 ? width - 4 : width - 1, 1);
    height = Math.max(height > 10 ? height - 4 : height - 1, 1);
    return createPathNode((0, _renderer.ellipse)(x, y, width, height, options(seed)), parent);
  }

  function hachureFill(points, seed) {
    var hf = new _zigzagFiller.ZigZagFiller(fillHelper);
    var ops = hf.fillPolygon(points, options(seed));
    return createPathNode(ops, null);
  }

  function hachureEllipseFill(cx, cy, width, height, seed) {
    var o = options(seed);
    var ep = (0, _renderer.generateEllipseParams)(width, height, o);
    var vertices = [];
    var angle = 0;

    while (angle <= Math.PI * 2) {
      vertices.push([cx + ep.rx * Math.cos(angle), cy + ep.ry * Math.sin(angle)]);
      angle += ep.increment;
    }

    return hachureFill(vertices, seed);
  }
});