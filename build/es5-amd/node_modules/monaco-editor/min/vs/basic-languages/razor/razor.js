function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.32.1(29a273516805a852aa8edc5e05059f119b13eff0)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
define("vs/basic-languages/razor/razor", ["require", "require"], function (require) {
  var moduleExports = function () {
    var h = Object.create;
    var i = Object.defineProperty;
    var u = Object.getOwnPropertyDescriptor;
    var b = Object.getOwnPropertyNames;
    var k = Object.getPrototypeOf,
        x = Object.prototype.hasOwnProperty;

    var s = function s(t) {
      return i(t, "__esModule", {
        value: !0
      });
    };

    var y = function (t) {
      return typeof require != "undefined" ? require : typeof Proxy != "undefined" ? new Proxy(t, {
        get: function get(e, r) {
          return (typeof require != "undefined" ? require : e)[r];
        }
      }) : t;
    }(function (t) {
      if (typeof require != "undefined") return require.apply(this, arguments);
      throw new Error('Dynamic require of "' + t + '" is not supported');
    });

    var T = function T(t, e) {
      return function () {
        return e || t((e = {
          exports: {}
        }).exports, e), e.exports;
      };
    },
        w = function w(t, e) {
      for (var r in e) {
        i(t, r, {
          get: e[r],
          enumerable: !0
        });
      }
    },
        m = function m(t, e, r, a) {
      if (e && babelHelpers.typeof(e) == "object" || typeof e == "function") {
        var _iterator = _createForOfIteratorHelper(b(e)),
            _step;

        try {
          var _loop = function _loop() {
            var n = _step.value;
            !x.call(t, n) && (r || n !== "default") && i(t, n, {
              get: function get() {
                return e[n];
              },
              enumerable: !(a = u(e, n)) || a.enumerable
            });
          };

          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            _loop();
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }

      return t;
    },
        c = function c(t, e) {
      return m(s(i(t != null ? h(k(t)) : {}, "default", !e && t && t.__esModule ? {
        get: function get() {
          return t.default;
        },
        enumerable: !0
      } : {
        value: t,
        enumerable: !0
      })), t);
    },
        g = function (t) {
      return function (e, r) {
        return t && t.get(e) || (r = m(s({}), e, 1), t && t.set(e, r), r);
      };
    }(typeof WeakMap != "undefined" ? new WeakMap() : 0);

    var d = T(function ($, l) {
      var S = c(y("vs/editor/editor.api"));
      l.exports = S;
    });
    var z = {};
    w(z, {
      conf: function conf() {
        return f;
      },
      language: function language() {
        return E;
      }
    });
    var o = {};
    m(o, c(d()));
    var p = ["area", "base", "br", "col", "embed", "hr", "img", "input", "keygen", "link", "menuitem", "meta", "param", "source", "track", "wbr"],
        f = {
      wordPattern: /(-?\d*\.\d\w*)|([^\`\~\!\@\$\^\&\*\(\)\-\=\+\[\{\]\}\\\|\;\:\'\"\,\.\<\>\/\s]+)/g,
      comments: {
        blockComment: ["<!--", "-->"]
      },
      brackets: [["<!--", "-->"], ["<", ">"], ["{", "}"], ["(", ")"]],
      autoClosingPairs: [{
        open: "{",
        close: "}"
      }, {
        open: "[",
        close: "]"
      }, {
        open: "(",
        close: ")"
      }, {
        open: '"',
        close: '"'
      }, {
        open: "'",
        close: "'"
      }],
      surroundingPairs: [{
        open: '"',
        close: '"'
      }, {
        open: "'",
        close: "'"
      }, {
        open: "<",
        close: ">"
      }],
      onEnterRules: [{
        beforeText: new RegExp("<(?!(?:".concat(p.join("|"), "))(\\w[\\w\\d]*)([^/>]*(?!/)>)[^<]*$"), "i"),
        afterText: /^<\/(\w[\w\d]*)\s*>$/i,
        action: {
          indentAction: o.languages.IndentAction.IndentOutdent
        }
      }, {
        beforeText: new RegExp("<(?!(?:".concat(p.join("|"), "))(\\w[\\w\\d]*)([^/>]*(?!/)>)[^<]*$"), "i"),
        action: {
          indentAction: o.languages.IndentAction.Indent
        }
      }]
    },
        E = {
      defaultToken: "",
      tokenPostfix: "",
      tokenizer: {
        root: [[/@@@@/], [/@[^@]/, {
          token: "@rematch",
          switchTo: "@razorInSimpleState.root"
        }], [/<!DOCTYPE/, "metatag.html", "@doctype"], [/<!--/, "comment.html", "@comment"], [/(<)([\w\-]+)(\/>)/, ["delimiter.html", "tag.html", "delimiter.html"]], [/(<)(script)/, ["delimiter.html", {
          token: "tag.html",
          next: "@script"
        }]], [/(<)(style)/, ["delimiter.html", {
          token: "tag.html",
          next: "@style"
        }]], [/(<)([:\w\-]+)/, ["delimiter.html", {
          token: "tag.html",
          next: "@otherTag"
        }]], [/(<\/)([\w\-]+)/, ["delimiter.html", {
          token: "tag.html",
          next: "@otherTag"
        }]], [/</, "delimiter.html"], [/[ \t\r\n]+/], [/[^<@]+/]],
        doctype: [[/@[^@]/, {
          token: "@rematch",
          switchTo: "@razorInSimpleState.comment"
        }], [/[^>]+/, "metatag.content.html"], [/>/, "metatag.html", "@pop"]],
        comment: [[/@[^@]/, {
          token: "@rematch",
          switchTo: "@razorInSimpleState.comment"
        }], [/-->/, "comment.html", "@pop"], [/[^-]+/, "comment.content.html"], [/./, "comment.content.html"]],
        otherTag: [[/@[^@]/, {
          token: "@rematch",
          switchTo: "@razorInSimpleState.otherTag"
        }], [/\/?>/, "delimiter.html", "@pop"], [/"([^"]*)"/, "attribute.value"], [/'([^']*)'/, "attribute.value"], [/[\w\-]+/, "attribute.name"], [/=/, "delimiter"], [/[ \t\r\n]+/]],
        script: [[/@[^@]/, {
          token: "@rematch",
          switchTo: "@razorInSimpleState.script"
        }], [/type/, "attribute.name", "@scriptAfterType"], [/"([^"]*)"/, "attribute.value"], [/'([^']*)'/, "attribute.value"], [/[\w\-]+/, "attribute.name"], [/=/, "delimiter"], [/>/, {
          token: "delimiter.html",
          next: "@scriptEmbedded.text/javascript",
          nextEmbedded: "text/javascript"
        }], [/[ \t\r\n]+/], [/(<\/)(script\s*)(>)/, ["delimiter.html", "tag.html", {
          token: "delimiter.html",
          next: "@pop"
        }]]],
        scriptAfterType: [[/@[^@]/, {
          token: "@rematch",
          switchTo: "@razorInSimpleState.scriptAfterType"
        }], [/=/, "delimiter", "@scriptAfterTypeEquals"], [/>/, {
          token: "delimiter.html",
          next: "@scriptEmbedded.text/javascript",
          nextEmbedded: "text/javascript"
        }], [/[ \t\r\n]+/], [/<\/script\s*>/, {
          token: "@rematch",
          next: "@pop"
        }]],
        scriptAfterTypeEquals: [[/@[^@]/, {
          token: "@rematch",
          switchTo: "@razorInSimpleState.scriptAfterTypeEquals"
        }], [/"([^"]*)"/, {
          token: "attribute.value",
          switchTo: "@scriptWithCustomType.$1"
        }], [/'([^']*)'/, {
          token: "attribute.value",
          switchTo: "@scriptWithCustomType.$1"
        }], [/>/, {
          token: "delimiter.html",
          next: "@scriptEmbedded.text/javascript",
          nextEmbedded: "text/javascript"
        }], [/[ \t\r\n]+/], [/<\/script\s*>/, {
          token: "@rematch",
          next: "@pop"
        }]],
        scriptWithCustomType: [[/@[^@]/, {
          token: "@rematch",
          switchTo: "@razorInSimpleState.scriptWithCustomType.$S2"
        }], [/>/, {
          token: "delimiter.html",
          next: "@scriptEmbedded.$S2",
          nextEmbedded: "$S2"
        }], [/"([^"]*)"/, "attribute.value"], [/'([^']*)'/, "attribute.value"], [/[\w\-]+/, "attribute.name"], [/=/, "delimiter"], [/[ \t\r\n]+/], [/<\/script\s*>/, {
          token: "@rematch",
          next: "@pop"
        }]],
        scriptEmbedded: [[/@[^@]/, {
          token: "@rematch",
          switchTo: "@razorInEmbeddedState.scriptEmbedded.$S2",
          nextEmbedded: "@pop"
        }], [/<\/script/, {
          token: "@rematch",
          next: "@pop",
          nextEmbedded: "@pop"
        }]],
        style: [[/@[^@]/, {
          token: "@rematch",
          switchTo: "@razorInSimpleState.style"
        }], [/type/, "attribute.name", "@styleAfterType"], [/"([^"]*)"/, "attribute.value"], [/'([^']*)'/, "attribute.value"], [/[\w\-]+/, "attribute.name"], [/=/, "delimiter"], [/>/, {
          token: "delimiter.html",
          next: "@styleEmbedded.text/css",
          nextEmbedded: "text/css"
        }], [/[ \t\r\n]+/], [/(<\/)(style\s*)(>)/, ["delimiter.html", "tag.html", {
          token: "delimiter.html",
          next: "@pop"
        }]]],
        styleAfterType: [[/@[^@]/, {
          token: "@rematch",
          switchTo: "@razorInSimpleState.styleAfterType"
        }], [/=/, "delimiter", "@styleAfterTypeEquals"], [/>/, {
          token: "delimiter.html",
          next: "@styleEmbedded.text/css",
          nextEmbedded: "text/css"
        }], [/[ \t\r\n]+/], [/<\/style\s*>/, {
          token: "@rematch",
          next: "@pop"
        }]],
        styleAfterTypeEquals: [[/@[^@]/, {
          token: "@rematch",
          switchTo: "@razorInSimpleState.styleAfterTypeEquals"
        }], [/"([^"]*)"/, {
          token: "attribute.value",
          switchTo: "@styleWithCustomType.$1"
        }], [/'([^']*)'/, {
          token: "attribute.value",
          switchTo: "@styleWithCustomType.$1"
        }], [/>/, {
          token: "delimiter.html",
          next: "@styleEmbedded.text/css",
          nextEmbedded: "text/css"
        }], [/[ \t\r\n]+/], [/<\/style\s*>/, {
          token: "@rematch",
          next: "@pop"
        }]],
        styleWithCustomType: [[/@[^@]/, {
          token: "@rematch",
          switchTo: "@razorInSimpleState.styleWithCustomType.$S2"
        }], [/>/, {
          token: "delimiter.html",
          next: "@styleEmbedded.$S2",
          nextEmbedded: "$S2"
        }], [/"([^"]*)"/, "attribute.value"], [/'([^']*)'/, "attribute.value"], [/[\w\-]+/, "attribute.name"], [/=/, "delimiter"], [/[ \t\r\n]+/], [/<\/style\s*>/, {
          token: "@rematch",
          next: "@pop"
        }]],
        styleEmbedded: [[/@[^@]/, {
          token: "@rematch",
          switchTo: "@razorInEmbeddedState.styleEmbedded.$S2",
          nextEmbedded: "@pop"
        }], [/<\/style/, {
          token: "@rematch",
          next: "@pop",
          nextEmbedded: "@pop"
        }]],
        razorInSimpleState: [[/@\*/, "comment.cs", "@razorBlockCommentTopLevel"], [/@[{(]/, "metatag.cs", "@razorRootTopLevel"], [/(@)(\s*[\w]+)/, ["metatag.cs", {
          token: "identifier.cs",
          switchTo: "@$S2.$S3"
        }]], [/[})]/, {
          token: "metatag.cs",
          switchTo: "@$S2.$S3"
        }], [/\*@/, {
          token: "comment.cs",
          switchTo: "@$S2.$S3"
        }]],
        razorInEmbeddedState: [[/@\*/, "comment.cs", "@razorBlockCommentTopLevel"], [/@[{(]/, "metatag.cs", "@razorRootTopLevel"], [/(@)(\s*[\w]+)/, ["metatag.cs", {
          token: "identifier.cs",
          switchTo: "@$S2.$S3",
          nextEmbedded: "$S3"
        }]], [/[})]/, {
          token: "metatag.cs",
          switchTo: "@$S2.$S3",
          nextEmbedded: "$S3"
        }], [/\*@/, {
          token: "comment.cs",
          switchTo: "@$S2.$S3",
          nextEmbedded: "$S3"
        }]],
        razorBlockCommentTopLevel: [[/\*@/, "@rematch", "@pop"], [/[^*]+/, "comment.cs"], [/./, "comment.cs"]],
        razorBlockComment: [[/\*@/, "comment.cs", "@pop"], [/[^*]+/, "comment.cs"], [/./, "comment.cs"]],
        razorRootTopLevel: [[/\{/, "delimiter.bracket.cs", "@razorRoot"], [/\(/, "delimiter.parenthesis.cs", "@razorRoot"], [/[})]/, "@rematch", "@pop"], {
          include: "razorCommon"
        }],
        razorRoot: [[/\{/, "delimiter.bracket.cs", "@razorRoot"], [/\(/, "delimiter.parenthesis.cs", "@razorRoot"], [/\}/, "delimiter.bracket.cs", "@pop"], [/\)/, "delimiter.parenthesis.cs", "@pop"], {
          include: "razorCommon"
        }],
        razorCommon: [[/[a-zA-Z_]\w*/, {
          cases: {
            "@razorKeywords": {
              token: "keyword.cs"
            },
            "@default": "identifier.cs"
          }
        }], [/[\[\]]/, "delimiter.array.cs"], [/[ \t\r\n]+/], [/\/\/.*$/, "comment.cs"], [/@\*/, "comment.cs", "@razorBlockComment"], [/"([^"]*)"/, "string.cs"], [/'([^']*)'/, "string.cs"], [/(<)([\w\-]+)(\/>)/, ["delimiter.html", "tag.html", "delimiter.html"]], [/(<)([\w\-]+)(>)/, ["delimiter.html", "tag.html", "delimiter.html"]], [/(<\/)([\w\-]+)(>)/, ["delimiter.html", "tag.html", "delimiter.html"]], [/[\+\-\*\%\&\|\^\~\!\=\<\>\/\?\;\:\.\,]/, "delimiter.cs"], [/\d*\d+[eE]([\-+]?\d+)?/, "number.float.cs"], [/\d*\.\d+([eE][\-+]?\d+)?/, "number.float.cs"], [/0[xX][0-9a-fA-F']*[0-9a-fA-F]/, "number.hex.cs"], [/0[0-7']*[0-7]/, "number.octal.cs"], [/0[bB][0-1']*[0-1]/, "number.binary.cs"], [/\d[\d']*/, "number.cs"], [/\d/, "number.cs"]]
      },
      razorKeywords: ["abstract", "as", "async", "await", "base", "bool", "break", "by", "byte", "case", "catch", "char", "checked", "class", "const", "continue", "decimal", "default", "delegate", "do", "double", "descending", "explicit", "event", "extern", "else", "enum", "false", "finally", "fixed", "float", "for", "foreach", "from", "goto", "group", "if", "implicit", "in", "int", "interface", "internal", "into", "is", "lock", "long", "nameof", "new", "null", "namespace", "object", "operator", "out", "override", "orderby", "params", "private", "protected", "public", "readonly", "ref", "return", "switch", "struct", "sbyte", "sealed", "short", "sizeof", "stackalloc", "static", "string", "select", "this", "throw", "true", "try", "typeof", "uint", "ulong", "unchecked", "unsafe", "ushort", "using", "var", "virtual", "volatile", "void", "when", "while", "where", "yield", "model", "inject"],
      escapes: /\\(?:[abfnrtv\\"']|x[0-9A-Fa-f]{1,4}|u[0-9A-Fa-f]{4}|U[0-9A-Fa-f]{8})/
    };
    return g(z);
  }();

  return moduleExports;
});