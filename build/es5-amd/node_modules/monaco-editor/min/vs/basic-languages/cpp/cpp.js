function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.32.1(29a273516805a852aa8edc5e05059f119b13eff0)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
define("vs/basic-languages/cpp/cpp", ["require", "require"], function (require) {
  var moduleExports = function () {
    var r = Object.defineProperty;
    var a = Object.getOwnPropertyDescriptor;
    var s = Object.getOwnPropertyNames;
    var _ = Object.prototype.hasOwnProperty;

    var c = function c(n) {
      return r(n, "__esModule", {
        value: !0
      });
    };

    var l = function l(n, e) {
      for (var t in e) {
        r(n, t, {
          get: e[t],
          enumerable: !0
        });
      }
    },
        d = function d(n, e, t, o) {
      if (e && babelHelpers.typeof(e) == "object" || typeof e == "function") {
        var _iterator = _createForOfIteratorHelper(s(e)),
            _step;

        try {
          var _loop = function _loop() {
            var i = _step.value;
            !_.call(n, i) && (t || i !== "default") && r(n, i, {
              get: function get() {
                return e[i];
              },
              enumerable: !(o = a(e, i)) || o.enumerable
            });
          };

          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            _loop();
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }

      return n;
    };

    var p = function (n) {
      return function (e, t) {
        return n && n.get(e) || (t = d(c({}), e, 1), n && n.set(e, t), t);
      };
    }(typeof WeakMap != "undefined" ? new WeakMap() : 0);

    var u = {};
    l(u, {
      conf: function conf() {
        return m;
      },
      language: function language() {
        return g;
      }
    });
    var m = {
      comments: {
        lineComment: "//",
        blockComment: ["/*", "*/"]
      },
      brackets: [["{", "}"], ["[", "]"], ["(", ")"]],
      autoClosingPairs: [{
        open: "[",
        close: "]"
      }, {
        open: "{",
        close: "}"
      }, {
        open: "(",
        close: ")"
      }, {
        open: "'",
        close: "'",
        notIn: ["string", "comment"]
      }, {
        open: '"',
        close: '"',
        notIn: ["string"]
      }],
      surroundingPairs: [{
        open: "{",
        close: "}"
      }, {
        open: "[",
        close: "]"
      }, {
        open: "(",
        close: ")"
      }, {
        open: '"',
        close: '"'
      }, {
        open: "'",
        close: "'"
      }],
      folding: {
        markers: {
          start: new RegExp("^\\s*#pragma\\s+region\\b"),
          end: new RegExp("^\\s*#pragma\\s+endregion\\b")
        }
      }
    },
        g = {
      defaultToken: "",
      tokenPostfix: ".cpp",
      brackets: [{
        token: "delimiter.curly",
        open: "{",
        close: "}"
      }, {
        token: "delimiter.parenthesis",
        open: "(",
        close: ")"
      }, {
        token: "delimiter.square",
        open: "[",
        close: "]"
      }, {
        token: "delimiter.angle",
        open: "<",
        close: ">"
      }],
      keywords: ["abstract", "amp", "array", "auto", "bool", "break", "case", "catch", "char", "class", "const", "constexpr", "const_cast", "continue", "cpu", "decltype", "default", "delegate", "delete", "do", "double", "dynamic_cast", "each", "else", "enum", "event", "explicit", "export", "extern", "false", "final", "finally", "float", "for", "friend", "gcnew", "generic", "goto", "if", "in", "initonly", "inline", "int", "interface", "interior_ptr", "internal", "literal", "long", "mutable", "namespace", "new", "noexcept", "nullptr", "__nullptr", "operator", "override", "partial", "pascal", "pin_ptr", "private", "property", "protected", "public", "ref", "register", "reinterpret_cast", "restrict", "return", "safe_cast", "sealed", "short", "signed", "sizeof", "static", "static_assert", "static_cast", "struct", "switch", "template", "this", "thread_local", "throw", "tile_static", "true", "try", "typedef", "typeid", "typename", "union", "unsigned", "using", "virtual", "void", "volatile", "wchar_t", "where", "while", "_asm", "_based", "_cdecl", "_declspec", "_fastcall", "_if_exists", "_if_not_exists", "_inline", "_multiple_inheritance", "_pascal", "_single_inheritance", "_stdcall", "_virtual_inheritance", "_w64", "__abstract", "__alignof", "__asm", "__assume", "__based", "__box", "__builtin_alignof", "__cdecl", "__clrcall", "__declspec", "__delegate", "__event", "__except", "__fastcall", "__finally", "__forceinline", "__gc", "__hook", "__identifier", "__if_exists", "__if_not_exists", "__inline", "__int128", "__int16", "__int32", "__int64", "__int8", "__interface", "__leave", "__m128", "__m128d", "__m128i", "__m256", "__m256d", "__m256i", "__m64", "__multiple_inheritance", "__newslot", "__nogc", "__noop", "__nounwind", "__novtordisp", "__pascal", "__pin", "__pragma", "__property", "__ptr32", "__ptr64", "__raise", "__restrict", "__resume", "__sealed", "__single_inheritance", "__stdcall", "__super", "__thiscall", "__try", "__try_cast", "__typeof", "__unaligned", "__unhook", "__uuidof", "__value", "__virtual_inheritance", "__w64", "__wchar_t"],
      operators: ["=", ">", "<", "!", "~", "?", ":", "==", "<=", ">=", "!=", "&&", "||", "++", "--", "+", "-", "*", "/", "&", "|", "^", "%", "<<", ">>", ">>>", "+=", "-=", "*=", "/=", "&=", "|=", "^=", "%=", "<<=", ">>=", ">>>="],
      symbols: /[=><!~?:&|+\-*\/\^%]+/,
      escapes: /\\(?:[abfnrtv\\"']|x[0-9A-Fa-f]{1,4}|u[0-9A-Fa-f]{4}|U[0-9A-Fa-f]{8})/,
      integersuffix: /([uU](ll|LL|l|L)|(ll|LL|l|L)?[uU]?)/,
      floatsuffix: /[fFlL]?/,
      encoding: /u|u8|U|L/,
      tokenizer: {
        root: [[/@encoding?R\"(?:([^ ()\\\t]*))\(/, {
          token: "string.raw.begin",
          next: "@raw.$1"
        }], [/[a-zA-Z_]\w*/, {
          cases: {
            "@keywords": {
              token: "keyword.$0"
            },
            "@default": "identifier"
          }
        }], [/^\s*#\s*include/, {
          token: "keyword.directive.include",
          next: "@include"
        }], [/^\s*#\s*\w+/, "keyword.directive"], {
          include: "@whitespace"
        }, [/\[\s*\[/, {
          token: "annotation",
          next: "@annotation"
        }], [/[{}()\[\]]/, "@brackets"], [/[<>](?!@symbols)/, "@brackets"], [/@symbols/, {
          cases: {
            "@operators": "delimiter",
            "@default": ""
          }
        }], [/\d*\d+[eE]([\-+]?\d+)?(@floatsuffix)/, "number.float"], [/\d*\.\d+([eE][\-+]?\d+)?(@floatsuffix)/, "number.float"], [/0[xX][0-9a-fA-F']*[0-9a-fA-F](@integersuffix)/, "number.hex"], [/0[0-7']*[0-7](@integersuffix)/, "number.octal"], [/0[bB][0-1']*[0-1](@integersuffix)/, "number.binary"], [/\d[\d']*\d(@integersuffix)/, "number"], [/\d(@integersuffix)/, "number"], [/[;,.]/, "delimiter"], [/"([^"\\]|\\.)*$/, "string.invalid"], [/"/, "string", "@string"], [/'[^\\']'/, "string"], [/(')(@escapes)(')/, ["string", "string.escape", "string"]], [/'/, "string.invalid"]],
        whitespace: [[/[ \t\r\n]+/, ""], [/\/\*\*(?!\/)/, "comment.doc", "@doccomment"], [/\/\*/, "comment", "@comment"], [/\/\/.*\\$/, "comment", "@linecomment"], [/\/\/.*$/, "comment"]],
        comment: [[/[^\/*]+/, "comment"], [/\*\//, "comment", "@pop"], [/[\/*]/, "comment"]],
        linecomment: [[/.*[^\\]$/, "comment", "@pop"], [/[^]+/, "comment"]],
        doccomment: [[/[^\/*]+/, "comment.doc"], [/\*\//, "comment.doc", "@pop"], [/[\/*]/, "comment.doc"]],
        string: [[/[^\\"]+/, "string"], [/@escapes/, "string.escape"], [/\\./, "string.escape.invalid"], [/"/, "string", "@pop"]],
        raw: [[/(.*)(\))(?:([^ ()\\\t"]*))(\")/, {
          cases: {
            "$3==$S2": ["string.raw", "string.raw.end", "string.raw.end", {
              token: "string.raw.end",
              next: "@pop"
            }],
            "@default": ["string.raw", "string.raw", "string.raw", "string.raw"]
          }
        }], [/.*/, "string.raw"]],
        annotation: [{
          include: "@whitespace"
        }, [/using|alignas/, "keyword"], [/[a-zA-Z0-9_]+/, "annotation"], [/[,:]/, "delimiter"], [/[()]/, "@brackets"], [/\]\s*\]/, {
          token: "annotation",
          next: "@pop"
        }]],
        include: [[/(\s*)(<)([^<>]*)(>)/, ["", "keyword.directive.include.begin", "string.include.identifier", {
          token: "keyword.directive.include.end",
          next: "@pop"
        }]], [/(\s*)(")([^"]*)(")/, ["", "keyword.directive.include.begin", "string.include.identifier", {
          token: "keyword.directive.include.end",
          next: "@pop"
        }]]]
      }
    };
    return p(u);
  }();

  return moduleExports;
});